diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index aea1f901d..52708fdd7 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -17,19 +17,28 @@ set(SRCS
   integ/bilininteg_convection_mf.cpp
   integ/bilininteg_convection_pa.cpp
   integ/bilininteg_convection_ea.cpp
+  integ/bilininteg_curlcurl_mf.cpp
   integ/bilininteg_curlcurl_pa.cpp
+  integ/bilininteg_curlcurlmass_pa.cpp
   integ/bilininteg_dgtrace_pa.cpp
   integ/bilininteg_dgtrace_ea.cpp
   integ/bilininteg_diffusion_mf.cpp
   integ/bilininteg_diffusion_pa.cpp
   integ/bilininteg_diffusion_ea.cpp
+  integ/bilininteg_diffusionmass_pa.cpp
+  integ/bilininteg_divdiv_mf.cpp
   integ/bilininteg_divdiv_pa.cpp
+  integ/bilininteg_divdivmass_pa.cpp
   integ/bilininteg_gradient_pa.cpp
-  integ/bilininteg_interp_pa.cpp
+  integ/bilininteg_interp_id_pa.cpp
+  integ/bilininteg_interp_grad_pa.cpp
+  integ/bilininteg_interp_curl_pa.cpp
   integ/bilininteg_mass_mf.cpp
   integ/bilininteg_mass_pa.cpp
   integ/bilininteg_mass_ea.cpp
+  integ/bilininteg_mixedcurl_mf.cpp
   integ/bilininteg_mixedcurl_pa.cpp
+  integ/bilininteg_mixedvecgrad_mf.cpp
   integ/bilininteg_mixedvecgrad_pa.cpp
   integ/bilininteg_transpose_ea.cpp
   integ/bilininteg_vecdiffusion_mf.cpp
@@ -38,6 +47,7 @@ set(SRCS
   integ/bilininteg_vecmass_mf.cpp
   integ/bilininteg_vecmass_pa.cpp
   integ/bilininteg_vectorfediv_pa.cpp
+  integ/bilininteg_vectorfemass_mf.cpp
   integ/bilininteg_vectorfemass_pa.cpp
   integ/bilininteg_diffusion_kernels.cpp
   integ/bilininteg_hcurl_kernels.cpp
@@ -77,15 +87,23 @@ set(SRCS
   hybridization.cpp
   intrules.cpp
   ceed/interface/basis.cpp
-  ceed/interface/restriction.cpp
   ceed/interface/operator.cpp
+  ceed/interface/restriction.cpp
   ceed/interface/util.cpp
+  ceed/integrators/mass/mass.cpp
   ceed/integrators/convection/convection.cpp
   ceed/integrators/diffusion/diffusion.cpp
   ceed/integrators/nlconvection/nlconvection.cpp
-  ceed/integrators/mass/mass.cpp
+  ceed/integrators/vecfemass/vecfemass.cpp
+  ceed/integrators/divdiv/divdiv.cpp
+  ceed/integrators/curlcurl/curlcurl.cpp
+  ceed/integrators/diffusionmass/diffusionmass.cpp
+  ceed/integrators/divdivmass/divdivmass.cpp
+  ceed/integrators/curlcurlmass/curlcurlmass.cpp
+  ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
+  ceed/integrators/mixedveccurl/mixedveccurl.cpp
+  ceed/integrators/interp/interp.cpp
   ceed/solvers/algebraic.cpp
-  ceed/solvers/full-assembly.cpp
   ceed/solvers/solvers-atpmg.cpp
   linearform.cpp
   linearform_ext.cpp
@@ -185,18 +203,39 @@ set(HDRS
   hybridization.hpp
   intrules.hpp
   ceed/interface/basis.hpp
+  ceed/interface/ceed.hpp
+  ceed/interface/coefficient.hpp
   ceed/interface/integrator.hpp
   ceed/interface/interface.hpp
+  ceed/interface/mixed_operator.hpp
   ceed/interface/operator.hpp
   ceed/interface/restriction.hpp
   ceed/interface/util.hpp
+  ceed/integrators/mass/mass.hpp
+  ceed/integrators/mass/mass_qf.h
   ceed/integrators/convection/convection.hpp
+  ceed/integrators/convection/convection_qf.h
   ceed/integrators/diffusion/diffusion.hpp
-  ceed/integrators/mass/mass.hpp
+  ceed/integrators/diffusion/diffusion_qf.h
   ceed/integrators/nlconvection/nlconvection.hpp
-  ceed/interface/coefficient.hpp
+  ceed/integrators/nlconvection/nlconvection_qf.h
+  ceed/integrators/vecfemass/vecfemass.hpp
+  ceed/integrators/vecfemass/vecfemass_qf.h
+  ceed/integrators/divdiv/divdiv.hpp
+  ceed/integrators/divdiv/divdiv_qf.h
+  ceed/integrators/curlcurl/curlcurl.hpp
+  ceed/integrators/curlcurl/curlcurl_qf.h
+  ceed/integrators/diffusionmass/diffusionmass.hpp
+  ceed/integrators/diffusionmass/diffusionmass_qf.h
+  ceed/integrators/divdivmass/divdivmass.hpp
+  ceed/integrators/divdivmass/divdivmass_qf.h
+  ceed/integrators/curlcurlmass/curlcurlmass.hpp
+  ceed/integrators/curlcurlmass/curlcurlmass_qf.h
+  ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
+  ceed/integrators/mixedveccurl/mixedveccurl.hpp
+  ceed/integrators/interp/interp.hpp
+  ceed/integrators/util/util_qf.h
   ceed/solvers/algebraic.hpp
-  ceed/solvers/full-assembly.hpp
   ceed/solvers/solvers-atpmg.hpp
   linearform.hpp
   linearform_ext.hpp
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index 8d0256462..b763d41be 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -2186,6 +2186,33 @@ void PADiscreteLinearOperatorExtension::Assemble()
    test_multiplicity.Reciprocal();
 }
 
+void PADiscreteLinearOperatorExtension::Mult(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   if (elem_restrict_trial)
+   {
+      elem_restrict_trial->Mult(x, local_trial);
+   }
+   if (elem_restrict_test)
+   {
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, y);
+   }
+   else
+   {
+      y = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+      }
+   }
+   y *= test_multiplicity;
+}
+
 void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
                                                 const double c) const
 {
@@ -2207,6 +2234,7 @@ void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
    }
    else
    {
+      temp_test = 0.0;
       for (BilinearFormIntegrator *interp : interpolators)
       {
          interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
@@ -2220,6 +2248,9 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
                                                          Vector &y,
                                                          const double c) const
 {
+   MFEM_VERIFY(c == 1.0,
+               "General coefficient case for PADiscreteLinearOperatorExtension::"
+               "AddMultTranspose is not yet supported!");
    Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
    temp_test = x;
    temp_test *= test_multiplicity;
@@ -2235,26 +2266,14 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
          interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
                                     local_trial);
       }
-      if (c != 1.0)
-      {
-         local_trial *= c;
-      }
       elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
       y.UseDevice(true); // typically this is a large vector, so store on device
-      if (c != 1.0)
-      {
-         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
-                    "AddMultTranspose is not yet supported!");
-      }
-      else
+      for (BilinearFormIntegrator *interp : interpolators)
       {
-         for (BilinearFormIntegrator *interp : interpolators)
-         {
-            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
-         }
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
       }
    }
 }
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index db26eb801..aa9271d8f 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -227,6 +227,7 @@ public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
    void Assemble();
+   void Mult(const Vector &x, Vector &y) const;
    void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index b07f4a9d9..71959402b 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -2598,10 +2598,10 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &VectorFEMassIntegrator::GetRule(
+const IntegrationRule &VectorFEMassIntegrator::GetRuleStatic(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
-   ElementTransformation &Trans) const
+   ElementTransformation &Trans)
 {
    int order = Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder();
    return IntRules.Get(test_fe.GetGeomType(), order);
@@ -2694,11 +2694,11 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
 
       elmat.SetSize(vdim*test_dof, trial_dof);
+      elmat = 0.0;
 
       const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
                                                                Trans);
 
-      elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2791,12 +2791,8 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 
       elmat.SetSize(test_dof, trial_dof);
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
       elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index a17058029..dd6c7625c 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -1847,14 +1847,30 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
    virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
@@ -1906,6 +1922,8 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1914,6 +1932,12 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
    virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
@@ -1966,6 +1990,8 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1974,6 +2000,12 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
    virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
@@ -2024,6 +2056,28 @@ public:
    MixedVectorWeakDivergenceIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
    virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
@@ -2196,6 +2250,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2205,6 +2262,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2281,6 +2341,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2345,6 +2408,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2354,6 +2420,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2496,6 +2565,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2503,6 +2575,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2573,6 +2648,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2580,6 +2658,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2760,6 +2841,8 @@ public:
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using NonlinearFormIntegrator::GetRule;
    virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                           const FiniteElement &test_fe,
@@ -2789,10 +2872,23 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2906,10 +3002,17 @@ public:
    VectorFEMassIntegrator(MatrixCoefficient *mq_) { Init(NULL, NULL, mq_); }
    VectorFEMassIntegrator(MatrixCoefficient &mq) { Init(NULL, NULL, &mq); }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans);
+
    using NonlinearFormIntegrator::GetRule;
    virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                           const FiniteElement &test_fe,
-                                          ElementTransformation &Trans) const;
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -2924,12 +3027,25 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -3004,6 +3120,8 @@ public:
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(&q) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using NonlinearFormIntegrator::GetRule;
    virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                           const FiniteElement &test_fe,
@@ -3021,13 +3139,233 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
+/** Class for integrating the bilinear form a(u,v) := (Qd grad u, grad v) +
+    (Qm u, v) */
+class DiffusionMassIntegrator: public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQd;
+   MatrixCoefficient *MQd;
+
+public:
+   /// Construct a diffusion + mass integrator with coefficients Qd = Qm = 1.
+   DiffusionMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), MQd(NULL) {}
+
+   /** Construct a diffusion + mass integrator with a scalar diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(Coefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQd(NULL), MQd(NULL) {}
+
+   /** Construct a diffusion + mass integrator with a vector diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(VectorCoefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(&qd), MQd(NULL) {}
+
+   /** Construct a diffusion + mass integrator with a matrix diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(MatrixCoefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(NULL), MQd(&qd) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+};
+
+/** Class for integrating the bilinear form a(u,v) := (Qd curl u, curl v) +
+    (Qm u, v) for ND elements */
+class CurlCurlMassIntegrator: public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQd, *VQm;
+   MatrixCoefficient *MQd, *MQm;
+
+public:
+   /// Construct a curl-curl + mass integrator with coefficients Qd = Qm = 1.
+   CurlCurlMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(NULL), MQd(NULL), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQd(NULL), VQm(NULL), MQd(NULL), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQd(NULL), VQm(&qm), MQd(NULL), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQd(NULL), VQm(NULL), MQd(NULL), MQm(&qm) {}
+
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(&qd), VQm(NULL), MQd(NULL), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(&qd), VQm(&qm), MQd(NULL), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(&qd), VQm(NULL), MQd(NULL), MQm(&qm) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(NULL), VQm(NULL), MQd(&qd), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(&qm), MQd(&qd), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(NULL), MQd(&qd), MQm(&qm) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+};
+
+/** Class for integrating the bilinear form a(u,v) := (Qd div u, div v) +
+    (Qm u, v) for RT elements */
+class DivDivMassIntegrator: public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQm;
+   MatrixCoefficient *MQm;
+
+public:
+   /// Construct a div-div + mass integrator with coefficients Qd = Qm = 1.
+   DivDivMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQm(NULL), MQm(NULL) {}
+
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       scalar mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, Coefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQm(NULL), MQm(NULL) {}
+
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       vector mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, VectorCoefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQm(&qm), MQm(NULL) {}
+
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       matrix mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, MatrixCoefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQm(NULL), MQm(&qm) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+};
+
 /** Integrator for the linear elasticity form:
     a(u,v) = (lambda div(u), div(v)) + (2 mu e(u), e(v)),
     where e(v) = (1/2) (grad(v) + grad(v)^T).
@@ -3550,7 +3888,19 @@ public:
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator {};
+class DiscreteInterpolator : public BilinearFormIntegrator
+{
+public:
+   // This avoids an error when GetRule is called with an interpolator even if
+   // it is never used.
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   {
+      return IntRules.Get(0, 0);
+   }
+};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3561,17 +3911,14 @@ public:
    GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
                                        const FiniteElement &nd_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   /** @brief Setup method for PA data.
-
-       @param[in] trial_fes   H1 Lagrange space
-       @param[in] test_fes    H(curl) Nedelec space
-    */
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -3597,6 +3944,8 @@ class IdentityInterpolator : public DiscreteInterpolator
 public:
    IdentityInterpolator(): dofquad_fe(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
@@ -3628,11 +3977,21 @@ private:
 class CurlInterpolator : public DiscreteInterpolator
 {
 public:
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 };
 
 /** Class for constructing the (local) discrete divergence matrix which can
diff --git a/fem/ceed/integrators/convection/convection.cpp b/fem/ceed/integrators/convection/convection.cpp
index c5560f354..cf6875d57 100644
--- a/fem/ceed/integrators/convection/convection.cpp
+++ b/fem/ceed/integrators/convection/convection.cpp
@@ -25,81 +25,96 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct ConvectionOperatorInfo : public OperatorInfo
 {
-   ConvectionContext ctx;
-   ConvectionOperatorInfo(int dim, double alpha)
+   ConvectionContext ctx = {0};
+   bool ctx_coeff = false;
+   ConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ, double alpha,
+                          bool use_bdr = false, bool use_mf = false)
    {
+      MFEM_VERIFY(VQ && VQ->GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Incorrect coefficient dimensions in ceed::ConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.alpha = alpha;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ->GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CONV_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/convection/convection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * (dim + 1) / 2;
-      ctx.alpha = alpha;
+      qdatasize = ctx.dim;
    }
 };
 #endif
 
 PAConvectionIntegrator::PAConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : PAIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedPAConvectionIntegrator::MixedPAConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? VQ : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
 MFConvectionIntegrator::MFConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFConvectionIntegrator::MixedMFConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? VQ : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/convection/convection.hpp b/fem/ceed/integrators/convection/convection.hpp
index 1cd968770..713b98c2c 100644
--- a/fem/ceed/integrators/convection/convection.hpp
+++ b/fem/ceed/integrators/convection/convection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_CONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,41 +23,25 @@ namespace ceed
 {
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::Partial using libCEED.
-class PAConvectionIntegrator : public PAIntegrator
+class PAConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedPAConvectionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   PAConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::None using libCEED.
-class MFConvectionIntegrator : public MFIntegrator
-{
-public:
-   MFConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedMFConvectionIntegrator : public MixedIntegrator<MFIntegrator>
+class MFConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   MFConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/convection/convection_qf.h b/fem/ceed/integrators/convection/convection_qf.h
index 68e96895e..0dd11387c 100644
--- a/fem/ceed/integrators/convection/convection_qf.h
+++ b/fem/ceed/integrators/convection/convection_qf.h
@@ -9,207 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct ConvectionContext {
-   CeedInt dim, space_dim, vdim;
-   CeedScalar coeff[3];
+#ifndef MFEM_LIBCEED_CONV_QF_H
+#define MFEM_LIBCEED_CONV_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CONV_COEFF_COMP_MAX 3
+
+struct ConvectionContext
+{
+   CeedInt dim, space_dim;
    CeedScalar alpha;
+   CeedScalar coeff[LIBCEED_CONV_COEFF_COMP_MAX];
 };
 
-/// libCEED Q-function for building quadrature data for a convection operator
+/// libCEED QFunction for building quadrature data for a convection operator
 /// with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute and store qw * α * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = alpha * coeff0 * qw[i] * J[i];
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * alpha * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   // At every quadrature point, compute and store qw * α * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = alpha * coeff * qw[i] * J[i];
+            qd[i] = qw[i] * alpha * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [dim, ncomp=1, Q]
+   // out[0] has shape [ncomp=1, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (bc->dim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
-         }
-         break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,313 +161,147 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1 + qd[i + Q * 2] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            const CeedScalar qd2 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
-         }
-         break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute qw * α * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * coeff0 * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * alpha * coeff0 * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw * α * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * c[i] * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar qd = qw[i] * alpha * c[i] * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt d = 0; d < 2; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt d = 0; d < 3; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_CONV_QF_H
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.cpp b/fem/ceed/integrators/curlcurl/curlcurl.cpp
new file mode 100644
index 000000000..0cc66b380
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.cpp
@@ -0,0 +1,249 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "curlcurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct CurlCurlOperatorInfo : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   CurlCurlOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                        bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "CurlCurlIntegrator requires dim == 2 or dim == 3!");
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Curl;
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.hpp b/fem/ceed/integrators/curlcurl/curlcurl.hpp
new file mode 100644
index 000000000..71d62c915
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_HPP
+#define MFEM_LIBCEED_CURLCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::Partial using libCEED.
+class PACurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PACurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::None using libCEED.
+class MFCurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFCurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_HPP
diff --git a/fem/ceed/integrators/curlcurl/curlcurl_qf.h b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
new file mode 100644
index 000000000..6fbace54b
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
@@ -0,0 +1,479 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_QF_H
+#define MFEM_LIBCEED_CURLCURL_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CURLCURL_COEFF_COMP_MAX 6
+
+struct CurlCurlContext
+{
+   CeedInt dim, space_dim, curl_dim;
+   CeedScalar coeff[LIBCEED_CURLCURL_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator
+CEED_QFUNCTION(f_apply_curlcurl)(void *ctx, CeedInt Q,
+                                 const CeedScalar *const *in,
+                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   const CeedScalar *uc = in[0], *qd = in[1];
+   CeedScalar *vc = out[0];
+   switch (10 * bc->dim + bc->curl_dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vc[i] = qd[i] * uc[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[i + Q * 0] * uc0 + qd[i + Q * 1] * uc1 + qd[i + Q * 2] * uc2;
+            vc[i + Q * 1] = qd[i + Q * 1] * uc0 + qd[i + Q * 3] * uc1 + qd[i + Q * 4] * uc2;
+            vc[i + Q * 2] = qd[i + Q * 2] * uc0 + qd[i + Q * 4] * uc1 + qd[i + Q * 5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_QF_H
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp b/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp
new file mode 100644
index 000000000..ad0327dda
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp
@@ -0,0 +1,155 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "curlcurlmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "curlcurlmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct CurlCurlMassOperatorInfo : public OperatorInfo
+{
+   CurlCurlMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType1, typename CoeffType2>
+   CurlCurlMassOperatorInfo(const mfem::FiniteElementSpace &fes,
+                            CoeffType1 *Qd, CoeffType2 *Qm,
+                            bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "CurlCurlMassIntegrator requires dim == 2 or dim == 3!");
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      apply_func = ":f_apply_curlcurl_mass";
+      apply_qf = &f_apply_curlcurl_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED CurlCurlMassIntegrator requires both a "
+                  "curl-curl and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/curlcurlmass/curlcurlmass_qf.h";
+      trial_op = EvalMode::InterpAndCurl;
+      test_op = EvalMode::InterpAndCurl;
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2 +
+                  (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_scalar;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_vector";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_vector;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_matrix;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_vector_scalar;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_vector";
+      build_qf = &f_build_curlcurl_mass_quad_vector_vector;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_vector_matrix;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_scalar;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_vector";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_vector;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType1, typename CoeffType2>
+PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType1 *Qd,
+   CoeffType2 *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::MatrixCoefficient *, const bool);
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::MatrixCoefficient *, const bool);
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp b/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp
new file mode 100644
index 000000000..e68d9c28b
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp
@@ -0,0 +1,41 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_MASS_HPP
+#define MFEM_LIBCEED_CURLCURL_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a CurlCurlMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PACurlCurlMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType1, typename CoeffType2>
+   PACurlCurlMassIntegrator(const mfem::CurlCurlMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType1 *Qd,
+                            CoeffType2 *Qm,
+                            const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_MASS_HPP
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h b/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h
new file mode 100644
index 000000000..a7cc2488d
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h
@@ -0,0 +1,432 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_MASS_QF_H
+#define MFEM_LIBCEED_CURLCURL_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct CurlCurlMassContext
+{
+   CeedInt dim, space_dim, curl_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar and vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar and matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector and scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector and matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix and scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix and vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl + mass operator
+CEED_QFUNCTION(f_apply_curlcurl_mass)(void *ctx, CeedInt Q,
+                                      const CeedScalar *const *in,
+                                      CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1], out[1] have shape [curl_dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *uc = in[1], *qdd = in[2],
+                     *qdm = in[2] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   CeedScalar *v = out[0], *vc = out[1];
+   switch (10 * bc->dim + bc->curl_dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vc[i] = qdd[i] * uc[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] =
+               qdd[i + Q * 0] * uc0 + qdd[i + Q * 1] * uc1 + qdd[i + Q * 2] * uc2;
+            vc[i + Q * 1] =
+               qdd[i + Q * 1] * uc0 + qdd[i + Q * 3] * uc1 + qdd[i + Q * 4] * uc2;
+            vc[i + Q * 2] =
+               qdd[i + Q * 2] * uc0 + qdd[i + Q * 4] * uc1 + qdd[i + Q * 5] * uc2;
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1 + qdm[i + Q * 2] * u2;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 3] * u1 + qdm[i + Q * 4] * u2;
+            v[i + Q * 2] = qdm[i + Q * 2] * u0 + qdm[i + Q * 4] * u1 + qdm[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_MASS_QF_H
diff --git a/fem/ceed/integrators/diffusion/diffusion.cpp b/fem/ceed/integrators/diffusion/diffusion.cpp
index 4cd68669f..0650eabbb 100644
--- a/fem/ceed/integrators/diffusion/diffusion.cpp
+++ b/fem/ceed/integrators/diffusion/diffusion.cpp
@@ -25,106 +25,258 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct DiffusionOperatorInfo : public OperatorInfo
 {
-   DiffusionContext ctx;
-   DiffusionOperatorInfo(int dim)
+   DiffusionContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DiffusionOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                         bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
       header = "/integrators/diffusion/diffusion_qf.h";
-      build_func_const = ":f_build_diff_const";
-      build_qf_const = &f_build_diff_const;
-      build_func_quad = ":f_build_diff_quad";
-      build_qf_quad = &f_build_diff_quad;
-      apply_func = ":f_apply_diff";
-      apply_qf = &f_apply_diff;
-      apply_func_mf_const = ":f_apply_diff_mf_const";
-      apply_qf_mf_const = &f_apply_diff_mf_const;
-      apply_func_mf_quad = ":f_apply_diff_mf_quad";
-      apply_qf_mf_quad = &f_apply_diff_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Grad;
-      qdatasize = dim*(dim+1)/2;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
    }
 };
 #endif
 
+template <typename CoeffType>
 PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const DiffusionIntegrator &integ,
+template <typename CoeffType>
+PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
+template <typename CoeffType>
+MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
+template <typename CoeffType>
 MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const DiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+// @cond DOXYGEN_SKIP
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+// @endcond
 
 } // namespace ceed
 
diff --git a/fem/ceed/integrators/diffusion/diffusion.hpp b/fem/ceed/integrators/diffusion/diffusion.hpp
index dd28c9d16..b92710bad 100644
--- a/fem/ceed/integrators/diffusion/diffusion.hpp
+++ b/fem/ceed/integrators/diffusion/diffusion.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_DIFF_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,37 @@ namespace ceed
 {
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::Partial using libCEED.
-class PADiffusionIntegrator : public PAIntegrator
+class PADiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PADiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedPADiffusionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPADiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedPADiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::None using libCEED.
-class MFDiffusionIntegrator : public MFIntegrator
+class MFDiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFDiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedMFDiffusionIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFDiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedMFDiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/diffusion/diffusion_qf.h b/fem/ceed/integrators/diffusion/diffusion_qf.h
index aa4850e37..9ab50a3ed 100644
--- a/fem/ceed/integrators/diffusion/diffusion_qf.h
+++ b/fem/ceed/integrators/diffusion/diffusion_qf.h
@@ -9,180 +9,331 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_DIFF_QF_H
+#define MFEM_LIBCEED_DIFF_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct DiffusionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// with a constant coefficient
-CEED_QFUNCTION(f_build_diff_const)(void *ctx, CeedInt Q,
-                                   const CeedScalar *const *in,
-                                   CeedScalar *const *out)
+#define LIBCEED_DIFF_COEFF_COMP_MAX 6
+
+struct DiffusionContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff[LIBCEED_DIFF_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_diff_const_scalar)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_diff_const_vector)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_diff_const_matrix)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] / J[i];
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// coefficient evaluated at quadrature points.
-CEED_QFUNCTION(f_build_diff_quad)(void *ctx, CeedInt Q,
-                                  const CeedScalar *const *in,
-                                  CeedScalar *const *out)
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_scalar)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = c[i] * qw[i] / J[i];
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_vector)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_matrix)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator
 CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->dim + bc->vdim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
+         }
+         break;
+      case 12:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd0 = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd0 * ug[i + Q * d];
+            }
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -191,23 +342,23 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
             const CeedScalar qd10 = qd01;
             const CeedScalar qd11 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 2; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd00 * ug0 + qd01 * ug1;
-               vg[i + Q * (c+2*1)] = qd10 * ug0 + qd11 * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd10 * ug0 + qd11 * ug1;
             }
          }
          break;
       case 31:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,8 +368,24 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[i + Q * 2] * ug0 + qd[i + Q * 4] * ug1 + qd[i + Q * 5] * ug2;
          }
          break;
+      case 23:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd01 = qd[i + Q * 1];
+            const CeedScalar qd10 = qd01;
+            const CeedScalar qd11 = qd[i + Q * 2];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1;
+            }
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
@@ -229,14 +396,14 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             const CeedScalar qd20 = qd02;
             const CeedScalar qd21 = qd12;
             const CeedScalar qd22 = qd[i + Q * 5];
-            for (CeedInt c = 0; c < 3; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
-               vg[i + Q * (c+3*1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
-               vg[i + Q * (c+3*2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
             }
          }
          break;
@@ -244,104 +411,105 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
-CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in,
-                                      CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt c = 0; c < 2; c++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (c+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -350,46 +518,19 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt c = 0; c < 3; c++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (c+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (c+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
@@ -397,105 +538,97 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
-CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in,
-                                     CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt d = 0; d < 2; d++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * (d+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (d+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -504,50 +637,507 @@ CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt d = 0; d < 3; d++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * (d+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (d+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (d+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
    }
    return 0;
 }
+
+/// libCEED QFunction for applying a diffusion operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_vector)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIFF_QF_H
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass.cpp b/fem/ceed/integrators/diffusionmass/diffusionmass.cpp
new file mode 100644
index 000000000..36201dc1c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass.cpp
@@ -0,0 +1,100 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "diffusionmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "diffusionmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DiffusionMassOperatorInfo : public OperatorInfo
+{
+   DiffusionMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DiffusionMassOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Qd,
+                             mfem::Coefficient *Qm, bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED DiffusionMassIntegrator for does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      apply_func = ":f_apply_diff_mass";
+      apply_qf = &f_apply_diff_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED DiffusionMassIntegrator requires both a "
+                  "diffusion and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/diffusionmass/diffusionmass_qf.h";
+      trial_op = EvalMode::InterpAndGrad;
+      test_op = EvalMode::InterpAndGrad;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2 + 1;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_scalar";
+      build_qf = &f_build_diff_mass_quad_scalar;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &VQd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_vector";
+      build_qf = &f_build_diff_mass_quad_vector;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &MQd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_matrix";
+      build_qf = &f_build_diff_mass_quad_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Qd,
+   mfem::Coefficient *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DiffusionMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::Coefficient *, const bool);
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::Coefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass.hpp b/fem/ceed/integrators/diffusionmass/diffusionmass.hpp
new file mode 100644
index 000000000..f81a9266c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass.hpp
@@ -0,0 +1,42 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIFF_MASS_HPP
+#define MFEM_LIBCEED_DIFF_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a DiffusionMassIntegrator with AssemblyLevel::Partial using
+    libCEED. */
+class PADiffusionMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PADiffusionMassIntegrator(const mfem::DiffusionMassIntegrator &integ,
+                             const mfem::FiniteElementSpace &fes,
+                             CoeffType *Qd,
+                             mfem::Coefficient *Qm,
+                             const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIFF_MASS_HPP
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h b/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h
new file mode 100644
index 000000000..a04a36e2c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h
@@ -0,0 +1,268 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIFF_MASS_QF_H
+#define MFEM_LIBCEED_DIFF_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct DiffusionMassContext
+{
+   CeedInt dim, space_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / J[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 2, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 2, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion + mass operator
+CEED_QFUNCTION(f_apply_diff_mass)(void *ctx, CeedInt Q,
+                                  const CeedScalar *const *in,
+                                  CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[1], out[1] have shape [dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *ug = in[1], *qdd = in[2],
+                     *qdm = in[2] + bc->dim * (bc->dim + 1) / 2 * Q;
+   CeedScalar *v = out[0], *vg = out[1];
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vg[i] = qdd[i] * ug[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qdd[i + Q * 0] * ug0 + qdd[i + Q * 1] * ug1;
+            vg[i + Q * 1] = qdd[i + Q * 1] * ug0 + qdd[i + Q * 2] * ug1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] =
+               qdd[i + Q * 0] * ug0 + qdd[i + Q * 1] * ug1 + qdd[i + Q * 2] * ug2;
+            vg[i + Q * 1] =
+               qdd[i + Q * 1] * ug0 + qdd[i + Q * 3] * ug1 + qdd[i + Q * 4] * ug2;
+            vg[i + Q * 2] =
+               qdd[i + Q * 2] * ug0 + qdd[i + Q * 4] * ug1 + qdd[i + Q * 5] * ug2;
+         }
+         break;
+   }
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      v[i] = qdm[i] * u[i];
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIFF_MASS_QF_H
diff --git a/fem/ceed/integrators/divdiv/divdiv.cpp b/fem/ceed/integrators/divdiv/divdiv.cpp
new file mode 100644
index 000000000..49ed27ca5
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.cpp
@@ -0,0 +1,127 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "divdiv.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "divdiv_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DivDivOperatorInfo : public OperatorInfo
+{
+   DivDivContext ctx = {0};
+   bool ctx_coeff = false;
+   DivDivOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                      bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_divdiv";
+         apply_qf = &f_apply_divdiv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_quad";
+            build_qf = &f_build_divdiv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_quad";
+            apply_qf = &f_apply_divdiv_mf_quad;
+         }
+      }
+      header = "/integrators/divdiv/divdiv_qf.h";
+      trial_op = EvalMode::Div;
+      test_op = EvalMode::Div;
+      qdatasize = 1;
+   }
+};
+#endif
+
+PADivDivIntegrator::PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+MFDivDivIntegrator::MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/divdiv/divdiv.hpp b/fem/ceed/integrators/divdiv/divdiv.hpp
new file mode 100644
index 000000000..1e5bf163e
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.hpp
@@ -0,0 +1,49 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_HPP
+#define MFEM_LIBCEED_DIVDIV_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a DivDivIntegrator with AssemblyLevel::Partial using libCEED.
+class PADivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+/// Represent a DivDivIntegrator with AssemblyLevel::None using libCEED.
+class MFDivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_HPP
diff --git a/fem/ceed/integrators/divdiv/divdiv_qf.h b/fem/ceed/integrators/divdiv/divdiv_qf.h
new file mode 100644
index 000000000..853aa0011
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv_qf.h
@@ -0,0 +1,250 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_QF_H
+#define MFEM_LIBCEED_DIVDIV_QF_H
+
+#include "../util/util_qf.h"
+
+struct DivDivContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a constant coefficient
+CEED_QFUNCTION(f_build_divdiv_const)(void *ctx, CeedInt Q,
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_quad)(void *ctx, CeedInt Q,
+                                    const CeedScalar *const *in,
+                                    CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator
+CEED_QFUNCTION(f_apply_divdiv)(void *ctx, CeedInt Q,
+                               const CeedScalar *const *in,
+                               CeedScalar *const *out)
+{
+   // in[0], out[0] have shape [ncomp=1, Q]
+   const CeedScalar *ud = in[0], *qd = in[1];
+   CeedScalar *vd = out[0];
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      vd[i] = qd[i] * ud[i];
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a constant
+/// coefficient
+CEED_QFUNCTION(f_apply_divdiv_mf_const)(void *ctx, CeedInt Q,
+                                        const CeedScalar *const *in,
+                                        CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *ud = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a coefficient
+/// evaluated at quadrature points
+CEED_QFUNCTION(f_apply_divdiv_mf_quad)(void *ctx, CeedInt Q,
+                                       const CeedScalar *const *in,
+                                       CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[0] is coefficients, size (Q)
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar *ud = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_QF_H
diff --git a/fem/ceed/integrators/divdivmass/divdivmass.cpp b/fem/ceed/integrators/divdivmass/divdivmass.cpp
new file mode 100644
index 000000000..b6595752c
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass.cpp
@@ -0,0 +1,101 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "divdivmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "divdivmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DivDivMassOperatorInfo : public OperatorInfo
+{
+   DivDivMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DivDivMassOperatorInfo(const mfem::FiniteElementSpace &fes,
+                          mfem::Coefficient *Qd, CoeffType *Qm,
+                          bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      apply_func = ":f_apply_divdiv_mass";
+      apply_qf = &f_apply_divdiv_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED DivDivMassIntegrator requires both a "
+                  "div-div and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/divdivmass/divdivmass_qf.h";
+      trial_op = EvalMode::InterpAndDiv;
+      test_op = EvalMode::InterpAndDiv;
+      qdatasize = 1 + (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_scalar";
+      build_qf = &f_build_divdiv_mass_quad_scalar;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_vector";
+      build_qf = &f_build_divdiv_mass_quad_vector;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_matrix";
+      build_qf = &f_build_divdiv_mass_quad_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   mfem::Coefficient *Qd,
+   CoeffType *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::VectorCoefficient *, const bool);
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/divdivmass/divdivmass.hpp b/fem/ceed/integrators/divdivmass/divdivmass.hpp
new file mode 100644
index 000000000..03f3d0c9b
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass.hpp
@@ -0,0 +1,41 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_MASS_HPP
+#define MFEM_LIBCEED_DIVDIV_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a DivDivMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PADivDivMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PADivDivMassIntegrator(const mfem::DivDivMassIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::Coefficient *Qd,
+                          CoeffType *Qm,
+                          const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_MASS_HPP
diff --git a/fem/ceed/integrators/divdivmass/divdivmass_qf.h b/fem/ceed/integrators/divdivmass/divdivmass_qf.h
new file mode 100644
index 000000000..788bfc0b4
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass_qf.h
@@ -0,0 +1,264 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_MASS_QF_H
+#define MFEM_LIBCEED_DIVDIV_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct DivDivMassContext
+{
+   CeedInt dim, space_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / J[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div + mass operator
+CEED_QFUNCTION(f_apply_divdiv_mass)(void *ctx, CeedInt Q,
+                                    const CeedScalar *const *in,
+                                    CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1], out[1] have shape [ncomp=1, Q]
+   const CeedScalar *u = in[0], *ud = in[1], *qdd = in[2], *qdm = in[2] + Q;
+   CeedScalar *v = out[0], *vd = out[1];
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      vd[i] = qdd[i] * ud[i];
+   }
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            v[i] = qdm[i] * u[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 2] * u1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1 + qdm[i + Q * 2] * u2;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 3] * u1 + qdm[i + Q * 4] * u2;
+            v[i + Q * 2] = qdm[i + Q * 2] * u0 + qdm[i + Q * 4] * u1 + qdm[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_MASS_QF_H
diff --git a/fem/ceed/integrators/interp/interp.cpp b/fem/ceed/integrators/interp/interp.cpp
new file mode 100644
index 000000000..6aab4f47f
--- /dev/null
+++ b/fem/ceed/integrators/interp/interp.cpp
@@ -0,0 +1,58 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "interp.hpp"
+
+#include "../../../../config/config.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DiscreteInterpolatorOperatorInfo : public OperatorInfo
+{
+   DiscreteInterpolatorOperatorInfo()
+   {
+      // Discrete interpolators use a built-in QFunction
+      header = "";
+      header = "";
+      build_func = "";
+      build_qf = nullptr;
+      apply_func = "";
+      apply_qf = nullptr;
+      apply_func_mf = "";
+      apply_qf_mf = nullptr;
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::None;
+      qdatasize = 0;
+   }
+};
+#endif
+
+PADiscreteInterpolator::PADiscreteInterpolator(
+   const mfem::DiscreteInterpolator &interp,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes)
+{
+#ifdef MFEM_USE_CEED
+   DiscreteInterpolatorOperatorInfo info;
+   Assemble(interp, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.hpp b/fem/ceed/integrators/interp/interp.hpp
similarity index 50%
rename from fem/ceed/solvers/full-assembly.hpp
rename to fem/ceed/integrators/interp/interp.hpp
index ed338f725..a923df572 100644
--- a/fem/ceed/solvers/full-assembly.hpp
+++ b/fem/ceed/integrators/interp/interp.hpp
@@ -9,12 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_CEED_ASSEMBLE_HPP
-#define MFEM_CEED_ASSEMBLE_HPP
+#ifndef MFEM_LIBCEED_INTERP_HPP
+#define MFEM_LIBCEED_INTERP_HPP
 
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
 
 namespace mfem
 {
@@ -22,18 +22,19 @@ namespace mfem
 namespace ceed
 {
 
-/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
-
-    In parallel, this assembles independently on each processor, that is, it
-    assembles at the L-vector level. The assembly procedure is always performed
-    on the host, but this works also for operators stored on device by copying
-    memory. */
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat);
-
-} // namespace ceed
+/** Represent DiscreteInterpolator classes with AssemblyLevel::Partial
+    using libCEED. */
+class PADiscreteInterpolator : public MixedOperator<Interpolator>
+{
+public:
+   PADiscreteInterpolator(
+      const mfem::DiscreteInterpolator &interp,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes);
+};
 
-} // namespace mfem
+}
 
-#endif
+}
 
-#endif
+#endif // MFEM_LIBCEED_INTERP_HPP
diff --git a/fem/ceed/integrators/mass/mass.cpp b/fem/ceed/integrators/mass/mass.cpp
index dfcc9a8ce..593d5faed 100644
--- a/fem/ceed/integrators/mass/mass.cpp
+++ b/fem/ceed/integrators/mass/mass.cpp
@@ -25,20 +25,69 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct MassOperatorInfo : public OperatorInfo
 {
-   MassContext ctx;
-   MassOperatorInfo()
+   MassContext ctx = {0};
+   bool ctx_coeff = false;
+   MassOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                    bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_mass";
+         apply_qf = &f_apply_mass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_quad";
+            build_qf = &f_build_mass_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_quad";
+            apply_qf = &f_apply_mass_mf_quad;
+         }
+      }
       header = "/integrators/mass/mass_qf.h";
-      build_func_const = ":f_build_mass_const";
-      build_qf_const = &f_build_mass_const;
-      build_func_quad = ":f_build_mass_quad";
-      build_qf_quad = &f_build_mass_quad;
-      apply_func = ":f_apply_mass";
-      apply_qf = &f_apply_mass;
-      apply_func_mf_const = ":f_apply_mass_mf_const";
-      apply_qf_mf_const = &f_apply_mass_mf_const;
-      apply_func_mf_quad = ":f_apply_mass_mf_quad";
-      apply_qf_mf_quad = &f_apply_mass_mf_quad;
       trial_op = EvalMode::Interp;
       test_op = EvalMode::Interp;
       qdatasize = 1;
@@ -46,75 +95,53 @@ struct MassOperatorInfo : public OperatorInfo
 };
 #endif
 
-PAMassIntegrator::PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : PAIntegrator()
+PAMassIntegrator::PAMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+PAMassIntegrator::PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+MFMassIntegrator::MFMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MFMassIntegrator::MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : MFIntegrator()
+MFMassIntegrator::MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/mass/mass.hpp b/fem/ceed/integrators/mass/mass.hpp
index 696f8c3dc..4125fc6ed 100644
--- a/fem/ceed/integrators/mass/mass.hpp
+++ b/fem/ceed/integrators/mass/mass.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_MASS_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,33 @@ namespace ceed
 {
 
 /// Represent a MassIntegrator with AssemblyLevel::Partial using libCEED.
-class PAMassIntegrator : public PAIntegrator
+class PAMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedPAMassIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   PAMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 /// Represent a MassIntegrator with AssemblyLevel::None using libCEED.
-class MFMassIntegrator : public MFIntegrator
+class MFMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedMFMassIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   MFMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/mass/mass_qf.h b/fem/ceed/integrators/mass/mass_qf.h
index 85002ae04..3cdd3b5e3 100644
--- a/fem/ceed/integrators/mass/mass_qf.h
+++ b/fem/ceed/integrators/mass/mass_qf.h
@@ -9,128 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_MASS_QF_H
+#define MFEM_LIBCEED_MASS_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct MassContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// constant coefficient
+struct MassContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a constant coefficient
 CEED_QFUNCTION(f_build_mass_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = coeff * J[i] * qw[i];
+            qd[i] = qw[i] * coeff * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * coeff * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
+            qd[i] = qw[i] * coeff * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_mass_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
-   // in[1] is quadrature weights, size (Q)
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = c[i] * J[i] * qw[i];
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a mass operator
+/// libCEED QFunction for applying a mass operator
 CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    MassContext *bc = (MassContext *)ctx;
-   const CeedScalar *u = in[0], *w = in[1];
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
    CeedScalar *v = out[0];
    switch (bc->vdim)
    {
       case 1:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            v[i] = w[i] * u[i];
+            v[i] = qd[i] * u[i];
          }
          break;
       case 2:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
       case 3:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
@@ -138,63 +161,95 @@ CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for applying a mass operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in, CeedScalar *const *out)
+                                      const CeedScalar *const *in,
+                                      CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * qw[i] / J[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
@@ -202,69 +257,99 @@ CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a mass operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_mass_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in, CeedScalar *const *out)
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
-   const CeedScalar *c = in[0], *u = in[1], *J = in[2], *qw = in[3];
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i=0; i<Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = c[i] * J[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i=0; i<Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt d = 0; d < 2; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i=0; i<Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            for (CeedInt d = 0; d < 3; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_MASS_QF_H
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
new file mode 100644
index 000000000..835e40736
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
@@ -0,0 +1,347 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedveccurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../curlcurl/curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorCurlOperatorInfoBase : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+   {
+      // Reuse H(div) quadrature functions for CurlCurlIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 3,
+                  "MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator "
+                  "require dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                               const mfem::FiniteElementSpace &test_fes,
+                               CoeffType *Q, bool use_bdr = false,
+                               bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorCurlIntegrator requires "
+         "H(curl) domain and H(div) range FE spaces!");
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorWeakCurlIntegrator requires "
+         "H(div) domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Curl;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
new file mode 100644
index 000000000..3bae19e0c
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECCURL_HPP
+#define MFEM_LIBCEED_MIXEDVECCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECCURL_HPP
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
new file mode 100644
index 000000000..7d00d542f
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
@@ -0,0 +1,409 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedvecgrad.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../diffusion/diffusion_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorGradientOperatorInfoBase : public OperatorInfo
+{
+   DiffusionContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                       const mfem::FiniteElementSpace &test_fes,
+                                       CoeffType *Q, bool use_bdr = false,
+                                       bool use_mf = false)
+   {
+      // Reuse H(curl) quadrature functions for DiffusionIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "MixedVectorGradientIntegrator and MixedVectorWeakDivergenceIntegrator "
+                  "require dim == 2 or dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.vdim = 1;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/diffusion/diffusion_qf.h";
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorGradientOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorGradientIntegrator requires "
+         "H^1 domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Grad;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakDivergenceOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakDivergenceOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                         const mfem::FiniteElementSpace &test_fes,
+                                         CoeffType *Q, bool use_bdr = false,
+                                         bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorWeakDivergenceIntegrator requires "
+         "H(curl) domain and H^1 range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Grad;
+      if (ctx_coeff)
+      {
+         for (int i = 0; i < LIBCEED_DIFF_COEFF_COMP_MAX; i++)
+         {
+            ctx.coeff[i] *= -1.0;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+namespace
+{
+
+#ifdef MFEM_USE_CEED
+mfem::Coefficient *NegativeCoeff(mfem::Coefficient &Q)
+{
+   return new mfem::ProductCoefficient(-1.0, Q);
+}
+
+mfem::VectorCoefficient *NegativeCoeff(mfem::VectorCoefficient &Q)
+{
+   return new mfem::ScalarVectorProductCoefficient(-1.0, Q);
+}
+
+mfem::MatrixCoefficient *NegativeCoeff(mfem::MatrixCoefficient &Q)
+{
+   return new mfem::ScalarMatrixProductCoefficient(-1.0, Q);
+}
+#endif
+
+} // namespace
+
+template <typename CoeffType>
+PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   if (!info.ctx_coeff)
+   {
+      // Does not inherit ownership of old Q
+      MFEM_VERIFY(Q, "Unexpected missing coefficient in libCEED "
+                  "MixedVectorGradientIntegrator!");
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr,
+               use_bdr);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr,
+                                              true);
+   if (!info.ctx_coeff)
+   {
+      // Does not inherit ownership of old Q
+      MFEM_VERIFY(Q, "Unexpected missing coefficient in libCEED "
+                  "MixedVectorGradientIntegrator!");
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr, true);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr,
+               use_bdr, true);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
new file mode 100644
index 000000000..c4220ea0f
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECGRAD_HPP
+#define MFEM_LIBCEED_MIXEDVECGRAD_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECGRAD_HPP
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.cpp b/fem/ceed/integrators/nlconvection/nlconvection.cpp
index ba4a274dc..e46c4a495 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.cpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.cpp
@@ -25,76 +25,101 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct NLConvectionOperatorInfo : public OperatorInfo
 {
-   NLConvectionContext ctx;
-   NLConvectionOperatorInfo(int dim)
+   NLConvectionContext ctx = {0};
+   bool ctx_coeff = false;
+   NLConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                            mfem::Coefficient *Q, bool use_bdr = false,
+                            bool use_mf = false)
    {
+      MFEM_VERIFY(fes.GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Missing coefficient in ceed::NLConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/nlconvection/nlconvection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::InterpAndGrad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * dim;
+      qdatasize = ctx.dim * ctx.space_dim;
    }
 };
 #endif
 
-PAVectorConvectionNLFIntegrator::PAVectorConvectionNLFIntegrator(
+PAVectorConvectionNLIntegrator::PAVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAVectorConvectionNLIntegrator::MixedPAVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
+MFVectorConvectionNLIntegrator::MFVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MFVectorConvectionNLFIntegrator::MFVectorConvectionNLFIntegrator(
-   const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFVectorConvectionNLIntegrator::MixedMFVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.hpp b/fem/ceed/integrators/nlconvection/nlconvection.hpp
index 3efe88728..cf245322a 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.hpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_NLCONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -24,40 +24,26 @@ namespace ceed
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::Partial
     using libCEED. */
-class PAVectorConvectionNLFIntegrator : public PAIntegrator
+class PAVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedPAVectorConvectionNLIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   PAVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::None
     using libCEED. */
-class MFVectorConvectionNLFIntegrator : public MFIntegrator
-{
-public:
-   MFVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedMFVectorConvectionNLIntegrator : public MixedIntegrator<MFIntegrator>
+class MFVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   MFVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/nlconvection/nlconvection_qf.h b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
index ef0d41327..ee1782784 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection_qf.h
+++ b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
@@ -9,186 +9,155 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct NLConvectionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#ifndef MFEM_LIBCEED_NLCONV_QF_H
+#define MFEM_LIBCEED_NLCONV_QF_H
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// with a constant coefficient
+#include "../util/util_qf.h"
+
+struct NLConvectionContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * coeff, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * c[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // out[0] has shape [ncomp=space_dim, Q]
    const CeedScalar *u = in[0], *ug = in[1], *qd = in[2];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vg[i] = qd[i] * u[i] * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = u[i] * ug[i] * qd[i];
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd00 * ug00;
+            const CeedScalar Dyu0 = qd10 * ug00;
+            const CeedScalar Dxu1 = qd00 * ug10;
+            const CeedScalar Dyu1 = qd10 * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -200,16 +169,47 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar qd20 = qd[i + Q * 2];
+            const CeedScalar qd01 = qd[i + Q * 3];
+            const CeedScalar qd11 = qd[i + Q * 4];
+            const CeedScalar qd21 = qd[i + Q * 5];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -232,15 +232,15 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01 + qd02 * ug02;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01 + qd12 * ug02;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01 + qd22 * ug02;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11 + qd02 * ug12;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11 + qd12 * ug12;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11 + qd22 * ug12;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21 + qd02 * ug22;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21 + qd12 * ug22;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21 + qd22 * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -250,91 +250,101 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
+   // At every quadrature point, compute qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *ug = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -347,15 +357,15 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -365,89 +375,101 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is coefficients, size (Q)
+   // in[3] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[4] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *u = in[1], *ug = in[2], *J = in[3], *qw = in[4];
+   // At every quadrature point, compute qw * c * adj(J)^T
+   const CeedScalar *u = in[0], *ug = in[1], *c = in[2], *J = in[3], *qw = in[4];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -460,15 +482,15 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -477,3 +499,5 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_NLCONV_QF_H
diff --git a/fem/ceed/integrators/util/util_qf.h b/fem/ceed/integrators/util/util_qf.h
new file mode 100644
index 000000000..fa7ca763b
--- /dev/null
+++ b/fem/ceed/integrators/util/util_qf.h
@@ -0,0 +1,855 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_UTIL_QF_H
+#define MFEM_LIBCEED_UTIL_QF_H
+
+#include <math.h>
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ22(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 2
+   //    1 3
+   return J[J_stride * 0] * J[J_stride * 3] -
+          J[J_stride * 1] * J[J_stride * 2];
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ21(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0
+   //    1
+   return sqrt(J[J_stride * 0] * J[J_stride * 0] +
+               J[J_stride * 1] * J[J_stride * 1]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ33(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   return J[J_stride * 0] * (J[J_stride * 4] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 7]) -
+          J[J_stride * 1] * (J[J_stride * 3] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 6]) +
+          J[J_stride * 2] * (J[J_stride * 3] * J[J_stride * 7] -
+                             J[J_stride * 4] * J[J_stride * 6]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ32(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar E = J[J_stride * 0] * J[J_stride * 0] +
+                        J[J_stride * 1] * J[J_stride * 1] +
+                        J[J_stride * 2] * J[J_stride * 2];
+   const CeedScalar G = J[J_stride * 3] * J[J_stride * 3] +
+                        J[J_stride * 4] * J[J_stride * 4] +
+                        J[J_stride * 5] * J[J_stride * 5];
+   const CeedScalar F = J[J_stride * 0] * J[J_stride * 3] +
+                        J[J_stride * 1] * J[J_stride * 4] +
+                        J[J_stride * 2] * J[J_stride * 5];
+   return sqrt(E * G - F * F);
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt22(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 1
+   //    1 3           -J21  J11       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 =  c[c_stride * 0] * J22 - c[c_stride * 1] * J12;
+      const CeedScalar R21 =  c[c_stride * 1] * J22 - c[c_stride * 2] * J12;
+      const CeedScalar R12 = -c[c_stride * 0] * J21 + c[c_stride * 1] * J11;
+      const CeedScalar R22 = -c[c_stride * 1] * J21 + c[c_stride * 2] * J11;
+      qd[qd_stride * 0] = w * (J22 * R11 - J12 * R21);
+      qd[qd_stride * 1] = w * (J11 * R21 - J21 * R11);
+      qd[qd_stride * 2] = w * (J11 * R22 - J21 * R12);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] =  w * (c[c_stride * 1] * J12 * J12 +
+                                c[c_stride * 0] * J22 * J22);
+      qd[qd_stride * 1] = -w * (c[c_stride * 1] * J11 * J12 +
+                                c[c_stride * 0] * J21 * J22);
+      qd[qd_stride * 2] =  w * (c[c_stride * 1] * J11 * J11 +
+                                c[c_stride * 0] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt21(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar d = J11 * J11 + J21 * J21;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21) / d;
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0];
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt33(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w = qw / (J11 * A11 + J21 * A12 + J31 * A13);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * A11 +
+                             c[c_stride * 1] * A12 +
+                             c[c_stride * 2] * A13;
+      const CeedScalar R12 = c[c_stride * 0] * A21 +
+                             c[c_stride * 1] * A22 +
+                             c[c_stride * 2] * A23;
+      const CeedScalar R13 = c[c_stride * 0] * A31 +
+                             c[c_stride * 1] * A32 +
+                             c[c_stride * 2] * A33;
+      const CeedScalar R21 = c[c_stride * 1] * A11 +
+                             c[c_stride * 3] * A12 +
+                             c[c_stride * 4] * A13;
+      const CeedScalar R22 = c[c_stride * 1] * A21 +
+                             c[c_stride * 3] * A22 +
+                             c[c_stride * 4] * A23;
+      const CeedScalar R23 = c[c_stride * 1] * A31 +
+                             c[c_stride * 3] * A32 +
+                             c[c_stride * 4] * A33;
+      const CeedScalar R31 = c[c_stride * 2] * A11 +
+                             c[c_stride * 4] * A12 +
+                             c[c_stride * 5] * A13;
+      const CeedScalar R32 = c[c_stride * 2] * A21 +
+                             c[c_stride * 4] * A22 +
+                             c[c_stride * 5] * A23;
+      const CeedScalar R33 = c[c_stride * 2] * A31 +
+                             c[c_stride * 4] * A32 +
+                             c[c_stride * 5] * A33;
+      qd[qd_stride * 0] = w * (A11 * R11 + A12 * R21 + A13 * R31);
+      qd[qd_stride * 1] = w * (A11 * R12 + A12 * R22 + A13 * R32);
+      qd[qd_stride * 2] = w * (A11 * R13 + A12 * R23 + A13 * R33);
+      qd[qd_stride * 3] = w * (A21 * R12 + A22 * R22 + A23 * R32);
+      qd[qd_stride * 4] = w * (A21 * R13 + A22 * R23 + A23 * R33);
+      qd[qd_stride * 5] = w * (A31 * R13 + A32 * R23 + A33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * A11 * A11 +
+                               c[c_stride * 1] * A12 * A12 +
+                               c[c_stride * 2] * A13 * A13);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * A11 * A21 +
+                               c[c_stride * 1] * A12 * A22 +
+                               c[c_stride * 2] * A13 * A23);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * A11 * A31 +
+                               c[c_stride * 1] * A12 * A32 +
+                               c[c_stride * 2] * A13 * A33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * A21 * A21 +
+                               c[c_stride * 1] * A22 * A22 +
+                               c[c_stride * 2] * A23 * A23);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * A21 * A31 +
+                               c[c_stride * 1] * A22 * A32 +
+                               c[c_stride * 2] * A23 * A33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * A31 * A31 +
+                               c[c_stride * 1] * A32 * A32 +
+                               c[c_stride * 2] * A33 * A33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (A11 * A11 + A12 * A12 + A13 * A13);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (A11 * A21 + A12 * A22 + A13 * A23);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (A11 * A31 + A12 * A32 + A13 * A33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (A21 * A21 + A22 * A22 + A23 * A23);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (A21 * A31 + A22 * A32 + A23 * A33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (A31 * A31 + A32 * A32 + A33 * A33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt32(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar d = E * G - F * F;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = G * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31) -
+                             F * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32);
+      const CeedScalar R21 = G * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31) -
+                             F * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32);
+      const CeedScalar R31 = G * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31) -
+                             F * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32);
+      const CeedScalar R12 = E * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32) -
+                             F * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31);
+      const CeedScalar R22 = E * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32) -
+                             F * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31);
+      const CeedScalar R32 = E * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32) -
+                             F * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0
+      //      1
+      //        2
+      const CeedScalar R11 = c[c_stride * 0] * (G * J11 - F * J12);
+      const CeedScalar R21 = c[c_stride * 1] * (G * J21 - F * J22);
+      const CeedScalar R31 = c[c_stride * 2] * (G * J31 - F * J32);
+      const CeedScalar R12 = c[c_stride * 0] * (E * J12 - F * J11);
+      const CeedScalar R22 = c[c_stride * 1] * (E * J22 - F * J21);
+      const CeedScalar R32 = c[c_stride * 2] * (E * J32 - F * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * G;
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * E;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ22(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 2   qd: 0 1
+   //    1 3       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      const CeedScalar R12 = c[c_stride * 0] * J12 + c[c_stride * 1] * J22;
+      const CeedScalar R22 = c[c_stride * 1] * J12 + c[c_stride * 2] * J22;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+      qd[qd_stride * 1] = w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] = w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ21(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = qw * c[c_stride * 0] * sqrt(J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ33(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar w = qw / (J11 * (J22 * J33 - J23 * J32) +
+                              J21 * (J13 * J32 - J12 * J33) +
+                              J31 * (J12 * J23 - J13 * J22));
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R13 = c[c_stride * 0] * J13 +
+                             c[c_stride * 1] * J23 +
+                             c[c_stride * 2] * J33;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R23 = c[c_stride * 1] * J13 +
+                             c[c_stride * 3] * J23 +
+                             c[c_stride * 4] * J33;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      const CeedScalar R33 = c[c_stride * 2] * J13 +
+                             c[c_stride * 4] * J23 +
+                             c[c_stride * 5] * J33;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J11 * R13 + J21 * R23 + J31 * R33);
+      qd[qd_stride * 3] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+      qd[qd_stride * 4] = w * (J12 * R13 + J22 * R23 + J32 * R33);
+      qd[qd_stride * 5] = w * (J13 * R13 + J23 * R23 + J33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J11 * J13 +
+                               c[c_stride * 1] * J21 * J23 +
+                               c[c_stride * 2] * J31 * J33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * J12 * J13 +
+                               c[c_stride * 1] * J22 * J23 +
+                               c[c_stride * 2] * J32 * J33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * J13 * J13 +
+                               c[c_stride * 1] * J23 * J23 +
+                               c[c_stride * 2] * J33 * J33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (J11 * J11 + J21 * J21 + J31 * J31);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (J11 * J12 + J21 * J22 + J31 * J32);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (J11 * J13 + J21 * J23 + J31 * J33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (J12 * J12 + J22 * J22 + J32 * J32);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (J12 * J13 + J22 * J23 + J32 * J33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (J13 * J13 + J23 * J23 + J33 * J33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ32(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * E;
+      qd[qd_stride * 1] = w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] = w * c[c_stride * 0] * G;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt22(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 2   adj(J):  J22 -J12
+   //    1 3           -J21  J11
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J22 - w2 * J12;
+   qd[qd_stride * 1] = -w1 * J21 + w2 * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt21(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J11 + w2 * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt33(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   const CeedScalar w3 = qw * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+   qd[qd_stride * 2] = w1 * A31 + w2 * A32 + w3 * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt32(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   const CeedScalar w3 = w * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt22(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 2
+   //    1 3           -J21  J11       1 3
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   qd[qd_stride * 0] =  qw * J22;
+   qd[qd_stride * 1] = -qw * J12;
+   qd[qd_stride * 2] = -qw * J21;
+   qd[qd_stride * 3] =  qw * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt21(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0   adj(J):  1/sqrt(J^T J) J^T   qd: 0
+   //    1                                    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   qd[qd_stride * 0] = w * J11;
+   qd[qd_stride * 1] = w * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt33(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3 6   qd: 0 3 6
+   //    1 4 7       1 4 7
+   //    2 5 8       2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   qd[qd_stride * 0] = qw * A11;
+   qd[qd_stride * 1] = qw * A12;
+   qd[qd_stride * 2] = qw * A13;
+   qd[qd_stride * 3] = qw * A21;
+   qd[qd_stride * 4] = qw * A22;
+   qd[qd_stride * 5] = qw * A23;
+   qd[qd_stride * 6] = qw * A31;
+   qd[qd_stride * 7] = qw * A32;
+   qd[qd_stride * 8] = qw * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt32(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3   qd: 0 3
+   //    1 4       1 4
+   //    2 5       2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   qd[qd_stride * 0] = w * A11;
+   qd[qd_stride * 1] = w * A12;
+   qd[qd_stride * 2] = w * A13;
+   qd[qd_stride * 3] = w * A21;
+   qd[qd_stride * 4] = w * A22;
+   qd[qd_stride * 5] = w * A23;
+}
+
+#endif // MFEM_LIBCEED_UTIL_QF_H
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.cpp b/fem/ceed/integrators/vecfemass/vecfemass.cpp
new file mode 100644
index 000000000..ea57d7e19
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.cpp
@@ -0,0 +1,279 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "vecfemass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "vecfemass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct VectorFEMassOperatorInfo : public OperatorInfo
+{
+   VectorFEMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   VectorFEMassOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                            bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      bool is_hdiv = (fes.FEColl()->GetMapType(ctx.dim) ==
+                      mfem::FiniteElement::H_DIV);
+      MFEM_VERIFY(is_hdiv ||
+                  fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL,
+                  "VectorFEMassIntegrator requires H(div) or H(curl) FE space!");
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_vecfemass";
+         apply_qf = &f_apply_vecfemass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, is_hdiv, use_mf);
+      }
+      header = "/integrators/vecfemass/vecfemass_qf.h";
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Interp;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_scalar" :
+                         ":f_build_hcurlmass_quad_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_scalar :
+                       &f_build_hcurlmass_quad_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_scalar" :
+                         ":f_apply_hcurlmass_mf_quad_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_scalar :
+                       &f_apply_hcurlmass_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_vector" :
+                         ":f_build_hcurlmass_const_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_vector :
+                       &f_build_hcurlmass_const_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_vector" :
+                         ":f_apply_hcurlmass_mf_const_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_vector :
+                       &f_apply_hcurlmass_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_vector" :
+                         ":f_build_hcurlmass_quad_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_vector :
+                       &f_build_hcurlmass_quad_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_vector" :
+                         ":f_apply_hcurlmass_mf_quad_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_vector :
+                       &f_apply_hcurlmass_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool is_hdiv, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_matrix" :
+                         ":f_build_hcurlmass_const_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_matrix :
+                       &f_build_hcurlmass_const_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_matrix" :
+                         ":f_apply_hcurlmass_mf_const_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_matrix :
+                       &f_apply_hcurlmass_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_matrix" :
+                         ":f_build_hcurlmass_quad_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_matrix :
+                       &f_build_hcurlmass_quad_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_matrix" :
+                         ":f_apply_hcurlmass_mf_quad_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_matrix :
+                       &f_apply_hcurlmass_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.hpp b/fem/ceed/integrators/vecfemass/vecfemass.hpp
new file mode 100644
index 000000000..aa0ca2ea3
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_HPP
+#define MFEM_LIBCEED_VECFEMASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PAVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::None using libCEED.
+class MFVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_HPP
diff --git a/fem/ceed/integrators/vecfemass/vecfemass_qf.h b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
new file mode 100644
index 000000000..571316ba8
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
@@ -0,0 +1,1454 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_QF_H
+#define MFEM_LIBCEED_VECFEMASS_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_VECFEMASS_COEFF_COMP_MAX 6
+
+struct VectorFEMassContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff[LIBCEED_VECFEMASS_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_scalar)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_vector)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_matrix)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a vector FE mass operator
+CEED_QFUNCTION(f_apply_vecfemass)(void *ctx, CeedInt Q,
+                                  const CeedScalar *const *in,
+                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
+   CeedScalar *v = out[0];
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            v[i] = qd[i] * u[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 2] * u1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1 + qd[i + Q * 2] * u2;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 3] * u1 + qd[i + Q * 4] * u2;
+            v[i + Q * 2] = qd[i + Q * 2] * u0 + qd[i + Q * 4] * u1 + qd[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_QF_H
diff --git a/fem/ceed/interface/basis.cpp b/fem/ceed/interface/basis.cpp
index 37858cb78..ee6225f40 100644
--- a/fem/ceed/interface/basis.cpp
+++ b/fem/ceed/interface/basis.cpp
@@ -9,7 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../gridfunc.hpp"
+#include "basis.hpp"
+
 #include "util.hpp"
 
 namespace mfem
@@ -44,78 +45,174 @@ static CeedElemTopology GetCeedTopology(Geometry::Type geom)
    }
 }
 
-static void InitNonTensorBasis(const mfem::FiniteElementSpace &fes,
-                               const mfem::FiniteElement &fe,
-                               const mfem::IntegrationRule &ir,
-                               Ceed ceed, CeedBasis *basis)
-{
-   const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::FULL);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int dim = mesh->Dimension();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::DenseMatrix qX(dim,nqpts);
-   mfem::Vector qW(nqpts);
-   for (int i = 0; i < nqpts; i++)
-   {
-      const mfem::IntegrationPoint &ip = ir.IntPoint(i);
-      qX(0,i) = ip.x;
-      if (dim>1) { qX(1,i) = ip.y; }
-      if (dim>2) { qX(2,i) = ip.z; }
-      qW(i) = ip.weight;
-   }
-   CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()),
-                     fes.GetVDim(), ndofs, nqpts,
-                     maps.Bt.GetData(), maps.Gt.GetData(),
-                     qX.GetData(), qW.GetData(), basis);
-}
-
 static void InitTensorBasis(const mfem::FiniteElementSpace &fes,
                             const mfem::FiniteElement &fe,
                             const mfem::IntegrationRule &ir,
-                            Ceed ceed, CeedBasis *basis)
+                            Ceed ceed,
+                            CeedBasis *basis)
 {
    const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::TENSOR);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::Vector qX(nqpts), qW(nqpts);
-   // The x-coordinates of the first `nqpts` points of the integration rule are
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::Vector qX(Q), qW(Q);
+   // The x-coordinates of the first `Q` points of the integration rule are
    // the points of the corresponding 1D rule. We also scale the weights
    // accordingly.
    double w_sum = 0.0;
-   for (int i = 0; i < nqpts; i++)
+   for (int i = 0; i < Q; i++)
    {
       const mfem::IntegrationPoint &ip = ir.IntPoint(i);
       qX(i) = ip.x;
       qW(i) = ip.weight;
       w_sum += ip.weight;
    }
-   qW *= 1.0/w_sum;
-   CeedBasisCreateTensorH1(ceed, mesh->Dimension(), fes.GetVDim(), ndofs,
-                           nqpts, maps.Bt.GetData(),
-                           maps.Gt.GetData(), qX.GetData(),
-                           qW.GetData(), basis);
+   qW *= 1.0 / w_sum;
+   CeedBasisCreateTensorH1(ceed, dim, ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
 }
 
-static void InitBasisImpl(const FiniteElementSpace &fes,
-                          const FiniteElement &fe,
-                          const IntegrationRule &ir,
-                          Ceed ceed, CeedBasis *basis)
+static void InitNonTensorBasis(const mfem::FiniteElementSpace &fes,
+                               const mfem::FiniteElement &fe,
+                               const mfem::IntegrationRule &ir,
+                               Ceed ceed,
+                               CeedBasis *basis)
 {
-   // Check for FES -> basis, restriction in hash tables
+   const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::FULL);
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::DenseMatrix qX(dim, Q);
+   mfem::Vector qW(Q);
+   for (int i = 0; i < Q; i++)
+   {
+      const mfem::IntegrationPoint &ip = ir.IntPoint(i);
+      qX(0, i) = ip.x;
+      if (dim > 1) { qX(1, i) = ip.y; }
+      if (dim > 2) { qX(2, i) = ip.z; }
+      qW(i) = ip.weight;
+   }
+   if (fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      CeedBasisCreateHdiv(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                          maps.Bt.GetData(), maps.Gt.GetData(),
+                          qX.GetData(), qW.GetData(), basis);
+   }
+   else if (fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      CeedBasisCreateHcurl(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
+   }
+   else
+   {
+      CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                        maps.Bt.GetData(), maps.Gt.GetData(),
+                        qX.GetData(), qW.GetData(), basis);
+   }
+}
+
+#if 0
+static void InitCeedInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   // Basis projection operator using libCEED
+   CeedBasis trial_basis, test_basis;
+   const int P = std::max(trial_fe.GetDof(), test_fe.GetDof()), ir_order_max = 100;
+   int ir_order = std::max(trial_fe.GetOrder(), test_fe.GetOrder());
+   for (; ir_order < ir_order_max; ir_order++)
+   {
+      if (IntRules.Get(trial_fe.GetGeomType(), ir_order).GetNPoints() >= P) { break; }
+   }
+   const IntegrationRule &ir = IntRules.Get(trial_fe.GetGeomType(), ir_order);
+   InitBasis(trial_fes, trial_fe, ir, ceed, &trial_basis);
+   InitBasis(test_fes, test_fe, ir, ceed, &test_basis);
+   CeedBasisCreateProjection(trial_basis, test_basis, basis);
+}
+#endif
+
+static void InitMfemInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   MFEM_VERIFY(trial_fes.GetVDim() == test_fes.GetVDim(),
+               "libCEED discrete linear operator requires same vdim for trial "
+               "and test FE spaces.");
+   const int dim = trial_fe.GetDim();
+   const int ncomp = trial_fes.GetVDim();
+   const int trial_P = trial_fe.GetDof();
+   const int test_P = test_fe.GetDof();
+   mfem::DenseMatrix qX(dim, test_P), Gt(trial_P, test_P * dim), Bt;
+   mfem::Vector qW(test_P);
+   mfem::IsoparametricTransformation dummy;
+   dummy.SetIdentityTransformation(trial_fe.GetGeomType());
+   if (trial_fe.GetMapType() == test_fe.GetMapType())
+   {
+      // Prolongation
+      test_fe.GetTransferMatrix(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::VALUE &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      // Discrete gradient interpolator
+      test_fe.ProjectGrad(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      // Discrete curl interpolator
+      test_fe.ProjectCurl(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_DIV &&
+            test_fe.GetMapType() == mfem::FiniteElement::INTEGRAL)
+   {
+      // Discrete divergence interpolator
+      test_fe.ProjectDiv(trial_fe, dummy, Bt);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported trial/test FE spaces for libCEED discrete "
+                 "linear operator");
+   }
+   Bt.Transpose();
+   Gt = 0.0;
+   qX = 0.0;
+   qW = 0.0;
+   CeedBasisCreateH1(ceed, GetCeedTopology(trial_fe.GetGeomType()), ncomp,
+                     trial_P, test_P, Bt.GetData(), Gt.GetData(),
+                     qX.GetData(), qW.GetData(), basis);
+}
+
+void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
+               const IntegrationRule &ir,
+               Ceed ceed,
+               CeedBasis *basis)
+{
+   // Check for fes -> basis in hash table
    const int P = fe.GetDof();
    const int Q = ir.GetNPoints();
    const int ncomp = fes.GetVDim();
-   BasisKey basis_key(&fes, &ir, ncomp, P, Q);
-   auto basis_itr = mfem::internal::ceed_basis_map.find(basis_key);
-   const bool tensor = dynamic_cast<const mfem::TensorBasisElement *>
-                       (&fe) != nullptr;
+   BasisKey basis_key(&fes, nullptr, &ir, {P, Q, ncomp});
 
    // Init or retrieve key values
-   if (basis_itr == mfem::internal::ceed_basis_map.end())
+   auto basis_itr = internal::ceed_basis_map.find(basis_key);
+   if (basis_itr == internal::ceed_basis_map.end())
    {
-      if ( tensor )
+      const bool tensor =
+         dynamic_cast<const mfem::TensorBasisElement *>(&fe) != nullptr;
+      const bool vector = fe.GetRangeType() == mfem::FiniteElement::VECTOR;
+      if (tensor && !vector)
       {
          InitTensorBasis(fes, fe, ir, ceed, basis);
       }
@@ -123,7 +220,7 @@ static void InitBasisImpl(const FiniteElementSpace &fes,
       {
          InitNonTensorBasis(fes, fe, ir, ceed, basis);
       }
-      mfem::internal::ceed_basis_map[basis_key] = *basis;
+      internal::ceed_basis_map[basis_key] = *basis;
    }
    else
    {
@@ -131,22 +228,41 @@ static void InitBasisImpl(const FiniteElementSpace &fes,
    }
 }
 
-void InitBasis(const FiniteElementSpace &fes,
-               const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis)
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis)
 {
-   const mfem::FiniteElement &fe = *fes.GetFE(0);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
-}
+   // Check for fes -> basis in hash table
+   const int P1 = trial_fe.GetDof();
+   const int P2 = test_fe.GetDof();
+   const int ncomp = trial_fes.GetVDim();  // Assumed same as test_fes
+   BasisKey basis_key(&trial_fes, &test_fes, nullptr, {P1, P2, ncomp});
 
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis)
-{
-   const mfem::FiniteElement &fe = *fes.GetFE(indices[0]);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
+   // Init or retrieve key values
+   auto basis_itr = internal::ceed_basis_map.find(basis_key);
+   if (basis_itr == internal::ceed_basis_map.end())
+   {
+#if 0
+      if (trial_fe.GetMapType() == test_fe.GetMapType())
+      {
+         InitCeedInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      else
+#endif
+      {
+         InitMfemInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      internal::ceed_basis_map[basis_key] = *basis;
+   }
+   else
+   {
+      *basis = basis_itr->second;
+   }
 }
 
 #endif
diff --git a/fem/ceed/interface/basis.hpp b/fem/ceed/interface/basis.hpp
index 3781f4cf7..f0591e662 100644
--- a/fem/ceed/interface/basis.hpp
+++ b/fem/ceed/interface/basis.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_BASIS
 #define MFEM_LIBCEED_BASIS
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -22,31 +23,111 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-/** @brief Initialize a CeedBasis for non-mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::FiniteElement @a fe, and an mfem::IntegrationRule @a ir.
 
-   @param[in] fes Input finite element space.
-   @param[in] ir Input integration rule.
-   @param[in] ceed Input Ceed object.
-   @param[out] basis The address of the initialized CeedBasis object.
-*/
+    @param[in] fes The finite element space.
+    @param[in] fe The finite element.
+    @param[in] ir The integration rule.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
 void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
                const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis);
+               Ceed ceed,
+               CeedBasis *basis);
 
-/** @brief Initialize a CeedBasis for mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::IntegrationRule @a ir, and an optional list of element indices
+    @a indices.
 
     @param[in] fes The finite element space.
-    @param[in] ir is the integration rule for the operator.
-    @param[in] nelem The number of elements.
+    @param[in] ir The integration rule.
+    @param[in] use_bdr Create the basis for boundary elements.
+    @param[in] indices The indices of the elements of same type in the
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      const int *indices,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe =
+      use_bdr ? *fes.GetBE(first_index) : *fes.GetFE(first_index);
+   InitBasis(fes, fe, ir, ceed, basis);
+}
+
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   InitBasis(fes, ir, use_bdr, nullptr, ceed, basis);
+}
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes. The type of
+    interpolation will be chosen based on the map type of the provided
+    mfem::FiniteElement objects.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
+    @param[in] trial_fe The trial finite element.
+    @param[in] test_fe The test finite element.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis);
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes, with an optional list
+    of element indices @a indices. The type of interpolation will be chosen
+    based on the map type of the provided spaces.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
     @param[in] ceed The Ceed object.
     @param[out] basis The `CeedBasis` to initialize. */
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis);
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  const int *indices,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   const mfem::FiniteElement *trial_fe, *test_fe;
+   if (indices)
+   {
+      trial_fe = trial_fes.GetFE(indices[0]);
+      test_fe = test_fes.GetFE(indices[0]);
+   }
+   else
+   {
+      trial_fe = trial_fes.GetFE(0);
+      test_fe = test_fes.GetFE(0);
+   }
+   InitInterpolatorBasis(trial_fes, test_fes, *trial_fe, *test_fe, ceed, basis);
+}
+
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   InitInterpolatorBasis(trial_fes, test_fes, nullptr, ceed, basis);
+}
 
 #endif
 
diff --git a/fem/ceed/interface/ceed.hpp b/fem/ceed/interface/ceed.hpp
index 1e06d9ab5..c519c6664 100644
--- a/fem/ceed/interface/ceed.hpp
+++ b/fem/ceed/interface/ceed.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_CEED
 #define MFEM_LIBCEED_CEED
 
+#include "../../../config/config.hpp"
 #ifdef MFEM_USE_CEED
 #include <ceed.h>
 #if !CEED_VERSION_GE(0,10,0)
@@ -24,7 +25,11 @@ namespace mfem
 namespace internal
 {
 
+// Definition in general/device.cpp.
 extern Ceed ceed;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed)
+#endif
 
 } // namespace internal
 
diff --git a/fem/ceed/interface/coefficient.hpp b/fem/ceed/interface/coefficient.hpp
index abb70e8b8..1862730be 100644
--- a/fem/ceed/interface/coefficient.hpp
+++ b/fem/ceed/interface/coefficient.hpp
@@ -15,7 +15,6 @@
 #ifdef MFEM_USE_CEED
 
 #include "../../../general/forall.hpp"
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../../linalg/dtensor.hpp"
 #include "../../../mesh/mesh.hpp"
@@ -27,54 +26,41 @@
 namespace mfem
 {
 
-class Mesh;
-class IntegrationRule;
-class Coefficient;
-class VectorCoefficient;
-class GridFunction;
-
 namespace ceed
 {
 
 struct Coefficient
 {
    const int ncomp;
-   Coefficient(int ncomp_) : ncomp(ncomp_) { }
-   virtual bool IsConstant() const { return true; }
-   virtual ~Coefficient() { }
-};
-
-struct VariableCoefficient : Coefficient
-{
-   CeedVector coeffVector = nullptr;
    const CeedEvalMode emode;
-   VariableCoefficient(int ncomp_, CeedEvalMode emode_)
-      : Coefficient(ncomp_), emode(emode_) { }
-   virtual bool IsConstant() const override { return false; }
-   ~VariableCoefficient()
+   CeedVector coeff_vector;
+   Coefficient(int ncomp, CeedEvalMode emode)
+      : ncomp(ncomp), emode(emode), coeff_vector(nullptr) {}
+   virtual ~Coefficient()
    {
-      CeedVectorDestroy(&coeffVector);
+      CeedVectorDestroy(&coeff_vector);
    }
 };
 
-struct GridCoefficient : VariableCoefficient
+struct GridCoefficient : Coefficient
 {
    const mfem::GridFunction &gf;
    CeedBasis basis;
    CeedElemRestriction restr;
-   GridCoefficient(const mfem::GridFunction &gf_)
-      : VariableCoefficient(gf_.VectorDim(), CEED_EVAL_INTERP),
-        gf(gf_)
+   GridCoefficient(const mfem::GridFunction &gf, Ceed ceed)
+      : Coefficient(gf.VectorDim(), CEED_EVAL_INTERP), gf(gf),
+        basis(nullptr), restr(nullptr)
    {
-      InitVector(gf, coeffVector);
+      InitVector(gf, ceed, coeff_vector);
    }
 };
 
-struct QuadCoefficient : VariableCoefficient
+struct QuadCoefficient : Coefficient
 {
-   mfem::Vector coeff;
+   mfem::Vector vector;
    CeedElemRestriction restr;
-   QuadCoefficient(int ncomp_) : VariableCoefficient(ncomp_, CEED_EVAL_NONE) { }
+   QuadCoefficient(int ncomp)
+      : Coefficient(ncomp, CEED_EVAL_NONE), restr(nullptr) {}
 };
 
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
@@ -84,73 +70,70 @@ struct QuadCoefficient : VariableCoefficient
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::Coefficient &Q,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
-   {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   if (mfem::GridFunctionCoefficient *gf_coeff =
+          dynamic_cast<mfem::GridFunctionCoefficient *>(&Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*gf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(&Q))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(1);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, ne);
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, ne);
+      mfem::IsoparametricTransformation T;
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
          for (int q = 0; q < nq; ++q)
          {
-            C(q,e) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, e) = Q.Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
     mfem::VectorCoefficient @a VQ, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir.
@@ -158,76 +141,130 @@ void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::VectorCoefficient &VQ,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
+   if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+          dynamic_cast<mfem::VectorGridFunctionCoefficient *>(&VQ))
    {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*vgf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(&VQ))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
-      const int ne = mesh.GetNE();
+      const int vdim = VQ.GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, ne);
-      mfem::DenseMatrix Q_ir;
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, ne);
+      mfem::IsoparametricTransformation T;
+      mfem::DenseMatrix Q_ip;
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
-         VQ->Eval(Q_ir, T, ir);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
+         VQ.Eval(Q_ip, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int i = 0; i < dim; ++i)
+            for (int i = 0; i < vdim; ++i)
+            {
+               C(i, q, e) = Q_ip(i, q);
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a MQ, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::MatrixCoefficient &MQ,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
+{
+   // Assumes matrix coefficient is symmetric
+   const int vdim = MQ.GetVDim();
+   const int ncomp = (vdim * (vdim + 1)) / 2;
+   const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+   const int nq = ir.GetNPoints();
+   auto *ceed_coeff = new QuadCoefficient(ncomp);
+   ceed_coeff->vector.SetSize(ncomp * nq * ne);
+   auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, ne);
+   mfem::IsoparametricTransformation T;
+   mfem::DenseMatrix Q_ip;
+   for (int e = 0; e < ne; ++e)
+   {
+      if (use_bdr)
+      {
+         mesh.GetBdrElementTransformation(e, &T);
+      }
+      else
+      {
+         mesh.GetElementTransformation(e, &T);
+      }
+      for (int q = 0; q < nq; ++q)
+      {
+         const IntegrationPoint &ip = ir.IntPoint(q);
+         T.SetIntPoint(&ip);
+         MQ.Eval(Q_ip, T, ip);
+         for (int j = 0; j < vdim; ++j)
+         {
+            for (int i = j; i < vdim; ++i)
             {
-               C(i,q,e) = Q_ir(i,q);
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               C(idx, q, e) = Q_ip(i, j);  // Column-major
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
    }
+   InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+   coeff_ptr = ceed_coeff;
 }
 
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
@@ -237,57 +274,45 @@ void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::Coefficient &Q,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
-   {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   if (mfem::GridFunctionCoefficient *gf_coeff =
+          dynamic_cast<mfem::GridFunctionCoefficient *>(&Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*gf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(&Q))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), nq, ne);
+      auto in = Reshape(qfunc.Read(), nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
@@ -296,140 +321,214 @@ void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
          out(q, sub_e) = in(q, e);
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, nelem);
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, nelem);
+      mfem::IsoparametricTransformation T;
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
          for (int q = 0; q < nq; ++q)
          {
-            C(q, i) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, i) = Q.Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
-    mfem::VectorCoefficient @a Q, an mfem::Mesh @a mesh, and an
+    mfem::VectorCoefficient @a VQ, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
 
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::VectorCoefficient &VQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
-   {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
-   }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+          dynamic_cast<mfem::VectorGridFunctionCoefficient *>(&VQ))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*vgf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(&VQ))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), dim, nq, ne);
+      auto in = Reshape(qfunc.Read(), vdim, nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), dim, nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), vdim, nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
          const int sub_e = i/nq;
          const int e = d_indices[sub_e];
-         for (int d = 0; d < dim; d++)
+         for (int d = 0; d < vdim; d++)
          {
             out(d, q, sub_e) = in(d, q, e);
          }
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
+      const int vdim = VQ.GetVDim();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, nelem);
-      mfem::DenseMatrix Q_ir;
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, nelem);
+      mfem::IsoparametricTransformation T;
+      mfem::DenseMatrix Q_ip;
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
-         VQ->Eval(Q_ir, T, ir);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
+         VQ.Eval(Q_ip, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int d = 0; d < dim; ++d)
+            for (int d = 0; d < vdim; ++d)
+            {
+               C(d, q, i) = Q_ip(d, q);
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a MQ, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
+                       `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::MatrixCoefficient &MQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
+{
+   // Assumes matrix coefficient is symmetric
+   const int vdim = MQ.GetVDim();
+   const int ncomp = (vdim * (vdim + 1)) / 2;
+   const int nq = ir.GetNPoints();
+   auto *ceed_coeff = new QuadCoefficient(ncomp);
+   ceed_coeff->vector.SetSize(ncomp * nq * nelem);
+   auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, nelem);
+   mfem::IsoparametricTransformation T;
+   mfem::DenseMatrix Q_ip;
+   for (int i = 0; i < nelem; ++i)
+   {
+      const int e = indices[i];
+      if (use_bdr)
+      {
+         mesh.GetBdrElementTransformation(e, &T);
+      }
+      else
+      {
+         mesh.GetElementTransformation(e, &T);
+      }
+      for (int q = 0; q < nq; ++q)
+      {
+         const IntegrationPoint &ip = ir.IntPoint(q);
+         T.SetIntPoint(&ip);
+         MQ.Eval(Q_ip, T, ip);
+         for (int dj = 0; dj < vdim; ++dj)
+         {
+            for (int di = dj; di < vdim; ++di)
             {
-               C(d, q, i) = Q_ir(d, q);
+               const int idx = (dj * vdim) - (((dj - 1) * dj) / 2) + di - dj;
+               C(idx, q, i) = Q_ip(di, dj);  // Column-major
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
    }
+   InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+   coeff_ptr = ceed_coeff;
 }
 
-template <typename Coeff, typename Context>
-void InitCoefficient(Coeff *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir, int nelem,
-                     const int* indices, Coefficient *&coeff_ptr, Context &ctx)
+template <typename CoeffType>
+inline void InitCoefficient(CoeffType &Q,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            int nelem,
+                            const int *indices,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
    if (indices)
    {
-      InitCoefficientWithIndices(Q, mesh, ir, nelem, indices, coeff_ptr, ctx);
+      InitCoefficientWithIndices(Q, mesh, ir, use_bdr, nelem, indices,
+                                 ceed, coeff_ptr);
    }
    else
    {
-      InitCoefficient(Q, mesh, ir, coeff_ptr, ctx);
+      InitCoefficient(Q, mesh, ir, use_bdr, ceed, coeff_ptr);
    }
 }
 
diff --git a/fem/ceed/interface/integrator.hpp b/fem/ceed/interface/integrator.hpp
index eea79388d..713518b42 100644
--- a/fem/ceed/interface/integrator.hpp
+++ b/fem/ceed/interface/integrator.hpp
@@ -9,17 +9,18 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_LIBCEED_INTEG
-#define MFEM_LIBCEED_INTEG
+#ifndef MFEM_LIBCEED_INTEGRATOR
+#define MFEM_LIBCEED_INTEGRATOR
 
-#include "../../../config/config.hpp"
 #include "../../fespace.hpp"
 #include "../../gridfunc.hpp"
-#include "operator.hpp"
+#include "basis.hpp"
 #include "coefficient.hpp"
+#include "operator.hpp"
 #include "restriction.hpp"
 #include "util.hpp"
 #include "ceed.hpp"
+#include <string>
 
 namespace mfem
 {
@@ -28,43 +29,29 @@ namespace ceed
 {
 
 /** The different evaluation modes available for PA and MF CeedIntegrator. */
-enum class EvalMode { None, Interp, Grad, InterpAndGrad };
+enum class EvalMode { None, Interp, Grad, Div, Curl,
+                      InterpAndGrad, InterpAndDiv, InterpAndCurl
+                    };
 
 #ifdef MFEM_USE_CEED
 /** This structure is a template interface for the Assemble methods of
     PAIntegrator and MFIntegrator. See ceed/mass.cpp for an example. */
 struct OperatorInfo
 {
-   /** The path to the qFunction header. */
+   /** The path to the QFunction header. */
    const char *header;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a constant Coefficient. */
-   const char *build_func_const;
-   /** The qFunction to build a partially assembled CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser build_qf_const;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a variable Coefficient. */
-   const char *build_func_quad;
-   /** The qFunction to build a partially assembled CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser build_qf_quad;
-   /** The name of the qFunction to apply a partially assembled CeedOperator. */
+   /** The name of the QFunction to build a partially assembled CeedOperator. */
+   const char *build_func;
+   /** The QFunction to build a partially assembled CeedOperator. */
+   CeedQFunctionUser build_qf;
+   /** The name of the QFunction to apply a partially assembled CeedOperator. */
    const char *apply_func;
-   /** The qFunction to apply a partially assembled CeedOperator. */
+   /** The QFunction to apply a partially assembled CeedOperator. */
    CeedQFunctionUser apply_qf;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       constant Coefficient. */
-   const char *apply_func_mf_const;
-   /** The qFunction to apply a matrix-free CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_const;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       variable Coefficient. */
-   const char *apply_func_mf_quad;
-   /** The qFunction to apply a matrix-free CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_quad;
+   /** The name of the QFunction to apply a matrix-free CeedOperator. */
+   const char *apply_func_mf;
+   /** The QFunction to apply a matrix-free CeedOperator. */
+   CeedQFunctionUser apply_qf_mf;
    /** The EvalMode on the trial basis functions. */
    EvalMode trial_op;
    /** The EvalMode on the test basis functions. */
@@ -74,284 +61,348 @@ struct OperatorInfo
 };
 #endif
 
-/** This class represent a partially assembled operator using libCEED. */
-class PAIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled bilinear,
+    mixed bilinear, or nonlinear form operator using libCEED. */
+class Integrator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis  trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction build_qfunc, apply_qfunc;
+   CeedOperator oper;
+   CeedBasis trial_basis, test_basis, mesh_basis;
+   CeedElemRestriction trial_restr, test_restr, mesh_restr, qdata_restr;
+   CeedQFunction apply_qfunc;
+   CeedQFunctionContext apply_ctx;
    CeedVector node_coords, qdata;
-   Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
-   CeedOperator build_oper;
+   Coefficient *coeff1, *coeff2;
 
 public:
-   PAIntegrator()
-      : Operator(),
+   Integrator()
+      : oper(nullptr),
         trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
         trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        build_qfunc(nullptr), apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr), build_oper(nullptr)
-   { }
-
-   /** @brief This method assembles the `PAIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
-   }
+        qdata_restr(nullptr),
+        apply_qfunc(nullptr), apply_ctx(nullptr),
+        node_coords(nullptr), qdata(nullptr),
+        coeff1(nullptr), coeff2(nullptr) {}
 
-   /** @brief This method assembles the `PAIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] nelem The number of elements.
-       @param[in] indices The indices of the elements of same type in the
-                          `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 int nelem,
-                 const int* indices,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
-   }
-
-   /** This method assembles the PAIntegrator for mixed forms.
+   CeedOperator GetOperator() const { return oper; }
+   CeedOperator GetTransposeOperator() const { return nullptr; }
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
-                       the `CeedOperatorInfo` type is expected to inherit from
-                       `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(ceed, info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q1, Q2, use_bdr, use_mf);
    }
 
-   /** This method assembles the PAIntegrator for mixed forms on mixed meshes.
+   /** This method assembles the `Integrator` for mixed forms on mixed meshes.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] ceed The Ceed object.
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir The `IntegrationRule` for the numerical integration.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q1 `Coefficient`, `VectorCoefficient`, or
+                     `MatrixCoefficient`.
+       @param[in] Q2 A second `Coefficient`, `VectorCoefficient`, or
+                     `MatrixCoefficient` for certain integrators.
+       @param[in] use_bdr Controls whether to construct the operator for the
+                          domain or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or
+                         partially assembled operator. */
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Ceed ceed(internal::ceed);
       mfem::Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string build_func = const_coeff ? info.build_func_const
-                               : info.build_func_quad;
-      CeedQFunctionUser build_qf = const_coeff ? info.build_qf_const
-                                   : info.build_qf_quad;
-      PAOperator op {info.qdatasize, info.header,
-                     build_func, build_qf,
-                     info.apply_func, info.apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-      CeedInt dim = mesh.SpaceDimension();
+      CeedInt dim = mesh.Dimension() - use_bdr;
+      CeedInt space_dim = mesh.SpaceDimension();
+      CeedInt curl_dim = (dim < 3) ? 1 : dim;
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
+      bool trial_vectorfe =
+         (trial_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      bool test_vectorfe =
+         (test_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(dim) > 1),
+                  "Use ceed::MixedOperator<ceed::Integrator> on mixed meshes.");
+      if (Q1) { InitCoefficient(*Q1, mesh, ir, use_bdr, nelem, indices, ceed, coeff1); }
+      if (Q2) { InitCoefficient(*Q2, mesh, ir, use_bdr, nelem, indices, ceed, coeff2); }
+
+      if (&trial_fes == &test_fes)
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         CeedBasisReferenceCopy(trial_basis, &test_basis);
+         CeedElemRestrictionReferenceCopy(trial_restr, &test_restr);
       }
       else
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices,
-                                 ceed, &test_basis, &test_restr);
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitBasis(test_fes, ir, use_bdr, indices, ceed,
+                   &test_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         InitRestriction(test_fes, use_bdr, nelem, indices, ceed,
+                         &test_restr);
       }
 
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices,
-                              ceed, &mesh_basis, &mesh_restr);
-
       CeedInt trial_nqpts, test_nqpts;
       CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
       CeedBasisGetNumQuadraturePoints(test_basis, &test_nqpts);
       MFEM_VERIFY(trial_nqpts == test_nqpts,
                   "Trial and test basis must have the same number of quadrature"
                   " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      const int qdatasize = op.qdatasize;
-      InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
-                             CEED_STRIDES_BACKEND,
-                             &restr_i);
-
-      InitVector(*mesh.GetNodes(), node_coords);
-
-      CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.build_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.build_qf, qf.c_str(),
-                                  &build_qfunc);
-
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
+      const CeedInt nqpts = trial_nqpts;
+#ifdef MFEM_USE_OPENMP
+      #pragma omp critical (MeshNodes)
+#endif
       {
-         CeedQFunctionAddInput(build_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
+         mesh.EnsureNodes();
+         InitVector(*mesh.GetNodes(), ceed, node_coords);
       }
-      CeedQFunctionAddInput(build_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
+      MFEM_VERIFY(mesh_fes, "The mesh has no nodal FE space.");
+      InitBasis(*mesh_fes, ir, use_bdr, indices, ceed, &mesh_basis);
+      InitRestriction(*mesh_fes, use_bdr, nelem, indices, ceed, &mesh_restr);
 
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
+      CeedQFunctionContextCreate(ceed, &apply_ctx);
+      CeedQFunctionContextSetData(apply_ctx, CEED_MEM_HOST,
                                   CEED_COPY_VALUES,
                                   sizeof(info.ctx),
                                   &info.ctx);
-      CeedQFunctionSetContext(build_qfunc, build_ctx);
 
-      // Create the operator that builds the quadrature data for the operator.
-      CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir,
-                                 nelem, indices, ceed,
-                                 &gridCoeff->basis,
-                                 &gridCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
+      if (!use_mf)
       {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
+         const int qdatasize = info.qdatasize;
+         InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
+                                CEED_STRIDES_BACKEND, ceed,
+                                &qdata_restr);
+         CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
+
+         // Create the QFunction that builds the operator (i.e. computes its
+         // quadrature data) and set its context data.
+         CeedQFunction build_qfunc;
+         std::string qf = GetCeedPath() + info.header + info.build_func;
+         CeedQFunctionCreateInterior(ceed, 1, info.build_qf, qf.c_str(),
+                                     &build_qfunc);
+         if (coeff1)
+         {
+            CeedQFunctionAddInput(build_qfunc, "coeff1", coeff1->ncomp, coeff1->emode);
+         }
+         if (coeff2)
+         {
+            CeedQFunctionAddInput(build_qfunc, "coeff2", coeff2->ncomp, coeff2->emode);
+         }
+         CeedQFunctionAddInput(build_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+         CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+         CeedQFunctionSetContext(build_qfunc, apply_ctx);
+
+         // Create the operator that builds the quadrature data for the operator.
+         CeedOperator build_oper;
+         CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
+         if (coeff1)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff1))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff1", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff1))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff1", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         if (coeff2)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff2))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff2", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff2))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff2", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         CeedOperatorSetField(build_oper, "dx", mesh_restr,
+                              mesh_basis, CEED_VECTOR_ACTIVE);
+         CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
+         CeedOperatorSetField(build_oper, "qdata", qdata_restr,
+                              CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
+         CeedOperatorCheckReady(build_oper);
+
+         // Compute the quadrature data for the operator.
+         CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
+
+         CeedOperatorDestroy(&build_oper);
+         CeedQFunctionDestroy(&build_qfunc);
+
+         CeedVectorDestroy(&node_coords);
+         node_coords = nullptr;
+         delete coeff1;
+         delete coeff2;
+         coeff1 = coeff2 = nullptr;
       }
-      CeedOperatorSetField(build_oper, "dx", mesh_restr,
-                           mesh_basis, CEED_VECTOR_ACTIVE);
-      CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      CeedOperatorSetField(build_oper, "qdata", restr_i,
-                           CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-
-      // Compute the quadrature data for the operator.
-      CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
-
-      // Create the Q-function that defines the action of the operator.
-      qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+
+      // Create the QFunction that defines the action of the operator.
+      std::string qf = GetCeedPath() + info.header + info.apply_func;
+      CeedQFunctionCreateInterior(ceed, 1, info.apply_qf, qf.c_str(),
                                   &apply_qfunc);
-      // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * (trial_vectorfe ? dim : 1),
+                                  CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddInput(apply_qfunc, "du", trial_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddInput(apply_qfunc, "cu", trial_vdim * curl_dim, CEED_EVAL_CURL);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!trial_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
             break;
+         case EvalMode::InterpAndDiv:
+            MFEM_VERIFY(trial_vectorfe,
+                        "EvalMode::InterpAndDiv is only intended for vector FE.");
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "du", trial_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::InterpAndCurl:
+            MFEM_VERIFY(trial_vectorfe,
+                        "EvalMode::InterpAndCurl is only intended for vector FE.");
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "cu", trial_vdim * curl_dim, CEED_EVAL_CURL);
+            break;
+      }
+      if (use_mf)
+      {
+         if (coeff1)
+         {
+            CeedQFunctionAddInput(apply_qfunc, "coeff1", coeff1->ncomp, coeff1->emode);
+         }
+         if (coeff2)
+         {
+            CeedQFunctionAddInput(apply_qfunc, "coeff2", coeff2->ncomp, coeff2->emode);
+         }
+         CeedQFunctionAddInput(apply_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+      }
+      else
+      {
+         CeedQFunctionAddInput(apply_qfunc, "qdata", info.qdatasize, CEED_EVAL_NONE);
       }
-      // qdata
-      CeedQFunctionAddInput(apply_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
-      // output
-      switch (op.test_op)
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * (test_vectorfe ? dim : 1),
+                                   CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddOutput(apply_qfunc, "dv", test_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddOutput(apply_qfunc, "cv", test_vdim * curl_dim, CEED_EVAL_CURL);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!test_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::InterpAndDiv:
+            MFEM_VERIFY(test_vectorfe,
+                        "EvalMode::InterpAndDiv is only intended for vector FE.");
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "dv", test_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::InterpAndCurl:
+            MFEM_VERIFY(test_vectorfe,
+                        "EvalMode::InterpAndCurl is only intended for vector FE.");
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "cv", test_vdim * curl_dim, CEED_EVAL_CURL);
             break;
       }
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
+      CeedQFunctionSetContext(apply_qfunc, apply_ctx);
 
       // Create the operator.
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
-      // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "u", trial_restr,
@@ -363,16 +414,88 @@ public:
          case EvalMode::Grad:
             CeedOperatorSetField(oper, "gu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "du", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
          case EvalMode::InterpAndGrad:
             CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::InterpAndDiv:
+            CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "du", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::InterpAndCurl:
+            CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "cu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+      }
+      if (use_mf)
+      {
+         if (coeff1)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff1))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(oper, "coeff1", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff1))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(oper, "coeff1", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         if (coeff2)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff2))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(oper, "coeff2", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff2))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(oper, "coeff2", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         CeedOperatorSetField(oper, "dx", mesh_restr, mesh_basis, node_coords);
+         CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
       }
-      // qdata
-      CeedOperatorSetField(oper, "qdata", restr_i, CEED_BASIS_COLLOCATED,
-                           qdata);
-      // output
-      switch (op.test_op)
+      else
+      {
+         CeedOperatorSetField(oper, "qdata", qdata_restr, CEED_BASIS_COLLOCATED, qdata);
+      }
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "v", test_restr,
@@ -384,389 +507,162 @@ public:
          case EvalMode::Grad:
             CeedOperatorSetField(oper, "gv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "dv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
          case EvalMode::InterpAndGrad:
             CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::InterpAndDiv:
+            CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "dv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::InterpAndCurl:
+            CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "cv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
       }
-
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedOperatorCheckReady(oper);
    }
 
-   virtual ~PAIntegrator()
+   ~Integrator()
    {
-      CeedQFunctionDestroy(&build_qfunc);
+      // All basis and restriction objects are destroyed by fes destructor
+      CeedOperatorDestroy(&oper);
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
+      CeedQFunctionContextDestroy(&apply_ctx);
       CeedVectorDestroy(&node_coords);
       CeedVectorDestroy(&qdata);
-      delete coeff;
-      CeedOperatorDestroy(&build_oper);
+      delete coeff1;
+      delete coeff2;
    }
-
-private:
-   /** This structure contains the data to assemble a partially assembled
-       operator with libCEED. */
-   struct PAOperator
-   {
-      /** The number of quadrature data at each quadrature point. */
-      int qdatasize;
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to build the quadrature data. */
-      std::string build_func;
-      /** The Qfunction to build the quadrature data. */
-      CeedQFunctionUser build_qf;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.)*/
-      EvalMode test_op;
-   };
 #endif
 };
 
-/** This class represent a matrix-free operator using libCEED. */
-class MFIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled discrete linear
+    operator using libCEED. */
+class Interpolator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction apply_qfunc;
-   CeedVector node_coords, qdata;
-   Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
+   CeedOperator oper, oper_t;
+   CeedBasis basis_ctof;
+   CeedElemRestriction trial_restr, test_restr;
+   CeedQFunction apply_qfunc, apply_qfunc_t;
 
 public:
-   MFIntegrator()
-      : Operator(),
-        trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
-        trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr) { }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
-   }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] nelem The number of elements.
-       @param[in] indices The indices of the elements of same type in the
-                          `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 int nelem,
-                 const int* indices,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
-   }
-
-   /** This method assembles the MFIntegrator for mixed forms.
-
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
-                       the `CeedOperatorInfo` type is expected to inherit from
-                       `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+   Interpolator()
+      : oper(nullptr), oper_t(nullptr),
+        basis_ctof(nullptr),
+        trial_restr(nullptr), test_restr(nullptr),
+        apply_qfunc(nullptr), apply_qfunc_t(nullptr) {}
+
+   CeedOperator GetOperator() const { return oper; }
+   CeedOperator GetTransposeOperator() const { return oper_t; }
+
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(ceed, info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q1, Q2, use_bdr, use_mf);
    }
 
-   /** This method assembles the MFIntegrator for mixed forms.
+   /** This method assembles the `Interpolator` on mixed meshes. Its signature
+       matches that for `Integrator`.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] ceed The Ceed object.
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir Not supported by `Interpolator`.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q1 Not supported by `Interpolator`.
+       @param[in] Q2 Not supported by `Interpolator`.
+       @param[in] use_bdr Not supported by `Interpolator`.
+       @param[in] use_mf Controls whether to construct a matrix-free or
+                         partially assembled operator. */
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Ceed ceed(internal::ceed);
-      Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string apply_func = const_coeff ? info.apply_func_mf_const
-                               : info.apply_func_mf_quad;
-      CeedQFunctionUser apply_qf = const_coeff ? info.apply_qf_mf_const
-                                   : info.apply_qf_mf_quad;
-      MFOperator op {info.header,
-                     apply_func, apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-
-      CeedInt dim = mesh.SpaceDimension();
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
-      }
-      else
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices, ceed,
-                                 &test_basis, &test_restr);
-      }
-
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices, ceed, &mesh_basis,
-                              &mesh_restr);
-
-      CeedInt trial_nqpts, test_nqpts;
-      CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
-      CeedBasisGetNumQuadraturePoints(trial_basis, &test_nqpts);
-      MFEM_VERIFY(trial_nqpts == test_nqpts,
-                  "Trial and test basis must have the same number of quadrature"
-                  " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      InitVector(*mesh.GetNodes(), node_coords);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+      MFEM_VERIFY(!Q1 && !Q2, "ceed:Interpolator does not support coefficients.");
+      MFEM_VERIFY(!use_bdr,
+                  "ceed:Interpolator does not support boundary interpolators.");
+      MFEM_VERIFY(trial_vdim == 1 && test_vdim == 1,
+                  "ceed:Interpolator does not support spaces with vdim > 1.");
+
+      InitInterpolatorBasis(trial_fes, test_fes, indices, ceed, &basis_ctof);
+      InitRestriction(trial_fes, use_bdr, true, false, nelem, indices,
+                      ceed, &trial_restr);
+      InitRestriction(test_fes, use_bdr, true, true, nelem, indices,
+                      ceed, &test_restr);
+      MFEM_VERIFY(info.trial_op == EvalMode::Interp,
+                  "ceed:Interpolator only supports trial_op == Interp.");
+      MFEM_VERIFY(info.test_op == EvalMode::None,
+                  "ceed:Interpolator only supports test_op == None.");
+
+      // Create the QFunction that defines the action of the operator
+      // (only an identity as element dof multiplicity is handled outside of libCEED)
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_INTERP, CEED_EVAL_NONE,
                                   &apply_qfunc);
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_NONE, CEED_EVAL_INTERP,
+                                  &apply_qfunc_t);
 
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
-      {
-         CeedQFunctionAddInput(apply_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-      }
-      CeedQFunctionAddInput(apply_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-      }
-
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
-                                  CEED_COPY_VALUES,
-                                  sizeof(info.ctx),
-                                  &info.ctx);
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
-
-      // Create the operator.
+      // Create the operator
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
-      // coefficient
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir, nelem, indices,
-                                 ceed, &gridCoeff->basis, &gridCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
-      {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "u", trial_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-      CeedOperatorSetField(oper, "dx", mesh_restr,
-                           mesh_basis, node_coords);
-      CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "v", test_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedOperatorSetField(oper, "input", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper, "output", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper);
+
+      // Create the transpose operator
+      CeedOperatorCreate(ceed, apply_qfunc_t, NULL, NULL, &oper_t);
+      CeedOperatorSetField(oper_t, "input", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper_t, "output", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper_t);
    }
 
-   virtual ~MFIntegrator()
+   ~Interpolator()
    {
+      // All basis and restriction objects are destroyed by fes destructor
+      CeedOperatorDestroy(&oper);
+      CeedOperatorDestroy(&oper_t);
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
-      CeedVectorDestroy(&node_coords);
-      CeedVectorDestroy(&qdata);
-      delete coeff;
+      CeedQFunctionDestroy(&apply_qfunc_t);
    }
-
-private:
-   /** This structure contains the data to assemble a matrix-free operator with
-       libCEED. */
-   struct MFOperator
-   {
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode test_op;
-   };
 #endif
 };
 
@@ -774,4 +670,4 @@ private:
 
 } // namespace mfem
 
-#endif // MFEM_LIBCEED_INTEG
+#endif // MFEM_LIBCEED_INTEGRATOR
diff --git a/fem/ceed/interface/interface.hpp b/fem/ceed/interface/interface.hpp
index 0a69121ad..8b877188c 100644
--- a/fem/ceed/interface/interface.hpp
+++ b/fem/ceed/interface/interface.hpp
@@ -14,6 +14,8 @@
 
 // Object wrapping a CeedOperator in a mfem::Operator.
 #include "operator.hpp"
+// Operator supporting mixed finite element spaces.
+#include "mixed_operator.hpp"
 // Functions to initialize CeedBasis objects.
 #include "basis.hpp"
 // Functions to initialize CeedRestriction objects.
@@ -22,8 +24,6 @@
 #include "coefficient.hpp"
 // PA or MF Operator using libCEED.
 #include "integrator.hpp"
-// PA Operator supporting mixed finite element spaces.
-#include "mixed_integrator.hpp"
 // Utility functions
 #include "util.hpp"
 // Wrapper to include <ceed.h>
diff --git a/fem/ceed/interface/mixed_integrator.hpp b/fem/ceed/interface/mixed_integrator.hpp
deleted file mode 100644
index 4e238bde3..000000000
--- a/fem/ceed/interface/mixed_integrator.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#ifndef MFEM_LIBCEED_MIXED_INTEGRATOR
-#define MFEM_LIBCEED_MIXED_INTEGRATOR
-
-#include "ceed.hpp"
-#include "integrator.hpp"
-#include <unordered_map>
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-/** @brief This class wraps a `ceed::PAIntegrator` or `ceed::MFIntegrator` to
-    support mixed finite element spaces. */
-template <typename CeedInteg>
-class MixedIntegrator : public ceed::Operator
-{
-#ifdef MFEM_USE_CEED
-   using ElementKey = std::pair<int, int>; //< Element::Type, Order >
-   struct key_hash
-   {
-      std::size_t operator()(const ElementKey& k) const
-      {
-         return k.first + 2 * k.second;
-      }
-   };
-   using ElementsMap = std::unordered_map<const ElementKey, int*, key_hash>;
-   std::vector<CeedInteg*> sub_ops;
-
-public:
-   template <typename Integrator, typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(const Integrator &integ,
-                 CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 CoeffType *Q)
-   {
-      ElementsMap count;
-      ElementsMap element_indices;
-      ElementsMap offsets;
-
-      // Count the number of elements of each type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         auto value = count.find(key);
-         if (value == count.end())
-         {
-            count[key] = new int(1);
-         }
-         else
-         {
-            (*value->second)++;
-         }
-      }
-
-      // Initialization of the arrays
-      for ( const auto& value : count )
-      {
-         element_indices[value.first] = new int[*value.second];
-         offsets[value.first] = new int(0);
-      }
-
-      // Populates the indices arrays for each element type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         int &offset = *(offsets[key]);
-         int* indices_array = element_indices[key];
-         indices_array[offset] = i;
-         offset++;
-      }
-
-      // Create composite CeedOperator
-      CeedCompositeOperatorCreate(internal::ceed, &oper);
-
-      // Create each sub-CeedOperator
-      sub_ops.reserve(element_indices.size());
-      for (const auto& value : element_indices)
-      {
-         const int* indices = value.second;
-         const int first_index = indices[0];
-         const mfem::FiniteElement &el = *fes.GetFE(first_index);
-         auto &T = *fes.GetMesh()->GetElementTransformation(first_index);
-         MFEM_ASSERT(!integ.GetIntegrationRule(),
-                     "Mixed mesh integrators should not have an"
-                     " IntegrationRule.");
-         const IntegrationRule &ir = integ.GetRule(el, el, T);
-         auto sub_op = new CeedInteg();
-         int nelem = *count[value.first];
-         sub_op->Assemble(info, fes, ir, nelem, indices, Q);
-         sub_ops.push_back(sub_op);
-         CeedCompositeOperatorAddSub(oper, sub_op->GetCeedOperator());
-      }
-
-      const int ndofs = fes.GetVDim() * fes.GetNDofs();
-      CeedVectorCreate(internal::ceed, ndofs, &u);
-      CeedVectorCreate(internal::ceed, ndofs, &v);
-   }
-
-   virtual ~MixedIntegrator()
-   {
-      for (auto sub_op : sub_ops)
-      {
-         delete sub_op;
-      }
-   }
-#endif
-};
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif // MFEM_LIBCEED_MIXED_INTEGRATOR
diff --git a/fem/ceed/interface/mixed_operator.hpp b/fem/ceed/interface/mixed_operator.hpp
new file mode 100644
index 000000000..b5a620280
--- /dev/null
+++ b/fem/ceed/interface/mixed_operator.hpp
@@ -0,0 +1,297 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXED_OPERATOR
+#define MFEM_LIBCEED_MIXED_OPERATOR
+
+#include "../../fespace.hpp"
+#include "operator.hpp"
+#include "util.hpp"
+#include "ceed.hpp"
+#include <array>
+#include <unordered_map>
+#include <vector>
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** @brief This class wraps one or more `OpType` objects to support finite
+    element spaces on mixed meshes. */
+template <typename OpType>
+class MixedOperator : public Operator
+{
+#ifdef MFEM_USE_CEED
+   using ElementKey =
+      std::array<int, 3>; // <mfem::Element::Type, TrialOrder, TestOrder>
+   struct ElementHash
+   {
+      std::size_t operator()(const ElementKey &k) const
+      {
+         return CeedHashCombine(
+                   CeedHashCombine(CeedHash(k[0]), CeedHash(k[1])),
+                   CeedHash(k[2]));
+      }
+   };
+#ifndef MFEM_USE_OPENMP
+   std::vector<OpType *> sub_ops;
+#else
+   std::vector<std::vector<OpType *>> sub_ops;
+#endif
+
+public:
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, fes, fes, Q, (mfem::Coefficient *)nullptr, use_bdr,
+               use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo,
+             typename CoeffType1, typename CoeffType2>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &fes,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, fes, fes, Q1, Q2, use_bdr, use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &trial_fes,
+                 const mfem::FiniteElementSpace &test_fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, trial_fes, test_fes, Q, (mfem::Coefficient *)nullptr,
+               use_bdr, use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo,
+             typename CoeffType1, typename CoeffType2>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &trial_fes,
+                 const mfem::FiniteElementSpace &test_fes,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      MFEM_VERIFY(trial_fes.GetMesh() == test_fes.GetMesh(),
+                  "Trial and test basis must correspond to the same Mesh.");
+      mfem::Mesh &mesh = *trial_fes.GetMesh();
+#ifndef MFEM_USE_OPENMP
+      const bool mixed =
+         mesh.GetNumGeometries(mesh.Dimension() - use_bdr) > 1 ||
+         trial_fes.IsVariableOrder() || test_fes.IsVariableOrder();
+      if (!mixed)
+      {
+         const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(0) :
+                                               *trial_fes.GetFE(0);
+         const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(0) :
+                                              *test_fes.GetFE(0);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(0) :
+                   *mesh.GetElementTransformation(0);
+         const mfem::IntegrationRule &ir =
+            integ.GetIntegrationRule() ? *integ.GetIntegrationRule() :
+            integ.GetRule(trial_fe, test_fe, T);
+         sub_ops.push_back(new OpType);
+         auto &sub_op = *sub_ops.back();
+         sub_op.Assemble(internal::ceed, info, trial_fes, test_fes, ir,
+                         Q1, Q2, use_bdr, use_mf);
+         CeedOperatorReferenceCopy(sub_op.GetOperator(), &oper);
+         if (sub_op.GetTransposeOperator())
+         {
+            CeedOperatorReferenceCopy(sub_op.GetTransposeOperator(), &oper_t);
+         }
+         CeedVectorCreate(internal::ceed,
+                          trial_fes.GetVDim() * trial_fes.GetNDofs(), &u);
+         CeedVectorCreate(internal::ceed,
+                          test_fes.GetVDim() * test_fes.GetNDofs(), &v);
+         return;
+      }
+#endif
+
+#ifdef MFEM_USE_OPENMP
+      #pragma omp parallel
+#endif
+      {
+         const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+#ifdef MFEM_USE_OPENMP
+         const int nt = omp_get_num_threads();
+         #pragma omp master
+         {
+            thread_ops.resize(nt, nullptr);
+            thread_ops_t.resize(nt, nullptr);
+            thread_u.resize(nt, nullptr);
+            thread_v.resize(nt, nullptr);
+            sub_ops.resize(nt);
+         }
+         const int tid = omp_get_thread_num();
+         const int stride = (ne + nt - 1) / nt;
+         const int start = tid * stride;
+         const int stop = std::min(start + stride, ne);
+#else
+         const int start = 0;
+         const int stop = ne;
+#endif
+
+         // Count the number of elements of each type
+         std::unordered_map<ElementKey, int, ElementHash> counts, offsets;
+         std::unordered_map<ElementKey, std::vector<int>, ElementHash> element_indices;
+         for (int i = start; i < stop; i++)
+         {
+            const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                                  *trial_fes.GetFE(i);
+            const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                                 *test_fes.GetFE(i);
+            mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                       mesh.GetElementType(i);
+            ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+            auto value = counts.find(key);
+            if (value == counts.end())
+            {
+               counts[key] = 1;
+            }
+            else
+            {
+               value->second++;
+            }
+         }
+
+         // Initialization of the arrays
+         for (const auto &value : counts)
+         {
+            offsets[value.first] = 0;
+            element_indices[value.first] = std::vector<int>(value.second);
+         }
+
+         // Populates the indices arrays for each element type
+         for (int i = start; i < stop; i++)
+         {
+            const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                                  *trial_fes.GetFE(i);
+            const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                                 *test_fes.GetFE(i);
+            mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                       mesh.GetElementType(i);
+            ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+            int &offset = offsets[key];
+            std::vector<int> &indices = element_indices[key];
+            indices[offset++] = i;
+         }
+
+         // Create each sub-CeedOperator, some threads may be empty
+#ifdef MFEM_USE_OPENMP
+         #pragma omp barrier
+         CeedOperator &loc_oper = thread_ops[tid];
+         CeedOperator &loc_oper_t = thread_ops_t[tid];
+         CeedVector &loc_u = thread_u[tid];
+         CeedVector &loc_v = thread_v[tid];
+         std::vector<OpType *> &loc_sub_ops = sub_ops[tid];
+#else
+         CeedOperator &loc_oper = oper;
+         CeedOperator &loc_oper_t = oper_t;
+         CeedVector &loc_u = u;
+         CeedVector &loc_v = v;
+         std::vector<OpType *> &loc_sub_ops = sub_ops;
+#endif
+         if (element_indices.size() > 0)
+         {
+            loc_sub_ops.reserve(element_indices.size());
+            CeedCompositeOperatorCreate(internal::ceed, &loc_oper);
+            IsoparametricTransformation T;  // Thread-safe
+            for (const auto &value : element_indices)
+            {
+               const std::vector<int> &indices = value.second;
+               const int first_index = indices[0];
+               const mfem::FiniteElement &trial_fe =
+                  use_bdr ? *trial_fes.GetBE(first_index) : *trial_fes.GetFE(first_index);
+               const mfem::FiniteElement &test_fe =
+                  use_bdr ? *test_fes.GetBE(first_index) : *test_fes.GetFE(first_index);
+               if (use_bdr)
+               {
+                  mesh.GetBdrElementTransformation(first_index, &T);
+               }
+               else
+               {
+                  mesh.GetElementTransformation(first_index, &T);
+               }
+               MFEM_VERIFY(!integ.GetIntegrationRule() || element_indices.size() == 1,
+                           "Mixed mesh integrators should not have an IntegrationRule.");
+               const mfem::IntegrationRule &ir =
+                  integ.GetIntegrationRule() ? *integ.GetIntegrationRule() :
+                  integ.GetRule(trial_fe, test_fe, T);
+               loc_sub_ops.push_back(new OpType);
+               auto &sub_op = *loc_sub_ops.back();
+               sub_op.Assemble(internal::ceed, info, trial_fes, test_fes, ir,
+                               static_cast<int>(indices.size()), indices.data(),
+                               Q1, Q2, use_bdr, use_mf);
+               CeedCompositeOperatorAddSub(loc_oper, sub_op.GetOperator());
+               if (sub_op.GetTransposeOperator())
+               {
+                  if (!loc_oper_t) { CeedCompositeOperatorCreate(internal::ceed, &loc_oper_t); }
+                  CeedCompositeOperatorAddSub(loc_oper_t, sub_op.GetTransposeOperator());
+               }
+            }
+            CeedOperatorCheckReady(loc_oper);
+            if (loc_oper_t) { CeedOperatorCheckReady(loc_oper_t); }
+            CeedVectorCreate(internal::ceed,
+                             trial_fes.GetVDim() * trial_fes.GetNDofs(), &loc_u);
+            CeedVectorCreate(internal::ceed,
+                             test_fes.GetVDim() * test_fes.GetNDofs(), &loc_v);
+         }
+      }
+   }
+
+   virtual ~MixedOperator()
+   {
+#ifndef MFEM_USE_OPENMP
+      for (auto *sub_op : sub_ops)
+      {
+         delete sub_op;
+      }
+#else
+      #pragma omp parallel
+      {
+         const int tid = omp_get_thread_num();
+         for (auto *sub_op : sub_ops[tid])
+         {
+            delete sub_op;
+         }
+      }
+#endif
+   }
+#endif
+};
+
+} // namespace ceed
+
+} // namespace mfem
+
+#endif // MFEM_LIBCEED_MIXED_OPERATOR
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index 8545ccaa8..05b5219b2 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -11,11 +11,12 @@
 
 #include "operator.hpp"
 
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../fespace.hpp"
 #include "util.hpp"
-#include "ceed.hpp"
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
 
 namespace mfem
 {
@@ -26,59 +27,100 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 Operator::Operator(CeedOperator op)
 {
-   oper = op;
    CeedSize in_len, out_len;
-   int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
+   int ierr = CeedOperatorGetActiveVectorLengths(op, &in_len, &out_len);
    PCeedChk(ierr);
-   height = out_len;
    width = in_len;
-   MFEM_VERIFY(height == out_len, "height overflow");
+   height = out_len;
    MFEM_VERIFY(width == in_len, "width overflow");
-   CeedVectorCreate(internal::ceed, height, &v);
+   MFEM_VERIFY(height == out_len, "height overflow");
+#ifndef MFEM_USE_OPENMP
+   oper = op;
+   oper_t = nullptr;
    CeedVectorCreate(internal::ceed, width, &u);
+   CeedVectorCreate(internal::ceed, height, &v);
+#else
+   thread_ops = {op};
+   thread_ops_t = {nullptr};
+   thread_u.resize(1);
+   thread_v.resize(1);
+   CeedVectorCreate(internal::ceed, width, &thread_u[0]);
+   CeedVectorCreate(internal::ceed, height, &thread_v[0]);
+#endif
 }
 #endif
 
-void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+Operator::~Operator()
 {
 #ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedOperatorDestroy(&oper);
+   CeedOperatorDestroy(&oper_t);
+   CeedVectorDestroy(&u);
+   CeedVectorDestroy(&v);
+#else
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      CeedOperatorDestroy(&thread_ops[tid]);
+      CeedOperatorDestroy(&thread_ops_t[tid]);
+      CeedVectorDestroy(&thread_u[tid]);
+      CeedVectorDestroy(&thread_v[tid]);
+   }
+#endif
+#endif
+}
+
+namespace
+{
+
+#ifdef MFEM_USE_CEED
+template <bool ADD>
+inline void CeedAddMult(CeedOperator oper, CeedVector u,
+                        CeedVector v, const mfem::Vector &x, mfem::Vector &y)
+{
+   if (!oper) { return; }  // No-op for an empty operator
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
-      y_ptr = y.Write();
+      y_ptr = (!ADD) ? y.Write() : y.ReadWrite();
    }
    else
    {
       x_ptr = x.HostRead();
-      y_ptr = y.HostWrite();
+      y_ptr = (!ADD) ? y.HostWrite() : y.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
+
    CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
    CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
-
-   CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
-
+   if (!ADD)
+   {
+      CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
+   else
+   {
+      CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
    CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
    CeedVectorTakeArray(v, mem, &y_ptr);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
 }
 
-void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
-                       const double a) const
+#ifdef MFEM_USE_OPENMP
+inline void CeedAddMult(const std::vector<CeedOperator> &ops,
+                        const std::vector<CeedVector> &u,
+                        const std::vector<CeedVector> &v,
+                        const mfem::Vector &x, mfem::Vector &y)
 {
-#ifdef MFEM_USE_CEED
-   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.ReadWrite();
@@ -89,13 +131,80 @@ void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
       y_ptr = y.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
-   CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
-   CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
 
-   CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      if (ops[tid])  // No-op for an empty operator
+      {
+         CeedScalar *u_ptr = const_cast<CeedScalar *>(x_ptr);
+         CeedScalar *v_ptr = y_ptr;
+         CeedVectorSetArray(u[tid], mem, CEED_USE_POINTER, u_ptr);
+         CeedVectorSetArray(v[tid], mem, CEED_USE_POINTER, v_ptr);
+         CeedOperatorApplyAdd(ops[tid], u[tid], v[tid], CEED_REQUEST_IMMEDIATE);
+         CeedVectorTakeArray(u[tid], mem, &u_ptr);
+         CeedVectorTakeArray(v[tid], mem, &v_ptr);
+      }
+   }
+}
+#endif
+#endif
+
+} // namespace
 
-   CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
-   CeedVectorTakeArray(v, mem, &y_ptr);
+void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<false>(oper, u, v, x, y);
+#else
+   y = 0.0;
+   CeedAddMult(thread_ops, thread_u, thread_v, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
+                       const double a) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(a == 1.0, "General coefficient case is not yet supported");
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<true>(oper, u, v, x, y);
+#else
+   CeedAddMult(thread_ops, thread_u, thread_v, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::MultTranspose(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<false>(oper_t, v, u, x, y);
+#else
+   y = 0.0;
+   CeedAddMult(thread_ops_t, thread_v, thread_u, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                                const double a) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(a == 1.0, "General coefficient case is not yet supported");
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<true>(oper_t, v, u, x, y);
+#else
+   CeedAddMult(thread_ops_t, thread_v, thread_u, x, y);
+#endif
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
@@ -106,8 +215,8 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
 #ifdef MFEM_USE_CEED
    CeedScalar *d_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       d_ptr = diag.ReadWrite();
    }
@@ -116,11 +225,25 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
       d_ptr = diag.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
-   CeedVectorSetArray(v, mem, CEED_USE_POINTER, d_ptr);
 
+#ifndef MFEM_USE_OPENMP
+   CeedVectorSetArray(v, mem, CEED_USE_POINTER, d_ptr);
    CeedOperatorLinearAssembleAddDiagonal(oper, v, CEED_REQUEST_IMMEDIATE);
-
    CeedVectorTakeArray(v, mem, &d_ptr);
+#else
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      if (thread_ops[tid])  // No-op for an empty operator
+      {
+         CeedScalar *v_ptr = d_ptr;
+         CeedVectorSetArray(thread_v[tid], mem, CEED_USE_POINTER, v_ptr);
+         CeedOperatorLinearAssembleAddDiagonal(thread_ops[tid], thread_v[tid],
+                                               CEED_REQUEST_IMMEDIATE);
+         CeedVectorTakeArray(thread_v[tid], mem, &v_ptr);
+      }
+   }
+#endif
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index cffea2fc7..4901236e9 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -14,6 +14,9 @@
 
 #include "../../../linalg/operator.hpp"
 #include "ceed.hpp"
+#ifdef MFEM_USE_OPENMP
+#include <vector>
+#endif
 
 namespace mfem
 {
@@ -26,34 +29,51 @@ class Operator : public mfem::Operator
 {
 protected:
 #ifdef MFEM_USE_CEED
-   CeedOperator oper;
+#ifndef MFEM_USE_OPENMP
+   CeedOperator oper, oper_t;
    CeedVector u, v;
+#else
+   std::vector<CeedOperator> thread_ops, thread_ops_t;
+   std::vector<CeedVector> thread_u, thread_v;
+#endif
 
-   Operator() : oper(nullptr), u(nullptr), v(nullptr) { }
+#ifndef MFEM_USE_OPENMP
+   Operator() : oper(nullptr), oper_t(nullptr), u(nullptr), v(nullptr) {}
+#else
+   Operator() {}
+#endif
 #endif
 
 public:
 #ifdef MFEM_USE_CEED
-   /// This class takes ownership of op and will delete it
+   /// This constructor takes ownership of the operator and will delete it
    Operator(CeedOperator op);
+
+   operator CeedOperator() const
+   {
+#ifndef MFEM_USE_OPENMP
+      return oper;
+#else
+      MFEM_VERIFY(thread_ops.size() == 1,
+                  "Threaded ceed:Operator should access CeedOperators by thread index");
+      return thread_ops[0];
+#endif
+   }
+#ifdef MFEM_USE_OPENMP
+   CeedOperator operator[](std::size_t i) const { return thread_ops[i]; }
+   std::size_t Size() const { return thread_ops.size(); }
+#endif
 #endif
+
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
    void AddMult(const mfem::Vector &x, mfem::Vector &y,
                 const double a = 1.0) const override;
+   void MultTranspose(const mfem::Vector &x, mfem::Vector &y) const override;
+   void AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                         const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
-   using mfem::Operator::SetupRAP;
-   virtual ~Operator()
-   {
-#ifdef MFEM_USE_CEED
-      CeedOperatorDestroy(&oper);
-      CeedVectorDestroy(&u);
-      CeedVectorDestroy(&v);
-#endif
-   }
 
-#ifdef MFEM_USE_CEED
-   CeedOperator& GetCeedOperator() { return oper; }
-#endif
+   virtual ~Operator();
 };
 
 } // namespace ceed
diff --git a/fem/ceed/interface/restriction.cpp b/fem/ceed/interface/restriction.cpp
index e7e8539bd..8f17a7fbe 100644
--- a/fem/ceed/interface/restriction.cpp
+++ b/fem/ceed/interface/restriction.cpp
@@ -9,8 +9,10 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../../fem/gridfunc.hpp"
-#include "ceed.hpp"
+#include "restriction.hpp"
+
+#include "util.hpp"
+#include <cstdint>
 
 namespace mfem
 {
@@ -20,248 +22,381 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(0) : *fes.GetFE(0);
+   const int P = fe.GetDof();
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
    mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_el_orients = false;
 
-   for (int i = 0; i < fes.GetNE(); i++)
+   for (int i = 0; i < nelem; i++)
    {
-      const int el_offset = P * i;
+      // No need to handle DofTransformation for tensor-product elements
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j+el_offset] = stride*el_dof.GetJ()[dof_map[j]+el_offset];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = el_map[did + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(0) : *fes.GetFE(0);
+   const int P = fe.GetDof();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
    mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_el_orients = false;
 
-   for (int e = 0; e < fes.GetNE(); e++)
+   for (int i = 0; i < nelem; i++)
    {
-      for (int i = 0; i < P; i++)
+      // DofTransformation support uses InitNativeRestrWithIndices
+      for (int j = 0; j < P; j++)
       {
-         tp_el_dof[i + e*P] = stride*el_dof.GetJ()[i + e*P];
+         const int sgid = el_map[j + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] = (sgid < 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitRestrictionImpl(const mfem::FiniteElementSpace &fes,
-                                Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   if (use_el_orients)
    {
-      InitNativeRestr(fes, ceed, restr);
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestr(fes, ceed, restr);
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
-static void InitNativeRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitLexicoRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients(nelem * P);
+   bool use_el_orients = false;
+   mfem::DofTransformation dof_trans;
 
    for (int i = 0; i < nelem; i++)
    {
+      // No need to handle DofTransformation for tensor-product elements
       const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
-      for (int j = 0; j < P; j++)
+      if (use_bdr)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[dof_map[j]];
+         fes.GetBdrElementDofs(elem_index, dofs, dof_trans);
       }
-   }
-
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitLexicoRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-
-   for (int i = 0; i < nelem; i++)
-   {
-      const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
+      else
+      {
+         fes.GetElementDofs(elem_index, dofs, dof_trans);
+      }
+      MFEM_VERIFY(!dof_trans.GetDofTransformation(),
+                  "Unexpected DofTransformation for lexicographic element "
+                  "restriction.");
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[j];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = dofs[did];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       bool has_dof_trans,
+                                       bool is_interp_range,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients;
+   mfem::Array<int8_t> tp_el_curl_orients;
+   bool use_el_orients = false;
+   mfem::DofTransformation dof_trans;
+   mfem::Vector el_trans_j;
+   if (!has_dof_trans)
    {
-      InitNativeRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_orients.SetSize(nelem * P);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_curl_orients.SetSize(nelem * P * 3, 0);
+      el_trans_j.SetSize(P);
    }
-}
 
-static void InitCoeffRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   int nquads,
-   int ncomp,
-   Ceed ceed,
-   CeedElemRestriction *restr)
-{
-   mfem::Array<int> tp_el_dof(nelem*nquads);
-   const int stride_quad = ncomp;
-   const int stride_elem = ncomp*nquads;
-   // TODO generalize to support different #quads
    for (int i = 0; i < nelem; i++)
    {
-      const int elem_index = indices[i];
-      const int el_offset = elem_index * stride_elem;
-      for (int j = 0; j < nquads; j++)
+      const int elem_index = indices ? indices[i] : i;
+      if (use_bdr)
+      {
+         fes.GetBdrElementDofs(elem_index, dofs, dof_trans);
+      }
+      else
+      {
+         fes.GetElementDofs(elem_index, dofs, dof_trans);
+      }
+      if (!has_dof_trans)
       {
-         tp_el_dof[j + nquads * i] = j * stride_quad + el_offset;
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+            tp_el_orients[j + P * i] = (sgid < 0);
+            use_el_orients = use_el_orients || tp_el_orients[j + P * i];
+         }
+      }
+      else
+      {
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+
+            // Fill column j of element tridiagonal matrix tp_el_curl_orients
+            el_trans_j = 0.0;
+            el_trans_j(j) = 1.0;
+            if (is_interp_range)
+            {
+               dof_trans.InvTransformDual(el_trans_j);
+            }
+            else
+            {
+               dof_trans.InvTransformPrimal(el_trans_j);
+            }
+            double sign_j = (sgid < 0) ? -1.0 : 1.0;
+            tp_el_curl_orients[3 * (j + 0 + P * i) + 1] =
+               static_cast<int8_t>(sign_j * el_trans_j(j + 0));
+            if (j > 0)
+            {
+               tp_el_curl_orients[3 * (j - 1 + P * i) + 2] =
+                  static_cast<int8_t>(sign_j * el_trans_j(j - 1));
+            }
+            if (j < P - 1)
+            {
+               tp_el_curl_orients[3 * (j + 1 + P * i) + 0] =
+                  static_cast<int8_t>(sign_j * el_trans_j(j + 1));
+            }
+#ifdef MFEM_DEBUG
+            int nnz = 0;
+            for (int k = 0; k < P; k++)
+            {
+               if (k < j - 1 && k > j + 1 && el_trans_j(k) != 0.0) { nnz++; }
+            }
+            MFEM_ASSERT(nnz == 0,
+                        "Element transformation matrix is not tridiagonal at column "
+                        << j << " (nnz = " << nnz << ")!");
+#endif
+         }
       }
    }
-   CeedElemRestrictionCreate(ceed, nelem, nquads, ncomp, 1,
-                             ncomp*fes.GetNE()*nquads,
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
 
-void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
-                            CeedElemRestriction *restr)
-{
-   RestrKey restr_key(&fes, nelem, nqpts, qdatasize, restr_type::Strided);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   if (tp_el_curl_orients.Size())
    {
-      CeedElemRestrictionCreateStrided(mfem::internal::ceed, nelem, nqpts, qdatasize,
-                                       nelem*nqpts*qdatasize,
-                                       strides,
-                                       restr);
-      // Will be automatically destroyed when @a fes gets destroyed.
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      CeedElemRestrictionCreateCurlOriented(ceed, nelem, P, fes.GetVDim(),
+                                            compstride, fes.GetVDim() * fes.GetNDofs(),
+                                            CEED_MEM_HOST, CEED_COPY_VALUES,
+                                            tp_el_dof.GetData(), tp_el_curl_orients.GetData(),
+                                            restr);
+   }
+   else if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
    else
    {
-      *restr = restr_itr->second;
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
 void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     bool is_interp,
+                     bool is_range,
+                     int nelem,
+                     const int *indices,
                      Ceed ceed,
                      CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   const int nelem = fes.GetNE();
+   // Check for fes -> restriction in hash table
+   // {-1, -1, -1} is unique from CEED_STRIDES_BACKEND for strided restrictions
+   // The restriction for an interpolator range space is slightly different as
+   // the output is a primal vector instead of a dual vector, and lexicographic
+   // ordering is never used (no use of tensor-product basis)
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
    const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-
-   // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const bool vector = fe.GetRangeType() == mfem::FiniteElement::VECTOR;
+   const bool lexico =
+      (tfe && tfe->GetDofMap().Size() > 0 && !vector && !is_interp);
+   mfem::Array<int> dofs;
+   mfem::DofTransformation dof_trans;
+   if (use_bdr)
    {
-      InitRestrictionImpl(fes, ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      fes.GetBdrElementDofs(first_index, dofs, dof_trans);
    }
    else
    {
-      *restr = restr_itr->second;
+      fes.GetElementDofs(first_index, dofs, dof_trans);
    }
-}
-
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr)
-{
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
+   const bool has_dof_trans = dof_trans.GetDofTransformation() &&
+                              !dof_trans.IsEmpty();
+   const bool unique_range_restr = (is_interp && is_range && has_dof_trans);
+   RestrKey restr_key(&fes, {nelem, P, ncomp, unique_range_restr}, {-1, -1, -1});
 
    // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   auto restr_itr = internal::ceed_restr_map.find(restr_key);
+   if (restr_itr == internal::ceed_restr_map.end())
    {
-      InitRestrictionWithIndicesImpl(fes, nelem, indices, ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      if (indices)
+      {
+         if (lexico)
+         {
+            // Lexicographic ordering using dof_map
+            InitLexicoRestrWithIndices(fes, use_bdr, nelem, indices,
+                                       ceed, restr);
+         }
+         else
+         {
+            // Native ordering
+            InitNativeRestrWithIndices(fes, use_bdr, has_dof_trans, is_interp && is_range,
+                                       nelem, indices, ceed, restr);
+         }
+      }
+      else
+      {
+         if (lexico)
+         {
+            // Lexicographic ordering using dof_map
+            MFEM_VERIFY(!has_dof_trans,
+                        "Unexpected DofTransformation for lexicographic element "
+                        "restriction.");
+            InitLexicoRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else if (!has_dof_trans)
+         {
+            // Native ordering without dof_trans
+            InitNativeRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else
+         {
+            // Native ordering with dof_trans
+            InitNativeRestrWithIndices(fes, use_bdr, has_dof_trans, is_interp && is_range,
+                                       nelem, nullptr, ceed, restr);
+         }
+      }
+      internal::ceed_restr_map[restr_key] = *restr;
    }
    else
    {
@@ -269,24 +404,26 @@ void InitRestrictionWithIndices(const FiniteElementSpace &fes,
    }
 }
 
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr)
+void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   RestrKey restr_key(&fes, nelem, nquads, ncomp, restr_type::Coeff);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
+   // Check for fes -> restriction in hash table
+   RestrKey restr_key(&fes, {nelem, nqpts, qdatasize, 0},
+   {strides[0], strides[1], strides[2]});
 
    // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   auto restr_itr = internal::ceed_restr_map.find(restr_key);
+   if (restr_itr == internal::ceed_restr_map.end())
    {
-      InitCoeffRestrictionWithIndicesImpl(fes, nelem, indices, nquads, ncomp,
-                                          ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      CeedElemRestrictionCreateStrided(ceed, nelem, nqpts, qdatasize,
+                                       nelem * nqpts * qdatasize, strides,
+                                       restr);
+      internal::ceed_restr_map[restr_key] = *restr;
    }
    else
    {
diff --git a/fem/ceed/interface/restriction.hpp b/fem/ceed/interface/restriction.hpp
index 221716b39..9b88e8e48 100644
--- a/fem/ceed/interface/restriction.hpp
+++ b/fem/ceed/interface/restriction.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_RESTR
 #define MFEM_LIBCEED_RESTR
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -21,65 +22,70 @@ namespace ceed
 {
 
 #ifdef MFEM_USE_CEED
-/** @brief Initialize a CeedElemRestriction for non-mixed meshes.
 
-    @param[in] fes Input finite element space.
-    @param[in] ceed Input Ceed object.
-    @param[out] restr The address of the initialized CeedElemRestriction object.
-*/
-void InitRestriction(const FiniteElementSpace &fes,
-                     Ceed ceed,
-                     CeedElemRestriction *restr);
-
-/** @brief Initialize a CeedElemRestriction for mixed meshes.
+/** @brief Initialize a CeedElemRestriction based on an
+    mfem::FiniteElementSpace @a fes and an optional list of @a nelem elements
+    of indices @a indices.
 
     @param[in] fes The finite element space.
-    @param[in] ceed The Ceed object.
+    @param[in] use_bdr Create the restriction for boundary elements.
+    @param[in] is_interp Create the restriction for an interpolation operator
+                         (sometimes requires special treatment).
+    @param[in] is_range Create the restriction for the range space of an
+                        operator (sometimes requires special treatment).
     @param[in] nelem The number of elements.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
     @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr);
+void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     bool is_interp,
+                     bool is_range,
+                     int nelem,
+                     const int *indices,
+                     Ceed ceed,
+                     CeedElemRestriction *restr);
+
+inline void InitRestriction(const FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            const int *indices,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
+{
+   InitRestriction(fes, use_bdr, false, false, nelem, indices, ceed, restr);
+}
+
+inline void InitRestriction(const FiniteElementSpace &fes,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
+{
+   InitRestriction(fes, false, false, false, fes.GetNE(), nullptr, ceed, restr);
+}
 
-/** @brief Initialize a strided CeedElemRestriction
+/** @brief Initialize a strided CeedElemRestriction.
 
     @param[in] fes Input finite element space.
     @param[in] nelem is the number of elements.
     @param[in] nqpts is the total number of quadrature points.
     @param[in] qdatasize is the number of data per quadrature point.
     @param[in] strides Array for strides between [nodes, components, elements].
-    Data for node i, component j, element k can be found in the L-vector at
-    index i*strides[0] + j*strides[1] + k*strides[2]. CEED_STRIDES_BACKEND may
-    be used with vectors created by a Ceed backend.
+                       Data for node i, component j, element k can be found in
+                       the L-vector at index i*strides[0] + j*strides[1] +
+                       k*strides[2]. CEED_STRIDES_BACKEND may be used with
+                       vectors created by a Ceed backend.
+    @param[in] ceed The Ceed object.
     @param[out] restr The `CeedElemRestriction` to initialize. */
 void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
                             CeedElemRestriction *restr);
 
-/** @brief Initialize a CeedElemRestriction for a mfem::Coefficient on a mixed
-    mesh.
-
-    @param[in] fes The finite element space.
-    @param[in] nelem is the number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
-    @param[in] nquads is the total number of quadrature points
-    @param[in] ncomp is the number of data per quadrature point
-    @param[in] ceed The Ceed object.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr);
-
 #endif
 
 } // namespace ceed
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index 882ba9399..970df6a3a 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -9,14 +9,11 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#include "util.hpp"
+
 #include "../../../general/device.hpp"
-#include "../../../fem/gridfunc.hpp"
 #include "../../../linalg/dtensor.hpp"
-
-#include "basis.hpp"
-#include "restriction.hpp"
-#include "ceed.hpp"
-
+#include "../../gridfunc.hpp"
 #include <sys/types.h>
 #include <sys/stat.h>
 #if !defined(_WIN32) || !defined(_MSC_VER)
@@ -41,30 +38,35 @@ namespace ceed
 void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
 {
 #ifdef MFEM_USE_CEED
-   auto itb = mfem::internal::ceed_basis_map.begin();
-   while (itb != mfem::internal::ceed_basis_map.end())
-   {
-      if (std::get<0>(itb->first)==fes)
-      {
-         CeedBasisDestroy(&itb->second);
-         itb = mfem::internal::ceed_basis_map.erase(itb);
-      }
-      else
-      {
-         itb++;
-      }
-   }
-   auto itr = mfem::internal::ceed_restr_map.begin();
-   while (itr != mfem::internal::ceed_restr_map.end())
+#ifdef MFEM_USE_OPENMP
+   #pragma omp parallel
+#endif
    {
-      if (std::get<0>(itr->first)==fes)
+      auto itb = internal::ceed_basis_map.begin();
+      while (itb != internal::ceed_basis_map.end())
       {
-         CeedElemRestrictionDestroy(&itr->second);
-         itr = mfem::internal::ceed_restr_map.erase(itr);
+         if (std::get<0>(itb->first) == fes)
+         {
+            CeedBasisDestroy(&itb->second);
+            itb = internal::ceed_basis_map.erase(itb);
+         }
+         else
+         {
+            itb++;
+         }
       }
-      else
+      auto itr = internal::ceed_restr_map.begin();
+      while (itr != internal::ceed_restr_map.end())
       {
-         itr++;
+         if (std::get<0>(itr->first) == fes)
+         {
+            CeedElemRestrictionDestroy(&itr->second);
+            itr = internal::ceed_restr_map.erase(itr);
+         }
+         else
+         {
+            itr++;
+         }
       }
    }
 #endif
@@ -72,84 +74,47 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
 
 #ifdef MFEM_USE_CEED
 
-void InitVector(const mfem::Vector &v, CeedVector &cv)
+void InitVector(const mfem::Vector &v, Ceed ceed, CeedVector &cv)
 {
-   CeedVectorCreate(mfem::internal::ceed, v.Size(), &cv);
+   CeedVectorCreate(ceed, v.Size(), &cv);
    CeedScalar *cv_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
-      cv_ptr = const_cast<CeedScalar*>(v.Read());
+      cv_ptr = const_cast<CeedScalar *>(v.Read());
    }
    else
    {
-      cv_ptr = const_cast<CeedScalar*>(v.HostRead());
+      cv_ptr = const_cast<CeedScalar *>(v.HostRead());
       mem = CEED_MEM_HOST;
    }
    CeedVectorSetArray(cv, mem, CEED_USE_POINTER, cv_ptr);
 }
 
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   InitBasis(fes, irm, ceed, basis);
-   InitRestriction(fes, ceed, restr);
-}
-
-void InitBasisAndRestrictionWithIndices(const FiniteElementSpace &fes,
-                                        const IntegrationRule &irm,
-                                        int nelem,
-                                        const int* indices,
-                                        Ceed ceed, CeedBasis *basis,
-                                        CeedElemRestriction *restr)
-{
-   InitBasisWithIndices(fes, irm, nelem, indices, ceed, basis);
-   InitRestrictionWithIndices(fes, nelem, indices, ceed, restr);
-}
-
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   if (indices)
-   {
-      InitBasisAndRestrictionWithIndices(fes,irm,nelem,indices,ceed,basis,restr);
-   }
-   else
-   {
-      InitBasisAndRestriction(fes,irm,ceed,basis,restr);
-   }
-}
-
 // Assumes a tensor-product operator with one active field
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
    bool isComposite;
-   ierr = CeedOperatorIsComposite(oper, &isComposite); CeedChk(ierr);
+   ierr = CeedOperatorIsComposite(oper, &isComposite); PCeedChk(ierr);
    CeedOperator *subops;
    if (isComposite)
    {
 #if CEED_VERSION_GE(0, 10, 2)
-      ierr = CeedCompositeOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedCompositeOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #else
-      ierr = CeedOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #endif
-      ierr = CeedOperatorGetQFunction(subops[0], &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(subops[0], &qf); PCeedChk(ierr);
    }
    else
    {
-      ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    }
    CeedInt numinputfields, numoutputfields;
    ierr = CeedQFunctionGetNumArgs(qf, &numinputfields, &numoutputfields);
@@ -157,12 +122,12 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    if (isComposite)
    {
       ierr = CeedOperatorGetFields(subops[0], &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
    else
    {
       ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
 
    CeedVector if_vector;
@@ -170,7 +135,7 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    int found_index = -1;
    for (int i = 0; i < numinputfields; ++i)
    {
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); CeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); PCeedChk(ierr);
       if (if_vector == CEED_VECTOR_ACTIVE)
       {
          if (found)
diff --git a/fem/ceed/interface/util.hpp b/fem/ceed/interface/util.hpp
index 6d1cc3c68..cffe365b1 100644
--- a/fem/ceed/interface/util.hpp
+++ b/fem/ceed/interface/util.hpp
@@ -12,16 +12,16 @@
 #ifndef MFEM_LIBCEED_UTIL
 #define MFEM_LIBCEED_UTIL
 
-#include "../../../config/config.hpp"
-#include <functional>
-#include <string>
-#include <tuple>
-#include <unordered_map>
-
+#include "../../../general/error.hpp"
 #include "ceed.hpp"
 #ifdef MFEM_USE_CEED
-#include <ceed/backend.h>  // for CeedOperatorField
+#include <ceed/backend.h>
 #endif
+#include <array>
+#include <functional>
+#include <tuple>
+#include <unordered_map>
+#include <string>
 
 namespace mfem
 {
@@ -40,7 +40,7 @@ namespace ceed
 {
 
 /** @brief Remove from ceed_basis_map and ceed_restr_map the entries associated
-    with the given @a fes. */
+    with the given @a fes when @a fes gets destroyed. */
 void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 
 #ifdef MFEM_USE_CEED
@@ -48,53 +48,18 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 #define PCeedChk(err) do {                                                     \
      if ((err))                                                                \
      {                                                                         \
-        const char * errmsg;                                                   \
+        const char *errmsg;                                                    \
         CeedGetErrorMessage(internal::ceed, &errmsg);                          \
         MFEM_ABORT(errmsg);                                                    \
      }                                                                         \
   } while(0);
 
 /// Initialize a CeedVector from an mfem::Vector
-void InitVector(const mfem::Vector &v, CeedVector &cv);
-
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize.
-
-    @warning Only for non-mixed finite element spaces. */
-void InitBasisAndRestriction(const mfem::FiniteElementSpace &fes,
-                             const mfem::IntegrationRule &ir,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
-
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir,
-    and a list of @a nelem elements of indices @a indices.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`. If `indices == nullptr`, assumes
-                       that the `FiniteElementSpace` is not mixed.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &ir,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
+void InitVector(const mfem::Vector &v, Ceed ceed, CeedVector &cv);
 
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field);
 
-/// Return the path to the libCEED q-function headers.
+/// Return the path to the libCEED QFunction headers.
 const std::string &GetCeedPath();
 
 /// Wrapper for std::hash.
@@ -113,42 +78,47 @@ inline std::size_t CeedHashCombine(std::size_t seed, std::size_t hash)
 }
 
 // Hash table for CeedBasis
-using BasisKey = std::tuple<const mfem::FiniteElementSpace*,
-      const mfem::IntegrationRule*,
-      int, int, int>;
+using BasisKey =
+   std::tuple<const mfem::FiniteElementSpace *, const mfem::FiniteElementSpace *,
+   const mfem::IntegrationRule *, std::array<int, 3>>;
 struct BasisHash
 {
-   std::size_t operator()(const BasisKey& k) const
+   std::size_t operator()(const BasisKey &k) const
    {
       return CeedHashCombine(
                 CeedHashCombine(
-                   CeedHash(std::get<0>(k)),
-                   CeedHash(std::get<1>(k))),
+                   CeedHashCombine(
+                      CeedHash(std::get<0>(k)),
+                      CeedHash(std::get<1>(k))),
+                   CeedHash(std::get<2>(k))),
                 CeedHashCombine(
-                   CeedHashCombine(CeedHash(std::get<2>(k)),
-                                   CeedHash(std::get<3>(k))),
-                   CeedHash(std::get<4>(k))));
+                   CeedHashCombine(CeedHash(std::get<3>(k)[0]),
+                                   CeedHash(std::get<3>(k)[1])),
+                   CeedHash(std::get<3>(k)[2])));
    }
 };
 using BasisMap = std::unordered_map<const BasisKey, CeedBasis, BasisHash>;
 
-enum restr_type {Standard, Strided, Coeff};
-
 // Hash table for CeedElemRestriction
 using RestrKey =
-   std::tuple<const mfem::FiniteElementSpace*, int, int, int, int>;
+   std::tuple<const mfem::FiniteElementSpace *, std::array<int, 4>,
+   std::array<int, 3>>;
 struct RestrHash
 {
-   std::size_t operator()(const RestrKey& k) const
+   std::size_t operator()(const RestrKey &k) const
    {
       return CeedHashCombine(
+                CeedHash(std::get<0>(k)),
                 CeedHashCombine(
                    CeedHashCombine(
-                      CeedHash(std::get<0>(k)),
-                      CeedHash(std::get<1>(k))),
-                   CeedHashCombine(CeedHash(std::get<2>(k)),
-                                   CeedHash(std::get<3>(k)))),
-                CeedHash(std::get<4>(k)));
+                      CeedHashCombine(CeedHash(std::get<1>(k)[0]),
+                                      CeedHash(std::get<1>(k)[1])),
+                      CeedHashCombine(CeedHash(std::get<1>(k)[2]),
+                                      CeedHash(std::get<1>(k)[3]))),
+                   CeedHashCombine(
+                      CeedHashCombine(CeedHash(std::get<2>(k)[0]),
+                                      CeedHash(std::get<2>(k)[1])),
+                      CeedHash(std::get<2>(k)[2]))));
    }
 };
 using RestrMap =
@@ -163,9 +133,15 @@ namespace internal
 
 #ifdef MFEM_USE_CEED
 /** @warning These maps have a tendency to create bugs when adding new "types"
-    of CeedBasis and CeedElemRestriction. */
+    of CeedBasis and CeedElemRestriction. Definitions in general/device.cpp. */
 extern ceed::BasisMap ceed_basis_map;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed_basis_map)
+#endif
 extern ceed::RestrMap ceed_restr_map;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed_restr_map)
+#endif
 #endif
 
 } // namespace internal
diff --git a/fem/ceed/solvers/algebraic.cpp b/fem/ceed/solvers/algebraic.cpp
index 2cc325dbc..581275858 100644
--- a/fem/ceed/solvers/algebraic.cpp
+++ b/fem/ceed/solvers/algebraic.cpp
@@ -11,14 +11,19 @@
 
 #include "algebraic.hpp"
 
+#include "../../../general/forall.hpp"
 #include "../../bilinearform.hpp"
 #include "../../fespace.hpp"
 #include "../../pfespace.hpp"
-#include "../../../general/forall.hpp"
-#include "solvers-atpmg.hpp"
-#include "full-assembly.hpp"
 #include "../interface/restriction.hpp"
-#include "../interface/ceed.hpp"
+#include "../interface/util.hpp"
+#include "solvers-atpmg.hpp"
+#ifdef MFEM_USE_CEED
+#include <ceed/backend.h>
+#endif
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
 
 namespace mfem
 {
@@ -28,44 +33,50 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
+int CeedInternalFree(void *p)
+{
+   free(*(void **)p);
+   *(void **)p = NULL;
+   return 0;
+}
+
 /** Wraps a CeedOperator in an mfem::Operator, with essential boundary
     conditions and a prolongation operator for parallel application. */
 class ConstrainedOperator : public mfem::Operator
 {
 public:
    /// This object takes ownership of oper and will delete it
-   ConstrainedOperator(CeedOperator oper, const Array<int> &ess_tdofs_,
-                       const mfem::Operator *P_);
-   ConstrainedOperator(CeedOperator oper, const mfem::Operator *P_);
+   ConstrainedOperator(CeedOperator oper, const Array<int> &ess_tdofs,
+                       const mfem::Operator *P);
+   ConstrainedOperator(CeedOperator oper, const mfem::Operator *P);
    ~ConstrainedOperator();
-   void Mult(const Vector& x, Vector& y) const;
-   CeedOperator GetCeedOperator() const;
+
    const Array<int> &GetEssentialTrueDofs() const;
    const mfem::Operator *GetProlongation() const;
+   operator CeedOperator() const { return (CeedOperator)*unconstrained_op; }
+   void Mult(const Vector& x, Vector& y) const;
+
 private:
    Array<int> ess_tdofs;
    const mfem::Operator *P;
    ceed::Operator *unconstrained_op;
-   mfem::ConstrainedOperator *constrained_op;
+   mfem::Operator *constrained_op;
 };
 
-ConstrainedOperator::ConstrainedOperator(
-   CeedOperator oper,
-   const Array<int> &ess_tdofs_,
-   const mfem::Operator *P_)
-   : ess_tdofs(ess_tdofs_), P(P_)
+ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
+                                         const Array<int> &ess_tdofs,
+                                         const mfem::Operator *P)
+   : ess_tdofs(ess_tdofs), P(P)
 {
    unconstrained_op = new ceed::Operator(oper);
-   mfem::Operator *rap = unconstrained_op->SetupRAP(P, P);
-   height = width = rap->Height();
-   bool own_rap = (rap != unconstrained_op);
-   constrained_op = new mfem::ConstrainedOperator(rap, ess_tdofs, own_rap);
+   unconstrained_op->FormSystemOperator(ess_tdofs, constrained_op);
+   height = width = constrained_op->Height();
 }
 
 ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
-                                         const mfem::Operator *P_)
-   : ConstrainedOperator(oper, Array<int>(), P_)
-{ }
+                                         const mfem::Operator *P)
+   : ConstrainedOperator(oper, Array<int>(), P)
+{}
 
 ConstrainedOperator::~ConstrainedOperator()
 {
@@ -78,11 +89,6 @@ void ConstrainedOperator::Mult(const Vector& x, Vector& y) const
    constrained_op->Mult(x, y);
 }
 
-CeedOperator ConstrainedOperator::GetCeedOperator() const
-{
-   return unconstrained_op->GetCeedOperator();
-}
-
 const Array<int> &ConstrainedOperator::GetEssentialTrueDofs() const
 {
    return ess_tdofs;
@@ -93,29 +99,21 @@ const mfem::Operator *ConstrainedOperator::GetProlongation() const
    return P;
 }
 
-/// assumes a square operator (you could do rectangular, you'd have
-/// to find separate active input and output fields/restrictions)
-int CeedOperatorGetSize(CeedOperator oper, CeedInt * size)
-{
-   CeedSize in_len, out_len;
-   int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
-   CeedChk(ierr);
-   *size = (CeedInt)in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == *size, "size overflow");
-   return 0;
-}
-
 Solver *BuildSmootherFromCeed(ConstrainedOperator &op, bool chebyshev)
 {
    int ierr;
-   CeedOperator ceed_op = op.GetCeedOperator();
+
    const Array<int> &ess_tdofs = op.GetEssentialTrueDofs();
    const mfem::Operator *P = op.GetProlongation();
+
    // Assemble the a local diagonal, in the sense of L-vector
    CeedVector diagceed;
-   CeedInt length;
-   ierr = CeedOperatorGetSize(ceed_op, &length); PCeedChk(ierr);
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(op, &l_in, &l_out);
+   PCeedChk(ierr);
+   MFEM_VERIFY(l_in == l_out, "Not a square CeedOperator.");
+   MFEM_VERIFY((CeedInt)l_in == l_in, "Size overflow.");
+   CeedInt length = l_in;
    ierr = CeedVectorCreate(internal::ceed, length, &diagceed); PCeedChk(ierr);
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
@@ -128,7 +126,7 @@ Solver *BuildSmootherFromCeed(ConstrainedOperator &op, bool chebyshev)
                      local_diag.Write(true);
    ierr = CeedVectorSetArray(diagceed, mem, CEED_USE_POINTER, ptr);
    PCeedChk(ierr);
-   ierr = CeedOperatorLinearAssembleDiagonal(ceed_op, diagceed,
+   ierr = CeedOperatorLinearAssembleDiagonal(op, diagceed,
                                              CEED_REQUEST_IMMEDIATE);
    PCeedChk(ierr);
    ierr = CeedVectorTakeArray(diagceed, mem, NULL); PCeedChk(ierr);
@@ -168,24 +166,19 @@ public:
    {
       MFEM_ASSERT(P != NULL, "Provided HypreParMatrix is invalid!");
       height = width = oper.Height();
-
-      int ierr;
-      const Array<int> ess_tdofs = oper.GetEssentialTrueDofs();
-
-      ierr = CeedOperatorFullAssemble(oper.GetCeedOperator(), &mat_local);
-      PCeedChk(ierr);
-
+      mat_local = CeedOperatorFullAssemble(oper);
       {
          HypreParMatrix hypre_local(
             P->GetComm(), P->GetGlobalNumRows(), P->RowPart(), mat_local);
          op_assembled = RAP(&hypre_local, P);
       }
+      const Array<int> ess_tdofs = oper.GetEssentialTrueDofs();
       HypreParMatrix *mat_e = op_assembled->EliminateRowsCols(ess_tdofs);
       delete mat_e;
       amg = new HypreBoomerAMG(*op_assembled);
       amg->SetPrintLevel(0);
    }
-   void SetOperator(const mfem::Operator &op) override { }
+   void SetOperator(const mfem::Operator &op) override {}
    void Mult(const Vector &x, Vector &y) const override { amg->Mult(x, y); }
    ~AssembledAMG()
    {
@@ -224,37 +217,47 @@ void CoarsenEssentialDofs(const mfem::Operator &interp,
    }
 }
 
-void AddToCompositeOperator(BilinearFormIntegrator *integ, CeedOperator op)
+namespace
 {
-   if (integ->SupportsCeed())
-   {
-      CeedCompositeOperatorAddSub(op, integ->GetCeedOp().GetCeedOperator());
-   }
-   else
+
+inline void CompositeOperatorAddSub(BilinearFormIntegrator &integ,
+                                    CeedOperator op)
+{
+   MFEM_VERIFY(integ.SupportsCeed(), "This integrator does not support Ceed!");
+#ifndef MFEM_USE_OPENMP
+   CeedCompositeOperatorAddSub(op, integ.GetCeedOp());
+#else
+   #pragma omp parallel
    {
-      MFEM_ABORT("This integrator does not support Ceed!");
+      const int tid = omp_get_thread_num();
+      if (integ.GetCeedOp()[tid])
+      {
+         #pragma omp critical
+         CeedCompositeOperatorAddSub(op, integ.GetCeedOp()[tid]);
+      }
    }
+#endif
 }
 
+} // namespace
+
 CeedOperator CreateCeedCompositeOperatorFromBilinearForm(BilinearForm &form)
 {
    int ierr;
    CeedOperator op;
    ierr = CeedCompositeOperatorCreate(internal::ceed, &op); PCeedChk(ierr);
-
-   MFEM_VERIFY(form.GetBBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetBFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-
-   // Get the domain bilinear form integrators (DBFIs)
-   Array<BilinearFormIntegrator*> *bffis = form.GetDBFI();
-   for (int i = 0; i < bffis->Size(); ++i)
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
    {
-      AddToCompositeOperator((*bffis)[i], op);
+      CompositeOperatorAddSub(*integ, op);
    }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      CompositeOperatorAddSub(*integ, op);
+   }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
    return op;
 }
 
@@ -262,13 +265,13 @@ CeedOperator CoarsenCeedCompositeOperator(
    CeedOperator op,
    CeedElemRestriction er,
    CeedBasis c2f,
-   int order_reduction
-)
+   int order_reduction)
 {
    int ierr;
    bool isComposite;
    ierr = CeedOperatorIsComposite(op, &isComposite); PCeedChk(ierr);
-   MFEM_ASSERT(isComposite, "");
+   MFEM_ASSERT(isComposite,
+               "CoarsenCeedCompositeOperator requires a composite operator.");
 
    CeedOperator op_coarse;
    ierr = CeedCompositeOperatorCreate(internal::ceed,
@@ -304,8 +307,8 @@ CeedOperator CoarsenCeedCompositeOperator(
 AlgebraicMultigrid::AlgebraicMultigrid(
    AlgebraicSpaceHierarchy &hierarchy,
    BilinearForm &form,
-   const Array<int> &ess_tdofs
-) : GeometricMultigrid(hierarchy)
+   const Array<int> &ess_tdofs)
+   : GeometricMultigrid(hierarchy)
 {
    int nlevels = fespaces.GetNumLevels();
    ceed_operators.SetSize(nlevels);
@@ -344,14 +347,14 @@ AlgebraicMultigrid::AlgebraicMultigrid(
          if (nlevels == 1)
          {
             // Only one level -- no coarsening, finest level
-            ParFiniteElementSpace *pfes
-               = dynamic_cast<ParFiniteElementSpace*>(&space);
+            ParFiniteElementSpace *pfes =
+               dynamic_cast<ParFiniteElementSpace*>(&space);
             if (pfes) { P_mat = pfes->Dof_TrueDof_Matrix(); }
          }
          else
          {
-            ParAlgebraicCoarseSpace *pspace
-               = dynamic_cast<ParAlgebraicCoarseSpace*>(&space);
+            ParAlgebraicCoarseSpace *pspace =
+               dynamic_cast<ParAlgebraicCoarseSpace*>(&space);
             if (pspace) { P_mat = pspace->GetProlongationHypreParMatrix(); }
          }
          if (P_mat) { smoother = new AssembledAMG(*op, P_mat); }
@@ -374,71 +377,71 @@ int AlgebraicInterpolation::Initialize(
    Ceed ceed, CeedBasis basisctof,
    CeedElemRestriction erestrictu_coarse, CeedElemRestriction erestrictu_fine)
 {
-   int ierr = 0;
-
+   int ierr;
    CeedSize height, width;
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_coarse, &width);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_fine, &height);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // interpolation qfunction
    const int bp3_ncompu = 1;
    CeedQFunction l_qf_restrict, l_qf_prolong;
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_NONE,
-                                      CEED_EVAL_INTERP, &l_qf_restrict); CeedChk(ierr);
+                                      CEED_EVAL_INTERP, &l_qf_restrict); PCeedChk(ierr);
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_INTERP,
-                                      CEED_EVAL_NONE, &l_qf_prolong); CeedChk(ierr);
+                                      CEED_EVAL_NONE, &l_qf_prolong); PCeedChk(ierr);
 
    qf_restrict = l_qf_restrict;
    qf_prolong = l_qf_prolong;
 
    CeedVector c_fine_multiplicity;
-   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); PCeedChk(ierr);
 
    // Create the restriction operator
    // Restriction - Fine to coarse
    ierr = CeedOperatorCreate(ceed, qf_restrict, CEED_QFUNCTION_NONE,
-                             CEED_QFUNCTION_NONE, &op_restrict); CeedChk(ierr);
+                             CEED_QFUNCTION_NONE, &op_restrict); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "input", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "output", erestrictu_coarse,
-                               basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    // Interpolation - Coarse to fine
    // Create the prolongation operator
    ierr =  CeedOperatorCreate(ceed, qf_prolong, CEED_QFUNCTION_NONE,
-                              CEED_QFUNCTION_NONE, &op_interp); CeedChk(ierr);
+                              CEED_QFUNCTION_NONE, &op_interp); PCeedChk(ierr);
    ierr =  CeedOperatorSetField(op_interp, "input", erestrictu_coarse,
-                                basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                                basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_interp, "output", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionGetMultiplicity(erestrictu_fine,
-                                             c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); CeedChk(ierr);
+                                             c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); PCeedChk(ierr);
 
    CeedScalar* fine_r_data;
    const CeedScalar* fine_data;
    ierr = CeedVectorGetArrayWrite(fine_multiplicity_r, CEED_MEM_HOST,
-                                  &fine_r_data); CeedChk(ierr);
+                                  &fine_r_data); PCeedChk(ierr);
    ierr = CeedVectorGetArrayRead(c_fine_multiplicity, CEED_MEM_HOST,
-                                 &fine_data); CeedChk(ierr);
+                                 &fine_data); PCeedChk(ierr);
    for (CeedSize i = 0; i < height; ++i)
    {
       fine_r_data[i] = 1.0 / fine_data[i];
    }
 
-   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data);
+   PCeedChk(ierr);
    ierr = CeedVectorRestoreArrayRead(c_fine_multiplicity, &fine_data);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&c_fine_multiplicity); CeedChk(ierr);
+   PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&c_fine_multiplicity); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &fine_work); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_work); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &v_); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, width, &u_); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &v_); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, width, &u_); PCeedChk(ierr);
 
    return 0;
 }
@@ -447,12 +450,12 @@ int AlgebraicInterpolation::Finalize()
 {
    int ierr;
 
-   ierr = CeedQFunctionDestroy(&qf_restrict); CeedChk(ierr);
-   ierr = CeedQFunctionDestroy(&qf_prolong); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_interp); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_restrict); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_multiplicity_r); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_work); CeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_restrict); PCeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_prolong); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_interp); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_restrict); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_multiplicity_r); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_work); PCeedChk(ierr);
 
    return 0;
 }
@@ -470,8 +473,8 @@ AlgebraicInterpolation::AlgebraicInterpolation(
                                             &ho_nldofs); PCeedChk(ierr);
    height = (int)ho_nldofs;
    width = (int)lo_nldofs;
-   MFEM_VERIFY(ho_nldofs == height, "height overflow");
-   MFEM_VERIFY(lo_nldofs == width, "width overflow");
+   MFEM_VERIFY(ho_nldofs == height, "Height overflow.");
+   MFEM_VERIFY(lo_nldofs == width, "Width overflow.");
    owns_basis_ = false;
    ierr = Initialize(ceed, basisctof, erestrictu_coarse, erestrictu_fine);
    PCeedChk(ierr);
@@ -490,7 +493,6 @@ AlgebraicInterpolation::~AlgebraicInterpolation()
 }
 
 /// a = a (pointwise*) b
-/// @todo: using MPI_FORALL in this Ceed-like function is ugly
 int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
 {
    int ierr;
@@ -498,8 +500,8 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    CeedVectorGetCeed(a, &ceed);
 
    CeedSize length, length2;
-   ierr = CeedVectorGetLength(a, &length); CeedChk(ierr);
-   ierr = CeedVectorGetLength(b, &length2); CeedChk(ierr);
+   ierr = CeedVectorGetLength(a, &length); PCeedChk(ierr);
+   ierr = CeedVectorGetLength(b, &length2); PCeedChk(ierr);
    if (length != length2)
    {
       return CeedError(ceed, 1, "Vector sizes don't match");
@@ -516,26 +518,28 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    }
    CeedScalar *a_data;
    const CeedScalar *b_data;
-   ierr = CeedVectorGetArray(a, mem, &a_data); CeedChk(ierr);
-   ierr = CeedVectorGetArrayRead(b, mem, &b_data); CeedChk(ierr);
-   MFEM_VERIFY(int(length) == length, "length overflow");
+   ierr = CeedVectorGetArray(a, mem, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorGetArrayRead(b, mem, &b_data); PCeedChk(ierr);
+   MFEM_VERIFY(int(length) == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
-   {a_data[i] *= b_data[i];});
+   {
+      a_data[i] *= b_data[i];
+   });
 
-   ierr = CeedVectorRestoreArray(a, &a_data); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(b, &b_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(a, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(b, &b_data); PCeedChk(ierr);
 
    return 0;
 }
 
 void AlgebraicInterpolation::Mult(const mfem::Vector& x, mfem::Vector& y) const
 {
-   int ierr = 0;
+   int ierr;
    const CeedScalar *in_ptr;
    CeedScalar *out_ptr;
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -563,12 +567,12 @@ void AlgebraicInterpolation::Mult(const mfem::Vector& x, mfem::Vector& y) const
 void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
                                            mfem::Vector& y) const
 {
-   int ierr = 0;
+   int ierr;
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
    const CeedScalar *in_ptr;
    CeedScalar *out_ptr;
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -592,9 +596,11 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedVectorGetArrayRead(fine_multiplicity_r, mem,
                                  &multiplicitydata); PCeedChk(ierr);
    ierr = CeedVectorGetArrayWrite(fine_work, mem, &workdata); PCeedChk(ierr);
-   MFEM_VERIFY((int)length == length, "length overflow");
+   MFEM_VERIFY((int)length == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
-   {workdata[i] = in_ptr[i] * multiplicitydata[i];});
+   {
+      workdata[i] = in_ptr[i] * multiplicitydata[i];
+   });
    ierr = CeedVectorRestoreArrayRead(fine_multiplicity_r,
                                      &multiplicitydata);
    ierr = CeedVectorRestoreArray(fine_work, &workdata); PCeedChk(ierr);
@@ -637,8 +643,7 @@ AlgebraicSpaceHierarchy::AlgebraicSpaceHierarchy(FiniteElementSpace &fes)
 
    current_order = order;
 
-   Ceed ceed = internal::ceed;
-   InitRestriction(fes, ceed, &fine_er);
+   InitRestriction(fes, internal::ceed, &fine_er);
    CeedElemRestriction er = fine_er;
 
    int dim = fes.GetMesh()->Dimension();
@@ -673,7 +678,7 @@ AlgebraicSpaceHierarchy::AlgebraicSpaceHierarchy(FiniteElementSpace &fes)
       current_order = current_order/2;
       fespaces[ilevel] = space;
       ceed_interpolations[ilevel] = new AlgebraicInterpolation(
-         ceed,
+         internal::ceed,
          space->GetCeedCoarseToFine(),
          space->GetCeedElemRestriction(),
          er
@@ -701,11 +706,10 @@ AlgebraicCoarseSpace::AlgebraicCoarseSpace(
    CeedElemRestriction fine_er,
    int order,
    int dim,
-   int order_reduction_
-) : order_reduction(order_reduction_)
+   int order_reduction)
+   : order_reduction(order_reduction)
 {
    int ierr;
-   order_reduction = order_reduction_;
 
    ierr = CeedATPMGElemRestriction(order, order_reduction, fine_er,
                                    &ceed_elem_restriction, dof_map);
@@ -717,7 +721,7 @@ AlgebraicCoarseSpace::AlgebraicCoarseSpace(
    ierr = CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &ndofs_);
    PCeedChk(ierr);
    ndofs = ndofs_;
-   MFEM_VERIFY(ndofs == ndofs_, "ndofs overflow");
+   MFEM_VERIFY(ndofs == ndofs_, "Overflow in ndofs.");
 
    mesh = fine_fes.GetMesh();
 }
@@ -743,9 +747,8 @@ ParAlgebraicCoarseSpace::ParAlgebraicCoarseSpace(
 {
    CeedSize lsize;
    CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &lsize);
+   MFEM_VERIFY((int)lsize == lsize, "Size overflow.");
    const Table &group_ldof_fine = gc_fine->GroupLDofTable();
-
-   MFEM_VERIFY((int)lsize == lsize, "size overflow");
    ldof_group.SetSize(lsize);
    ldof_group = 0;
 
@@ -825,7 +828,8 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
    if (P_mat) { return P_mat; }
 
    ParMesh *pmesh = dynamic_cast<ParMesh*>(mesh);
-   MFEM_VERIFY(pmesh != NULL, "");
+   MFEM_VERIFY(pmesh != NULL,
+               "ParAlgebraicCoarseSpace requires a ParMesh mesh object.");
    Array<HYPRE_BigInt> dof_offsets, tdof_offsets, tdof_nb_offsets;
    Array<HYPRE_BigInt> *offsets[2] = {&dof_offsets, &tdof_offsets};
    int lsize = P->Height();
@@ -950,12 +954,12 @@ AlgebraicSolver::AlgebraicSolver(BilinearForm &form,
                                  const Array<int>& ess_tdofs)
 {
    MFEM_VERIFY(DeviceCanUseCeed(),
-               "AlgebraicSolver requires a Ceed device");
+               "AlgebraicSolver requires a Ceed device.");
    MFEM_VERIFY(form.GetAssemblyLevel() == AssemblyLevel::PARTIAL ||
                form.GetAssemblyLevel() == AssemblyLevel::NONE,
                "AlgebraicSolver requires partial assembly or fully matrix-free.");
    MFEM_VERIFY(UsesTensorBasis(*form.FESpace()),
-               "AlgebraicSolver requires tensor product basis functions.");
+               "AlgebraicSolver requires tensor-product basis functions.");
 #ifdef MFEM_USE_CEED
    fespaces = new AlgebraicSpaceHierarchy(*form.FESpace());
    multigrid = new AlgebraicMultigrid(*fespaces, form, ess_tdofs);
@@ -986,6 +990,121 @@ void AlgebraicSolver::SetOperator(const mfem::Operator& op)
 #endif
 }
 
+#ifdef MFEM_USE_CEED
+namespace
+{
+
+inline void OperatorFullAssemble(BilinearFormIntegrator &integ, bool set,
+                                 Array<SparseMatrix *> &mat_i)
+{
+   if (!integ.SupportsCeed()) { return; }
+#ifndef MFEM_USE_OPENMP
+   mat_i.Append(CeedOperatorFullAssemble(integ.GetCeedOp(), set));
+#else
+   #pragma omp parallel
+   {
+      SparseMatrix *mat_integ;
+      const int tid = omp_get_thread_num();
+      if (integ.GetCeedOp()[tid])
+      {
+         mat_integ = CeedOperatorFullAssemble(integ.GetCeedOp()[tid], set);
+         #pragma omp critical
+         mat_i.Append(mat_integ);
+      }
+   }
+#endif
+}
+
+} // namespace
+
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set)
+{
+   Array<SparseMatrix *> mat_i;
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+
+   // This method frees all the no longer used memory from mat_i
+   return Add(mat_i);
+}
+
+SparseMatrix *CeedOperatorFullAssemble(MixedBilinearForm &form, bool set)
+{
+   Array<SparseMatrix *> mat_i;
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   MFEM_VERIFY(form.GetTFBFI()->Size() == 0, "AddTraceFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+   MFEM_VERIFY(form.GetBTFBFI()->Size() == 0, "AddBdrTraceFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+
+   // This method frees all the no longer used memory from mat_i
+   return Add(mat_i);
+}
+
+SparseMatrix *CeedOperatorFullAssemble(CeedOperator op, bool set)
+{
+   int ierr;
+   Ceed ceed;
+   ierr = CeedOperatorGetCeed(op, &ceed); PCeedChk(ierr);
+
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(op, &l_in, &l_out); PCeedChk(ierr);
+   MFEM_VERIFY((int)l_in == l_in && (int)l_out == l_out, "Size overflow.");
+
+   CeedSize nnz;
+   CeedInt *rows, *cols;
+   ierr = CeedOperatorLinearAssembleSymbolic(op, &nnz, &rows, &cols);
+   PCeedChk(ierr);
+
+   CeedVector vals;
+   ierr = CeedVectorCreate(ceed, nnz, &vals); PCeedChk(ierr);
+   ierr = CeedOperatorLinearAssemble(op, vals); PCeedChk(ierr);
+
+   mfem::SparseMatrix *mat = new SparseMatrix(l_out, l_in);
+
+   const CeedScalar *val_array;
+   ierr = CeedVectorGetArrayRead(vals, CEED_MEM_HOST, &val_array); PCeedChk(ierr);
+   for (CeedSize k = 0; k < nnz; ++k)
+   {
+      if (set)
+      {
+         mat->Set(rows[k], cols[k], val_array[k]);
+      }
+      else
+      {
+         mat->Add(rows[k], cols[k], val_array[k]);
+      }
+   }
+   ierr = CeedVectorRestoreArrayRead(vals, &val_array); PCeedChk(ierr);
+
+   ierr = CeedVectorDestroy(&vals); PCeedChk(ierr);
+   ierr = CeedInternalFree(&rows); PCeedChk(ierr);
+   ierr = CeedInternalFree(&cols); PCeedChk(ierr);
+
+   // Enforce structurally symmetric for later elimination
+   const int skip_zeros = 0;
+   mat->Finalize(skip_zeros);
+
+   return mat;
+}
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/algebraic.hpp b/fem/ceed/solvers/algebraic.hpp
index 49cdbca98..94e697c09 100644
--- a/fem/ceed/solvers/algebraic.hpp
+++ b/fem/ceed/solvers/algebraic.hpp
@@ -12,9 +12,9 @@
 #ifndef MFEM_CEED_ALGEBRAIC_HPP
 #define MFEM_CEED_ALGEBRAIC_HPP
 
+#include "../../../linalg/sparsemat.hpp"
 #include "../../fespacehierarchy.hpp"
 #include "../../multigrid.hpp"
-#include "../interface/operator.hpp"
 #include "../interface/ceed.hpp"
 
 namespace mfem
@@ -32,13 +32,14 @@ class AlgebraicCoarseSpace : public FiniteElementSpace
 {
 public:
    AlgebraicCoarseSpace(FiniteElementSpace &fine_fes, CeedElemRestriction fine_er,
-                        int order, int dim, int order_reduction_);
+                        int order, int dim, int order_reduction);
+   ~AlgebraicCoarseSpace();
+
    int GetOrderReduction() const { return order_reduction; }
    CeedElemRestriction GetCeedElemRestriction() const { return ceed_elem_restriction; }
    CeedBasis GetCeedCoarseToFine() const { return coarse_to_fine; }
    virtual const mfem::Operator *GetProlongationMatrix() const override { return NULL; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return NULL; }
-   ~AlgebraicCoarseSpace();
 
 protected:
    int *dof_map;
@@ -64,11 +65,12 @@ public:
       int order_reduction_,
       GroupCommunicator *gc_fine
    );
+   ~ParAlgebraicCoarseSpace();
+
    virtual const mfem::Operator *GetProlongationMatrix() const override { return P; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return R_mat; }
    GroupCommunicator *GetGroupCommunicator() const { return gc; }
    HypreParMatrix *GetProlongationHypreParMatrix();
-   ~ParAlgebraicCoarseSpace();
 
 private:
    SparseMatrix *R_mat;
@@ -92,14 +94,11 @@ public:
       Ceed ceed, CeedBasis basisctof,
       CeedElemRestriction erestrictu_coarse,
       CeedElemRestriction erestrictu_fine);
-
    ~AlgebraicInterpolation();
 
    virtual void Mult(const mfem::Vector& x, mfem::Vector& y) const;
-
    virtual void MultTranspose(const mfem::Vector& x, mfem::Vector& y) const;
 
-   using mfem::Operator::SetupRAP;
 private:
    int Initialize(Ceed ceed, CeedBasis basisctof,
                   CeedElemRestriction erestrictu_coarse,
@@ -127,11 +126,6 @@ public:
        The given space is a real (geometric) space, but the coarse spaces are
        constructed semi-algebraically with no mesh information. */
    AlgebraicSpaceHierarchy(FiniteElementSpace &fespace);
-   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
-   {
-      MFEM_ASSERT(level < GetNumLevels() - 1, "");
-      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
-   }
    ~AlgebraicSpaceHierarchy()
    {
       for (int i=0; i<R_tr.Size(); ++i)
@@ -144,6 +138,12 @@ public:
       }
    }
 
+   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
+   {
+      MFEM_ASSERT(level < GetNumLevels() - 1, "");
+      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
+   }
+
 private:
    CeedElemRestriction fine_er;
    Array<AlgebraicInterpolation*> ceed_interpolations;
@@ -163,14 +163,13 @@ public:
        @param[in] form       partially assembled BilinearForm on finest level
        @param[in] ess_tdofs  List of essential true dofs on finest level
     */
-   AlgebraicMultigrid(
-      AlgebraicSpaceHierarchy &hierarchy,
-      BilinearForm &form,
-      const Array<int> &ess_tdofs
-   );
-   virtual void SetOperator(const mfem::Operator &op) override { }
+   AlgebraicMultigrid(AlgebraicSpaceHierarchy &hierarchy,
+                      BilinearForm &form,
+                      const Array<int> &ess_tdofs);
    ~AlgebraicMultigrid();
 
+   virtual void SetOperator(const mfem::Operator &op) override {}
+
 private:
    OperatorHandle fine_operator;
    Array<CeedOperator> ceed_operators;
@@ -186,12 +185,12 @@ class AlgebraicSolver : public Solver
 {
 private:
 #ifdef MFEM_USE_CEED
-   AlgebraicSpaceHierarchy * fespaces;
-   AlgebraicMultigrid * multigrid;
+   AlgebraicSpaceHierarchy *fespaces;
+   AlgebraicMultigrid *multigrid;
 #endif
 
 public:
-   /** @brief Constructs algebraic multigrid hierarchy and solver.
+   /** @brief Constructs algebraic multigrid hierarchy and solver
 
        This only works if the Ceed device backend is enabled.
 
@@ -200,10 +199,35 @@ public:
     */
    AlgebraicSolver(BilinearForm &form, const Array<int>& ess_tdofs);
    ~AlgebraicSolver();
+
    void Mult(const Vector& x, Vector& y) const;
    void SetOperator(const mfem::Operator& op);
 };
 
+#ifdef MFEM_USE_CEED
+/** @brief Assemble the CeedOperators from a BilinearForm as an
+    mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set = false);
+
+/** @brief Assemble the CeedOperators from a MixedBilinearForm as an
+    mfem::SparseMatrix */
+SparseMatrix *CeedOperatorFullAssemble(MixedBilinearForm &form,
+                                       bool set = false);
+
+/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+SparseMatrix *CeedOperatorFullAssemble(CeedOperator op, bool set = false);
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.cpp b/fem/ceed/solvers/full-assembly.cpp
deleted file mode 100644
index ccf9b145a..000000000
--- a/fem/ceed/solvers/full-assembly.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "full-assembly.hpp"
-
-#include "../../../linalg/sparsemat.hpp"
-#include "../interface/util.hpp"
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-int CeedHackReallocArray(size_t n, size_t unit, void *p)
-{
-   *(void **)p = realloc(*(void **)p, n*unit);
-   if (n && unit && !*(void **)p)
-      return CeedError(NULL, 1, "realloc failed to allocate %zd members of size "
-                       "%zd\n", n, unit);
-   return 0;
-}
-
-#define CeedHackRealloc(n, p) CeedHackReallocArray((n), sizeof(**(p)), p)
-
-int CeedHackFree(void *p)
-{
-   free(*(void **)p);
-   *(void **)p = NULL;
-   return 0;
-}
-
-int CeedSingleOperatorFullAssemble(CeedOperator op, SparseMatrix *out)
-{
-   int ierr;
-   Ceed ceed;
-   ierr = CeedOperatorGetCeed(op, &ceed); CeedChk(ierr);
-
-   // Assemble QFunction
-   CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(op, &qf); CeedChk(ierr);
-   CeedInt numinputfields, numoutputfields;
-   CeedChk(ierr);
-   CeedVector assembledqf;
-   CeedElemRestriction rstr_q;
-   ierr = CeedOperatorLinearAssembleQFunction(
-             op, &assembledqf, &rstr_q, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-
-   CeedSize qflength;
-   ierr = CeedVectorGetLength(assembledqf, &qflength); CeedChk(ierr);
-
-   CeedOperatorField *input_fields;
-   CeedOperatorField *output_fields;
-   ierr = CeedOperatorGetFields(op, &numinputfields, &input_fields,
-                                &numoutputfields, &output_fields);
-   CeedChk(ierr);
-
-   // Determine active input basis
-   CeedQFunctionField *qffields;
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, &qffields,
-                                 &numoutputfields, NULL);
-   CeedChk(ierr);
-   CeedInt numemodein = 0, ncomp, dim = 1;
-   CeedEvalMode *emodein = NULL;
-   CeedBasis basisin = NULL;
-   CeedElemRestriction rstrin = NULL;
-   for (CeedInt i=0; i<numinputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(input_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(input_fields[i], &basisin);
-         CeedChk(ierr);
-         ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-         ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(input_fields[i], &rstrin);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodein + 1, &emodein); CeedChk(ierr);
-               emodein[numemodein] = emode;
-               numemodein += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodein + dim, &emodein); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodein[numemodein+d] = emode;
-               }
-               numemodein += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   // Determine active output basis
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, NULL, &numoutputfields,
-                                 &qffields); CeedChk(ierr);
-   CeedInt numemodeout = 0;
-   CeedEvalMode *emodeout = NULL;
-   CeedBasis basisout = NULL;
-   CeedElemRestriction rstrout = NULL;
-   for (CeedInt i=0; i<numoutputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(output_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(output_fields[i], &basisout);
-         CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(output_fields[i], &rstrout);
-         CeedChk(ierr);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodeout + 1, &emodeout); CeedChk(ierr);
-               emodeout[numemodeout] = emode;
-               numemodeout += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodeout + dim, &emodeout); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodeout[numemodeout+d] = emode;
-               }
-               numemodeout += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   CeedInt nelem, elemsize, nqpts;
-   CeedSize nnodes;
-   ierr = CeedElemRestrictionGetNumElements(rstrin, &nelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(rstrin, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(rstrin, &nnodes); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints(basisin, &nqpts); CeedChk(ierr);
-
-   // Determine elem_dof relation
-   CeedVector index_vec;
-   ierr = CeedVectorCreate(ceed, nnodes, &index_vec); CeedChk(ierr);
-   CeedScalar *array;
-   ierr = CeedVectorGetArrayWrite(index_vec, CEED_MEM_HOST, &array);
-   CeedChk(ierr);
-   for (CeedSize i = 0; i < nnodes; ++i)
-   {
-      array[i] = i;
-   }
-   ierr = CeedVectorRestoreArray(index_vec, &array); CeedChk(ierr);
-   CeedVector elem_dof;
-   ierr = CeedVectorCreate(ceed, nelem * elemsize, &elem_dof); CeedChk(ierr);
-   ierr = CeedVectorSetValue(elem_dof, 0.0); CeedChk(ierr);
-   CeedElemRestrictionApply(rstrin, CEED_NOTRANSPOSE, index_vec,
-                            elem_dof, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   const CeedScalar * elem_dof_a;
-   ierr = CeedVectorGetArrayRead(elem_dof, CEED_MEM_HOST, &elem_dof_a);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&index_vec); CeedChk(ierr);
-
-   // loop over elements and put in SparseMatrix
-   // SparseMatrix * out = new SparseMatrix(nnodes, nnodes);
-   MFEM_ASSERT(out->Height() == nnodes, "Sizes don't match!");
-   MFEM_ASSERT(out->Width() == nnodes, "Sizes don't match!");
-   const CeedScalar *interpin, *gradin;
-   ierr = CeedBasisGetInterp(basisin, &interpin); CeedChk(ierr);
-   ierr = CeedBasisGetGrad(basisin, &gradin); CeedChk(ierr);
-
-   const CeedScalar * assembledqfarray;
-   ierr = CeedVectorGetArrayRead(assembledqf, CEED_MEM_HOST, &assembledqfarray);
-   CeedChk(ierr);
-
-   CeedInt layout[3];
-   ierr = CeedElemRestrictionGetELayout(rstr_q, &layout); CeedChk(ierr);
-   ierr = CeedElemRestrictionDestroy(&rstr_q); CeedChk(ierr);
-
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   MFEM_ASSERT(numemodein == numemodeout,
-               "Ceed full assembly not implemented for this case.");
-   for (int e = 0; e < nelem; ++e)
-   {
-      // get Array<int> for use in SparseMatrix::AddSubMatrix()
-      Array<int> rows(elemsize);
-      for (int i = 0; i < elemsize; ++i)
-      {
-         rows[i] = elem_dof_a[e * elemsize + i];
-      }
-
-      // form element matrix itself
-      DenseMatrix Bmat(nqpts * numemodein, elemsize);
-      Bmat = 0.0;
-      // Store block-diagonal D matrix as collection of small dense blocks
-      DenseTensor Dmat(numemodeout, numemodein, nqpts);
-      Dmat = 0.0;
-      DenseMatrix elem_mat(elemsize, elemsize);
-      elem_mat = 0.0;
-      for (int q = 0; q < nqpts; ++q)
-      {
-         for (int n = 0; n < elemsize; ++n)
-         {
-            CeedInt din = -1;
-            for (int ein = 0; ein < numemodein; ++ein)
-            {
-               if (emodein[ein] == CEED_EVAL_INTERP)
-               {
-                  Bmat(numemodein * q + ein, n) += interpin[q * elemsize + n];
-               }
-               else if (emodein[ein] == CEED_EVAL_GRAD)
-               {
-                  din += 1;
-                  Bmat(numemodein * q + ein, n) += gradin[(din*nqpts+q) * elemsize + n];
-               }
-               else
-               {
-                  MFEM_ASSERT(false, "Not implemented!");
-               }
-            }
-         }
-         for (int ei = 0; ei < numemodein; ++ei)
-         {
-            for (int ej = 0; ej < numemodein; ++ej)
-            {
-               const int comp = ei * numemodein + ej;
-               const int index = q*layout[0] + comp*layout[1] + e*layout[2];
-               Dmat(ei, ej, q) += assembledqfarray[index];
-            }
-         }
-      }
-      DenseMatrix BTD(elemsize, nqpts*numemodein);
-      // Compute B^T*D
-      BTD = 0.0;
-      for (int j=0; j<elemsize; ++j)
-      {
-         for (int q=0; q<nqpts; ++q)
-         {
-            int qq = numemodein*q;
-            for (int ei = 0; ei < numemodein; ++ei)
-            {
-               for (int ej = 0; ej < numemodein; ++ej)
-               {
-                  BTD(j,qq+ei) += Bmat(qq+ej,j)*Dmat(ej,ei,q);
-               }
-            }
-         }
-      }
-
-      Mult(BTD, Bmat, elem_mat);
-
-      // put element matrix in sparsemat
-      out->AddSubMatrix(rows, rows, elem_mat, skip_zeros);
-   }
-
-   ierr = CeedVectorRestoreArrayRead(elem_dof, &elem_dof_a); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&elem_dof); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(assembledqf, &assembledqfarray);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&assembledqf); CeedChk(ierr);
-   ierr = CeedHackFree(&emodein); CeedChk(ierr);
-   ierr = CeedHackFree(&emodeout); CeedChk(ierr);
-
-   return 0;
-}
-
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat)
-{
-   int ierr;
-
-   CeedSize in_len, out_len;
-   ierr = CeedOperatorGetActiveVectorLengths(op, &in_len, &out_len);
-   CeedChk(ierr);
-   const int nnodes = in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == nnodes, "size overflow");
-
-   SparseMatrix *out = new SparseMatrix(nnodes, nnodes);
-
-   bool isComposite;
-   ierr = CeedOperatorIsComposite(op, &isComposite); CeedChk(ierr);
-   if (isComposite)
-   {
-      CeedInt numsub;
-      CeedOperator *subops;
-#if CEED_VERSION_GE(0, 10, 2)
-      CeedCompositeOperatorGetNumSub(op, &numsub);
-      ierr = CeedCompositeOperatorGetSubList(op, &subops); CeedChk(ierr);
-#else
-      CeedOperatorGetNumSub(op, &numsub);
-      ierr = CeedOperatorGetSubList(op, &subops); CeedChk(ierr);
-#endif
-      for (int i = 0; i < numsub; ++i)
-      {
-         ierr = CeedSingleOperatorFullAssemble(subops[i], out); CeedChk(ierr);
-      }
-   }
-   else
-   {
-      ierr = CeedSingleOperatorFullAssemble(op, out); CeedChk(ierr);
-   }
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   out->Finalize(skip_zeros);
-   *mat = out;
-
-   return 0;
-}
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif
diff --git a/fem/ceed/solvers/solvers-atpmg.cpp b/fem/ceed/solvers/solvers-atpmg.cpp
index 8f4be00b2..603c92d44 100644
--- a/fem/ceed/solvers/solvers-atpmg.cpp
+++ b/fem/ceed/solvers/solvers-atpmg.cpp
@@ -11,15 +11,13 @@
 
 #include "solvers-atpmg.hpp"
 
-#include "../interface/ceed.hpp"
 #include "../interface/util.hpp"
-
 #ifdef MFEM_USE_CEED
 #include <ceed/backend.h>
-
+#endif
 #include <math.h>
-// todo: should probably use Ceed memory wrappers instead of calloc/free?
-#include <stdlib.h>
+
+#ifdef MFEM_USE_CEED
 
 namespace mfem
 {
@@ -86,17 +84,17 @@ int CeedATPMGElemRestriction(int order,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); PCeedChk(ierr);
 
    CeedInt numelem, numcomp, elemsize;
    CeedSize numnodes;
-   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); PCeedChk(ierr);
    if (numcomp != 1)
    {
-      // todo: multi-component will require more thought
+      // TODO: multi-component will require more thought
       return CeedError(ceed, 1, "Algebraic element restriction not "
                        "implemented for multiple components.");
    }
@@ -107,31 +105,31 @@ int CeedATPMGElemRestriction(int order,
 
    CeedVector in_lvec, in_evec;
    ierr = CeedElemRestrictionCreateVector(er_in, &in_lvec, &in_evec);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create the elem_dof array from the given high-order ElemRestriction
    // by using it to map the L-vector indices to an E-vector
    CeedScalar * lvec_data;
    ierr = CeedVectorGetArrayWrite(in_lvec, CEED_MEM_HOST, &lvec_data);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    for (CeedSize i = 0; i < numnodes; ++i)
    {
       lvec_data[i] = (CeedScalar) i;
    }
-   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); PCeedChk(ierr);
    CeedInt in_layout[3];
-   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); PCeedChk(ierr);
    if (in_layout[0] == 0 && in_layout[1] == 0 && in_layout[2] == 0)
    {
       return CeedError(ceed, 1, "Cannot interpret e-vector ordering of given"
                        "CeedElemRestriction!");
    }
    ierr = CeedElemRestrictionApply(er_in, CEED_NOTRANSPOSE, in_lvec, in_evec,
-                                   CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_lvec); CeedChk(ierr);
+                                   CEED_REQUEST_IMMEDIATE); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_lvec); PCeedChk(ierr);
    const CeedScalar * in_elem_dof;
    ierr = CeedVectorGetArrayRead(in_evec, CEED_MEM_HOST, &in_elem_dof);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create a map (dof_map) that maps high-order ldof indices to
    // low-order ldof indices, with -1 indicating no correspondence
@@ -469,13 +467,13 @@ int CeedATPMGElemRestriction(int order,
                        "CeedATPMGElemRestriction does not yet support this dimension.");
    }
 
-   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_evec); CeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_evec); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionCreate(ceed, numelem, coarse_elemsize, numcomp,
                                     0, running_out_ldof_count,
                                     CEED_MEM_HOST, CEED_COPY_VALUES, out_elem_dof,
-                                    er_out); CeedChk(ierr);
+                                    er_out); PCeedChk(ierr);
 
    delete [] out_elem_dof;
 
@@ -491,7 +489,7 @@ int CeedBasisATPMGCoarseToFine(Ceed ceed, int P1d, int dim, int order_reduction,
    // calling the following Ceed function)
    int ierr;
    ierr = CeedBasisCreateTensorH1Lagrange(ceed, dim, 1, P1d - order_reduction, P1d,
-                                          CEED_GAUSS_LOBATTO, basisc2f); CeedChk(ierr);
+                                          CEED_GAUSS_LOBATTO, basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -501,13 +499,13 @@ int CeedBasisATPMGCoarseToFine(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, P1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(ceed, P1d, dim, order_reduction,
-                                     basisc2f); CeedChk(ierr);
+                                     basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -518,38 +516,38 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, ncomp, P1d, Q1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumComponents(basisin, &ncomp); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
+   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); PCeedChk(ierr);
 
    CeedInt coarse_P1d = P1d - order_reduction;
 
    const CeedScalar *interp1d;
-   ierr = CeedBasisGetInterp1D(basisin, &interp1d); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisin, &interp1d); PCeedChk(ierr);
    const CeedScalar * grad1d;
-   ierr = CeedBasisGetGrad1D(basisin, &grad1d); CeedChk(ierr);
+   ierr = CeedBasisGetGrad1D(basisin, &grad1d); PCeedChk(ierr);
 
    CeedScalar * coarse_interp1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * coarse_grad1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * fine_nodal_points = new CeedScalar[P1d];
 
    // these things are in [-1, 1], not [0, 1], which matters
-   // (todo: how can we determine this or something related, algebraically?)
+   // (TODO: how can we determine this or something related, algebraically?)
    /* one way you might be able to tell is to just run this algorithm
       with coarse_P1d = 2 (i.e., linear) and look for symmetry in the coarse
       basis matrix? */
-   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); CeedChk(ierr);
+   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); PCeedChk(ierr);
    for (int i = 0; i < P1d; ++i)
    {
       fine_nodal_points[i] = 0.5 * fine_nodal_points[i] + 0.5; // cheating
    }
 
    const CeedScalar *interp_ctof;
-   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); PCeedChk(ierr);
 
    for (int i = 0; i < Q1d; ++i)
    {
@@ -568,12 +566,12 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
    }
 
    const CeedScalar * qref1d;
-   ierr = CeedBasisGetQRef(basisin, &qref1d); CeedChk(ierr);
+   ierr = CeedBasisGetQRef(basisin, &qref1d); PCeedChk(ierr);
    const CeedScalar * qweight1d;
-   ierr = CeedBasisGetQWeights(basisin, &qweight1d); CeedChk(ierr);
+   ierr = CeedBasisGetQWeights(basisin, &qweight1d); PCeedChk(ierr);
    ierr = CeedBasisCreateTensorH1(ceed, dim, ncomp,
                                   coarse_P1d, Q1d, coarse_interp1d, coarse_grad1d,
-                                  qref1d, qweight1d, basisout); CeedChk(ierr);
+                                  qref1d, qweight1d, basisout); PCeedChk(ierr);
 
    delete [] fine_nodal_points;
    delete [] coarse_interp1d;
@@ -593,19 +591,19 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedQFunctionField *inputqfields, *outputqfields;
    ierr = CeedQFunctionGetFields(qf, &numinputfields, &inputqfields,
                                  &numoutputfields, &outputqfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    CeedOperatorField *inputfields, *outputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, &outputfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedElemRestriction * er_input = new CeedElemRestriction[numinputfields];
    CeedElemRestriction * er_output = new CeedElemRestriction[numoutputfields];
@@ -619,10 +617,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numinputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(inputfields[i],
-                                                 &er_input[i]); CeedChk(ierr);
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]); CeedChk(ierr);
+                                                 &er_input[i]); PCeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(inputfields[i], &basis_input[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          if (active_input_basis < 0)
@@ -638,11 +637,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numoutputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(outputfields[i],
-                                                 &er_output[i]); CeedChk(ierr);
+                                                 &er_output[i]); PCeedChk(ierr);
       ierr = CeedOperatorFieldGetVector(outputfields[i], &of_vector[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(outputfields[i], &basis_output[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          // should already be coarsened
@@ -659,36 +658,36 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    CeedOperator coper;
    ierr = CeedOperatorCreate(ceed, qf, CEED_QFUNCTION_NONE, CEED_QFUNCTION_NONE,
-                             &coper); CeedChk(ierr);
+                             &coper); PCeedChk(ierr);
 
    for (int i = 0; i < numinputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_input[i], basis_input[i],
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
    }
    for (int i = 0; i < numoutputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_output[i], basis_output[i],
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
    }
    delete [] er_input;
@@ -711,21 +710,21 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    int ierr;
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedOperatorField *inputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, NULL);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedBasis basis;
-   ierr = CeedOperatorGetActiveBasis(oper, &basis); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveBasis(oper, &basis); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(basis, basis_ctof_out, order_reduction);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarsen(basis, *basis_ctof_out, coarse_basis_out,
-                                order_reduction); CeedChk(ierr);
+                                order_reduction); PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, coarse_er, *coarse_basis_out,
-                            *basis_ctof_out, out); CeedChk(ierr);
+                            *basis_ctof_out, out); PCeedChk(ierr);
    return 0;
 }
 
@@ -734,11 +733,11 @@ int CeedOperatorGetOrder(CeedOperator oper, CeedInt * order)
    int ierr;
 
    CeedOperatorField active_field;
-   ierr = CeedOperatorGetActiveField(oper, &active_field); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveField(oper, &active_field); PCeedChk(ierr);
    CeedBasis basis;
-   ierr = CeedOperatorFieldGetBasis(active_field, &basis); CeedChk(ierr);
+   ierr = CeedOperatorFieldGetBasis(active_field, &basis); PCeedChk(ierr);
    int P1d;
-   ierr = CeedBasisGetNumNodes1D(basis, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basis, &P1d); PCeedChk(ierr);
    *order = P1d - 1;
 
    return 0;
@@ -753,13 +752,13 @@ int CeedATPMGBundle(CeedOperator oper, int order_reduction,
 {
    int ierr;
    CeedInt order;
-   ierr = CeedOperatorGetOrder(oper, &order); CeedChk(ierr);
+   ierr = CeedOperatorGetOrder(oper, &order); PCeedChk(ierr);
    CeedElemRestriction ho_er;
-   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); PCeedChk(ierr);
    ierr = CeedATPMGElemRestriction(order, order_reduction, ho_er, er_out, dof_map);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, *er_out, coarse_basis_out,
-                            basis_ctof_out, coarse_oper); CeedChk(ierr);
+                            basis_ctof_out, coarse_oper); PCeedChk(ierr);
    return 0;
 }
 
diff --git a/fem/ceed/solvers/solvers-atpmg.hpp b/fem/ceed/solvers/solvers-atpmg.hpp
index 8d85b1840..62a1640fe 100644
--- a/fem/ceed/solvers/solvers-atpmg.hpp
+++ b/fem/ceed/solvers/solvers-atpmg.hpp
@@ -25,7 +25,7 @@ namespace ceed
 /** @brief Take given (high-order) CeedElemRestriction and make a new
     CeedElemRestriction, which corresponds to a lower-order problem.
 
-    Assumes a Gauss-Lobatto basis and tensor product elements, and assumes that
+    Assumes a Gauss-Lobatto basis and tensor-product elements, and assumes that
     the nodes in er_in are ordered in a tensor-product way.
 
     This is a setup routine that operates on the host.
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 062594f76..61c963e13 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -1296,11 +1296,9 @@ public:
 /// @brief Return true if the mesh contains only one topology and the elements are tensor elements.
 inline bool UsesTensorBasis(const FiniteElementSpace& fes)
 {
-   Mesh & mesh = *fes.GetMesh();
-   const bool mixed = mesh.GetNumGeometries(mesh.Dimension()) > 1;
-   // Potential issue: empty local mesh --> no element 0.
-   return !mixed &&
-          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0))!=nullptr;
+   Mesh &mesh = *fes.GetMesh();
+   return mesh.GetNE() > 0 && mesh.GetNumGeometries(mesh.Dimension()) == 1 &&
+          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0)) != nullptr;
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_convection_mf.cpp b/fem/integ/bilininteg_convection_mf.cpp
index 22ed53c33..484c25b90 100644
--- a/fem/integ/bilininteg_convection_mf.cpp
+++ b/fem/integ/bilininteg_convection_mf.cpp
@@ -18,36 +18,47 @@ namespace mfem
 
 void ConvectionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::MFConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *fes.GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: ConvectionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void ConvectionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -60,7 +71,7 @@ void ConvectionIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 66d2c9466..c73e7a5c1 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -116,26 +116,19 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = dims;
    nq = ir->GetNPoints();
@@ -166,11 +159,30 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void ConvectionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -1527,7 +1539,7 @@ void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_curlcurl_mf.cpp b/fem/integ/bilininteg_curlcurl_mf.cpp
new file mode 100644
index 000000000..cde2098bf
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurl_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void CurlCurlIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void CurlCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
index ef61b92d3..aaeee22ea 100644
--- a/fem/integ/bilininteg_curlcurl_pa.cpp
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -10,6 +10,7 @@
 // CONTRIBUTING.md for details.
 
 #include "../qfunction.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 
 namespace mfem
@@ -17,10 +18,19 @@ namespace mfem
 
 void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
@@ -28,18 +38,15 @@ void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
 
    QuadratureSpace qs(*mesh, *ir);
@@ -72,131 +79,153 @@ void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
+void CurlCurlIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x34:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x45:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x56:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            default:
-               return internal::SmemPACurlCurlAssembleDiagonal3D(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x34:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x45:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x56:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               default:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+            }
          }
+         else
+         {
+            internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
+                                                   mapsO->B, mapsC->B,
+                                                   mapsO->G, mapsC->G,
+                                                   pa_data, diag);
+         }
+      }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                                mapsO->B, mapsC->G, pa_data, diag);
       }
       else
       {
-         internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                                mapsO->B, mapsC->B,
-                                                mapsO->G, mapsC->G,
-                                                pa_data, diag);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                             mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlApply3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPACurlCurlApply3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPACurlCurlApply3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPACurlCurlApply3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               default:
+                  return internal::SmemPACurlCurlApply3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+            }
+         }
+         else
          {
-            case 0x23:
-               return internal::SmemPACurlCurlApply3D<2,3>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPACurlCurlApply3D<3,4>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPACurlCurlApply3D<4,5>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPACurlCurlApply3D<5,6>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            default:
-               return internal::SmemPACurlCurlApply3D(
-                         dofs1D, quad1D, symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
+                                        mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
+                                        pa_data, x, y);
          }
       }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
+                                     mapsC->G, mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
-                                     mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
-                                     pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
-                                  mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_curlcurlmass_pa.cpp b/fem/integ/bilininteg_curlcurlmass_pa.cpp
new file mode 100644
index 000000000..077b33237
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurlmass_pa.cpp
@@ -0,0 +1,119 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/curlcurlmass/curlcurlmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void CurlCurlMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, Qm); }
+      }
+      else if (VQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, Qm); }
+      }
+      else
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, Qm); }
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void CurlCurlMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, Qm, true); }
+      }
+      else if (VQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, Qm, true); }
+      }
+      else
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, Qm, true); }
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void CurlCurlMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index db91bfde3..34a8fba40 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -18,39 +18,51 @@ namespace mfem
 
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: DiffusionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void DiffusionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -63,7 +75,7 @@ void DiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index be306f17f..fedf0cb46 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -22,30 +22,21 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -74,11 +65,32 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
                               ir->GetWeights(), geom->J, coeff, pa_data);
 }
 
+void DiffusionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -91,7 +103,7 @@ void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_diffusionmass_pa.cpp b/fem/integ/bilininteg_diffusionmass_pa.cpp
new file mode 100644
index 000000000..55fd1b6cb
--- /dev/null
+++ b/fem/integ/bilininteg_diffusionmass_pa.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusionmass/diffusionmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DiffusionMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, MQd, Qm); }
+      else if (VQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, VQd, Qm); }
+      else { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, Qd, Qm); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DiffusionMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void DiffusionMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, MQd, Qm, true); }
+      else if (VQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, VQd, Qm, true); }
+      else { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, Qd, Qm, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DiffusionMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DiffusionMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DiffusionMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void DiffusionMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DiffusionMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_divdiv_mf.cpp b/fem/integ/bilininteg_divdiv_mf.cpp
new file mode 100644
index 000000000..8ed401f0a
--- /dev/null
+++ b/fem/integ/bilininteg_divdiv_mf.cpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DivDivIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void DivDivIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
index 300117e60..c01b03900 100644
--- a/fem/integ/bilininteg_divdiv_pa.cpp
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
 
 namespace mfem
@@ -19,10 +20,17 @@ namespace mfem
 
 void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q);
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
@@ -30,20 +38,16 @@ void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    pa_data.SetSize(nq * ne, Device::GetMemoryType());
 
    QuadratureSpace qs(*mesh, *ir);
@@ -65,31 +69,72 @@ void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+void DivDivIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
    {
-      internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
-      internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      if (dim == 3)
+      {
+         internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
 void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-      internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      if (dim == 3)
+      {
+         internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_divdivmass_pa.cpp b/fem/integ/bilininteg_divdivmass_pa.cpp
new file mode 100644
index 000000000..07bcf3eff
--- /dev/null
+++ b/fem/integ/bilininteg_divdivmass_pa.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/divdivmass/divdivmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DivDivMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, MQm); }
+      else if (VQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, VQm); }
+      else { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, Qm); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void DivDivMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, MQm, true); }
+      else if (VQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, VQm, true); }
+      else { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, Qm, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void DivDivMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_interp_curl_pa.cpp b/fem/integ/bilininteg_interp_curl_pa.cpp
new file mode 100644
index 000000000..73c33b02b
--- /dev/null
+++ b/fem/integ/bilininteg_interp_curl_pa.cpp
@@ -0,0 +1,65 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void CurlInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   // const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   // const FiniteElement *test_fel = test_fes.GetFE(0);
+   MFEM_ABORT("Error: CurlInterpolator::AssemblePA only implemented with libCEED");
+}
+
+void CurlInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+void CurlInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultTransposePA only implemented"
+                 "with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_interp_pa.cpp b/fem/integ/bilininteg_interp_grad_pa.cpp
similarity index 55%
rename from fem/integ/bilininteg_interp_pa.cpp
rename to fem/integ/bilininteg_interp_grad_pa.cpp
index 0ec03faec..8b3213746 100644
--- a/fem/integ/bilininteg_interp_pa.cpp
+++ b/fem/integ/bilininteg_interp_grad_pa.cpp
@@ -13,10 +13,68 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
 
 namespace mfem
 {
 
+void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
+               "Orders do not match!");
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+   o_dofs1D = maps_O_C->nqpt;
+   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   {
+      B_id = true;
+      c_dofs1D = maps_O_C->ndof;
+   }
+   else
+   {
+      B_id = false;
+      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+      c_dofs1D = maps_C_C->nqpt;
+   }
+}
+
 // Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
 // to get a dof in H(curl) (range). You can think of the range as the "test" space
 // and the domain as the "trial" space, but there's no integration.
@@ -1018,920 +1076,85 @@ static void PAHcurlApplyGradientTranspose3DBId(
    });
 }
 
-void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
+void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
-               "Orders do not match!");
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-   o_dofs1D = maps_O_C->nqpt;
-   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   if (DeviceCanUseCeed())
    {
-      B_id = true;
-      c_dofs1D = maps_O_C->ndof;
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
-      B_id = false;
-      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-      c_dofs1D = maps_C_C->nqpt;
-   }
-}
-
-void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
+      if (dim == 3)
       {
-         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+         if (B_id)
+         {
+            PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
                                    maps_O_C->G, x, y);
+         }
       }
-      else
-      {
-         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
+      else if (dim == 2)
       {
-         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
+         if (B_id)
+         {
+            PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
+                                   x, y);
+         }
       }
       else
       {
-         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
-                                x, y);
+         MFEM_ABORT("Bad dimension!");
       }
    }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
 }
 
 void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
+   if (DeviceCanUseCeed())
    {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
    }
    else
    {
-      mfem_error("Bad dimension!");
-   }
-}
-
-static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
-   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in y
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bo(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = ey*o_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in y
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      if (dim == 3)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
+         if (B_id)
          {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bc(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
+            PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
+      else if (dim == 2)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < o_dofs1D; ++ex)
+         if (B_id)
          {
-            const int local_index = ey*o_dofs1D + ex;
-            const double xd = x(local_index, e);
-
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bc(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
+            PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      else
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-            const double xd = x(local_index, e);
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
+         MFEM_ABORT("Bad dimension!");
       }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bo(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < o_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < o_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-   });
-}
-
-void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order);
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-
-   o_dofs1D = maps_O_C->nqpt;
-   c_dofs1D = maps_C_C->nqpt;
-   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
-               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
-
-   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
-                         : 2 * c_dofs1D * o_dofs1D;
-
-   const IntegrationRule & Nodes = test_el->GetNodes();
-
-   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
-   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
-
-   const Array<int> &dofmap = test_el->GetDofMap();
-
-   if (dim == 3)
-   {
-      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
-      // the last 3 having negative signs. Here the signs are all positive, as
-      // signs are applied in ElementRestriction.
-
-      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
-
-      for (int c=0; c<3; ++c)
-      {
-         for (int i=0; i<ndof_test/3; ++i)
-         {
-            const int d = (c*ndof_test/3) + i;
-            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[3];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<3; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-   else // 2D case
-   {
-      const double tk[4] = { 1.,0.,  0.,1. };
-      for (int c=0; c<2; ++c)
-      {
-         for (int i=0; i<ndof_test/2; ++i)
-         {
-            const int d = (c*ndof_test/2) + i;
-            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[2];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<2; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-}
-
-void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
    }
 }
 
diff --git a/fem/integ/bilininteg_interp_id_pa.cpp b/fem/integ/bilininteg_interp_id_pa.cpp
new file mode 100644
index 000000000..62cbe6c9b
--- /dev/null
+++ b/fem/integ/bilininteg_interp_id_pa.cpp
@@ -0,0 +1,843 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order);
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+
+   o_dofs1D = maps_O_C->nqpt;
+   c_dofs1D = maps_C_C->nqpt;
+   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
+               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
+
+   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
+                         : 2 * c_dofs1D * o_dofs1D;
+
+   const IntegrationRule & Nodes = test_el->GetNodes();
+
+   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
+   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
+
+   const Array<int> &dofmap = test_el->GetDofMap();
+
+   if (dim == 3)
+   {
+      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
+      // the last 3 having negative signs. Here the signs are all positive, as
+      // signs are applied in ElementRestriction.
+
+      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
+
+      for (int c=0; c<3; ++c)
+      {
+         for (int i=0; i<ndof_test/3; ++i)
+         {
+            const int d = (c*ndof_test/3) + i;
+            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[3];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<3; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+   else // 2D case
+   {
+      const double tk[4] = { 1.,0.,  0.,1. };
+      for (int c=0; c<2; ++c)
+      {
+         for (int i=0; i<ndof_test/2; ++i)
+         {
+            const int d = (c*ndof_test/2) + i;
+            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[2];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<2; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+}
+
+static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
+   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in y
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bo(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = ey*o_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in y
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bc(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int local_index = ey*o_dofs1D + ex;
+            const double xd = x(local_index, e);
+
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bc(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+            const double xd = x(local_index, e);
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bo(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < o_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < o_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+   });
+}
+
+void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index 61f91ab68..68362a569 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -18,49 +18,47 @@ namespace mfem
 
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: MassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void MassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: MassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void MassIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -69,4 +67,17 @@ void MassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index d3feea5ca..cc7314f5e 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -23,28 +23,19 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T =* mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T =* mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    int map_type = el.GetMapType();
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
@@ -116,10 +107,16 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
    const FiniteElement &el = *fes.GetBE(0);
    ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, *T0);
@@ -188,7 +185,7 @@ void MassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -201,7 +198,7 @@ void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_mixedcurl_mf.cpp b/fem/integ/bilininteg_mixedcurl_mf.cpp
new file mode 100644
index 000000000..4e5418c64
--- /dev/null
+++ b/fem/integ/bilininteg_mixedcurl_mf.cpp
@@ -0,0 +1,108 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
+
+namespace mfem
+{
+
+void MixedVectorCurlIntegrator::AssembleMF(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void MixedVectorCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index 62f9fc261..3ae534657 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hcurlhdiv_kernels.hpp"
 
@@ -109,8 +110,30 @@ void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
 void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                            const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -193,84 +216,121 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
 void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2Apply3D<2,3>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2Apply3D<3,4>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2Apply3D<4,5>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2Apply3D<5,6>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2Apply3D(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2Apply3D<2,3>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2Apply3D<3,4>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2Apply3D<4,5>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2Apply3D<5,6>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2Apply3D(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
+                                       mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::DIV &&
+               trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
-                                    mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
-                                   pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                    Vector &y) const
 {
-   if (testType == mfem::FiniteElement::DIV &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
-                                            mapsC->Gt, pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::DIV &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
-void MixedVectorWeakCurlIntegrator::AssemblePA(
-   const FiniteElementSpace &trial_fes,
-   const FiniteElementSpace &test_fes)
+void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
+                                               &trial_fes,
+                                               const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -349,75 +409,90 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
 
 void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<2,3>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<3,4>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<4,5>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<5,6>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+            }
+         }
+         else
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<2,3>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<3,4>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<4,5>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<5,6>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2ApplyTranspose3D(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
+            internal::PAHcurlL2ApplyTranspose3D(dofs1D, quad1D, ndata, ne, mapsO->B,
+                                                mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
+                                                pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::CURL &&
+               trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsO->Bt, mapsC->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2ApplyTranspose3D(dofs1D, quad1D, ndata, ne, mapsO->B,
-                                             mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
-                                             pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::CURL &&
-            trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsO->Bt, mapsC->Bt,
-                                            mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                        Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::DIV && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
-                                   pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorWeakCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_mixedvecgrad_mf.cpp b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
new file mode 100644
index 000000000..76afe676c
--- /dev/null
+++ b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
@@ -0,0 +1,174 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
+
+namespace mfem
+{
+
+void MixedVectorGradientIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorGradientIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultMF(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index 59ae9bc5f..3e0479252 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -13,6 +13,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 
 namespace mfem
@@ -22,8 +23,30 @@ void MixedVectorGradientIntegrator::AssemblePA(
    const FiniteElementSpace &trial_fes,
    const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -80,6 +103,38 @@ void MixedVectorGradientIntegrator::AssemblePA(
    }
 }
 
+void MixedVectorGradientIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
 // Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
 // integrated against H(curl) test functions corresponding to y.
 static void PAHcurlH1Apply2D(const int D1D,
@@ -720,38 +775,131 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
 
 void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      if (dim == 3)
+      {
+         PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
 void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
                                                        Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorGradientIntegrator.");
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
+   }
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePA only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
    }
-   else if (dim == 2)
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultPA(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      ceedOp->AddMult(x, y);
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
    }
 }
 
diff --git a/fem/integ/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
index d46a1a27b..52d38b1e5 100644
--- a/fem/integ/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -18,52 +18,52 @@ namespace mfem
 
 void VectorDiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
-      delete ceedOp;
       MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMF only implemented"
               " with libCEED");
 }
 
-void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorDiffusionIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
-                 " with libCEED");
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMFBoundary only implemented"
+              " with libCEED");
 }
 
 void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -72,4 +72,17 @@ void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
+                 " with libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index c21a949b2..983f0e39d 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -114,26 +114,21 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
 
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -209,6 +204,28 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorDiffusionIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssemblePABoundary only implemented"
+              " with libCEED");
+}
+
 template<int T_D1D = 0, int T_Q1D = 0>
 static void PAVectorDiffusionDiagonal2D(const int NE,
                                         const Array<double> &b,
@@ -382,7 +399,7 @@ void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -721,7 +738,7 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
index ad271f1fa..f44503dcc 100644
--- a/fem/integ/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -18,49 +18,47 @@ namespace mfem
 
 void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorMassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -69,4 +67,17 @@ void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index c796afbd5..5474f23a8 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -19,32 +19,23 @@ namespace mfem
 
 void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::COORDINATES |
-                                    GeometricFactors::JACOBIANS);
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
    dofs1D = maps->ndof;
    quad1D = maps->nqpt;
@@ -105,6 +96,25 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassAssembleDiagonal2D(const int NE,
                                            const Array<double> &B_,
@@ -237,7 +247,7 @@ void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -502,7 +512,7 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_vectorfemass_mf.cpp b/fem/integ/bilininteg_vectorfemass_mf.cpp
new file mode 100644
index 000000000..eddf6c5f5
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfemass_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void VectorFEMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void VectorFEMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index 90d0cd8c6..588d76642 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
@@ -23,29 +24,37 @@ namespace mfem
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(&trial_fes == &test_fes,
+                  "VectorFEMassIntegrator with mixed FE spaces is not supported by libCEED!");
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, DQ); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const VectorTensorFiniteElement *trial_el =
       dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
    MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
    const FiniteElement *test_fel = test_fes.GetFE(0);
    const VectorTensorFiniteElement *test_el =
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
    ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *trial_el,
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
                                                             T);
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = trial_fes.GetNE();
    MFEM_VERIFY(ne == test_fes.GetNE(),
                "Different meshes for test and trial spaces");
@@ -54,13 +63,10 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1Dtest = mapsCtest->ndof;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    trial_fetype = trial_el->GetDerivType();
    test_fetype = test_el->GetDerivType();
 
@@ -71,6 +77,7 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+
    if (Q) { coeff.Project(*Q); }
    else if (MQ) { coeff.ProjectTranspose(*MQ); }
    else if (DQ) { coeff.Project(*DQ); }
@@ -137,172 +144,206 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    }
 }
 
-void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
+void VectorFEMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
    {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  default:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x34:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x45:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x56:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               default:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
+               internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                       mapsO->B, mapsC->B, pa_data, diag);
             }
          }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
          else
          {
-            internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                    mapsO->B, mapsC->B, pa_data, diag);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                 mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
+      else // 2D
       {
-         internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+         {
+            internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                    mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
 
 void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
    {
-      if (trial_curl && test_curl)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_curl && test_curl)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassApply3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassApply3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassApply3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassApply3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  default:
+                     return internal::SmemPAHcurlMassApply3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassApply3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x34:
-                  return internal::SmemPAHcurlMassApply3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x45:
-                  return internal::SmemPAHcurlMassApply3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x56:
-                  return internal::SmemPAHcurlMassApply3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               default:
-                  return internal::SmemPAHcurlMassApply3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
+               internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                            mapsO->Bt, mapsC->Bt, pa_data, x, y);
             }
          }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                      mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_curl && test_div)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_curl)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
          else
          {
-            internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_curl && test_div)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_curl)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_curl && test_curl)
+      else // 2D
       {
-         internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+         if (trial_curl && test_curl)
+         {
+            internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
                                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt,
-                                   mapsC->Bt, pa_data, x, y);
-      }
-      else if ((trial_curl && test_div) || (trial_div && test_curl))
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          trial_curl, false, mapsO->B, mapsC->B,
-                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         }
+         else if ((trial_curl && test_div) || (trial_div && test_curl))
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             trial_curl, false, mapsO->B, mapsC->B,
+                                             mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
@@ -310,35 +351,43 @@ void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
                                                 Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   bool symmetricSpaces = true;
-   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       trial_div, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
+   if (DeviceCanUseCeed())
    {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       !trial_curl, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " VectorFEMassIntegrator.");
    }
-   if (symmetricSpaces)
+   else
    {
-      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      bool symmetricSpaces = true;
+      if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          trial_div, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
       {
-         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          !trial_curl, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      if (symmetricSpaces)
+      {
+         if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+         {
+            MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         }
+         AddMultPA(x, y);
       }
-      AddMultPA(x, y);
    }
 }
 
diff --git a/fem/integ/nonlininteg_vecconvection_mf.cpp b/fem/integ/nonlininteg_vecconvection_mf.cpp
index edcf7d20f..d7fb41ac0 100644
--- a/fem/integ/nonlininteg_vecconvection_mf.cpp
+++ b/fem/integ/nonlininteg_vecconvection_mf.cpp
@@ -18,34 +18,29 @@ namespace mfem
 void VectorConvectionNLFIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
-               "PA Only supports Ordering::byNODES!");
+               "MF only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
-   MFEM_ABORT("Not yet implemented.");
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorConvectionNLFIntegrator::AssembleMF only"
+              " implemented with libCEED");
 }
 
 void VectorConvectionNLFIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/nonlininteg_vecconvection_pa.cpp b/fem/integ/nonlininteg_vecconvection_pa.cpp
index f2f9e242b..1d9fccc10 100644
--- a/fem/integ/nonlininteg_vecconvection_pa.cpp
+++ b/fem/integ/nonlininteg_vecconvection_pa.cpp
@@ -21,24 +21,18 @@ void VectorConvectionNLFIntegrator::AssemblePA(const FiniteElementSpace &fes)
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
                "PA Only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
@@ -808,7 +802,7 @@ void VectorConvectionNLFIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 1480cb56b..3a79b8c4d 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -1168,17 +1168,13 @@ TransferOperator::TransferOperator(const FiniteElementSpace& lFESpace_,
       P.SetOperatorOwner(false);
       opr = P.Ptr();
    }
-   else if (lFESpace_.GetMesh()->GetNE() > 0
-            && hFESpace_.GetMesh()->GetNE() > 0
-            && lFESpace_.GetVDim() == 1
-            && hFESpace_.GetVDim() == 1
-            && dynamic_cast<const TensorBasisElement*>(lFESpace_.GetFE(0))
-            && dynamic_cast<const TensorBasisElement*>(hFESpace_.GetFE(0))
-            && !isvar_order
-            && (hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::CONTINUOUS ||
-                hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::DISCONTINUOUS))
+   else if (UsesTensorBasis(lFESpace_) && UsesTensorBasis(hFESpace_) &&
+            lFESpace_.GetVDim() == 1 && hFESpace_.GetVDim() == 1 &&
+            !isvar_order &&
+            (hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::CONTINUOUS ||
+             hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::DISCONTINUOUS))
    {
       opr = new TensorProductPRefinementTransferOperator(lFESpace_, hFESpace_);
    }
diff --git a/general/array.cpp b/general/array.cpp
index 12c3e3c06..e1a81e2d1 100644
--- a/general/array.cpp
+++ b/general/array.cpp
@@ -175,6 +175,7 @@ void Array2D<T>::Print(std::ostream &os, int width_)
    }
 }
 
+template class Array<bool>;
 template class Array<char>;
 template class Array<int>;
 template class Array<long long>;
diff --git a/general/device.cpp b/general/device.cpp
index 25e91b22f..d8579c83a 100644
--- a/general/device.cpp
+++ b/general/device.cpp
@@ -33,7 +33,6 @@ occa::device occaDevice;
 
 #ifdef MFEM_USE_CEED
 Ceed ceed = NULL;
-
 ceed::BasisMap ceed_basis_map;
 ceed::RestrMap ceed_restr_map;
 #endif
@@ -149,19 +148,24 @@ Device::~Device()
    if (!device_env &&  destroy_mm && !mem_host_env)
    {
 #ifdef MFEM_USE_CEED
-      // Destroy FES -> CeedBasis, CeedElemRestriction hash table contents
-      for (auto entry : internal::ceed_basis_map)
-      {
-         CeedBasisDestroy(&entry.second);
-      }
-      internal::ceed_basis_map.clear();
-      for (auto entry : internal::ceed_restr_map)
+#ifdef MFEM_USE_OPENMP
+      #pragma omp parallel
+#endif
       {
-         CeedElemRestrictionDestroy(&entry.second);
+         // Destroy FES -> CeedBasis, CeedElemRestriction hash table contents
+         for (auto entry : internal::ceed_basis_map)
+         {
+            CeedBasisDestroy(&entry.second);
+         }
+         internal::ceed_basis_map.clear();
+         for (auto entry : internal::ceed_restr_map)
+         {
+            CeedElemRestrictionDestroy(&entry.second);
+         }
+         internal::ceed_restr_map.clear();
+         // Destroy Ceed context
+         CeedDestroy(&internal::ceed);
       }
-      internal::ceed_restr_map.clear();
-      // Destroy Ceed context
-      CeedDestroy(&internal::ceed);
 #endif
       mm.Destroy();
    }
@@ -404,22 +408,27 @@ static void OccaDeviceSetup(const int dev)
 #endif
 }
 
-static void CeedDeviceSetup(const char* ceed_spec)
+static void CeedDeviceSetup(const char *ceed_spec)
 {
 #ifdef MFEM_USE_CEED
-   CeedInit(ceed_spec, &internal::ceed);
-   const char *ceed_backend;
-   CeedGetResource(internal::ceed, &ceed_backend);
-   if (strcmp(ceed_spec, ceed_backend) && strcmp(ceed_spec, "/cpu/self") &&
-       strcmp(ceed_spec, "/gpu/hip"))
+#ifdef MFEM_USE_OPENMP
+   #pragma omp parallel
+#endif
    {
-      mfem::out << std::endl << "WARNING!!!\n"
-                "libCEED is not using the requested backend!!!\n"
-                "WARNING!!!\n" << std::endl;
-   }
+      CeedInit(ceed_spec, &internal::ceed);
+      const char *ceed_backend;
+      CeedGetResource(internal::ceed, &ceed_backend);
+      size_t ceed_spec_len = strlen(ceed_spec);
+      if (strncmp(ceed_spec, ceed_backend, ceed_spec_len))
+      {
+         mfem::out << std::endl << "WARNING!!!\n"
+                   "libCEED is not using the requested backend!!!\n"
+                   "WARNING!!!\n" << std::endl;
+      }
 #ifdef MFEM_DEBUG
-   CeedSetErrorHandler(internal::ceed, CeedErrorStore);
+      CeedSetErrorHandler(internal::ceed, CeedErrorStore);
 #endif
+   }
 #else
    MFEM_CONTRACT_VAR(ceed_spec);
 #endif
diff --git a/makefile b/makefile
index b16112ccd..0716a898f 100644
--- a/makefile
+++ b/makefile
@@ -271,7 +271,6 @@ MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS
  GSLIB OCCA CEED RAJA UMPIRE MKL_CPARDISO MKL_PARDISO AMGX CALIPER PARELAG BENCHMARK\
  MOONOLITH ALGOIM
 
-
 PETSC_ERROR_MSG = $(if $(PETSC_FOUND),,. PETSC config not found: $(PETSC_VARS))
 SLEPC_ERROR_MSG = $(if $(SLEPC_FOUND),,. SLEPC config not found: $(SLEPC_VARS))
 
@@ -409,7 +408,12 @@ endif
 DIRS = general linalg linalg/simd mesh mesh/submesh fem fem/ceed/interface \
        fem/ceed/integrators/mass fem/ceed/integrators/convection \
        fem/ceed/integrators/diffusion fem/ceed/integrators/nlconvection \
-       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/integ fem/tmop
+       fem/ceed/integrators/vecfemass fem/ceed/integrators/divdiv \
+       fem/ceed/integrators/curlcurl fem/ceed/integrators/diffusionmass \
+       fem/ceed/integrators/divdivmass fem/ceed/integrators/curlcurlmass \
+       fem/ceed/integrators/mixedvecgrad fem/ceed/integrators/mixedveccurl \
+       fem/ceed/integrators/interp fem/ceed/integrators/util fem/ceed/solvers \
+       fem/fe fem/lor fem/qinterp fem/integ fem/tmop
 
 ifeq ($(MFEM_USE_MOONOLITH),YES)
    MFEM_CXXFLAGS += $(MOONOLITH_CXX_FLAGS)
@@ -423,7 +427,7 @@ RELSRC_FILES = $(patsubst $(SRC)%,%,$(SOURCE_FILES))
 OBJECT_FILES = $(patsubst $(SRC)%,$(BLD)%,$(SOURCE_FILES:.cpp=.o))
 OKL_DIRS = fem
 
-.PHONY: lib all clean distclean install config status info deps serial parallel	\
+.PHONY: lib all clean distclean install config status info deps serial parallel \
 	debug pdebug cuda hip pcuda cudebug pcudebug hpc style check test unittest \
 	deprecation-warnings
 
@@ -603,6 +607,20 @@ install: $(if $(static),$(BLD)libmfem.a) $(if $(shared),$(BLD)libmfem.$(SO_EXT))
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/diffusion/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusion
 	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/nlconvection/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/vecfemass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/divdiv/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/curlcurl/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusionmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/diffusionmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusionmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/divdivmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/divdivmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/divdivmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurlmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/curlcurlmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurlmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/util
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/util/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/util
 # install config.mk in $(PREFIX_SHARE)
 	mkdir -p $(PREFIX_SHARE)
 	$(MAKE) -C $(BLD)config config-mk CONFIG_MK=config-install.mk
@@ -727,17 +745,16 @@ status info:
 ASTYLE_BIN = astyle
 ASTYLE = $(ASTYLE_BIN) --options=$(SRC)config/mfem.astylerc
 ASTYLE_VER = "Artistic Style Version 3.1"
-FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.?pp)
-FORMAT_FILES += tests/unit/*.?pp
-UNIT_TESTS_SUBDIRS = general linalg mesh fem miniapps ceed
-MINIAPPS_SUBDIRS = dpg/util hooke/operators hooke/preconditioners hooke/materials hooke/kernels
-FORMAT_FILES += $(foreach dir,$(UNIT_TESTS_SUBDIRS),tests/unit/$(dir)/*.?pp)
-FORMAT_FILES += $(foreach dir,$(MINIAPPS_SUBDIRS),miniapps/$(dir)/*.?pp)
-FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp
+FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += tests/unit/*.[ch]pp
+FORMAT_FILES += $(foreach dir,$(wildcard tests/unit/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += $(foreach dir,$(wildcard miniapps/*/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp fem/picojson.h general/tinyxml2.h
 FORMAT_LIST = $(filter-out $(FORMAT_EXCLUDE),$(wildcard $(FORMAT_FILES)))
 
-COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp)
-COUT_CERR_EXCLUDE = '^general/error\.cpp' '^general/globals\.[ch]pp'
+COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp $(dir)/*.[ch])
+COUT_CERR_EXCLUDE = general/error.cpp general/globals.cpp general/globals.hpp
+COUT_CERR_LIST = $(filter-out $(COUT_CERR_EXCLUDE),$(wildcard $(COUT_CERR_FILES)))
 
 DEPRECATION_WARNING := \
 "This feature is planned for removal in the next release."\
@@ -773,12 +790,12 @@ style:
 	    "Please make sure the changes are committed");\
 	echo "Checking for use of std::cout...";\
 	$(call mfem_check_command,\
-	   grep cout $(COUT_CERR_FILES) | grep -v $(COUT_CERR_EXCLUDE:%=-e %),\
+	   grep cout $(COUT_CERR_LIST),\
 	   "No use of std::cout found", "Use mfem::out instead of std::cout");\
 	echo "Checking for use of std::cerr...";\
 	$(call mfem_check_command,\
-	   grep cerr $(COUT_CERR_FILES) |\
-	      grep -v $(COUT_CERR_EXCLUDE:%=-e %) -e cerrno,\
+	   grep cerr $(COUT_CERR_LIST) |\
+	      grep -v -e cerrno,\
 	   "No use of std::cerr found", "Use mfem::err instead of std::cerr");\
 	exit $$err_code
 
diff --git a/tests/unit/ceed/test_ceed.cpp b/tests/unit/ceed/test_ceed.cpp
index 971b68e24..2353f43a6 100644
--- a/tests/unit/ceed/test_ceed.cpp
+++ b/tests/unit/ceed/test_ceed.cpp
@@ -21,7 +21,15 @@ namespace ceed_test
 
 #ifdef MFEM_USE_CEED
 
-enum class CeedCoeffType { Const, Grid, Quad, VecConst, VecGrid, VecQuad };
+enum class CeedCoeffType { Const,
+                           Grid,
+                           Quad,
+                           VecConst,
+                           VecGrid,
+                           VecQuad,
+                           MatConst,
+                           MatQuad
+                         };
 
 double coeff_function(const Vector &x)
 {
@@ -41,11 +49,24 @@ void velocity_function(const Vector &x, Vector &v)
    }
 }
 
+// Matrix-valued velocity coefficient
+void matrix_velocity_function(const Vector &x, DenseMatrix &m)
+{
+   int dim = x.Size();
+   Vector v(dim);
+   velocity_function(x, v);
+   m.SetSize(dim);
+   m = 0.5;
+   for (int i = 0; i < dim; i++)
+   {
+      m(i, i) = 1.0 + v(i);
+   }
+}
+
 // Vector valued quantity to convect
 void quantity(const Vector &x, Vector &u)
 {
    int dim = x.Size();
-
    switch (dim)
    {
       case 1: u(0) = x[0]*x[0]; break;
@@ -59,7 +80,6 @@ void quantity(const Vector &x, Vector &u)
 void convected_quantity(const Vector &x, Vector &u)
 {
    double a, b, c;
-
    int dim = x.Size();
    switch (dim)
    {
@@ -82,7 +102,7 @@ void convected_quantity(const Vector &x, Vector &u)
    }
 }
 
-std::string getString(AssemblyLevel assembly)
+std::string GetString(AssemblyLevel assembly)
 {
    switch (assembly)
    {
@@ -106,7 +126,7 @@ std::string getString(AssemblyLevel assembly)
    return "";
 }
 
-std::string getString(CeedCoeffType coeff_type)
+std::string GetString(CeedCoeffType coeff_type)
 {
    switch (coeff_type)
    {
@@ -128,6 +148,12 @@ std::string getString(CeedCoeffType coeff_type)
       case CeedCoeffType::VecQuad:
          return "VecQuad";
          break;
+      case CeedCoeffType::MatConst:
+         return "MatConst";
+         break;
+      case CeedCoeffType::MatQuad:
+         return "MatQuad";
+         break;
    }
    MFEM_ABORT("Unknown CeedCoeffType.");
    return "";
@@ -138,10 +164,18 @@ enum class Problem { Mass,
                      Diffusion,
                      VectorMass,
                      VectorDiffusion,
-                     MassDiffusion
+                     HDivMass,
+                     HCurlMass,
+                     DivDiv,
+                     CurlCurl,
+                     MassDiffusion,
+                     HDivMassDivDiv,
+                     HCurlMassCurlCurl,
+                     MixedVectorGradient,
+                     MixedVectorCurl
                    };
 
-std::string getString(Problem pb)
+std::string GetString(Problem pb)
 {
    switch (pb)
    {
@@ -160,9 +194,33 @@ std::string getString(Problem pb)
       case Problem::VectorDiffusion:
          return "VectorDiffusion";
          break;
+      case Problem::HDivMass:
+         return "HDivMass";
+         break;
+      case Problem::HCurlMass:
+         return "HCurlMass";
+         break;
+      case Problem::DivDiv:
+         return "DivDiv";
+         break;
+      case Problem::CurlCurl:
+         return "CurlCurl";
+         break;
       case Problem::MassDiffusion:
          return "MassDiffusion";
          break;
+      case Problem::HDivMassDivDiv:
+         return "HDivMassDivDiv";
+         break;
+      case Problem::HCurlMassCurlCurl:
+         return "HCurlMassCurlCurl";
+         break;
+      case Problem::MixedVectorGradient:
+         return "MixedVectorGradient";
+         break;
+      case Problem::MixedVectorCurl:
+         return "MixedVectorCurl";
+         break;
    }
    MFEM_ABORT("Unknown Problem.");
    return "";
@@ -170,7 +228,7 @@ std::string getString(Problem pb)
 
 enum class NLProblem {Convection};
 
-std::string getString(NLProblem pb)
+std::string GetString(NLProblem pb)
 {
    switch (pb)
    {
@@ -178,14 +236,15 @@ std::string getString(NLProblem pb)
          return "Convection";
          break;
    }
-   MFEM_ABORT("Unknown Problem.");
+   MFEM_ABORT("Unknown NLProblem.");
    return "";
 }
 
 void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
                const CeedCoeffType coeff_type, GridFunction *&gf,
-               FiniteElementSpace *& coeff_fes,
-               Coefficient *&coeff, VectorCoefficient *&vcoeff)
+               FiniteElementSpace *&coeff_fes,
+               Coefficient *&coeff, VectorCoefficient *&vcoeff,
+               MatrixCoefficient *&mcoeff)
 {
    switch (coeff_type)
    {
@@ -209,7 +268,7 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
          Vector val(dim);
          for (int i = 0; i < dim; i++)
          {
-            val(i) = 1.0;
+            val(i) = 1.0 + i;
          }
          vcoeff = new VectorConstantCoefficient(val);
          break;
@@ -226,21 +285,93 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
       case CeedCoeffType::VecQuad:
          vcoeff = new VectorFunctionCoefficient(dim, velocity_function);
          break;
+      case CeedCoeffType::MatConst:
+      {
+         DenseMatrix val(dim);
+         val = 0.5;
+         for (int i = 0; i < dim; i++)
+         {
+            val(i, i) = 1.0 + i;
+         }
+         mcoeff = new MatrixConstantCoefficient(val);
+         break;
+      }
+      case CeedCoeffType::MatQuad:
+         mcoeff = new MatrixFunctionCoefficient(dim, matrix_velocity_function);
+         break;
    }
 }
 
-void test_ceed_operator(const char* input, int order,
+class DiffusionIntegrator2 : public DiffusionIntegrator
+{
+public:
+   DiffusionIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   DiffusionIntegrator2(VectorCoefficient &q,
+                        const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   DiffusionIntegrator2(MatrixCoefficient &q,
+                        const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+class DivDivIntegrator2 : public DivDivIntegrator
+{
+public:
+   DivDivIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : DivDivIntegrator(q, ir) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+class CurlCurlIntegrator2 : public CurlCurlIntegrator
+{
+public:
+   CurlCurlIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   CurlCurlIntegrator2(VectorCoefficient &q,
+                       const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   CurlCurlIntegrator2(MatrixCoefficient &q,
+                       const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+void test_ceed_operator(const char *input, int order,
                         const CeedCoeffType coeff_type, const Problem pb,
-                        const AssemblyLevel assembly)
+                        const AssemblyLevel assembly, bool mixed_p, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (mixed_p ? "mixed_p: true\n" : "") +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
+   if (mixed_p) { mesh.EnsureNCMesh(); }
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
@@ -249,43 +380,59 @@ void test_ceed_operator(const char* input, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!mcoeff,
+               "Unexpected matrix-valued coefficient in test_ceed_operator.");
 
    // Build the BilinearForm
    bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
+   if (mixed_p)
+   {
+      fes.SetElementOrder(0, order+1);
+      fes.SetElementOrder(fes.GetNE() - 1, order+1);
+      fes.Update(false);
+   }
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new ConvectionIntegrator(*vcoeff, -1));
+         AddIntegrator(k_test, new ConvectionIntegrator(*vcoeff, -1));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
          break;
       case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorMassIntegrator(*coeff));
          break;
       case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         break;
-      case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorDiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorDiffusionIntegrator(*coeff));
          break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
    k_ref.Assemble();
@@ -294,121 +441,622 @@ void test_ceed_operator(const char* input, int order,
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
+   d_ref.UseDevice(true);
+   d_test.UseDevice(true);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (mesh.Nonconforming() &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nDIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nDIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nDIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ? 1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
-void test_mixed_p_ceed_operator(const char* input, int order,
-                                const CeedCoeffType coeff_type, const Problem pb,
-                                const AssemblyLevel assembly)
+void test_ceed_vectorfe_operator(const char *input, int order,
+                                 const CeedCoeffType coeff_type, const Problem pb,
+                                 const AssemblyLevel assembly, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
-   mesh.EnsureNCMesh();
    int dim = mesh.Dimension();
-   MFEM_VERIFY(dim == 2, "p-adaptivity only supported in serial 2D.");
-   H1_FECollection fec(order, dim);
+   FiniteElementCollection *fec = nullptr;
+   if ((pb == Problem::HDivMass || pb == Problem::DivDiv ||
+        pb == Problem::HDivMassDivDiv) && bdr_integ)
+   {
+      // Boundary RT elements in 2D and 3D are actually L2
+      return;
+   }
+   if ((pb == Problem::CurlCurl || pb == Problem::HCurlMassCurlCurl) &&
+       dim - bdr_integ < 2)
+   {
+      // No 1D ND curl shape
+      return;
+   }
+   if (assembly == AssemblyLevel::NONE && (pb == Problem::MassDiffusion ||
+                                           pb == Problem::HDivMassDivDiv ||
+                                           pb == Problem::HCurlMassCurlCurl))
+   {
+      // No MF assembly for these integrators.
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::Mass:
+      case Problem::Diffusion:
+      case Problem::MassDiffusion:
+         fec = new H1_FECollection(order, dim);
+         break;
+      case Problem::HDivMass:
+      case Problem::DivDiv:
+      case Problem::HDivMassDivDiv:
+         fec = new RT_FECollection(order-1, dim);
+         break;
+      case Problem::HCurlMass:
+      case Problem::CurlCurl:
+      case Problem::HCurlMassCurlCurl:
+         fec = new ND_FECollection(order, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
 
    // Coefficient Initialization
    GridFunction *gf = nullptr;
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   if (!coeff && (pb == Problem::Mass || pb == Problem::DivDiv ||
+                  (pb == Problem::CurlCurl && dim - bdr_integ < 3)))
+   {
+      delete gf;
+      delete coeff_fes;
+      delete coeff;
+      delete vcoeff;
+      delete mcoeff;
+      delete fec;
+      return;
+   }
+   if (!coeff && (pb == Problem::MassDiffusion || pb == Problem::HDivMassDivDiv ||
+                  (pb == Problem::HCurlMassCurlCurl && dim - bdr_integ < 3)))
+   {
+      coeff = new ConstantCoefficient(1.0);
+   }
 
    // Build the BilinearForm
-   bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
-   const int vdim = vecOp ? dim : 1;
-   FiniteElementSpace fes(&mesh, &fec, vdim);
-   fes.SetElementOrder(0, order+1);
-   fes.SetElementOrder(fes.GetNE() - 1, order+1);
-   fes.Update(false);
+   FiniteElementSpace fes(&mesh, fec);
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         break;
-      case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*mcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*vcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
+         }
          break;
-      case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+      case Problem::MassDiffusion:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*mcoeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*mcoeff, *coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*vcoeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*vcoeff, *coeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*coeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*coeff, *coeff));
+         }
          break;
-      case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
+      case Problem::HDivMass:
+      case Problem::HCurlMass:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*coeff));
+         }
          break;
-      case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+      case Problem::DivDiv:
+         AddIntegrator(k_ref, new DivDivIntegrator(*coeff));
+         AddIntegrator(k_test, new DivDivIntegrator(*coeff));
+         break;
+      case Problem::HDivMassDivDiv:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *coeff));
+         }
+         break;
+      case Problem::CurlCurl:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*coeff));
+         }
          break;
+      case Problem::HCurlMassCurlCurl:
+         if (mcoeff)
+         {
+            if (coeff)
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *mcoeff));
+            }
+            else
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*mcoeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*mcoeff, *mcoeff));
+            }
+         }
+         else if (vcoeff)
+         {
+            if (coeff)
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *vcoeff));
+            }
+            else
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*vcoeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*vcoeff, *vcoeff));
+            }
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *coeff));
+         }
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_ref, chrono_setup_test;
+   StopWatch chrono_apply_ref, chrono_apply_test;
+   chrono_setup_ref.Clear();
+   chrono_setup_ref.Start();
+
    k_ref.Assemble();
    k_ref.Finalize();
 
+   chrono_setup_ref.Stop();
+   chrono_setup_test.Clear();
+   chrono_setup_test.Start();
+
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   chrono_setup_test.Stop();
+
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
+   d_ref.UseDevice(true);
+   d_test.UseDevice(true);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   chrono_apply_ref.Clear();
+   chrono_apply_ref.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_ref.Mult(x, y_ref);
+   }
+
+   chrono_apply_ref.Stop();
+   chrono_apply_test.Clear();
+   chrono_apply_test.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_test.Mult(x, y_test);
+   }
+
+   chrono_apply_test.Stop();
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (!UsesTensorBasis(fes) && order > 1 &&
+   //     (pb == Problem::HCurlMass || pb == Problem::CurlCurl ||
+   //      pb == Problem::HCurlMassCurlCurl) &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nH(CURL) DIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ||
+            (!UsesTensorBasis(fes) && order > 1 &&
+             (pb == Problem::HCurlMass || pb == Problem::CurlCurl ||
+              pb == Problem::HCurlMassCurlCurl)) ?
+            1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
+
+   if (debug)
+   {
+      // Estimates only for non-mixed meshes
+      std::size_t mem_test = 0;
+      if (mesh.GetNumGeometries(dim) == 1)
+      {
+         // Estimate for QFunction memory
+         const FiniteElement &fe = bdr_integ ? *fes.GetBE(0) : *fes.GetFE(0);
+         ElementTransformation &T =
+            bdr_integ ? *mesh.GetBdrElementTransformation(0) :
+            *mesh.GetElementTransformation(0);
+         const int Q =
+            bdr_integ ? (*k_ref.GetBBFI())[0]->GetRule(fe, T).GetNPoints() :
+            (*k_ref.GetDBFI())[0]->GetRule(fe, T).GetNPoints();
+         const int P = fe.GetDof();
+         const int Qd = dim - bdr_integ;
+         switch (pb)
+         {
+            case Problem::Mass:
+               mem_test = Q * 1 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::Diffusion:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::MassDiffusion:
+               mem_test = Q * ((Qd * (Qd + 1)) + 1) / 2 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::HDivMass:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::DivDiv:
+               mem_test = Q * 1 * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::HDivMassDivDiv:
+               mem_test = Q * (1 + (Qd * (Qd + 1)) / 2 * 8) * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::HCurlMass:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 3 * 1);  // Tri-diagonal curl orientations
+               break;
+            case Problem::CurlCurl:
+               mem_test = Q * (Qd < 3 ? 1 : Qd * (Qd + 1) / 2) * 8;
+               mem_test += P * (4 + 3 * 1);
+               break;
+            case Problem::HCurlMassCurlCurl:
+               mem_test = Q * (Qd < 3 ? 1 : Qd * (Qd + 1) / 2) * 8;
+               mem_test += Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 3 * 1);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+         mem_test *= bdr_integ ? mesh.GetNBE() : mesh.GetNE();
+      }
+      std::size_t mem_ref = k_ref.SpMat().NumNonZeroElems() * (8 + 4) +
+                            k_ref.Height() * 4;
+
+      out << "\n" << section << "\n";
+      out << "benchmark (" << fes.GetTrueVSize() << " unknowns)\n"
+          << "    setup: ref = "
+          << chrono_setup_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    mem usage: ref = " << mem_ref / 1e6 << " MB\n"
+          << "               test = " << mem_test / 1e6 << " MB\n";
+   }
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
+   delete fec;
 }
 
-void test_ceed_nloperator(const char* mesh_filename, int order,
+void test_ceed_mixed_operator(const char *input, int order,
+                              const CeedCoeffType coeff_type, const Problem pb,
+                              const AssemblyLevel assembly, bool bdr_integ)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   FiniteElementCollection *trial_fec = nullptr, *test_fec = nullptr;
+   if (pb == Problem::MixedVectorGradient && dim - bdr_integ < 2)
+   {
+      // MixedVectorGradient is only supported in 2D or 3D
+      return;
+   }
+   if (pb == Problem::MixedVectorCurl && dim - bdr_integ < 3)
+   {
+      // MixedVectorCurl is only supported in 3D
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         trial_fec = new H1_FECollection(order, dim);
+         test_fec = new ND_FECollection(order, dim);
+         break;
+      case Problem::MixedVectorCurl:
+         trial_fec = new ND_FECollection(order, dim);
+         test_fec = new RT_FECollection(order - 1, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   // Coefficient Initialization
+   GridFunction *gf = nullptr;
+   FiniteElementSpace *coeff_fes = nullptr;
+   Coefficient *coeff = nullptr;
+   VectorCoefficient *vcoeff = nullptr;
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *trial_fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff,
+             mcoeff);
+
+   // Build the BilinearForm
+   FiniteElementSpace trial_fes(&mesh, trial_fec);
+   FiniteElementSpace test_fes(&mesh, test_fec);
+
+   MixedBilinearForm k_ref(&trial_fes, &test_fes);
+   MixedBilinearForm k_test(&trial_fes, &test_fes);
+   MixedBilinearForm k_test_t(&test_fes, &trial_fes);
+   auto AddIntegrator = [&bdr_integ](MixedBilinearForm &k,
+                                     BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*mcoeff));
+         }
+         break;
+      case Problem::MixedVectorCurl:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*mcoeff));
+         }
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   k_ref.Assemble();
+   k_ref.Finalize();
+
+   k_test.SetAssemblyLevel(assembly);
+   k_test.Assemble();
+
+   k_test_t.SetAssemblyLevel(assembly);
+   k_test_t.Assemble();
+
+   // Compare ceed with mfem
+   GridFunction x(&trial_fes), y_ref(&test_fes), y_test(&test_fes);
+   GridFunction x_t(&test_fes), y_t_ref(&trial_fes), y_t_test(&trial_fes);
+
+   x.Randomize(1);
+
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
+
+   y_test -= y_ref;
+
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   x_t.Randomize(1);
+
+   k_ref.MultTranspose(x_t, y_t_ref);
+   k_test_t.Mult(x_t, y_t_test);
+
+   y_t_test.Add((pb == Problem::MixedVectorCurl) ? -1.0 : 1.0, y_t_ref);
+
+   REQUIRE(y_t_test.Norml2() < 1.e-12 * std::max(y_t_ref.Norml2(), 1.0));
+   delete gf;
+   delete coeff_fes;
+   delete coeff;
+   delete vcoeff;
+   delete mcoeff;
+   delete trial_fec;
+   delete test_fec;
+}
+
+void test_ceed_nloperator(const char *input, int order,
                           const CeedCoeffType coeff_type,
                           const NLProblem pb, const AssemblyLevel assembly)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
-                         "mesh: " + mesh_filename;
+                         "mesh: " + input;
    INFO(section);
-   Mesh mesh(mesh_filename, 1, 1);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
@@ -418,15 +1066,18 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!vcoeff && !mcoeff,
+               "Unexpected vector- or matrix-valued coefficient in test_ceed_nloperator.");
 
    // Build the NonlinearForm
    bool vecOp = pb == NLProblem::Convection;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
 
-   NonlinearForm k_test(&fes);
    NonlinearForm k_ref(&fes);
+   NonlinearForm k_test(&fes);
    switch (pb)
    {
       case NLProblem::Convection:
@@ -435,42 +1086,48 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
          break;
    }
 
+   k_ref.Setup();
    k_test.SetAssemblyLevel(assembly);
    k_test.Setup();
-   k_ref.Setup();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
 // This function specifically tests convection of a vector valued quantity and
 // using a custom integration rule. The integration rule is chosen s.t. in
 // combination with an appropriate order, it can represent the analytical
 // polynomial functions correctly.
-void test_ceed_convection(const char* mesh_filename, int order,
+void test_ceed_convection(const char *input, int order,
                           const AssemblyLevel assembly)
 {
-   Mesh mesh(mesh_filename, 1, 1);
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
    VectorFunctionCoefficient velocity_coeff(dim, velocity_function);
 
-   FiniteElementSpace fes(&mesh, &fec, dim);
+   FiniteElementSpace fes(&mesh, &fec, 1);
+   FiniteElementSpace vfes(&mesh, &fec, dim);
    BilinearForm conv_op(&fes);
 
    IntegrationRules rules(0, Quadrature1D::GaussLobatto);
@@ -483,7 +1140,7 @@ void test_ceed_convection(const char* mesh_filename, int order,
    conv_op.SetAssemblyLevel(assembly);
    conv_op.Assemble();
 
-   GridFunction q(&fes), r(&fes), ex(&fes);
+   GridFunction q(&vfes), r(&vfes), ex(&vfes);
 
    VectorFunctionCoefficient quantity_coeff(dim, quantity);
    q.ProjectCoefficient(quantity_coeff);
@@ -492,9 +1149,15 @@ void test_ceed_convection(const char* mesh_filename, int order,
    ex.ProjectCoefficient(convected_quantity_coeff);
 
    r = 0.0;
-   conv_op.Mult(q, r);
+   for (int i = 0; i < dim; i++)
+   {
+      GridFunction qi, ri;
+      qi.MakeRef(&fes, q, i * fes.GetVSize());
+      ri.MakeRef(&fes, r, i * fes.GetVSize());
+      conv_op.Mult(qi, ri);
+   }
 
-   LinearForm f(&fes);
+   LinearForm f(&vfes);
    VectorDomainLFIntegrator *vlf_integ = new VectorDomainLFIntegrator(
       convected_quantity_coeff);
    vlf_integ->SetIntRule(&ir);
@@ -503,27 +1166,465 @@ void test_ceed_convection(const char* mesh_filename, int order,
 
    r -= f;
 
-   REQUIRE(r.Norml2() < 1e-12);
+   REQUIRE(r.Norml2() < 1.e-12 * std::max(f.Norml2(), 1.0));
+}
+
+void test_ceed_full_assembly(const char *input, int order,
+                             const AssemblyLevel assembly)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+
+   DenseMatrix val(dim);
+   val = 0.0;
+   for (int i = 0; i < dim; i++)
+   {
+      val(i, i) = 1.0 + i;
+   }
+   MatrixConstantCoefficient diff_coeff(val);
+   ConstantCoefficient mass_coeff(1.0);
+
+   for (int t = 0; t < 3; t++)
+   {
+      FiniteElementCollection *fec = nullptr;
+      switch (t)
+      {
+         case 0:
+            fec = new H1_FECollection(order, dim);
+            break;
+         case 1:
+            fec = new ND_FECollection(order, dim);
+            break;
+         case 2:
+            fec = new RT_FECollection(order - 1, dim);
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      FiniteElementSpace fes(&mesh, fec, 1);
+      BilinearForm k_test(&fes);
+      BilinearForm k_ref(&fes);
+
+      switch (t)
+      {
+         case 0:
+            k_ref.AddDomainIntegrator(new DiffusionIntegrator2(diff_coeff));
+            k_ref.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+            k_ref.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               k_test.AddDomainIntegrator(new DiffusionIntegrator2(diff_coeff));
+               k_test.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+            }
+            else
+            {
+               k_test.AddDomainIntegrator(new DiffusionMassIntegrator(diff_coeff, mass_coeff));
+            }
+            k_test.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+            break;
+         case 1:
+            if (dim < 3)
+            {
+               k_ref.AddDomainIntegrator(new CurlCurlIntegrator2(mass_coeff));
+            }
+            else
+            {
+               k_ref.AddDomainIntegrator(new CurlCurlIntegrator2(diff_coeff));
+            }
+            k_ref.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            k_ref.AddBoundaryIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               if (dim < 3)
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlIntegrator2(mass_coeff));
+               }
+               else
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlIntegrator2(diff_coeff));
+               }
+               k_test.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            }
+            else
+            {
+               if (dim < 3)
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlMassIntegrator(mass_coeff, mass_coeff));
+               }
+               else
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlMassIntegrator(diff_coeff, mass_coeff));
+               }
+            }
+            k_test.AddBoundaryIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            break;
+         case 2:
+            k_ref.AddDomainIntegrator(new DivDivIntegrator2(mass_coeff));
+            k_ref.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               k_test.AddDomainIntegrator(new DivDivIntegrator2(mass_coeff));
+               k_test.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            }
+            else
+            {
+               k_test.AddDomainIntegrator(new DivDivMassIntegrator(mass_coeff, mass_coeff));
+            }
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      k_ref.Assemble();
+      k_ref.Finalize();
+
+      k_test.SetAssemblyLevel(assembly);
+      k_test.Assemble();
+
+      SparseMatrix *mat_ref = &k_ref.SpMat();
+      SparseMatrix *mat_test = ceed::CeedOperatorFullAssemble(k_test);
+      SparseMatrix *mat_diff = Add(1.0, *mat_ref, -1.0, *mat_test);
+
+      REQUIRE(mat_diff->MaxNorm() < 1.e-12 * std::max(mat_ref->MaxNorm(), 1.0));
+      delete mat_diff;
+      delete mat_test;
+      delete fec;
+   }
 }
 
-TEST_CASE("CEED mass & diffusion", "[CEED]")
+void test_ceed_linear_interpolator(const char *input, int order)
+{
+   std::string section = "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   H1_FECollection h1_fec(order, dim);
+   ND_FECollection nd_fec(order, dim);
+   RT_FECollection rt_fec(order - 1, dim);
+
+   // Build the DiscreteLinearOperator
+   FiniteElementSpace h1_fes(&mesh, &h1_fec);
+   FiniteElementSpace nd_fes(&mesh, &nd_fec);
+   FiniteElementSpace rt_fes(&mesh, &rt_fec);
+
+   // Discrete gradient
+   DiscreteLinearOperator grad_ref(&h1_fes, &nd_fes);
+   DiscreteLinearOperator grad_test(&h1_fes, &nd_fes);
+   grad_ref.AddDomainInterpolator(new GradientInterpolator);
+   grad_test.AddDomainInterpolator(new GradientInterpolator);
+
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_grad_ref, chrono_setup_grad_test;
+   StopWatch chrono_apply_grad_ref, chrono_apply_grad_test;
+   StopWatch chrono_apply_id_ref, chrono_apply_id_test;
+   chrono_setup_grad_ref.Clear();
+   chrono_setup_grad_ref.Start();
+
+   grad_ref.Assemble();
+   grad_ref.Finalize();
+
+   chrono_setup_grad_ref.Stop();
+   chrono_setup_grad_test.Clear();
+   chrono_setup_grad_test.Start();
+
+   grad_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   grad_test.Assemble();
+
+   chrono_setup_grad_test.Stop();
+
+   // Compare ceed with mfem
+   {
+      GridFunction x(&h1_fes), y_ref(&nd_fes), y_test(&nd_fes);
+      GridFunction x_t(&nd_fes), y_t_ref(&h1_fes), y_t_test(&h1_fes);
+
+      x.Randomize(1);
+
+      chrono_apply_grad_ref.Clear();
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.Mult(x, y_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Clear();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.Mult(x, y_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_test -= y_ref;
+
+      REQUIRE(y_test.Norml2() < 1.e-12);
+
+      x_t.Randomize(1);
+
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.MultTranspose(x_t, y_t_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.MultTranspose(x_t, y_t_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_t_test -= y_t_ref;
+
+      REQUIRE(y_t_test.Norml2() < 1.e-12);
+   }
+
+   // Discrete curl
+   if (dim == 3)
+   {
+      DiscreteLinearOperator curl_ref(&nd_fes, &rt_fes);
+      DiscreteLinearOperator curl_test(&nd_fes, &rt_fes);
+      curl_ref.AddDomainInterpolator(new CurlInterpolator);
+      curl_test.AddDomainInterpolator(new CurlInterpolator);
+
+      curl_ref.Assemble();
+      curl_ref.Finalize();
+
+      curl_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+      curl_test.Assemble();
+
+      // Compare ceed with mfem
+      {
+         GridFunction x(&nd_fes), y_ref(&rt_fes), y_test(&rt_fes);
+         GridFunction x_t(&rt_fes), y_t_ref(&nd_fes), y_t_test(&nd_fes);
+
+         x.Randomize(1);
+
+         curl_ref.Mult(x, y_ref);
+         curl_test.Mult(x, y_test);
+
+         y_test -= y_ref;
+
+         REQUIRE(y_test.Norml2() < 1.e-10);
+
+         x_t.Randomize(1);
+
+         curl_ref.MultTranspose(x_t, y_t_ref);
+         curl_test.MultTranspose(x_t, y_t_test);
+
+         y_t_test -= y_t_ref;
+
+         REQUIRE(y_t_test.Norml2() < 1.e-10);
+      }
+   }
+
+   // Prolongation and restriction
+   H1_FECollection fine_h1_fec(order + 1, dim);
+   ND_FECollection fine_nd_fec(order + 1, dim);
+   RT_FECollection fine_rt_fec(order, dim);
+
+   FiniteElementSpace fine_h1_fes(&mesh, &fine_h1_fec);
+   FiniteElementSpace fine_nd_fes(&mesh, &fine_nd_fec);
+   FiniteElementSpace fine_rt_fes(&mesh, &fine_rt_fec);
+
+   DiscreteLinearOperator id_h1_test(&h1_fes, &fine_h1_fes);
+   DiscreteLinearOperator id_nd_test(&nd_fes, &fine_nd_fes);
+   DiscreteLinearOperator id_rt_test(&rt_fes, &fine_rt_fes);
+   id_h1_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_nd_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_rt_test.AddDomainInterpolator(new IdentityInterpolator);
+
+   id_h1_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_h1_test.Assemble();
+
+   id_nd_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_nd_test.Assemble();
+
+   id_rt_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_rt_test.Assemble();
+
+   TransferOperator id_h1_ref(h1_fes, fine_h1_fes);
+   TransferOperator id_nd_ref(nd_fes, fine_nd_fes);
+   TransferOperator id_rt_ref(rt_fes, fine_rt_fes);
+
+   // Compare ceed with mfem
+   for (int t = 0; t < 3; t++)
+   {
+      GridFunction *x = nullptr, *y_t_ref = nullptr, *y_t_test = nullptr;
+      GridFunction *y_exact = nullptr, *y_ref = nullptr, *y_test = nullptr;
+      switch (t)
+      {
+         case 0:
+            x = new GridFunction(&h1_fes);
+            y_t_ref = new GridFunction(&h1_fes);
+            y_t_test = new GridFunction(&h1_fes);
+            y_exact = new GridFunction(&fine_h1_fes);
+            y_ref = new GridFunction(&fine_h1_fes);
+            y_test = new GridFunction(&fine_h1_fes);
+            break;
+         case 1:
+            x = new GridFunction(&nd_fes);
+            y_t_ref = new GridFunction(&nd_fes);
+            y_t_test = new GridFunction(&nd_fes);
+            y_exact = new GridFunction(&fine_nd_fes);
+            y_ref = new GridFunction(&fine_nd_fes);
+            y_test = new GridFunction(&fine_nd_fes);
+            break;
+         case 2:
+            x = new GridFunction(&rt_fes);
+            y_t_ref = new GridFunction(&rt_fes);
+            y_t_test = new GridFunction(&rt_fes);
+            y_exact = new GridFunction(&fine_rt_fes);
+            y_ref = new GridFunction(&fine_rt_fes);
+            y_test = new GridFunction(&fine_rt_fes);
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      if (t == 0)
+      {
+         FunctionCoefficient f_coeff(coeff_function);
+         x->ProjectCoefficient(f_coeff);
+         y_exact->ProjectCoefficient(f_coeff);
+      }
+      else
+      {
+         VectorFunctionCoefficient vf_coeff(dim, velocity_function);
+         x->ProjectCoefficient(vf_coeff);
+         y_exact->ProjectCoefficient(vf_coeff);
+      }
+
+      chrono_apply_id_ref.Clear();
+      chrono_apply_id_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_ref.Mult(*x, *y_ref);
+               id_h1_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 1:
+               id_nd_ref.Mult(*x, *y_ref);
+               id_nd_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 2:
+               id_rt_ref.Mult(*x, *y_ref);
+               id_rt_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_ref.Stop();
+      chrono_apply_id_test.Clear();
+      chrono_apply_id_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_test.Mult(*x, *y_test);
+               id_h1_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 1:
+               id_nd_test.Mult(*x, *y_test);
+               id_nd_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 2:
+               id_rt_test.Mult(*x, *y_test);
+               id_rt_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_test.Stop();
+
+      *y_test -= *y_ref;
+
+      REQUIRE(y_test->Norml2() < 1.e-10);
+
+      *y_t_test -= *y_t_ref;
+
+      REQUIRE(y_t_test->Norml2() < 1.e-10);
+      delete x;
+      delete y_t_ref;
+      delete y_t_test;
+      delete y_exact;
+      delete y_ref;
+      delete y_test;
+   }
+
+   if (debug)
+   {
+      out << "\n" << section << "\n";
+      out << "benchmark (unknowns: H1: " << h1_fes.GetTrueVSize()
+          << ", ND: " << nd_fes.GetTrueVSize()
+          << ", RT: " << rt_fes.GetTrueVSize() << ",\n"
+          << "                     fine H1: " << fine_h1_fes.GetTrueVSize()
+          << ", fine ND: " << fine_nd_fes.GetTrueVSize()
+          << ", fine RT: " << fine_rt_fes.GetTrueVSize() << ")\n"
+          << "    discrete gradient interpolator\n"
+          << "    setup: ref = "
+          << chrono_setup_grad_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_grad_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_grad_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_grad_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    identity interpolator\n"
+          << "    apply: ref = "
+          << chrono_apply_id_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_id_test.RealTime() * 1e3 / trials << " ms\n";
+   }
+}
+
+TEST_CASE("CEED mass and diffusion", "[CEED]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
                               CeedCoeffType::Quad);
-   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,
                       Problem::VectorMass,Problem::VectorDiffusion);
-   auto order = GENERATE(1);
+   auto order = GENERATE(1,2);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
-                        "../../data/periodic-square.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   test_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
 TEST_CASE("CEED p-adaptivity", "[CEED]")
@@ -531,7 +1632,7 @@ TEST_CASE("CEED p-adaptivity", "[CEED]")
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
                               CeedCoeffType::Quad);
-   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,
                       Problem::VectorMass,Problem::VectorDiffusion);
    auto order = GENERATE(1);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
@@ -539,46 +1640,97 @@ TEST_CASE("CEED p-adaptivity", "[CEED]")
                         "../../data/star-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/square-mixed.mesh");
-   test_mixed_p_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = true;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection low", "[CEED],[Convection]")
+TEST_CASE("CEED vector FE operators", "[CEED], [VectorFE]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
-   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
-                              CeedCoeffType::VecQuad);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::HDivMass,Problem::DivDiv,Problem::HDivMassDivDiv,
+                      Problem::HCurlMass,Problem::CurlCurl,Problem::HCurlMassCurlCurl);
+   auto order = GENERATE(1,2);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   Problem pb = Problem::Convection;
+   test_ceed_vectorfe_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
+} // test case
 
-   // Test that the CEED and MFEM integrators give the same answer
-   int low_order = 1;
-   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly);
+TEST_CASE("CEED mixed integrators",
+          "[CEED], [MixedVectorIntegrator], [VectorFE]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::MixedVectorGradient,Problem::MixedVectorCurl);
+   auto order = GENERATE(2);
+   auto bdr_integ = GENERATE(false,true);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   test_ceed_mixed_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection high", "[CEED],[Convection]")
+TEST_CASE("CEED convection low", "[CEED], [Convection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
+                              CeedCoeffType::VecQuad);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
-                        "../../data/fichera-amr.mesh");
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   Problem pb = Problem::Convection;
+   int low_order = 1;
+   bool mixed_p = false;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly, mixed_p,
+                      bdr_integ);
+} // test case
 
+TEST_CASE("CEED convection high", "[CEED], [Convection]")
+{
    // Apply the CEED convection integrator applied to a vector quantity, check
    // that we get the exact answer (with sufficiently high polynomial degree)
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/periodic-square.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh");
    int high_order = 4;
    test_ceed_convection(mesh, high_order, assembly);
 } // test case
 
-TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
+TEST_CASE("CEED nonlinear convection", "[CEED], [NLConvection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
@@ -587,6 +1739,8 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    auto order = GENERATE(1);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera.mesh",
@@ -595,6 +1749,37 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    test_ceed_nloperator(mesh, order, coeff_type, pb, assembly);
 } // test case
 
+TEST_CASE("CEED full assembly", "[CEED]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 2;
+   test_ceed_full_assembly(mesh, order, assembly);
+} // test case
+
+TEST_CASE("CEED linear interpolators", "[CEED]")
+{
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 2;
+   test_ceed_linear_interpolator(mesh, order);
+} // test case
+
 #endif
 
 } // namespace ceed_test
diff --git a/tests/unit/enzyme/compatibility.cpp b/tests/unit/enzyme/compatibility.cpp
index 8cbb658d1..118f11b12 100644
--- a/tests/unit/enzyme/compatibility.cpp
+++ b/tests/unit/enzyme/compatibility.cpp
@@ -8,38 +8,40 @@
 template<typename VectorT>
 void square(const VectorT& v, double& y)
 {
-  for (int i = 0; i < 4; i++) {
-    y += v[i]*v[i];
-  }
+   for (int i = 0; i < 4; i++)
+   {
+      y += v[i]*v[i];
+   }
 }
 
 template<typename VectorT>
 void dsquare(const VectorT& v, double& y, VectorT& dydv)
 {
-  double seed = 1.0;
-  __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
+   double seed = 1.0;
+   __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
 }
 
 template<typename VectorT>
-void run_test() {
-  VectorT v(4);
-  v[0] = 2.0;
-  v[1] = 3.0;
-  v[2] = 1.0;
-  v[3] = 7.0;
-
-  double yy = 0;
-  VectorT dydv(4);
-  dydv[0] = 0;
-  dydv[1] = 0;
-  dydv[2] = 0;
-  dydv[3] = 0;
-  dsquare(v, yy, dydv);
-
-  REQUIRE(dydv[0] == MFEM_Approx(4.0));
-  REQUIRE(dydv[1] == MFEM_Approx(6.0));
-  REQUIRE(dydv[2] == MFEM_Approx(2.0));
-  REQUIRE(dydv[3] == MFEM_Approx(14.0));
+void run_test()
+{
+   VectorT v(4);
+   v[0] = 2.0;
+   v[1] = 3.0;
+   v[2] = 1.0;
+   v[3] = 7.0;
+
+   double yy = 0;
+   VectorT dydv(4);
+   dydv[0] = 0;
+   dydv[1] = 0;
+   dydv[2] = 0;
+   dydv[3] = 0;
+   dsquare(v, yy, dydv);
+
+   REQUIRE(dydv[0] == MFEM_Approx(4.0));
+   REQUIRE(dydv[1] == MFEM_Approx(6.0));
+   REQUIRE(dydv[2] == MFEM_Approx(2.0));
+   REQUIRE(dydv[3] == MFEM_Approx(14.0));
 }
 
 TEST_CASE("AD Vector implementation", "[Enzyme]")
