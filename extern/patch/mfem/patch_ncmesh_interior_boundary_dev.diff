diff --git a/CHANGELOG b/CHANGELOG
index e76cda016..b01affc9b 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -15,6 +15,8 @@ Discretization improvements
 ---------------------------
 - Introduced support for higher order non conformal Nedelec elements on
   simplices in ParMesh.
+- Introduced support for internal boundary elements in nonconformal adapted
+  meshes.
 
 - Added functionality for construction of cut-surface and cut-volume
   IntegrationRules through a moment-fitting approach. The cut is specified by
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index 2fee83d19..e0e7a6b27 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -1074,7 +1074,8 @@ void BilinearForm::EliminateEssentialBCFromDofs(
 void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
                                                  DiagonalPolicy dpolicy)
 {
-   MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
+   MFEM_ASSERT(ess_dofs.Size() == height,
+               "incorrect dof Array size: " << ess_dofs.Size() << ' ' << height);
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
@@ -1086,7 +1087,8 @@ void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
 void BilinearForm::EliminateEssentialBCFromDofsDiag (const Array<int> &ess_dofs,
                                                      double value)
 {
-   MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
+   MFEM_ASSERT(ess_dofs.Size() == height,
+               "incorrect dof Array size: " << ess_dofs.Size() << ' ' << height);
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 660fec17a..1462adc81 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -503,13 +503,11 @@ void FiniteElementSpace::BuildDofToArrays()
    }
 }
 
-static void mark_dofs(const Array<int> &dofs, Array<int> &mark_array)
+static void MarkDofs(const Array<int> &dofs, Array<int> &mark_array)
 {
-   for (int i = 0; i < dofs.Size(); i++)
+   for (auto d : dofs)
    {
-      int k = dofs[i];
-      if (k < 0) { k = -1 - k; }
-      mark_array[k] = -1;
+      mark_array[d >= 0 ? d : -1 - d] = -1;
    }
 }
 
@@ -517,11 +515,9 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
                                            Array<int> &ess_vdofs,
                                            int component) const
 {
-   Array<int> vdofs, dofs;
-
+   Array<int> dofs;
    ess_vdofs.SetSize(GetVSize());
    ess_vdofs = 0;
-
    for (int i = 0; i < GetNBE(); i++)
    {
       if (bdr_attr_is_ess[GetBdrAttribute(i)-1])
@@ -529,16 +525,14 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
          if (component < 0)
          {
             // Mark all components.
-            GetBdrElementVDofs(i, vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetBdrElementVDofs(i, dofs);
          }
          else
          {
             GetBdrElementDofs(i, dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 
@@ -546,38 +540,47 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
    // local DOFs affected by boundary elements on other processors
    if (Nonconforming())
    {
-      Array<int> bdr_verts, bdr_edges;
-      mesh->ncmesh->GetBoundaryClosure(bdr_attr_is_ess, bdr_verts, bdr_edges);
-
-      for (int i = 0; i < bdr_verts.Size(); i++)
+      Array<int> bdr_verts, bdr_edges, bdr_faces;
+      mesh->ncmesh->GetBoundaryClosure(bdr_attr_is_ess, bdr_verts, bdr_edges,
+                                       bdr_faces);
+      for (auto v : bdr_verts)
+      {
+         if (component < 0)
+         {
+            GetVertexVDofs(v, dofs);
+         }
+         else
+         {
+            GetVertexDofs(v, dofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
+         }
+         MarkDofs(dofs, ess_vdofs);
+      }
+      for (auto e : bdr_edges)
       {
          if (component < 0)
          {
-            GetVertexVDofs(bdr_verts[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetEdgeVDofs(e, dofs);
          }
          else
          {
-            GetVertexDofs(bdr_verts[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            GetEdgeDofs(e, dofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
-      for (int i = 0; i < bdr_edges.Size(); i++)
+      for (auto f : bdr_faces)
       {
          if (component < 0)
          {
-            GetEdgeVDofs(bdr_edges[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetEntityVDofs(2, f, dofs);
          }
          else
          {
-            GetEdgeDofs(bdr_edges[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            GetEntityDofs(2, f, dofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 }
@@ -596,6 +599,30 @@ void FiniteElementSpace::GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
    else
    {
       R->BooleanMult(ess_vdofs, ess_tdofs);
+#ifdef MFEM_DEBUG
+      // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs
+      Array<int> ess_tdofs2(ess_tdofs.Size());
+      GetConformingProlongation()->BooleanMultTranspose(ess_vdofs, ess_tdofs2);
+
+      int counter = 0;
+      std::string error_msg = "failed dof: ";
+      for (int i = 0; i < ess_tdofs2.Size(); ++i)
+      {
+         if (bool(ess_tdofs[i]) != bool(ess_tdofs2[i]))
+         {
+            error_msg += std::to_string(i) += "(R ";
+            error_msg += std::to_string(bool(ess_tdofs[i])) += " P^T ";
+            error_msg += std::to_string(bool(ess_tdofs2[i])) += ") ";
+            counter++;
+         }
+      }
+
+      MFEM_ASSERT(R->Height() == GetConformingProlongation()->Width(), "!");
+      MFEM_ASSERT(R->Width() == GetConformingProlongation()->Height(), "!");
+      MFEM_ASSERT(R->Width() == ess_vdofs.Size(), "!");
+      MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter
+                  << ' ' << error_msg);
+#endif
    }
    MarkerToList(ess_tdofs, ess_tdof_list);
 }
@@ -944,6 +971,15 @@ int FiniteElementSpace::GetEntityDofs(int entity, int index, Array<int> &dofs,
    }
 }
 
+int FiniteElementSpace::GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                                       Geometry::Type master_geom,
+                                       int variant) const
+{
+   int n = GetEntityDofs(entity, index, dofs, master_geom, variant);
+   DofsToVDofs(dofs);
+   return n;
+}
+
 void FiniteElementSpace::BuildConformingInterpolation() const
 {
 #ifdef MFEM_USE_MPI
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 0fd44b613..cd0f861a0 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -383,6 +383,10 @@ protected:
    int GetEntityDofs(int entity, int index, Array<int> &dofs,
                      Geometry::Type master_geom = Geometry::INVALID,
                      int variant = 0) const;
+   /// Helper to get vertex, edge or face VDOFs (entity=0,1,2 resp.).
+   int GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                      Geometry::Type master_geom = Geometry::INVALID,
+                      int variant = 0) const;
 
    // Get degenerate face DOFs: see explanation in method implementation.
    int GetDegenerateFaceDofs(int index, Array<int> &dofs,
@@ -840,6 +844,7 @@ public:
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
+   ///
    /// In variable order spaces, multiple variants of DOFs can be returned.
    /// See GetEdgeDofs() for more details.
    /// @return Order of the selected variant, or -1 if there are no more
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index 52620452f..310d8d704 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -2125,8 +2125,8 @@ void GridFunction::AccumulateAndCountBdrValues(
       Vector vals;
       Mesh *mesh = fes->GetMesh();
       NCMesh *ncmesh = mesh->ncmesh;
-      Array<int> bdr_edges, bdr_vertices;
-      ncmesh->GetBoundaryClosure(attr, bdr_vertices, bdr_edges);
+      Array<int> bdr_edges, bdr_vertices, bdr_faces;
+      ncmesh->GetBoundaryClosure(attr, bdr_vertices, bdr_edges, bdr_faces);
 
       for (i = 0; i < bdr_edges.Size(); i++)
       {
@@ -2232,8 +2232,8 @@ void GridFunction::AccumulateAndCountBdrTangentValues(
    {
       Mesh *mesh = fes->GetMesh();
       NCMesh *ncmesh = mesh->ncmesh;
-      Array<int> bdr_edges, bdr_vertices;
-      ncmesh->GetBoundaryClosure(bdr_attr, bdr_vertices, bdr_edges);
+      Array<int> bdr_edges, bdr_vertices, bdr_faces;
+      ncmesh->GetBoundaryClosure(bdr_attr, bdr_vertices, bdr_edges, bdr_faces);
 
       for (int i = 0; i < bdr_edges.Size(); i++)
       {
diff --git a/fem/gridfunc.hpp b/fem/gridfunc.hpp
index 245d00078..50d7c1105 100644
--- a/fem/gridfunc.hpp
+++ b/fem/gridfunc.hpp
@@ -586,6 +586,10 @@ public:
       return ComputeLpError(infinity(), exsol, NULL, NULL, irs);
    }
 
+   virtual double ComputeL1Error(Coefficient *exsol[],
+                                 const IntegrationRule *irs[] = NULL) const
+   { return ComputeW11Error(*exsol, NULL, 1, NULL, irs); }
+
    virtual double ComputeL1Error(Coefficient &exsol,
                                  const IntegrationRule *irs[] = NULL) const
    { return ComputeLpError(1.0, exsol, NULL, irs); }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 74ef3f3b9..272021d3d 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -90,20 +90,19 @@ ParNURBSExtension *ParFiniteElementSpace::MakeLocalNURBSext(
 void ParFiniteElementSpace::ParInit(ParMesh *pm)
 {
    pmesh = pm;
-   pncmesh = NULL;
+   pncmesh = nullptr;
 
    MyComm = pmesh->GetComm();
    NRanks = pmesh->GetNRanks();
    MyRank = pmesh->GetMyRank();
 
-   gcomm = NULL;
+   gcomm = nullptr;
 
-   P = NULL;
-   Pconf = NULL;
+   P = nullptr;
+   Pconf = nullptr;
    nonconf_P = false;
-   Rconf = NULL;
-   R = NULL;
-
+   Rconf = nullptr;
+   R = nullptr;
    num_face_nbr_dofs = -1;
 
    if (NURBSext && !pNURBSext())
@@ -519,7 +518,7 @@ void ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs,
 int ParFiniteElementSpace::GetFaceDofs(int i, Array<int> &dofs,
                                        int variant) const
 {
-   if (face_dof && variant == 0)
+   if (face_dof != nullptr && variant == 0)
    {
       face_dof->GetRow(i, dofs);
       return fec->GetOrder();
@@ -1039,18 +1038,28 @@ void ParFiniteElementSpace::GetEssentialTrueDofs(const Array<int>
 #ifdef MFEM_DEBUG
    // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs.
    Array<int> true_ess_dofs2(true_ess_dofs.Size());
-   HypreParMatrix *Pt = Dof_TrueDof_Matrix()->Transpose();
+   auto Pt = std::unique_ptr<HypreParMatrix>(Dof_TrueDof_Matrix()->Transpose());
+
    const int *ess_dofs_data = ess_dofs.HostRead();
    Pt->BooleanMult(1, ess_dofs_data, 0, true_ess_dofs2);
-   delete Pt;
    int counter = 0;
    const int *ted = true_ess_dofs.HostRead();
+   std::string error_msg = "failed dof: ";
    for (int i = 0; i < true_ess_dofs.Size(); i++)
    {
-      if (bool(ted[i]) != bool(true_ess_dofs2[i])) { counter++; }
+      if (bool(ted[i]) != bool(true_ess_dofs2[i]))
+      {
+         error_msg += std::to_string(i) += "(R ";
+         error_msg += std::to_string(bool(ted[i])) += " P^T ";
+         error_msg += std::to_string(bool(true_ess_dofs2[i])) += ") ";
+         ++counter;
+      }
    }
+   MFEM_ASSERT(R->Height() == P->Width(), "!");
+   MFEM_ASSERT(R->Width() == P->Height(), "!");
+   MFEM_ASSERT(R->Width() == ess_dofs.Size(), "!");
    MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter
-               << ", rank = " << MyRank);
+               << ", rank = " << MyRank << ", " << error_msg);
 #endif
 
    MarkerToList(true_ess_dofs, ess_tdof_list);
@@ -1945,8 +1954,7 @@ struct PMatrixRow
       elems.reserve(elems.size() + other.elems.size());
       for (const PMatrixElement &oei : other.elems)
       {
-         elems.push_back(
-            PMatrixElement(oei.column, oei.stride, coef * oei.value));
+         elems.emplace_back(oei.column, oei.stride, coef * oei.value);
       }
    }
 
@@ -2022,7 +2030,7 @@ public:
    void AddRow(int entity, int index, int edof, GroupId group,
                const PMatrixRow &row)
    {
-      rows.push_back(RowInfo(entity, index, edof, group, row));
+      rows.emplace_back(entity, index, edof, group, row);
    }
 
    const std::vector<RowInfo>& GetRows() const { return rows; }
@@ -2038,8 +2046,8 @@ protected:
    ParNCMesh *pncmesh;
    const FiniteElementCollection* fec;
 
-   virtual void Encode(int rank);
-   virtual void Decode(int);
+   void Encode(int rank) override;
+   void Decode(int) override;
 };
 
 void NeighborRowMessage::Encode(int rank)
@@ -2158,6 +2166,11 @@ void NeighborRowMessage::Decode(int rank)
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
+         // P2 tri faces have dofs that must be processed in pairs, as the doftransformation
+         // is not diagonal.
+         const bool process_dof_pairs = (ent == 2 &&
+                                         fec->GetContType() == FiniteElementCollection::TANGENTIAL
+                                         && !Geometry::IsTensorProduct(geom));
 
 #ifdef MFEM_DEBUG_PMATRIX
          mfem::out << "Rank " << pncmesh->MyRank << " receiving from " << rank
@@ -2177,7 +2190,7 @@ void NeighborRowMessage::Decode(int rank)
 
          // Create a row for this entity, recording the index of the mesh
          // element
-         rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
+         rows.emplace_back(ent, id.index, edof, group_ids[gi++]);
          rows.back().row.read(stream, s);
 
 #ifdef MFEM_DEBUG_PMATRIX
@@ -2187,8 +2200,7 @@ void NeighborRowMessage::Decode(int rank)
                    << std::endl;
 #endif
 
-         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
-             && !Geometry::IsTensorProduct(geom))
+         if (process_dof_pairs)
          {
             // ND face dofs need to be processed together, as the transformation
             // is given by a 2x2 matrix, so we manually apply an extra increment
@@ -2209,8 +2221,10 @@ void NeighborRowMessage::Decode(int rank)
             // there is no hidden copying that could result in a dangling
             // reference.
             auto &first_row = rows.back().row;
+
             // This is the first "fundamental unit" used in the transformation.
             const auto initial_first_row = first_row;
+
             // Extract the next dof too, and apply any dof order transformation
             // expected.
             const MeshId &next_id = ids[++i];
@@ -2226,15 +2240,34 @@ void NeighborRowMessage::Decode(int rank)
                edof = -1 - edof;
                s *= -1.0;
             }
-            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+
+            rows.emplace_back(ent, next_id.index, edof, group_ids[gi++]);
             rows.back().row.read(stream, s);
             auto &second_row = rows.back().row;
 
             // This is the second "fundamental unit" used in the transformation.
             const auto initial_second_row = second_row;
+
+            // Transform the received dofs by the primal transform. This is
+            // because within mfem as a face is visited its orientation is
+            // asigned to match the element that visited it first. Thus on
+            // processor boundaries, the transform will always be identity
+            // going into the element. However, the sending processor also
+            // thought the face orientation was zero, so it has sent the
+            // information in a different orientation. To map onto the local
+            // orientation definition, extract the orientation of the sending
+            // rank (the lower rank face defines the orientation fo), then
+            // apply the transform to the dependencies. The action of this
+            // transform on the dependencies is performed by adding scaled
+            // versions of the original two rows (which by the mfem assumption
+            // of face orientation, represent the identity transform).
+            MFEM_ASSERT(fo != 2 && fo != 4,
+                        "This code branch is ambiguous for face orientations 2 and 4."
+                        " Please report this mesh for further testing.\n");
             const double *T =
                ND_DofTransformation::GetFaceTransform(fo).GetData();
 
+            // Remove the identity matrix from the transformation.
             first_row.AddRow(initial_first_row, T[0] - 1.0);
             first_row.AddRow(initial_second_row, T[2]);
             second_row.AddRow(initial_first_row, T[1]);
@@ -2410,7 +2443,7 @@ int ParFiniteElementSpace
 
             if (master_dofs.Size() == 0) { continue; }
 
-            const FiniteElement* fe = fec->FiniteElementForGeometry(mf.Geom());
+            const FiniteElement * const fe = fec->FiniteElementForGeometry(mf.Geom());
             if (fe == nullptr) { continue; }
 
             switch (mf.Geom())
@@ -2439,7 +2472,6 @@ int ParFiniteElementSpace
             }
          }
       }
-
       deps.Finalize();
    }
 
@@ -2568,15 +2600,15 @@ int ParFiniteElementSpace
 
    // big container for all messages we send (the list is for iterations)
    std::list<NeighborRowMessage::Map> send_msg;
-   send_msg.push_back(NeighborRowMessage::Map());
+   send_msg.emplace_back();
 
    // put identity in P and R for true DOFs, set ldof_ltdof
    for (int dof = 0, tdof = 0; dof < ndofs; dof++)
    {
       if (finalized[dof])
       {
-         pmatrix[dof].elems.push_back(
-            PMatrixElement(my_tdof_offset + vdim_factor*tdof, tdof_stride, 1.));
+         pmatrix[dof].elems.emplace_back(my_tdof_offset + vdim_factor*tdof, tdof_stride,
+                                         1.);
 
          // prepare messages to neighbors with identity rows
          if (dof_group[dof] != 0)
@@ -2620,7 +2652,7 @@ int ParFiniteElementSpace
       // prepare a new round of send buffers
       if (send_msg.back().size())
       {
-         send_msg.push_back(NeighborRowMessage::Map());
+         send_msg.emplace_back();
       }
 
       // check for incoming messages, receive PMatrixRows
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index a410c669e..2b93230d5 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -124,8 +124,8 @@ private:
    void GetGhostVertexDofs(const MeshId &id, Array<int> &dofs) const;
    void GetGhostEdgeDofs(const MeshId &edge_id, Array<int> &dofs) const;
    void GetGhostFaceDofs(const MeshId &face_id, Array<int> &dofs) const;
-
    void GetGhostDofs(int entity, const MeshId &id, Array<int> &dofs) const;
+
    /// Return the dofs associated with the interior of the given mesh entity.
    void GetBareDofs(int entity, int index, Array<int> &dofs) const;
 
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index 98e59172b..e54609359 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -752,7 +752,8 @@ void ParGridFunction::ProjectBdrCoefficientTangent(VectorCoefficient &vcoeff,
    {
       MFEM_ASSERT(pfes->GetLocalTDofNumber(i) == -1 ||
                   bool(values_counter[i]) == bool(ess_vdofs_marker[i]),
-                  "internal error");
+                  "internal error: " << pfes->GetLocalTDofNumber(i) << ' ' << bool(
+                     values_counter[i]));
    }
 #endif
 }
diff --git a/fem/pgridfunc.hpp b/fem/pgridfunc.hpp
index bc422a260..041dc1c98 100644
--- a/fem/pgridfunc.hpp
+++ b/fem/pgridfunc.hpp
@@ -112,12 +112,12 @@ public:
 
    ParFiniteElementSpace *ParFESpace() const { return pfes; }
 
-   virtual void Update();
+   void Update() override;
 
    /// Associate a new FiniteElementSpace with the ParGridFunction.
    /** The ParGridFunction is resized using the SetSize() method. The new space
        @a f is expected to be a ParFiniteElementSpace. */
-   virtual void SetSpace(FiniteElementSpace *f);
+   void SetSpace(FiniteElementSpace *f) override;
 
    /// Associate a new parallel space with the ParGridFunction.
    void SetSpace(ParFiniteElementSpace *f);
@@ -130,7 +130,7 @@ public:
        ParGridFunction and sets the pointer @a v as external data in the
        ParGridFunction. The new space @a f is expected to be a
        ParFiniteElementSpace. */
-   virtual void MakeRef(FiniteElementSpace *f, double *v);
+   void MakeRef(FiniteElementSpace *f, double *v) override;
 
    /** @brief Make the ParGridFunction reference external data on a new
        ParFiniteElementSpace. */
@@ -147,7 +147,7 @@ public:
        expected to be a ParFiniteElementSpace.
        @note This version of the method will also perform bounds checks when
        the build option MFEM_DEBUG is enabled. */
-   virtual void MakeRef(FiniteElementSpace *f, Vector &v, int v_offset);
+   void MakeRef(FiniteElementSpace *f, Vector &v, int v_offset) override;
 
    /** @brief Make the ParGridFunction reference external data on a new
        ParFiniteElementSpace. */
@@ -166,7 +166,7 @@ public:
    void AddDistribute(double a, const Vector &tv) { AddDistribute(a, &tv); }
 
    /// Set the GridFunction from the given true-dof vector.
-   virtual void SetFromTrueDofs(const Vector &tv) { Distribute(tv); }
+   void SetFromTrueDofs(const Vector &tv) override { Distribute(tv); }
 
    /// Short semantic for Distribute()
    ParGridFunction &operator=(const HypreParVector &tv)
@@ -209,26 +209,26 @@ public:
    const Vector &FaceNbrData() const { return face_nbr_data; }
 
    // Redefine to handle the case when i is a face-neighbor element
-   virtual double GetValue(int i, const IntegrationPoint &ip,
-                           int vdim = 1) const;
+   double GetValue(int i, const IntegrationPoint &ip,
+                   int vdim = 1) const override;
    double GetValue(ElementTransformation &T)
    { return GetValue(T, T.GetIntPoint()); }
 
    // Redefine to handle the case when T describes a face-neighbor element
-   virtual double GetValue(ElementTransformation &T, const IntegrationPoint &ip,
-                           int comp = 0, Vector *tr = NULL) const;
+   double GetValue(ElementTransformation &T, const IntegrationPoint &ip,
+                   int comp = 0, Vector *tr = NULL) const override;
 
-   virtual void GetVectorValue(int i, const IntegrationPoint &ip,
-                               Vector &val) const;
+   void GetVectorValue(int i, const IntegrationPoint &ip,
+                       Vector &val) const override;
 
    // Redefine to handle the case when T describes a face-neighbor element
-   virtual void GetVectorValue(ElementTransformation &T,
-                               const IntegrationPoint &ip,
-                               Vector &val, Vector *tr = NULL) const;
+   void GetVectorValue(ElementTransformation &T,
+                       const IntegrationPoint &ip,
+                       Vector &val, Vector *tr = NULL) const override;
 
    /** @brief For each vdof, counts how many elements contain the vdof,
        as containment is determined by FiniteElementSpace::GetElementVDofs(). */
-   virtual void CountElementsPerVDof(Array<int> &elem_per_vdof) const;
+   void CountElementsPerVDof(Array<int> &elem_per_vdof) const override;
 
    /// Parallel version of GridFunction::GetDerivative(); see its documentation.
    void GetDerivative(int comp, int der_comp, ParGridFunction &der);
@@ -237,112 +237,111 @@ public:
        freedom of element @a el. If @a el is greater than or equal to the number
        of local elements, it will be interpreted as a shifted index of a face
        neighbor element. */
-   virtual void GetElementDofValues(int el, Vector &dof_vals) const;
+   void GetElementDofValues(int el, Vector &dof_vals) const override;
 
    using GridFunction::ProjectCoefficient;
-   virtual void ProjectCoefficient(Coefficient &coeff);
+   void ProjectCoefficient(Coefficient &coeff) override;
 
    using GridFunction::ProjectDiscCoefficient;
    /** @brief Project a discontinuous vector coefficient as a grid function on
        a continuous finite element space. The values in shared dofs are
        determined from the element with maximal attribute. */
-   virtual void ProjectDiscCoefficient(VectorCoefficient &coeff);
+   void ProjectDiscCoefficient(VectorCoefficient &coeff) override;
 
-   virtual void ProjectDiscCoefficient(Coefficient &coeff, AvgType type);
+   void ProjectDiscCoefficient(Coefficient &coeff, AvgType type) override;
 
-   virtual void ProjectDiscCoefficient(VectorCoefficient &vcoeff, AvgType type);
+   void ProjectDiscCoefficient(VectorCoefficient &vcoeff, AvgType type) override;
 
    using GridFunction::ProjectBdrCoefficient;
 
    // Only the values in the master are guaranteed to be correct!
-   virtual void ProjectBdrCoefficient(VectorCoefficient &vcoeff,
-                                      Array<int> &attr)
+   void ProjectBdrCoefficient(VectorCoefficient &vcoeff,
+                              Array<int> &attr) override
    { ProjectBdrCoefficient(NULL, &vcoeff, attr); }
 
    // Only the values in the master are guaranteed to be correct!
-   virtual void ProjectBdrCoefficient(Coefficient *coeff[], Array<int> &attr)
+   void ProjectBdrCoefficient(Coefficient *coeff[], Array<int> &attr) override
    { ProjectBdrCoefficient(coeff, NULL, attr); }
 
    // Only the values in the master are guaranteed to be correct!
-   virtual void ProjectBdrCoefficientTangent(VectorCoefficient &vcoeff,
-                                             Array<int> &bdr_attr);
+   void ProjectBdrCoefficientTangent(VectorCoefficient &vcoeff,
+                                     Array<int> &bdr_attr) override;
 
-   virtual double ComputeL1Error(Coefficient *exsol[],
-                                 const IntegrationRule *irs[] = NULL) const
+   double ComputeL1Error(Coefficient *exsol[],
+                         const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(1.0, GridFunction::ComputeW11Error(
                              *exsol, NULL, 1, NULL, irs), pfes->GetComm());
    }
 
-   virtual double ComputeL1Error(Coefficient &exsol,
-                                 const IntegrationRule *irs[] = NULL) const
+   double ComputeL1Error(Coefficient &exsol,
+                         const IntegrationRule *irs[] = NULL) const override
    { return ComputeLpError(1.0, exsol, NULL, irs); }
 
-   virtual double ComputeL1Error(VectorCoefficient &exsol,
-                                 const IntegrationRule *irs[] = NULL) const
+   double ComputeL1Error(VectorCoefficient &exsol,
+                         const IntegrationRule *irs[] = NULL) const override
    { return ComputeLpError(1.0, exsol, NULL, NULL, irs); }
 
-   virtual double ComputeL2Error(Coefficient *exsol[],
-                                 const IntegrationRule *irs[] = NULL,
-                                 const Array<int> *elems = NULL) const
+   double ComputeL2Error(Coefficient *exsol[],
+                         const IntegrationRule *irs[] = NULL,
+                         const Array<int> *elems = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeL2Error(exsol, irs, elems),
                           pfes->GetComm());
    }
 
-   virtual double ComputeL2Error(Coefficient &exsol,
-                                 const IntegrationRule *irs[] = NULL,
-                                 const Array<int> *elems = NULL) const
+   double ComputeL2Error(Coefficient &exsol,
+                         const IntegrationRule *irs[] = NULL,
+                         const Array<int> *elems = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeL2Error(exsol, irs, elems),
                           pfes->GetComm());
    }
 
 
-   virtual double ComputeL2Error(VectorCoefficient &exsol,
-                                 const IntegrationRule *irs[] = NULL,
-                                 const Array<int> *elems = NULL) const
+   double ComputeL2Error(VectorCoefficient &exsol,
+                         const IntegrationRule *irs[] = NULL,
+                         const Array<int> *elems = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeL2Error(exsol, irs, elems),
                           pfes->GetComm());
    }
 
    /// Returns ||grad u_ex - grad u_h||_L2 for H1 or L2 elements
-   virtual double ComputeGradError(VectorCoefficient *exgrad,
-                                   const IntegrationRule *irs[] = NULL) const
+   double ComputeGradError(VectorCoefficient *exgrad,
+                           const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeGradError(exgrad,irs),
                           pfes->GetComm());
    }
 
    /// Returns ||curl u_ex - curl u_h||_L2 for ND elements
-   virtual double ComputeCurlError(VectorCoefficient *excurl,
-                                   const IntegrationRule *irs[] = NULL) const
+   double ComputeCurlError(VectorCoefficient *excurl,
+                           const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeCurlError(excurl,irs),
                           pfes->GetComm());
    }
 
    /// Returns ||div u_ex - div u_h||_L2 for RT elements
-   virtual double ComputeDivError(Coefficient *exdiv,
-                                  const IntegrationRule *irs[] = NULL) const
+   double ComputeDivError(Coefficient *exdiv,
+                          const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeDivError(exdiv,irs),
                           pfes->GetComm());
    }
 
    /// Returns the Face Jumps error for L2 elements
-   virtual double ComputeDGFaceJumpError(Coefficient *exsol,
-                                         Coefficient *ell_coeff,
-                                         JumpScaling jump_scaling,
-                                         const IntegrationRule *irs[]=NULL)
-   const;
+   double ComputeDGFaceJumpError(Coefficient *exsol,
+                                 Coefficient *ell_coeff,
+                                 JumpScaling jump_scaling,
+                                 const IntegrationRule *irs[]=NULL) const override;
 
    /// Returns either the H1-seminorm or the DG Face Jumps error or both
    /// depending on norm_type = 1, 2, 3
-   virtual double ComputeH1Error(Coefficient *exsol, VectorCoefficient *exgrad,
-                                 Coefficient *ell_coef, double Nu,
-                                 int norm_type) const
+   double ComputeH1Error(Coefficient *exsol, VectorCoefficient *exgrad,
+                         Coefficient *ell_coef, double Nu,
+                         int norm_type) const override
    {
       return GlobalLpNorm(2.0,
                           GridFunction::ComputeH1Error(exsol,exgrad,ell_coef,
@@ -352,56 +351,56 @@ public:
 
    /// Returns the error measured in H1-norm for H1 elements or in "broken"
    /// H1-norm for L2 elements
-   virtual double ComputeH1Error(Coefficient *exsol, VectorCoefficient *exgrad,
-                                 const IntegrationRule *irs[] = NULL) const
+   double ComputeH1Error(Coefficient *exsol, VectorCoefficient *exgrad,
+                         const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeH1Error(exsol,exgrad,irs),
                           pfes->GetComm());
    }
 
    /// Returns the error measured H(div)-norm for RT elements
-   virtual double ComputeHDivError(VectorCoefficient *exsol,
-                                   Coefficient *exdiv,
-                                   const IntegrationRule *irs[] = NULL) const
+   double ComputeHDivError(VectorCoefficient *exsol,
+                           Coefficient *exdiv,
+                           const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0, GridFunction::ComputeHDivError(exsol,exdiv,irs),
                           pfes->GetComm());
    }
 
    /// Returns the error measured H(curl)-norm for ND elements
-   virtual double ComputeHCurlError(VectorCoefficient *exsol,
-                                    VectorCoefficient *excurl,
-                                    const IntegrationRule *irs[] = NULL) const
+   double ComputeHCurlError(VectorCoefficient *exsol,
+                            VectorCoefficient *excurl,
+                            const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(2.0,
                           GridFunction::ComputeHCurlError(exsol,excurl,irs),
                           pfes->GetComm());
    }
 
-   virtual double ComputeMaxError(Coefficient *exsol[],
-                                  const IntegrationRule *irs[] = NULL) const
+   double ComputeMaxError(Coefficient *exsol[],
+                          const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(infinity(),
                           GridFunction::ComputeMaxError(exsol, irs),
                           pfes->GetComm());
    }
 
-   virtual double ComputeMaxError(Coefficient &exsol,
-                                  const IntegrationRule *irs[] = NULL) const
+   double ComputeMaxError(Coefficient &exsol,
+                          const IntegrationRule *irs[] = NULL) const override
    {
       return ComputeLpError(infinity(), exsol, NULL, irs);
    }
 
-   virtual double ComputeMaxError(VectorCoefficient &exsol,
-                                  const IntegrationRule *irs[] = NULL) const
+   double ComputeMaxError(VectorCoefficient &exsol,
+                          const IntegrationRule *irs[] = NULL) const override
    {
       return ComputeLpError(infinity(), exsol, NULL, NULL, irs);
    }
 
-   virtual double ComputeLpError(const double p, Coefficient &exsol,
-                                 Coefficient *weight = NULL,
-                                 const IntegrationRule *irs[] = NULL,
-                                 const Array<int> *elems = NULL) const
+   double ComputeLpError(const double p, Coefficient &exsol,
+                         Coefficient *weight = NULL,
+                         const IntegrationRule *irs[] = NULL,
+                         const Array<int> *elems = NULL) const override
    {
       return GlobalLpNorm(p, GridFunction::ComputeLpError(p, exsol, weight, irs,
                                                           elems), pfes->GetComm());
@@ -410,23 +409,23 @@ public:
    /** When given a vector weight, compute the pointwise (scalar) error as the
        dot product of the vector error with the vector weight. Otherwise, the
        scalar error is the l_2 norm of the vector error. */
-   virtual double ComputeLpError(const double p, VectorCoefficient &exsol,
-                                 Coefficient *weight = NULL,
-                                 VectorCoefficient *v_weight = NULL,
-                                 const IntegrationRule *irs[] = NULL) const
+   double ComputeLpError(const double p, VectorCoefficient &exsol,
+                         Coefficient *weight = NULL,
+                         VectorCoefficient *v_weight = NULL,
+                         const IntegrationRule *irs[] = NULL) const override
    {
       return GlobalLpNorm(p, GridFunction::ComputeLpError(
                              p, exsol, weight, v_weight, irs), pfes->GetComm());
    }
 
-   virtual void ComputeFlux(BilinearFormIntegrator &blfi,
-                            GridFunction &flux,
-                            bool wcoef = true, int subdomain = -1);
+   void ComputeFlux(BilinearFormIntegrator &blfi,
+                    GridFunction &flux,
+                    bool wcoef = true, int subdomain = -1) override;
 
    /** Save the local portion of the ParGridFunction. This differs from the
        serial GridFunction::Save in that it takes into account the signs of
        the local dofs. */
-   virtual void Save(std::ostream &out) const;
+   void Save(std::ostream &out) const override;
 
    /// Save the ParGridFunction to a single file (written using MPI rank 0). The
    /// given @a precision will be used for ASCII output.
@@ -435,7 +434,7 @@ public:
    /// Save the ParGridFunction to files (one for each MPI rank). The files will
    /// be given suffixes according to the MPI rank. The given @a precision will
    /// be used for ASCII output.
-   virtual void Save(const char *fname, int precision=16) const;
+   void Save(const char *fname, int precision=16) const override;
 
    /// Returns a GridFunction on MPI rank @a save_rank that does not have any
    /// duplication of vertices/nodes at processor boundaries.
@@ -452,15 +451,16 @@ public:
    /** Save the local portion of the ParGridFunction. This differs from the
        serial GridFunction::Save in that it takes into account the signs of
        the local dofs. */
-   virtual void Save(
+   void Save(
       adios2stream &out, const std::string &variable_name,
-      const adios2stream::data_type type = adios2stream::data_type::point_data) const;
+      const adios2stream::data_type type = adios2stream::data_type::point_data) const
+   override;
 #endif
 
    /// Merge the local grid functions
    void SaveAsOne(std::ostream &out = mfem::out) const;
 
-   virtual ~ParGridFunction() { }
+   virtual ~ParGridFunction() = default;
 };
 
 
diff --git a/general/communication.hpp b/general/communication.hpp
index afa504791..8638202be 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -570,8 +570,8 @@ struct VarMessage
    }
 
 protected:
-   virtual void Encode(int rank) {}
-   virtual void Decode(int rank) {}
+   virtual void Encode(int rank) = 0;
+   virtual void Decode(int rank) = 0;
 };
 
 
diff --git a/general/hash.hpp b/general/hash.hpp
index 288d51288..b517172aa 100644
--- a/general/hash.hpp
+++ b/general/hash.hpp
@@ -335,6 +335,8 @@ public:
 
    iterator begin() { return iterator(Base::begin()); }
    iterator end() { return iterator(); }
+   const_iterator begin() const { return const_iterator(Base::cbegin()); }
+   const_iterator end() const { return const_iterator(); }
 
    const_iterator cbegin() const { return const_iterator(Base::cbegin()); }
    const_iterator cend() const { return const_iterator(); }
diff --git a/mesh/element.hpp b/mesh/element.hpp
index f1b003cae..ccd72724a 100644
--- a/mesh/element.hpp
+++ b/mesh/element.hpp
@@ -57,12 +57,15 @@ public:
    /// Set element's attribute.
    inline void SetAttribute(const int attr) { attribute = attr; }
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
-   /// Returns element's vertices.
+   /// Get the indices defining the vertices
    virtual void GetVertices(Array<int> &v) const = 0;
 
+   /// Set the indices defining the vertices
+   virtual void SetVertices(const Array<int> &v) = 0;
+
+   /// Set the indices the element according to the input.
+   virtual void SetVertices(const int *ind) = 0;
+
    /// @note The returned array should NOT be deleted by the caller.
    virtual int *GetVertices() = 0;
 
diff --git a/mesh/hexahedron.cpp b/mesh/hexahedron.cpp
index beeab3b6a..e86e209c1 100644
--- a/mesh/hexahedron.cpp
+++ b/mesh/hexahedron.cpp
@@ -43,10 +43,18 @@ Hexahedron::Hexahedron(int ind1, int ind2, int ind3, int ind4,
 void Hexahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(8);
-   for (int i = 0; i < 8; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 8, v.begin());
+}
+
+void Hexahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 8, "!");
+   std::copy(v.begin(), v.end(), indices);
+}
+
+void Hexahedron::SetVertices(const int *ind)
+{
+   std::copy(ind, ind + 8, indices);
 }
 
 TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/hexahedron.hpp b/mesh/hexahedron.hpp
index a8186c0c8..450cac0ce 100644
--- a/mesh/hexahedron.hpp
+++ b/mesh/hexahedron.hpp
@@ -37,35 +37,42 @@ public:
               int ind5, int ind6, int ind7, int ind8, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::HEXAHEDRON; }
+   Type GetType() const override { return Element::HEXAHEDRON; }
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 8; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return 12; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const
+   int GetNVertices() const override { return 8; }
+
+   int GetNEdges() const override { return 12; }
+
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 4; return 6; }
 
-   virtual int GetNFaces() const { return 6; }
+   int GetNFaces() const override { return 6; }
 
-   virtual int GetNFaceVertices(int) const { return 4; }
+   int GetNFaceVertices(int) const override { return 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Hexahedron(indices, attribute); }
 
-   virtual ~Hexahedron() { }
+   virtual ~Hexahedron() = default;
 };
 
 extern MFEM_EXPORT class TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 673765dce..a46277750 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1416,6 +1416,7 @@ Geometry::Type Mesh::GetFaceGeometry(int Face) const
          }
          // ghost face
          const int nc_face_id = faces_info[Face].NCFace;
+
          MFEM_ASSERT(nc_face_id >= 0, "parent ghost faces are not supported");
          return faces[nc_faces_info[nc_face_id].MasterFace]->GetGeometryType();
    }
@@ -2050,9 +2051,9 @@ int Mesh::AddBdrPoint(int v, int attr)
 
 void Mesh::GenerateBoundaryElements()
 {
-   for (int i = 0; i < boundary.Size(); i++)
+   for (auto &b : boundary)
    {
-      FreeElement(boundary[i]);
+      FreeElement(b);
    }
 
    if (Dim == 3)
@@ -2063,9 +2064,9 @@ void Mesh::GenerateBoundaryElements()
 
    // count the 'NumOfBdrElements'
    NumOfBdrElements = 0;
-   for (int i = 0; i < faces_info.Size(); i++)
+   for (const auto &fi : faces_info)
    {
-      if (faces_info[i].Elem2No < 0) { NumOfBdrElements++; }
+      if (fi.Elem2No < 0) { ++NumOfBdrElements; }
    }
 
    // Add the boundary elements
@@ -4854,7 +4855,7 @@ Mesh::Mesh(Mesh *orig_mesh, int ref_factor, int ref_type)
    MakeRefined_(*orig_mesh, ref_factors, ref_type);
 }
 
-void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                         int ref_type)
 {
    SetEmpty();
@@ -6641,22 +6642,22 @@ int Mesh::CheckBdrElementOrientation(bool fix_it)
             {
                // swap vertices 0 and 1 so that we don't change the marked edge:
                // (0,1,2) -> (1,0,2)
-               mfem::Swap<int>(bv[0], bv[1]);
+               mfem::Swap(bv[0], bv[1]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[1], be[2]);
+                  mfem::Swap(be[1], be[2]);
                }
                break;
             }
             case Element::QUADRILATERAL:
             {
-               mfem::Swap<int>(bv[0], bv[2]);
+               mfem::Swap(bv[0], bv[2]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[0], be[1]);
-                  mfem::Swap<int>(be[2], be[3]);
+                  mfem::Swap(be[0], be[1]);
+                  mfem::Swap(be[2], be[3]);
                }
                break;
             }
@@ -7449,26 +7450,27 @@ void Mesh::AddQuadFaceElement(int lf, int gf, int el,
 
 void Mesh::GenerateFaces()
 {
-   int i, nfaces = GetNumFaces();
+   int nfaces = GetNumFaces();
 
-   for (i = 0; i < faces.Size(); i++)
+   for (auto &f : faces)
    {
-      FreeElement(faces[i]);
+      FreeElement(f);
    }
 
    // (re)generate the interior faces and the info for them
    faces.SetSize(nfaces);
    faces_info.SetSize(nfaces);
-   for (i = 0; i < nfaces; i++)
+   for (int i = 0; i < nfaces; ++i)
    {
       faces[i] = NULL;
       faces_info[i].Elem1No = -1;
       faces_info[i].NCFace = -1;
    }
-   for (i = 0; i < NumOfElements; i++)
+
+   Array<int> v;
+   for (int i = 0; i < NumOfElements; ++i)
    {
-      const int *v = elements[i]->GetVertices();
-      const int *ef;
+      elements[i]->GetVertices(v);
       if (Dim == 1)
       {
          AddPointFaceElement(0, v[0], i);
@@ -7476,7 +7478,7 @@ void Mesh::GenerateFaces()
       }
       else if (Dim == 2)
       {
-         ef = el_to_edge->GetRow(i);
+         const int * const ef = el_to_edge->GetRow(i);
          const int ne = elements[i]->GetNEdges();
          for (int j = 0; j < ne; j++)
          {
@@ -7486,7 +7488,7 @@ void Mesh::GenerateFaces()
       }
       else
       {
-         ef = el_to_face->GetRow(i);
+         const int * const ef = el_to_face->GetRow(i);
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
@@ -7552,9 +7554,9 @@ void Mesh::GenerateNCFaceInfo()
 {
    MFEM_VERIFY(ncmesh, "missing NCMesh.");
 
-   for (int i = 0; i < faces_info.Size(); i++)
+   for (auto &x : faces_info)
    {
-      faces_info[i].NCFace = -1;
+      x.NCFace = -1;
    }
 
    const NCMesh::NCList &list =
@@ -7566,9 +7568,8 @@ void Mesh::GenerateNCFaceInfo()
    int nfaces = GetNumFaces();
 
    // add records for master faces
-   for (int i = 0; i < list.masters.Size(); i++)
+   for (const NCMesh::Master &master : list.masters)
    {
-      const NCMesh::Master &master = list.masters[i];
       if (master.index >= nfaces) { continue; }
 
       FaceInfo &master_fi = faces_info[master.index];
@@ -7580,10 +7581,8 @@ void Mesh::GenerateNCFaceInfo()
    }
 
    // add records for slave faces
-   for (int i = 0; i < list.slaves.Size(); i++)
+   for (const NCMesh::Slave &slave : list.slaves)
    {
-      const NCMesh::Slave &slave = list.slaves[i];
-
       if (slave.index < 0 || // degenerate slave face
           slave.index >= nfaces || // ghost slave
           slave.master >= nfaces) // has ghost master
@@ -7674,7 +7673,7 @@ STable3D *Mesh::GetFacesTable()
 
 STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
 {
-   int i, *v;
+   Array<int> v;
    STable3D *faces_tbl;
 
    if (el_to_face != NULL)
@@ -7683,9 +7682,9 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    }
    el_to_face = new Table(NumOfElements, 6);  // must be 6 for hexahedra
    faces_tbl = new STable3D(NumOfVertices);
-   for (i = 0; i < NumOfElements; i++)
+   for (int i = 0; i < NumOfElements; i++)
    {
-      v = elements[i]->GetVertices();
+      elements[i]->GetVertices(v);
       switch (GetElementType(i))
       {
          case Element::TETRAHEDRON:
@@ -7749,9 +7748,10 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    el_to_face->Finalize();
    NumOfFaces = faces_tbl->NumberOfElements();
    be_to_face.SetSize(NumOfBdrElements);
-   for (i = 0; i < NumOfBdrElements; i++)
+
+   for (int i = 0; i < NumOfBdrElements; i++)
    {
-      v = boundary[i]->GetVertices();
+      boundary[i]->GetVertices(v);
       switch (GetBdrElementType(i))
       {
          case Element::TRIANGLE:
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index 1be7e372e..58e77d388 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -597,7 +597,7 @@ protected:
    void Make1D(int n, double sx = 1.0);
 
    /// Internal function used in Mesh::MakeRefined
-   void MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+   void MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                      int ref_type);
 
    /// Initialize vertices/elements/boundary/tables from a nonconforming mesh.
@@ -1788,7 +1788,7 @@ public:
                           };
 
    /** @brief This structure is used as a human readable output format that
-       decipheres the information contained in Mesh::FaceInfo when using the
+       deciphers the information contained in Mesh::FaceInfo when using the
        Mesh::GetFaceInformation() method.
 
        The element indices in this structure don't need further processing,
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index ecb5fb90b..5c57adc4a 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -19,6 +19,36 @@
 
 #include "ncmesh_tables.hpp"
 
+
+namespace
+{
+/**
+ * @brief Base case of convenience variadic max function.
+ *
+ * @tparam T Base type
+ * @param arg Recursion base value
+ * @return T value to max over
+ */
+template<typename T>
+T max(T&& arg)
+{
+   return arg;
+}
+/**
+ * @brief Convenience variadic max function.
+ *
+ * @tparam T Base Type
+ * @tparam Ts Parameter pack of other types
+ * @param arg Singular argument
+ * @param args Pack of arguments
+ * @return T maximum value
+ */
+template<typename T, typename... Ts>
+T max(T arg, Ts... args)
+{
+   return std::max(std::forward<T>(arg), max(args...));
+}
+} // namespace
 namespace mfem
 {
 
@@ -2449,18 +2479,21 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
    // left uninitialized here; they will be initialized later by the Mesh from
    // Nodes -- here we just make sure mesh.vertices has the correct size.
 
-   for (int i = 0; i < mesh.NumOfElements; i++)
+   for (auto &elem : mesh.elements)
    {
-      mesh.FreeElement(mesh.elements[i]);
+      mesh.FreeElement(elem);
    }
    mesh.elements.SetSize(0);
 
-   for (int i = 0; i < mesh.NumOfBdrElements; i++)
+   for (auto &elem : mesh.boundary)
    {
-      mesh.FreeElement(mesh.boundary[i]);
+      mesh.FreeElement(elem);
    }
    mesh.boundary.SetSize(0);
 
+   // Save off boundary face vertices to make boundary elements later.
+   std::map<int, mfem::Array<int>> unique_boundary_faces;
+
    // create an mfem::Element for each leaf Element
    for (int i = 0; i < NElements; i++)
    {
@@ -2478,65 +2511,83 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
          elem->GetVertices()[j] = nodes[node[j]].vert_index;
       }
 
-      // create boundary elements
-      // TODO: use boundary_faces?
-      for (int k = 0; k < gi.nf; k++)
+      // Loop over faces and collect those marked as boundaries
+      for (int k = 0; k < gi.nf; ++k)
       {
-         const int* fv = gi.faces[k];
          const int nfv = gi.nfv[k];
-         const Face* face = faces.Find(node[fv[0]], node[fv[1]],
-                                       node[fv[2]], node[fv[3]]);
-         if (face->Boundary())
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+         if (id >= 0 && faces[id].Boundary())
          {
-            if ((nc_elem.geom == Geometry::CUBE) ||
-                ((nc_elem.geom == Geometry::PRISM ||
-                  nc_elem.geom == Geometry::PYRAMID) && nfv == 4))
-            {
-               auto* quad = (Quadrilateral*) mesh.NewElement(Geometry::SQUARE);
-               quad->SetAttribute(face->attribute);
-               for (int j = 0; j < 4; j++)
-               {
-                  quad->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(quad);
-            }
-            else if (nc_elem.geom == Geometry::PRISM ||
-                     nc_elem.geom == Geometry::PYRAMID ||
-                     nc_elem.geom == Geometry::TETRAHEDRON)
+            const auto &face = faces[id];
+            if (face.elem[0] >= 0 && face.elem[1] >= 0 &&
+                nc_elem.rank != std::min(elements[face.elem[0]].rank,
+                                         elements[face.elem[1]].rank))
             {
-               MFEM_ASSERT(nfv == 3, "");
-               auto* tri = (Triangle*) mesh.NewElement(Geometry::TRIANGLE);
-               tri->SetAttribute(face->attribute);
-               for (int j = 0; j < 3; j++)
-               {
-                  tri->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(tri);
+               // This is a conformal internal face, but this element is not the lowest
+               // ranking attached processor, thus not the owner of the face.
+               // Consequently, we do not add this face to avoid double
+               // counting.
+               continue;
             }
-            else if (nc_elem.geom == Geometry::SQUARE ||
-                     nc_elem.geom == Geometry::TRIANGLE)
+
+            // Add in all boundary faces that are actual boundaries or not masters of another face.
+            // The fv[2] in the edge split is on purpose.
+            if ((nfv == 4 &&
+                 QuadFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]], node[fv[3]]))
+                || (nfv == 3 && TriFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]]))
+                || (nfv == 2 &&
+                    EdgeSplitLevel(node[fv[0]], node[fv[2]] /* [2] not an error */) == 0))
             {
-               auto* segment = (Segment*) mesh.NewElement(Geometry::SEGMENT);
-               segment->SetAttribute(face->attribute);
-               for (int j = 0; j < 2; j++)
+               // This face has no split faces below, it is conformal or a
+               // slave.
+               unique_boundary_faces[id].SetSize(nfv);
+               for (int v = 0; v < nfv; ++v)
                {
-                  segment->GetVertices()[j] = nodes[node[fv[2*j]]].vert_index;
+                  // Using a map overwrites if a face is visited twice.
+                  // The nfv==2 is necessary because faces of 2D are storing the
+                  // second index in the 2 slot, not the 1 slot.
+                  unique_boundary_faces[id][v] = nodes[node[fv[(nfv==2) ? 2*v : v]]].vert_index;
                }
-               mesh.boundary.Append(segment);
-            }
-            else
-            {
-               MFEM_ASSERT(nc_elem.geom == Geometry::SEGMENT, "");
-               auto* point = (mfem::Point*) mesh.NewElement(Geometry::POINT);
-               point->SetAttribute(face->attribute);
-               point->GetVertices()[0] = nodes[node[fv[0]]].vert_index;
-               mesh.boundary.Append(point);
             }
          }
       }
    }
+
+   auto geom_from_nfv = [](int nfv)
+   {
+      switch (nfv)
+      {
+         case 1: return Geometry::POINT;
+         case 2: return Geometry::SEGMENT;
+         case 3: return Geometry::TRIANGLE;
+         case 4: return Geometry::SQUARE;
+      }
+      return Geometry::INVALID;
+   };
+
+   for (const auto &fv : unique_boundary_faces)
+   {
+      const auto f = fv.first;
+      const auto &v = fv.second;
+      const auto &face = faces.At(f);
+
+      auto geom = geom_from_nfv(v.Size());
+
+      MFEM_ASSERT(geom != Geometry::INVALID,
+                  "nfv: " << v.Size() <<
+                  " does not match a valid face geometry: Quad, Tri, Segment, Point");
+
+      // Add a new boundary element, with matching attribute and vertices
+      mesh.boundary.Append(mesh.NewElement(geom));
+      auto * const be = mesh.boundary.Last();
+      be->SetAttribute(face.attribute);
+      be->SetVertices(v);
+   }
 }
 
+
 void NCMesh::OnMeshUpdated(Mesh *mesh)
 {
    //// PART 1: pull indices of regular edges/faces from the Mesh
@@ -2651,13 +2702,14 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
       for (int j = 0; j < gi.nf; j++)
       {
          const int *fv = gi.faces[j];
-         Face* face = faces.Find(el.node[fv[0]], el.node[fv[1]],
-                                 el.node[fv[2]], el.node[fv[3]]);
-         MFEM_ASSERT(face, "face not found!");
+         int fid = faces.FindId(el.node[fv[0]], el.node[fv[1]],
+                                el.node[fv[2]], el.node[fv[3]]);
+         MFEM_ASSERT(fid >= 0, "face not found!");
+         auto &face = faces[fid];
 
-         if (face->index < 0)
+         if (face.index < 0)
          {
-            face->index = NFaces + (nghosts++);
+            face.index = NFaces + (nghosts++);
 
             // store the face geometry
             static const Geometry::Type types[5] =
@@ -2665,7 +2717,7 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
                Geometry::INVALID, Geometry::INVALID,
                Geometry::SEGMENT, Geometry::TRIANGLE, Geometry::SQUARE
             };
-            face_geom[face->index] = types[gi.nfv[j]];
+            face_geom[face.index] = types[gi.nfv[j]];
          }
       }
    }
@@ -2741,7 +2793,7 @@ bool NCMesh::TriFaceSplit(int v1, int v2, int v3, int mid[3]) const
 
    if (mid) { mid[0] = e1, mid[1] = e2, mid[2] = e3; }
 
-   // NOTE: face (v1, v2, v3) still needs to be checked
+   // This is necessary but not sufficient to determine if a face has been split.
    return true;
 }
 
@@ -3157,6 +3209,7 @@ void NCMesh::BuildFaceList()
          int fgeom = (node[3] >= 0) ? Geometry::SQUARE : Geometry::TRIANGLE;
 
          Face &fa = faces[face];
+         bool is_master = false;
          if (fa.elem[0] >= 0 && fa.elem[1] >= 0)
          {
             // this is a conforming face, add it to the list
@@ -3183,6 +3236,7 @@ void NCMesh::BuildFaceList()
             if (sb < se)
             {
                // found slaves, so this is a master face; add it to the list
+               is_master = true;
                face_list.masters.Append(
                   Master(fa.index, elem, j, fgeom, sb, se));
 
@@ -3194,7 +3248,8 @@ void NCMesh::BuildFaceList()
             }
          }
 
-         if (fa.Boundary()) { boundary_faces.Append(face); }
+         // To support internal boundaries can only insert non-master faces.
+         if (fa.Boundary() && !is_master) { boundary_faces.Append(face); }
       }
    }
 
@@ -3270,20 +3325,22 @@ void NCMesh::BuildEdgeList()
          // tell ParNCMesh about the edge
          ElementSharesEdge(elem, j, enode);
 
-         // (2D only, store boundary faces)
-         if (Dim <= 2)
-         {
-            int face = faces.FindId(node[0], node[0], node[1], node[1]);
-            MFEM_ASSERT(face >= 0, "face not found!");
-            if (faces[face].Boundary()) { boundary_faces.Append(face); }
-         }
-
          // store element/local for later
          edge_element[nd.edge_index] = elem;
          edge_local[nd.edge_index] = j;
 
          // skip slave edges here, they will be reached from their masters
-         if (GetEdgeMaster(enode) >= 0) { continue; }
+         if (GetEdgeMaster(enode) >= 0)
+         {
+            // (2D only, store internal boundary faces)
+            if (Dim <= 2)
+            {
+               int face = faces.FindId(node[0], node[0], node[1], node[1]);
+               MFEM_ASSERT(face >= 0, "face not found!");
+               if (faces[face].Boundary()) { boundary_faces.Append(face); }
+            }
+            continue;
+         }
 
          // have we already processed this edge? skip if yes
          if (processed_edges[enode]) { continue; }
@@ -3316,6 +3373,13 @@ void NCMesh::BuildEdgeList()
          {
             // no slaves, this is a conforming edge
             edge_list.conforming.Append(MeshId(nd.edge_index, elem, j));
+            // (2D only, store boundary faces)
+            if (Dim <= 2)
+            {
+               int face = faces.FindId(node[0], node[0], node[1], node[1]);
+               MFEM_ASSERT(face >= 0, "face not found!");
+               if (faces[face].Boundary()) { boundary_faces.Append(face); }
+            }
          }
       }
    }
@@ -3477,7 +3541,6 @@ NCMesh::NCList::BuildIndex() const
          inv_index.emplace(slaves[i].index, std::make_pair(MeshIdType::SLAVE, i));
       }
    }
-
    MFEM_ASSERT(inv_index.size() > 0,
                "Empty inverse index, member lists must be populated before BuildIndex is called!");
 }
@@ -5195,22 +5258,23 @@ void NCMesh::FindFaceNodes(int face, int node[4])
 }
 
 void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
-                                Array<int> &bdr_vertices, Array<int> &bdr_edges)
+                                Array<int> &bdr_vertices, Array<int> &bdr_edges,
+                                Array<int> &bdr_faces)
 {
    bdr_vertices.SetSize(0);
    bdr_edges.SetSize(0);
+   bdr_faces.SetSize(0);
 
    if (Dim == 3)
    {
       GetFaceList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int f : boundary_faces)
       {
-         int face = boundary_faces[i];
-         if (bdr_attr_is_ess[faces[face].attribute - 1])
+         if (bdr_attr_is_ess[faces[f].attribute - 1])
          {
             int node[4];
-            FindFaceNodes(face, node);
+            FindFaceNodes(f, node);
             int nfv = (node[3] < 0) ? 3 : 4;
 
             for (int j = 0; j < nfv; j++)
@@ -5228,6 +5292,17 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
                   bdr_edges.Append(nodes[enode].edge_index);
                }
             }
+
+            // If the face is a slave face, collect any non-ghost master face
+            const Face &face = faces[f];
+
+            const auto id_and_type = GetFaceList().GetMeshIdAndType(face.index);
+            if (id_and_type.type == NCList::MeshIdType::SLAVE)
+            {
+               // A slave face must mark any masters
+               const auto &slave_face_id = static_cast<const Slave&>(*id_and_type.id);
+               bdr_faces.Append(slave_face_id.master);
+            }
          }
       }
    }
@@ -5235,36 +5310,38 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetEdgeList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int f : boundary_faces)
       {
-         int face = boundary_faces[i];
-         Face &fc = faces[face];
-         if (bdr_attr_is_ess[fc.attribute - 1])
+         Face &face = faces[f];
+         if (bdr_attr_is_ess[face.attribute - 1])
+         {
+            bdr_vertices.Append(nodes[face.p1].vert_index);
+            bdr_vertices.Append(nodes[face.p3].vert_index);
+         }
+
+         const auto id_and_type = GetEdgeList().GetMeshIdAndType(face.index);
+         if (id_and_type.type == NCList::MeshIdType::SLAVE)
          {
-            bdr_vertices.Append(nodes[fc.p1].vert_index);
-            bdr_vertices.Append(nodes[fc.p3].vert_index);
+            // A slave face must mark any masters
+            const auto &slave_edge_id = static_cast<const Slave&>(*id_and_type.id);
+            bdr_edges.Append(slave_edge_id.master);
          }
       }
    }
 
-   bdr_vertices.Sort();
-   bdr_vertices.Unique();
-
-   bdr_edges.Sort();
-   bdr_edges.Unique();
-}
+   // Filter, sort and unique an array, so it contains only local unique values.
+   auto FilterSortUnique = [](Array<int> &v, int N)
+   {
+      // Perform the O(N) filter before the O(NlogN) sort.
+      // begin -> it is only entries < N.
+      auto it = std::remove_if(v.begin(), v.end(), [N](int i) { return i >= N; });
+      std::sort(v.begin(), it);
+      v.SetSize(std::distance(v.begin(), std::unique(v.begin(), it)));
+   };
 
-static int max4(int a, int b, int c, int d)
-{
-   return std::max(std::max(a, b), std::max(c, d));
-}
-static int max6(int a, int b, int c, int d, int e, int f)
-{
-   return std::max(max4(a, b, c, d), std::max(e, f));
-}
-static int max8(int a, int b, int c, int d, int e, int f, int g, int h)
-{
-   return std::max(max4(a, b, c, d), max4(e, f, g, h));
+   FilterSortUnique(bdr_vertices, NVertices);
+   FilterSortUnique(bdr_edges, NEdges);
+   FilterSortUnique(bdr_faces, NFaces);
 }
 
 int NCMesh::EdgeSplitLevel(int vn1, int vn2) const
@@ -5280,15 +5357,13 @@ int NCMesh::TriFaceSplitLevel(int vn1, int vn2, int vn3) const
    if (TriFaceSplit(vn1, vn2, vn3, mid) &&
        faces.FindId(vn1, vn2, vn3) < 0)
    {
-      return 1 + max4(TriFaceSplitLevel(vn1, mid[0], mid[2]),
-                      TriFaceSplitLevel(mid[0], vn2, mid[1]),
-                      TriFaceSplitLevel(mid[2], mid[1], vn3),
-                      TriFaceSplitLevel(mid[0], mid[1], mid[2]));
-   }
-   else // not split
-   {
-      return 0;
+      return 1 + max(TriFaceSplitLevel(vn1, mid[0], mid[2]),
+                     TriFaceSplitLevel(mid[0], vn2, mid[1]),
+                     TriFaceSplitLevel(mid[2], mid[1], vn3),
+                     TriFaceSplitLevel(mid[0], mid[1], mid[2]));
    }
+
+   return 0; // not split
 }
 
 void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
@@ -5318,6 +5393,13 @@ void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
    }
 }
 
+int NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const
+{
+   int h_level, v_level;
+   QuadFaceSplitLevel(vn1, vn2, vn3, vn4, h_level, v_level);
+   return h_level + v_level;
+}
+
 void NCMesh::CountSplits(int elem, int splits[3]) const
 {
    const Element &el = elements[elem];
@@ -5354,57 +5436,52 @@ void NCMesh::CountSplits(int elem, int splits[3]) const
 
    if (el.Geom() == Geometry::CUBE)
    {
-      splits[0] = max8(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
-                       elevel[0], elevel[2], elevel[4], elevel[6]);
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
+                      elevel[0], elevel[2], elevel[4], elevel[6]);
 
-      splits[1] = max8(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
-                       elevel[1], elevel[3], elevel[5], elevel[7]);
+      splits[1] = max(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
+                      elevel[1], elevel[3], elevel[5], elevel[7]);
 
-      splits[2] = max8(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[8], elevel[9], elevel[10], elevel[11]);
+      splits[2] = max(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[8], elevel[9], elevel[10], elevel[11]);
    }
    else if (el.Geom() == Geometry::PRISM)
    {
-      splits[0] = splits[1] =
-                     std::max(
-                        max6(flevel[0][0], flevel[1][0], 0,
-                             flevel[2][0], flevel[3][0], flevel[4][0]),
-                        max6(elevel[0], elevel[1], elevel[2],
-                             elevel[3], elevel[4], elevel[5]));
+      splits[0] = splits[1] = max(flevel[0][0], flevel[1][0], 0,
+                                  flevel[2][0], flevel[3][0], flevel[4][0],
+                                  elevel[0], elevel[1], elevel[2],
+                                  elevel[3], elevel[4], elevel[5]);
 
-      splits[2] = max6(flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[6], elevel[7], elevel[8]);
+      splits[2] = max(flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[6], elevel[7], elevel[8]);
    }
    else if (el.Geom() == Geometry::PYRAMID)
    {
-      splits[0] = std::max(
-                     max6(flevel[0][0], flevel[1][0], 0,
-                          flevel[2][0], flevel[3][0], flevel[4][0]),
-                     max8(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5],
-                          elevel[6], elevel[7]));
+      splits[0] = max(flevel[0][0], flevel[1][0], 0,
+                      flevel[2][0], flevel[3][0], flevel[4][0],
+                      elevel[0], elevel[1], elevel[2],
+                      elevel[3], elevel[4], elevel[5],
+                      elevel[6], elevel[7]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::TETRAHEDRON)
    {
-      splits[0] = std::max(
-                     max4(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0]),
-                     max6(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5]));
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0],
+                      elevel[0], elevel[1], elevel[2], elevel[3], elevel[4], elevel[5]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::SQUARE)
    {
-      splits[0] = std::max(elevel[0], elevel[2]);
-      splits[1] = std::max(elevel[1], elevel[3]);
+      splits[0] = max(elevel[0], elevel[2]);
+      splits[1] = max(elevel[1], elevel[3]);
    }
    else if (el.Geom() == Geometry::TRIANGLE)
    {
-      splits[0] = std::max(elevel[0], std::max(elevel[1], elevel[2]));
+      splits[0] = max(elevel[0], elevel[1], elevel[2]);
       splits[1] = splits[0];
    }
    else
@@ -6377,17 +6454,17 @@ void NCMesh::DebugDump(std::ostream &os) const
 
    // dump faces
    os << faces.Size() << "\n";
-   for (auto face = faces.cbegin(); face != faces.cend(); ++face)
+   for (const auto &face : faces)
    {
-      int elem = face->elem[0];
-      if (elem < 0) { elem = face->elem[1]; }
+      int elem = face.elem[0];
+      if (elem < 0) { elem = face.elem[1]; }
       MFEM_ASSERT(elem >= 0, "");
       const Element &el = elements[elem];
 
       int lf = find_local_face(el.Geom(),
-                               find_node(el, face->p1),
-                               find_node(el, face->p2),
-                               find_node(el, face->p3));
+                               find_node(el, face.p1),
+                               find_node(el, face.p2),
+                               find_node(el, face.p3));
 
       const int* fv = GI[el.Geom()].faces[lf];
       const int nfv = GI[el.Geom()].nfv[lf];
@@ -6397,7 +6474,7 @@ void NCMesh::DebugDump(std::ostream &os) const
       {
          os << " " << el.node[fv[i]];
       }
-      //os << " # face " << face.index() << ", index " << face->index << "\n";
+      //os << " # face " << face.index() << ", index " << face.index << "\n";
       os << "\n";
    }
 }
diff --git a/mesh/ncmesh.hpp b/mesh/ncmesh.hpp
index 8ac50d342..b004cf43e 100644
--- a/mesh/ncmesh.hpp
+++ b/mesh/ncmesh.hpp
@@ -293,6 +293,7 @@ public:
       mutable std::unordered_map<int, std::pair<MeshIdType, int>> inv_index;
    };
 
+
    /// Return the current list of conforming and nonconforming faces.
    const NCList& GetFaceList()
    {
@@ -392,11 +393,13 @@ public:
    /** Get a list of vertices (2D/3D) and edges (3D) that coincide with boundary
        elements with the specified attributes (marked in 'bdr_attr_is_ess').
        In 3D this function also reveals "hidden" boundary edges. In parallel it
-       helps identifying boundary vertices/edges affected by non-local boundary
-       elements. */
+       helps identifying boundary vertices/edges/faces affected by non-local boundary
+       elements. Hidden faces can occur for an internal boundary coincident to a processor
+       boundary.
+       */
    virtual void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
                                    Array<int> &bdr_vertices,
-                                   Array<int> &bdr_edges);
+                                   Array<int> &bdr_edges, Array<int> &bdr_faces);
 
    /// Return element geometry type. @a index is the Mesh element number.
    Geometry::Type GetElementGeometry(int index) const
@@ -456,7 +459,6 @@ protected: // non-public interface for the Mesh class
        by calling Mesh::SetCurvature or otherwise setting the Nodes. */
    void MakeTopologyOnly() { coordinates.DeleteAll(); }
 
-
 protected: // implementation
 
    int Dim, spaceDim; ///< dimensions of the elements and the vertex coordinates
@@ -594,7 +596,6 @@ protected: // implementation
 
    Table element_vertex; ///< leaf-element to vertex table, see FindSetNeighbors
 
-
    /// Update the leaf elements indices in leaf_elements
    void UpdateLeafElements();
 
@@ -712,10 +713,79 @@ protected: // implementation
 
    mfem::Element* NewMeshElement(int geom) const;
 
-   int QuadFaceSplitType(int v1, int v2, int v3, int v4, int mid[5]
+   /**
+    * @brief Given a quad face defined by four vertices, establish which edges
+    * of this face have been split, and if so optionally return the mid points
+    * of those edges.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return int 0 -- no split, 1 -- "vertical" split, 2 -- "horizontal" split
+    */
+   int QuadFaceSplitType(int n1, int n2, int n3, int n4, int mid[5]
                          = NULL /*optional output of mid-edge nodes*/) const;
 
-   bool TriFaceSplit(int v1, int v2, int v3, int mid[3] = NULL) const;
+   /**
+    * @brief Given a tri face defined by three vertices, establish whether the
+    * edges that make up this face have been split, and if so optionally return
+    * the midpoints.
+    * @details This is a necessary condition for this face to have been split,
+    * but is not sufficient. Consider a triangle attached to three refined
+    * triangles, in this scenario all edges can be split but this face not be
+    * split. In this case, it is necessary to check if there is a face made up
+    * of the returned midpoint nodes.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return true Splits for all edges have been found
+    * @return false
+    */
+   bool TriFaceSplit(int n1, int n2, int n3, int mid[3] = NULL) const;
+
+   /**
+    * @brief Determine if a Triangle face is not a master
+    * @details This check requires looking for the edges making up the triangle
+    * being split, if nodes exist at their midpoints, and there are vertices at
+    * them, this implies the face COULD be split. To determine if it is, we then
+    * check whether these midpoints have all been connected, this is required to
+    * discriminate between an internal master face surrounded by nonconformal
+    * refinements and a conformal boundary face surrounded by refinements.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @return true The face is not a master
+    * @return false The face is a master
+    */
+   inline bool TriFaceNotMaster(int n1, int n2, int n3) const
+   {
+      int mid[3];
+      return !TriFaceSplit(n1, n2, n3, mid) // The edges aren't split
+             // OR none of the midpoints are connected.
+             || (nodes.FindId(mid[0], mid[1]) < 0 &&
+                 nodes.FindId(mid[0], mid[2]) < 0 &&
+                 nodes.FindId(mid[1], mid[2]) < 0);
+   }
+
+   /**
+    * @brief Determine if  a Quad face is not a master
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @return true The quad face is not a master
+    * @return false The quad face is a master
+    */
+   inline bool QuadFaceNotMaster(int n1, int n2, int n3, int n4) const
+   {
+      return QuadFaceSplitType(n1, n2, n3, n4) == 0;
+   }
 
    void ForceRefinement(int vn1, int vn2, int vn3, int vn4);
 
@@ -792,7 +862,6 @@ protected: // implementation
    virtual void ElementSharesEdge(int elem, int local, int enode) {} // ParNCMesh
    virtual void ElementSharesVertex(int elem, int local, int vnode) {} // ParNCMesh
 
-
    // neighbors / element_vertex table
 
    /** Return all vertex-, edge- and face-neighbors of a set of elements.
@@ -981,9 +1050,7 @@ protected: // implementation
    void InitDerefTransforms();
    void SetDerefMatrixCodes(int parent, Array<int> &fine_coarse);
 
-
    // vertex temporary data, used by GetMeshComponents
-
    struct TmpVertex
    {
       bool valid, visited;
@@ -1002,10 +1069,56 @@ protected: // implementation
 
    void FindFaceNodes(int face, int node[4]);
 
+   /**
+    * @brief Return the number of splits of this edge that have occurred in the
+    * NCMesh. If zero, this means the segment is not the master of any other segments.
+    *
+    * @param vn1 The first vertex making up the segment
+    * @param vn2 The second vertex making up the segment
+    * @return int The depth of splits of this segment that are present in the mesh.
+    */
    int EdgeSplitLevel(int vn1, int vn2) const;
+   /**
+    * @brief Return the number of splits of this triangle that have occurred in
+    * the NCMesh. If zero, this means the triangle is neither split, nor the
+    * master of a split face.
+    *
+    * @param vn1 The first vertex making up the triangle
+    * @param vn2 The second vertex making up the triangle
+    * @param vn3 The third vertex making up the triangle
+    * @return int The depth of splits of this triangle that are present in the mesh.
+    */
    int TriFaceSplitLevel(int vn1, int vn2, int vn3) const;
+   /**
+    * @brief Computes the number of horizontal and vertical splits of this quad
+    * that have occurred in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @param h_level The number of "horizontal" splits of the quad
+    * @param v_level The number of "vertical" splits of the quad
+    */
    void QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
                            int& h_level, int& v_level) const;
+   /**
+    * @brief Returns the total number of splits of this quad that have occurred
+    * in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    * @details This is a convenience wrapper that sums the horizontal and
+    * vertical levels from the full method.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @return int The depth of splits of this triangle that are present in the
+    * mesh. NB: An isotropic refinement has a level of 2, one horizontal split,
+    * followed by a vertical split.
+    */
+   int QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const;
 
    void CountSplits(int elem, int splits[3]) const;
    void GetLimitRefinements(Array<Refinement> &refinements, int max_level);
@@ -1042,7 +1155,6 @@ protected: // implementation
    /// Load the deprecated MFEM mesh v1.1 format for backward compatibility.
    void LoadLegacyFormat(std::istream &input, int &curved, int &is_nc);
 
-
    // geometry
 
    /// This holds in one place the constants about the geometries we support
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index c43e2ea53..5b5657546 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -364,11 +364,8 @@ int ParMesh::BuildLocalVertices(const mfem::Mesh &mesh,
 int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
                                 const Array<int>& vert_global_local)
 {
-   int nelems = 0;
-   for (int i = 0; i < mesh.GetNE(); i++)
-   {
-      if (partitioning[i] == MyRank) { nelems++; }
-   }
+   const int nelems = std::count_if(partitioning,
+   partitioning + mesh.GetNE(), [this](int i) { return i == MyRank;});
 
    elements.SetSize(nelems);
 
@@ -387,7 +384,7 @@ int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
          {
             v[j] = vert_global_local[v[j]];
          }
-         element_counter++;
+         ++element_counter;
       }
    }
 
@@ -400,7 +397,6 @@ int ParMesh::BuildLocalBoundary(const Mesh& mesh, const int* partitioning,
                                 Table*& edge_element)
 {
    int nbdry = 0;
-
    if (mesh.NURBSext)
    {
       activeBdrElem.SetSize(mesh.GetNBE());
@@ -2102,7 +2098,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors mostly without communication
+      // With ParNCMesh we can set up face neighbors mostly without communication.
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index cd6625e9c..169c5c6bb 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -577,41 +577,81 @@ void ParNCMesh::CalcFaceOrientations()
    face_orient.SetSize(NFaces);
    face_orient = 0;
 
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto face : faces)
    {
-      if (face->elem[0] >= 0 && face->elem[1] >= 0 && face->index < NFaces)
+      if (face.elem[0] >= 0 && face.elem[1] >= 0 && face.index < NFaces)
       {
-         Element *e1 = &elements[face->elem[0]];
-         Element *e2 = &elements[face->elem[1]];
+         Element *e1 = &elements[face.elem[0]];
+         Element *e2 = &elements[face.elem[1]];
 
          if (e1->rank == e2->rank) { continue; }
          if (e1->rank > e2->rank) { std::swap(e1, e2); }
 
-         face_orient[face->index] = get_face_orientation(*face, *e1, *e2);
+         face_orient[face.index] = get_face_orientation(face, *e1, *e2);
       }
    }
 }
 
 void ParNCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
                                    Array<int> &bdr_vertices,
-                                   Array<int> &bdr_edges)
+                                   Array<int> &bdr_edges, Array<int> &bdr_faces)
 {
-   NCMesh::GetBoundaryClosure(bdr_attr_is_ess, bdr_vertices, bdr_edges);
+   NCMesh::GetBoundaryClosure(bdr_attr_is_ess, bdr_vertices, bdr_edges, bdr_faces);
 
-   int i, j;
-   // filter out ghost vertices
-   for (i = j = 0; i < bdr_vertices.Size(); i++)
+   if (Dim == 3)
    {
-      if (bdr_vertices[i] < NVertices) { bdr_vertices[j++] = bdr_vertices[i]; }
+      // Mark masters of shared slave boundary faces as essential boundary faces. Some
+      // master faces may only have slave children.
+      for (const auto &mf : shared_faces.masters)
+      {
+         if (elements[mf.element].rank != MyRank) { continue; }
+         for (int j = mf.slaves_begin; j < mf.slaves_end; j++)
+         {
+            const auto &sf = GetFaceList().slaves[j];
+            if (sf.index < 0)
+            {
+               // Edge-face constraint. Skip this edge.
+               continue;
+            }
+            Face *face = GetFace(elements[sf.element], sf.local);
+            if (face && face->Boundary() && bdr_attr_is_ess[face->attribute - 1])
+            {
+               bdr_faces.Append(mf.index);
+            }
+         }
+      }
    }
-   bdr_vertices.SetSize(j);
-
-   // filter out ghost edges
-   for (i = j = 0; i < bdr_edges.Size(); i++)
+   else if (Dim == 2)
    {
-      if (bdr_edges[i] < NEdges) { bdr_edges[j++] = bdr_edges[i]; }
+      // Mark masters of shared slave boundary edges as essential boundary edges. Some
+      // master edges may only have slave children.
+      for (const auto &me : shared_edges.masters)
+      {
+         if (elements[me.element].rank != MyRank) { continue; }
+         for (int j = me.slaves_begin; j < me.slaves_end; j++)
+         {
+            const auto &se = GetEdgeList().slaves[j];
+            Face *face = GetFace(elements[se.element], se.local);
+            if (face && face->Boundary() && bdr_attr_is_ess[face->attribute - 1])
+            {
+               bdr_edges.Append(me.index);
+            }
+         }
+      }
    }
-   bdr_edges.SetSize(j);
+
+   // Filter, sort and unique an array, so it contains only local unique values.
+   auto FilterSortUnique = [](Array<int> &v, int N)
+   {
+      // Perform the O(N) filter before the O(NlogN) sort.
+      auto local = std::remove_if(v.begin(), v.end(), [N](int i) { return i >= N; });
+      std::sort(v.begin(), local);
+      v.SetSize(std::distance(v.begin(), std::unique(v.begin(), local)));
+   };
+
+   FilterSortUnique(bdr_vertices, NVertices);
+   FilterSortUnique(bdr_edges, NEdges);
+   FilterSortUnique(bdr_faces, NFaces);
 }
 
 
@@ -698,9 +738,9 @@ static void set_to_array(const std::set<T> &set, Array<T> &array)
 {
    array.Reserve(set.size());
    array.SetSize(0);
-   for (std::set<int>::iterator it = set.begin(); it != set.end(); ++it)
+   for (auto x : set)
    {
-      array.Append(*it);
+      array.Append(x);
    }
 }
 
@@ -789,8 +829,10 @@ void ParNCMesh::GetConformingSharedStructures(ParMesh &pmesh)
       for (int ent = 0; ent < Dim; ent++)
       {
          GetSharedList(ent);
-         MFEM_VERIFY(entity_conf_group[ent].Size(), "internal error");
-         MFEM_VERIFY(entity_elem_local[ent].Size(), "internal error");
+         MFEM_VERIFY(entity_conf_group[ent].Size() ||
+                     pmesh.GetNE() == 0, "Non empty partitions must be connected");
+         MFEM_VERIFY(entity_elem_local[ent].Size() ||
+                     pmesh.GetNE() == 0, "Non empty partitions must be connected");
       }
    }
 
@@ -1119,7 +1161,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
             bool sloc = (sfe.rank == MyRank);
             bool mloc = (mfe.rank == MyRank);
             if (sloc == mloc // both or neither face is owned by this processor
-                || sf.index < 0) // the face is degenerate (i.e. a face-edge constraint)
+                || sf.index < 0) // the face is degenerate (i.e. a edge-face constraint)
             {
                continue;
             }
@@ -1307,8 +1349,6 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
       }
    }
-
-
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
@@ -1322,7 +1362,6 @@ void ParNCMesh::ClearAuxPM()
    aux_pm_store.DeleteAll();
 }
 
-
 //// Prune, Refine, Derefine ///////////////////////////////////////////////////
 
 bool ParNCMesh::PruneTree(int elem)
@@ -1953,10 +1992,9 @@ void ParNCMesh::RedistributeElements(Array<int> &new_ranks, int target_elements,
    NeighborElementRankMessage::RecvAll(recv_ghost_ranks, MyComm);
 
    // read new ranks for the ghost layer from messages received
-   NeighborElementRankMessage::Map::iterator it;
-   for (it = recv_ghost_ranks.begin(); it != recv_ghost_ranks.end(); ++it)
+   for (auto &kv : recv_ghost_ranks)
    {
-      NeighborElementRankMessage &msg = it->second;
+      NeighborElementRankMessage &msg = kv.second;
       for (int i = 0; i < msg.Size(); i++)
       {
          int ghost_index = elements[msg.elements[i]].index;
@@ -2483,9 +2521,8 @@ void ParNCMesh::AdjustMeshIds(Array<MeshId> ids[], int rank)
 
    // find vertices/edges of master faces shared with 'rank', and modify their
    // MeshIds so their element/local matches the element of the master face
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const MeshId &face_id : shared_faces.masters)
    {
-      const MeshId &face_id = shared_faces.masters[i];
       if (contains_rank[entity_pmat_group[2][face_id.index]])
       {
          int v[4], e[4], eo[4], pos, k;
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index df5fb929e..d33f5cbbe 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -229,10 +229,11 @@ public:
                                     const Table &deref_table);
 
    /** Extension of NCMesh::GetBoundaryClosure. Filters out ghost vertices and
-       ghost edges from 'bdr_vertices' and 'bdr_edges'. */
+       ghost edges from 'bdr_vertices' and 'bdr_edges', and uncovers hidden internal
+       boundary faces. */
    void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
                            Array<int> &bdr_vertices,
-                           Array<int> &bdr_edges) override;
+                           Array<int> &bdr_edges, Array<int> &bdr_faces) override;
 
    /// Save memory by releasing all non-essential and cached data.
    void Trim() override;
@@ -258,8 +259,6 @@ protected: // interface for ParMesh
    /** Populate face neighbor members of ParMesh from the ghost layer, without
        communication. */
    void GetFaceNeighbors(class ParMesh &pmesh);
-
-
 protected: // implementation
 
    MPI_Comm MyComm;
diff --git a/mesh/point.cpp b/mesh/point.cpp
index ecf6a4dd0..473655b11 100644
--- a/mesh/point.cpp
+++ b/mesh/point.cpp
@@ -21,12 +21,24 @@ Point::Point( const int *ind, int attr ) : Element(Geometry::POINT)
    indices[0] = ind[0];
 }
 
-void Point::GetVertices( Array<int> &v ) const
+void Point::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 1 );
+   v.SetSize(1);
    v[0] = indices[0];
 }
 
+void Point::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 1, "!");
+   indices[0] = v[0];
+}
+
+
+void Point::SetVertices(const int *ind)
+{
+   indices[0] = ind[0];
+}
+
 PointFiniteElement PointFE;
 
 }
diff --git a/mesh/point.hpp b/mesh/point.hpp
index f154e205e..be00c9c84 100644
--- a/mesh/point.hpp
+++ b/mesh/point.hpp
@@ -33,33 +33,40 @@ public:
    Point( const int *ind, int attr = -1 );
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::POINT; }
+   Type GetType() const override { return Element::POINT; }
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices( Array<int> &v ) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int * GetVertices () { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 1; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return (0); }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   int GetNVertices() const override { return 1; }
+
+   int GetNEdges() const override { return (0); }
+
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Point (indices, attribute); }
 
-   virtual ~Point() { }
+   virtual ~Point() = default;
 };
 
 class PointFiniteElement;
diff --git a/mesh/pyramid.cpp b/mesh/pyramid.cpp
index d67841564..f64f2afe9 100644
--- a/mesh/pyramid.cpp
+++ b/mesh/pyramid.cpp
@@ -48,10 +48,13 @@ void Pyramid::SetVertices(const int *ind)
 void Pyramid::GetVertices(Array<int> &v) const
 {
    v.SetSize(5);
-   for (int i = 0; i < 5; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 5, v.begin());
+}
+
+void Pyramid::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 5, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Pyramid::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 8e171a31d..adcc540ed 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -37,38 +37,42 @@ public:
            int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::PYRAMID; }
+   Type GetType() const override { return Element::PYRAMID; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 5; }
+   int GetNVertices() const override { return 5; }
 
-   virtual int GetNEdges() const { return 8; }
+   int GetNEdges() const override { return 8; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return ( ( fi < 1 ) ? 4 : 3); }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Pyramid(indices, attribute); }
 
-   virtual ~Pyramid() { }
+   virtual ~Pyramid() = default;
 };
 
 extern class LinearPyramidFiniteElement PyramidFE;
diff --git a/mesh/quadrilateral.cpp b/mesh/quadrilateral.cpp
index 1a69cf179..29fa3bbe1 100644
--- a/mesh/quadrilateral.cpp
+++ b/mesh/quadrilateral.cpp
@@ -37,19 +37,20 @@ Quadrilateral::Quadrilateral( int ind1, int ind2, int ind3, int ind4,
 
 void Quadrilateral::SetVertices(const int *ind)
 {
-   for (int i=0; i<4; i++)
-   {
-      indices[i] = ind[i];
-   }
+   std::copy(ind, ind + 4, indices);
 }
 
-void Quadrilateral::GetVertices( Array<int> &v ) const
+void Quadrilateral::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 4 );
-   for (int i=0; i<4; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(4);
+   std::copy(indices, indices + 4, v.begin());
+}
+
+
+void Quadrilateral::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/quadrilateral.hpp b/mesh/quadrilateral.hpp
index 9f6b9a442..70fcbfdcc 100644
--- a/mesh/quadrilateral.hpp
+++ b/mesh/quadrilateral.hpp
@@ -36,37 +36,41 @@ public:
    Quadrilateral(int ind1, int ind2, int ind3, int ind4, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::QUADRILATERAL; }
+   Type GetType() const override { return Element::QUADRILATERAL; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (4); }
+   int GetNEdges() const override { return (4); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Quadrilateral(indices, attribute); }
 
-   virtual ~Quadrilateral() { }
+   virtual ~Quadrilateral() = default;
 };
 
 extern MFEM_EXPORT class BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/segment.cpp b/mesh/segment.cpp
index 717245907..910614770 100644
--- a/mesh/segment.cpp
+++ b/mesh/segment.cpp
@@ -37,13 +37,16 @@ void Segment::SetVertices(const int *ind)
    indices[1] = ind[1];
 }
 
-void Segment::GetVertices( Array<int> &v ) const
+void Segment::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 2 );
-   for (int i=0; i<2; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(2);
+   std::copy(indices, indices + 2, v.begin());
+}
+
+void Segment::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 2, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Linear1DFiniteElement SegmentFE;
diff --git a/mesh/segment.hpp b/mesh/segment.hpp
index 6ca918758..aafc4909f 100644
--- a/mesh/segment.hpp
+++ b/mesh/segment.hpp
@@ -35,37 +35,41 @@ public:
    /// Constructs triangle by specifying the indices and the attribute.
    Segment(int ind1, int ind2, int attr = 1);
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
    /// Return element's type.
-   virtual Type GetType() const { return Element::SEGMENT; }
+   Type GetType() const override { return Element::SEGMENT; }
+
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 2; }
+   int GetNVertices() const override { return 2; }
 
-   virtual int GetNEdges() const { return (0); }
+   int GetNEdges() const override { return 0; }
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Segment(indices, attribute); }
 
-   virtual ~Segment() { }
+   virtual ~Segment() = default;
 };
 
 class Linear1DFiniteElement;
diff --git a/mesh/tetrahedron.cpp b/mesh/tetrahedron.cpp
index c1b0ae6d8..133a69b41 100644
--- a/mesh/tetrahedron.cpp
+++ b/mesh/tetrahedron.cpp
@@ -341,10 +341,13 @@ void Tetrahedron::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Tetrahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(4);
-   for (int i = 0; i < 4; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 4, v.begin());
+}
+
+void Tetrahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Element *Tetrahedron::Duplicate(Mesh *m) const
diff --git a/mesh/tetrahedron.hpp b/mesh/tetrahedron.hpp
index ef8f36eb8..157c75895 100644
--- a/mesh/tetrahedron.hpp
+++ b/mesh/tetrahedron.hpp
@@ -56,7 +56,7 @@ public:
              int ref_flag = 0);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TETRAHEDRON; }
+   Type GetType() const override { return Element::TETRAHEDRON; }
 
    void  ParseRefinementFlag(int refinement_edges[2], int &type,
                              int &flag) const;
@@ -69,10 +69,7 @@ public:
    void SetRefinementFlag(int rf) { refinement_flag = rf; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
@@ -81,42 +78,49 @@ public:
    void MarkEdge(const DSTable &v_to_v, const Array<T1> &length,
                  const Array<T2> &length2);
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (6); }
+   int GetNEdges() const override { return (6); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 3; return 4; }
 
-   virtual int GetNFaces() const { return 4; }
+   int GetNFaces() const override { return 4; }
 
-   virtual int GetNFaceVertices(int) const { return 3; }
+   int GetNFaceVertices(int) const override { return 3; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const;
+   Element *Duplicate(Mesh *m) const override;
 
-   virtual ~Tetrahedron() { }
+   virtual ~Tetrahedron() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/triangle.cpp b/mesh/triangle.cpp
index abd2b4379..80d11f4b6 100644
--- a/mesh/triangle.cpp
+++ b/mesh/triangle.cpp
@@ -155,10 +155,13 @@ void Triangle::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Triangle::GetVertices(Array<int> &v) const
 {
    v.SetSize(3);
-   for (int i = 0; i < 3; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 3, v.begin());
+}
+
+void Triangle::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 3, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 // @cond DOXYGEN_SKIP
diff --git a/mesh/triangle.hpp b/mesh/triangle.hpp
index 49fb4fe99..480c04118 100644
--- a/mesh/triangle.hpp
+++ b/mesh/triangle.hpp
@@ -39,13 +39,10 @@ public:
    Triangle(int ind1, int ind2, int ind3, int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TRIANGLE; }
+   Type GetType() const override { return Element::TRIANGLE; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
@@ -59,43 +56,51 @@ public:
    static void MarkEdge(int *indices, const DSTable &v_to_v,
                         const Array<T1> &length, const Array<T2> &length2);
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
+
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int *GetVertices() { return indices; }
 
-   virtual int GetNVertices() const { return 3; }
+   int GetNVertices() const override { return 3; }
 
-   virtual int GetNEdges() const { return (3); }
+   int GetNEdges() const override { return (3); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { MFEM_ABORT("not implemented"); return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Triangle(indices, attribute); }
 
-   virtual ~Triangle() { }
+   virtual ~Triangle() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/wedge.cpp b/mesh/wedge.cpp
index 898da7653..b1aea933d 100644
--- a/mesh/wedge.cpp
+++ b/mesh/wedge.cpp
@@ -50,10 +50,13 @@ void Wedge::SetVertices(const int *ind)
 void Wedge::GetVertices(Array<int> &v) const
 {
    v.SetSize(6);
-   for (int i = 0; i < 6; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 6, v.begin());
+}
+
+void Wedge::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 6, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Wedge::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/wedge.hpp b/mesh/wedge.hpp
index fb8583f8e..2eae6d104 100644
--- a/mesh/wedge.hpp
+++ b/mesh/wedge.hpp
@@ -37,38 +37,42 @@ public:
          int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::WEDGE; }
+   Type GetType() const override { return Element::WEDGE; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 6; }
+   int GetNVertices() const override { return 6; }
 
-   virtual int GetNEdges() const { return 9; }
+   int GetNEdges() const override { return 9; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return (fi < 2) ? 3 : 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Wedge(indices, attribute); }
 
-   virtual ~Wedge() { }
+   virtual ~Wedge() = default;
 };
 
 extern MFEM_EXPORT class LinearWedgeFiniteElement WedgeFE;
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index dc0e9fea8..678abb706 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -43,6 +43,7 @@ set(UNIT_TESTS_SRCS
   linalg/test_operator.cpp
   linalg/test_vector.cpp
   mesh/test_face_orientations.cpp
+  mesh/mesh_test_utils.cpp
   mesh/test_fms.cpp
   mesh/test_mesh.cpp
   mesh/test_ncmesh.cpp
diff --git a/tests/unit/mesh/mesh_test_utils.cpp b/tests/unit/mesh/mesh_test_utils.cpp
new file mode 100644
index 000000000..65fb2e01d
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.cpp
@@ -0,0 +1,207 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mesh_test_utils.hpp"
+
+namespace mfem
+{
+
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction sol(&fes);
+
+   ConstantCoefficient one(1.0);
+   BilinearForm a(&fes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+
+   LinearForm b(&fes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(mesh.bdr_attributes.Max() > 0);
+
+   // Mark all boundaries essential
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      bdr_attr_is_ess[mesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   REQUIRE(ess_tdof_list.Size() > 0);
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B);
+
+   // Solve the system
+   CG(*A, B, X, 2, 1000, 1e-20, 0.0);
+
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   bool satisfy_bc = true;
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+   return ess_tdof_list.Size();
+};
+
+#ifdef MFEM_USE_MPI
+
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&pmesh, &fec);
+
+   ParGridFunction sol(&pfes);
+
+   ConstantCoefficient one(1.0);
+   ParBilinearForm a(&pfes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+   ParLinearForm b(&pfes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(pmesh.bdr_attributes.Max() > 0);
+
+   Array<int> bdr_attr_is_ess(pmesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      CAPTURE(disabled_boundary_attribute);
+      bdr_attr_is_ess[pmesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   int num_ess_dof = ess_tdof_list.Size();
+   MPI_Allreduce(MPI_IN_PLACE, &num_ess_dof, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   REQUIRE(num_ess_dof > 0);
+
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   const bool copy_interior = true; // interior(sol) --> interior(X)
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B, copy_interior);
+
+   // Solve the system
+   CGSolver cg(MPI_COMM_WORLD);
+   // HypreBoomerAMG preconditioner;
+   cg.SetMaxIter(2000);
+   cg.SetRelTol(1e-12);
+   cg.SetPrintLevel(0);
+   cg.SetOperator(*A);
+   // cg.SetPreconditioner(preconditioner);
+   cg.Mult(B, X);
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   // Initialize the bdr_dof to be checked
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   bool satisfy_bc = true;
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+};
+
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition)
+{
+   auto pmesh = std::unique_ptr<ParMesh>(new ParMesh(MPI_COMM_WORLD, smesh,
+                                                     partition.get()));
+
+   int nbe = pmesh->GetNBE();
+   MPI_Allreduce(MPI_IN_PLACE, &nbe, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(nbe == smesh.GetNBE());
+   return pmesh;
+};
+
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared)
+{
+   int e1, e2;
+   pmesh.GetFaceElements(f, &e1, &e2);
+   int inf1, inf2, ncface;
+   pmesh.GetFaceInfos(f, &inf1, &inf2, &ncface);
+
+   if (e2 < 0 && inf2 >=0)
+   {
+      // Shared face on processor boundary -> Need to discover the neighbor
+      // attributes
+      auto FET = pmesh.GetSharedFaceTransformations(local_to_shared.at(f));
+
+      if (FET->Elem1->Attribute != FET->Elem2->Attribute && f < pmesh.GetNumFaces())
+      {
+         // shared face on domain attribute boundary, which this rank owns
+         return true;
+      }
+   }
+
+   if (e2 >= 0 && pmesh.GetAttribute(e1) != pmesh.GetAttribute(e2))
+   {
+      // local face on domain attribute boundary
+      return true;
+   }
+   return false;
+};
+
+#endif
+
+} // namespace mfem
diff --git a/tests/unit/mesh/mesh_test_utils.hpp b/tests/unit/mesh/mesh_test_utils.hpp
new file mode 100644
index 000000000..e4088a788
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.hpp
@@ -0,0 +1,78 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_MESH_TEST_UTILS
+#define MFEM_MESH_TEST_UTILS
+
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+namespace mfem
+{
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a serial mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The SERIAL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute = -1);
+
+#ifdef MFEM_USE_MPI
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a parallel mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The PARALLEL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute = -1);
+
+/**
+ * @brief Check that a Parmesh generates the same number of boundary elements as
+ * the serial mesh.
+ *
+ * @param smesh Serial mesh to be built from and compared against
+ * @param partition Optional partition
+ * @return std::unique_ptr<ParMesh> Pointer to the mesh in question.
+ */
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition = nullptr);
+
+/**
+ * @brief Helper function to track if a face index is internal
+ *
+ * @param pmesh The mesh containing the face
+ * @param f The face index
+ * @param local_to_shared A map from local faces to shared faces
+ * @return true the face is between domain attributes (and owned by this rank)
+ * @return false the face is not between domain attributes or not owned by this rank
+ */
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared);
+
+#endif
+
+} // namespace mfem
+
+#endif // MFEM_MESH_TEST_UTILS
\ No newline at end of file
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index c1bb54e13..c38ab18b2 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -10,6 +10,7 @@
 // CONTRIBUTING.md for details.
 
 #include "mfem.hpp"
+#include "mesh_test_utils.hpp"
 #include "unit_tests.hpp"
 
 #include <array>
@@ -18,6 +19,34 @@ namespace mfem
 
 constexpr double EPS = 1e-10;
 
+// Helper to count H1 essential dofs for a given order with a given attribute
+template <typename FECollection, bool TDOF = true>
+int CountEssentialDof(Mesh &mesh, int order, int attribute)
+{
+   constexpr int dim = 3;
+   FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 0;
+   bdr_attr_is_ess[mesh.bdr_attributes.Find(attribute)] = 1;
+
+   if (TDOF)
+   {
+      Array<int> ess_tdof_list;
+      fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+      return ess_tdof_list.Size();
+   }
+   else
+   {
+      // VDOF
+      Array<int> ess_vdof_marker, vdof_list;
+      fes.GetEssentialVDofs(bdr_attr_is_ess, ess_vdof_marker);
+      fes.MarkerToList(ess_vdof_marker, vdof_list);
+      return vdof_list.Size();
+   }
+};
+
 // Test case: Verify that a conforming mesh yields the same norm for the
 //            assembled diagonal with PA when using the standard (conforming)
 //            Mesh vs. the corresponding (non-conforming) NCMesh.
@@ -114,7 +143,6 @@ TEST_CASE("NCMesh PA diagonal", "[NCMesh]")
 
 } // test case
 
-
 TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -146,7 +174,6 @@ TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
    REQUIRE(summed_volume == MFEM_Approx(original_volume));
 } // test case
 
-
 TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -176,6 +203,134 @@ TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
    REQUIRE(derefined_volume == MFEM_Approx(original_volume));
 } // test case
 
+// Helper to create a mesh of a tet with four face neighbor tets and internal boundary between
+Mesh StarMesh()
+{
+   const int nnode = 4 + 4;
+   const int nelem = 5;
+
+   Mesh mesh(3, nnode, nelem);
+
+   // central tet
+   mesh.AddVertex(0.0, 0.0, 0.0);
+   mesh.AddVertex(1.0, 0.0, 0.0);
+   mesh.AddVertex(0.0, 1.0, 0.0);
+   mesh.AddVertex(0.0, 0.0, 1.0);
+
+   mesh.AddVertex( 1.0,  1.0,  1.0); // opposite 0
+   mesh.AddVertex(-1.0,  0.0,  0.0); // opposite 1
+   mesh.AddVertex( 0.0, -1.0,  0.0); // opposite 2
+   mesh.AddVertex( 0.0,  0.0, -1.0); // opposite 3
+
+   mesh.AddTet(0, 1, 2, 3, 1); // central
+   mesh.AddTet(4, 1, 2, 3, 2); // opposite 0
+   mesh.AddTet(0, 5, 2, 3, 3); // opposite 1
+   mesh.AddTet(0, 1, 6, 3, 4); // opposite 2
+   mesh.AddTet(0, 1, 2, 7, 5); // opposite 3
+
+   mesh.FinalizeTopology();
+   mesh.Finalize(true, true);
+
+   // Introduce internal boundary elements
+   const int new_attribute = mesh.bdr_attributes.Max() + 1;
+   Array<int> original_boundary_vertices;
+   for (int f = 0; f < mesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      mesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && mesh.GetAttribute(e1) != mesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = mesh.GetFace(f)->Duplicate(&mesh);
+         new_elem->SetAttribute(new_attribute);
+         new_elem->GetVertices(original_boundary_vertices);
+         mesh.AddBdrElement(new_elem);
+      }
+   }
+   mesh.SetAttributes();
+   mesh.FinalizeTopology();
+   mesh.Finalize(true, true);
+
+   return mesh;
+}
+
+Mesh DividingPlaneMesh(bool tet_mesh = true, bool split = true)
+{
+   auto mesh = Mesh("../../data/ref-cube.mesh");
+   {
+      Array<Refinement> refs;
+      refs.Append(Refinement(0, Refinement::X));
+      mesh.GeneralRefinement(refs);
+   }
+   delete mesh.ncmesh;
+   mesh.ncmesh = nullptr;
+   mesh.FinalizeTopology();
+   mesh.Finalize(true, true);
+
+   mesh.SetAttribute(0, 1);
+   mesh.SetAttribute(1, split ? 2 : 1);
+
+   // Introduce internal boundary elements
+   const int new_attribute = mesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < mesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      mesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && mesh.GetAttribute(e1) != mesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = mesh.GetFace(f)->Duplicate(&mesh);
+         new_elem->SetAttribute(new_attribute);
+         mesh.AddBdrElement(new_elem);
+      }
+   }
+   if (tet_mesh)
+   {
+      mesh = Mesh::MakeSimplicial(mesh);
+   }
+   mesh.FinalizeTopology();
+   mesh.Finalize(true, true);
+   return mesh;
+}
+
+// Define a pair of tet with a shared triangle in the y-z plane.
+// Vary the vertex ordering to achieve the 3 possible odd orientations
+Mesh OrientedTriFaceMesh(int orientation, bool add_extbdr = false)
+{
+   REQUIRE((orientation == 1 || orientation == 3 || orientation == 5));
+
+   Mesh mesh(3, 4, 2);
+   mesh.AddVertex(-1.0, 0.0, 0.0);
+   mesh.AddVertex(0.0, 0.0, 0.0);
+   mesh.AddVertex(0.0, 1.0, 0.0);
+   mesh.AddVertex(0.0, 0.0, 1.0);
+
+   // opposing vertex
+   mesh.AddVertex(1.0, 0.0, 0.0);
+
+   mesh.AddTet(0, 1, 2, 3, 1);
+
+   switch (orientation)
+   {
+      case 1:
+         mesh.AddTet(4,2,1,3,2); break;
+      case 3:
+         mesh.AddTet(4,3,2,1,2); break;
+      case 5:
+         mesh.AddTet(4,1,3,2,2); break;
+   }
+
+   mesh.FinalizeTopology(add_extbdr);
+   mesh.SetAttributes();
+
+   auto *bdr = new Triangle(1,2,3,
+                            mesh.bdr_attributes.Size() == 0 ? 1 : mesh.bdr_attributes.Max() + 1);
+   mesh.AddBdrElement(bdr);
+
+   mesh.FinalizeTopology(false);
+   mesh.Finalize();
+   return mesh;
+};
 
 #ifdef MFEM_USE_MPI
 
@@ -297,7 +452,6 @@ TEST_CASE("pNCMesh PA diagonal",  "[Parallel], [NCMesh]")
    }
 } // test case
 
-
 // Given a parallel and a serial mesh, perform an L2 projection and check the
 // solutions match exactly.
 std::array<double, 2> CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
@@ -618,7 +772,6 @@ TEST_CASE("EdgeFaceConstraint",  "[Parallel], [NCMesh]")
          }
       }
       ParMesh pmesh(MPI_COMM_WORLD, smesh, partition.get());
-
       {
          constexpr int dim = 3;
          constexpr int order = 1;
@@ -630,7 +783,6 @@ TEST_CASE("EdgeFaceConstraint",  "[Parallel], [NCMesh]")
          const auto parallel_ntdof = pfes.GlobalTrueVSize();
          CHECK(serial_ntdof == parallel_ntdof);
       }
-
       for (int order = 1; order <= 4; order++)
       {
          CAPTURE(order);
@@ -1026,6 +1178,2607 @@ TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
    }
 }
 
-#endif // MFEM_USE_MPI
+TEST_CASE("TetCornerRefines", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+// Count the number of essential dofs on a ParMesh.
+template <typename FECollection, bool TDOF = true>
+int CountEssentialDof(ParMesh &mesh, int order, int attribute)
+{
+   constexpr int dim = 3;
+   FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&mesh, &fec);
+
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 0;
+   bdr_attr_is_ess[mesh.bdr_attributes.Find(attribute)] = 1;
+
+   Array<int> ess_tdof_list;
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   if (TDOF)
+   {
+      pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+      return ess_tdof_list.Size();
+   }
+   else
+   {
+      // VDOF
+      Array<int> ess_vdof_marker, vdof_list;
+      pfes.GetEssentialVDofs(bdr_attr_is_ess, ess_vdof_marker);
+      pfes.MarkerToList(ess_vdof_marker, vdof_list);
+      return vdof_list.Size();
+   }
+};
+
+template <typename FECollection, bool TDOF = true>
+int ParCountEssentialDof(ParMesh &mesh, int order, int attribute)
+{
+   auto num_essential_dof = CountEssentialDof<FECollection, TDOF>(mesh, order,
+                                                                  attribute);
+   MPI_Allreduce(MPI_IN_PLACE, &num_essential_dof, 1, MPI_INT, MPI_SUM,
+                 MPI_COMM_WORLD);
+   return num_essential_dof;
+};
+
+TEST_CASE("InteriorBoundaryReferenceTets", "[Parallel], [NCMesh]")
+{
+   constexpr auto seed = 314159;
+   srand(seed);
+   auto p = 1;//GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   int num_initial_ess_tdof = CountEssentialDof<H1_FECollection>(*pmesh, p,
+                                                                 smesh.bdr_attributes.Max());
+   if (Mpi::Root())
+   {
+      REQUIRE(num_initial_ess_tdof > 0);
+   }
+   // Level of refinement difference across the processor boundary from root zero to the
+   // others
+   auto ref_level = 1;//GENERATE(1,2,3);
+   auto refined_attribute = 2;//GENERATE(1,2);
+   CAPTURE(ref_level);
+   CAPTURE(refined_attribute);
+
+   Mesh modified_smesh(smesh);
+   for (int r = 0; r < ref_level; r++)
+   {
+      Array<int> el_to_refine;
+      for (int n = 0; n < modified_smesh.GetNE(); n++)
+      {
+         if (modified_smesh.GetAttribute(n) == refined_attribute)
+         {
+            el_to_refine.Append(n);
+         }
+      }
+      modified_smesh.GeneralRefinement(el_to_refine);
+   }
+
+   // There should now be some internal boundary elements, where there was one
+   // before.
+   CHECK(modified_smesh.GetNBE() == 3 /* external boundaries of unrefined  */
+         + std::pow(4, ref_level) /* internal boundaries */
+         + (3 * std::pow(4, ref_level)) /* external boundaries of refined */);
+
+   // Force the partition to have the edge case of a parent and child being
+   // divided across the processor boundary. This necessitates the
+   // GhostBoundaryElement treatment.
+   auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+   for (int i = 0; i < modified_smesh.GetNE(); i++)
+   {
+      // Randomly assign to any processor but zero.
+      partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+   }
+   if (Mpi::WorldSize() > 0)
+   {
+      // Make sure rank 0 has the non-refined attribute. This ensures it will have
+      // a parent face with only ghost children.
+      const int unrefined_attribute = refined_attribute == 1 ? 2 : 1;
+      Array<int> root_element;
+      for (int n = 0; n < modified_smesh.GetNE(); n++)
+      {
+         if (modified_smesh.GetAttribute(n) == unrefined_attribute)
+         {
+            root_element.Append(n);
+         }
+      }
+      REQUIRE(root_element.Size() == 1);
+      partition[root_element[0]] = 0;
+   }
+
+   pmesh = CheckParMeshNBE(modified_smesh, partition);
+   pmesh->Finalize();
+   pmesh->FinalizeTopology();
+   pmesh->ExchangeFaceNbrData();
+
+   // return;
+   auto check_faces = [&]()
+   {
+      // repopulate the local to shared map.
+      local_to_shared.clear();
+      for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+      {
+         local_to_shared[pmesh->GetSharedFace(i)] = i;
+      }
+
+      // Count the number of internal faces via the boundary elements
+      num_internal = 0;
+      for (int n = 0; n < pmesh->GetNBE(); ++n)
+      {
+         int f, o;
+         pmesh->GetBdrElementFace(n, &f, &o);
+         if (CheckFaceInternal(*pmesh, f, local_to_shared))
+         {
+            ++num_internal;
+         }
+      }
+      MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+      CHECK(num_internal == std::pow(4, ref_level));
+      CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+      CheckPoisson(*pmesh, p);
+   };
+
+
+   check_faces();
+   pmesh->Rebalance();
+   pmesh->ExchangeFaceNbrData();
+   check_faces();
+}
+
+TEST_CASE("InteriorBoundaryInlineTetRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-tet.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   auto num_attributes = 3;
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % num_attributes) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   smesh.EnsureNCMesh(true);
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark all elements of a given attribute for refinement to a given depth.
+   auto ref_level = GENERATE(1,2);
+   auto marked_attribute = GENERATE(1,2,3);
+   REQUIRE(marked_attribute <= num_attributes);
+   CAPTURE(ref_level);
+   CAPTURE(marked_attribute);
+   for (int r = 0; r < ref_level; r++)
+   {
+      Array<int> elem_to_refine;
+      for (int i = 0; i < smesh.GetNE(); ++i)
+      {
+         if (smesh.GetAttribute(i) == marked_attribute)
+         {
+            elem_to_refine.Append(i);
+         }
+      }
+      smesh.GeneralRefinement(elem_to_refine);
+   }
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   auto check_faces = [&]()
+   {
+      // repopulate the local to shared map.
+      local_to_shared.clear();
+      for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+      {
+         local_to_shared[pmesh->GetSharedFace(i)] = i;
+      }
+
+      num_internal = 0;
+      for (int n = 0; n < pmesh->GetNBE(); ++n)
+      {
+         int f, o;
+         pmesh->GetBdrElementFace(n, &f, &o);
+         if (CheckFaceInternal(*pmesh, f, local_to_shared))
+         {
+            ++num_internal;
+         }
+      }
+      MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+      CHECK(num_internal == num_internal_serial);
+
+      CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+      CheckPoisson(*pmesh, p);
+   };
+
+   check_faces();
+   pmesh->Rebalance();
+   pmesh->ExchangeFaceNbrData();
+   check_faces();
+}
+
+TEST_CASE("InteriorBoundaryReferenceCubes", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+
+   REQUIRE(smesh.GetNBE() == 6);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   // Throw away the NCMesh, will restart NC later.
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 5 + 1);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Conforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 5 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (5 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rank 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineHexRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-hex.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+TEST_CASE("ParMeshInternalBoundaryStarMesh", "[Parallel], [NCMesh]")
+{
+   auto smesh = StarMesh();
+   smesh.EnsureNCMesh(true);
+
+   if (Mpi::WorldSize() < 5) { return;}
+
+   auto partition = std::unique_ptr<int[]>(new int[5]);
+   for (int i = 0; i < 5; i++)
+   {
+      partition[i] = i;
+   }
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   const int rank = Mpi::WorldRank();
+   SECTION("Unrefined")
+   {
+      MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+      CHECK(num_internal == 4);
+
+      CHECK(CountEssentialDof<H1_FECollection>(*pmesh, 1,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 4 : 0));
+      CHECK(CountEssentialDof<H1_FECollection>(*pmesh, 2,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 4 + 6 : 0));
+      CHECK(CountEssentialDof<H1_FECollection>(*pmesh, 3,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 4 + 6*2 + 4*1 : 0));
+      CHECK(CountEssentialDof<H1_FECollection>(*pmesh, 4,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 4 + 6*3 + 4*3 : 0));
+
+      CHECK(CountEssentialDof<ND_FECollection>(*pmesh, 1,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 6 : 0));
+      CHECK(CountEssentialDof<ND_FECollection>(*pmesh, 2,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 20 : 0));
+      CHECK(CountEssentialDof<ND_FECollection>(*pmesh, 3,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 42 : 0));
+      CHECK(CountEssentialDof<ND_FECollection>(*pmesh, 4,
+                                               smesh.bdr_attributes.Max()) == (rank == 0 ? 72 : 0));
+      CHECK(pmesh->GetNBE() == (rank == 0 ? 4 : (rank < 5 ? 3 : 0)));
+   }
+
+   SECTION("Refinement")
+   {
+      // Refining an element attached to the core should not change the number of essential
+      // DOF, or the owner of them.
+
+      const int refined_attribute = GENERATE(1,2,3,4,5); // equal to rank of owner + 1
+      int ref_level = GENERATE(0, 1, 2, 3);
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < pmesh->GetNE(); n++)
+         {
+            if (pmesh->GetAttribute(n) == refined_attribute)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         pmesh->GeneralRefinement(el_to_refine);
+      }
+      pmesh->ExchangeFaceNbrData();
+
+      CAPTURE(rank);
+      CAPTURE(refined_attribute);
+      CAPTURE(ref_level);
+      CHECK(pmesh->GetNE() == (rank == refined_attribute - 1 ? std::pow(8,
+                                                                        ref_level) : 1));
+      CHECK(pmesh->GetNBE() == (rank == refined_attribute - 1
+                                ? std::pow(4, ref_level + 1)
+                                : (ref_level == 0 && rank == 0 ? 4 : 3)));
+
+      // Refining on only one side of the boundary face should not change the number of
+      // essential true dofs, which should match the number within the original face.
+      CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 1,
+                                                  smesh.bdr_attributes.Max()) == 4);
+      CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 2,
+                                                  smesh.bdr_attributes.Max()) == 4 + 6);
+      CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 3,
+                                                  smesh.bdr_attributes.Max()) == 4 + 6*2 + 4*1);
+      CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 4,
+                                                  smesh.bdr_attributes.Max()) == 4 + 6*3 + 4*3);
+
+      CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 1,
+                                                  smesh.bdr_attributes.Max()) == (rank == 0 ? 6 : 0));
+      CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 2,
+                                                  smesh.bdr_attributes.Max()) == (rank == 0 ? 20 : 0));
+      CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 3,
+                                                  smesh.bdr_attributes.Max()) == (rank == 0 ? 42 : 0));
+      CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 4,
+                                                  smesh.bdr_attributes.Max()) == (rank == 0 ? 72 : 0));
+   }
+}
+
+TEST_CASE("ParDividingPlaneMesh", "[Parallel], [NCMesh]")
+{
+   auto RefineAttribute = [](Mesh& mesh, int attr, int ref_level)
+   {
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < mesh.GetNE(); n++)
+         {
+            if (mesh.GetAttribute(n) == attr)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         mesh.GeneralRefinement(el_to_refine);
+      }
+   };
+
+   SECTION("Hex")
+   {
+      auto mesh = DividingPlaneMesh(false);
+      mesh.EnsureNCMesh(true);
+
+      CHECK(mesh.GetNBE() == 2 * 5 + 1);
+      CHECK(mesh.GetNE() == 2);
+
+      SECTION("H1Hex")
+      {
+         mesh.UniformRefinement();
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == 3*3);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == 5*5);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == 7*7);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == 9*9);
+
+         auto attr = GENERATE(1,2);
+         auto ref_level = GENERATE(1,2);
+         RefineAttribute(mesh, attr, ref_level);
+
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == 3*3);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == 5*5);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == 7*7);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == 9*9);
+      }
+   }
+
+   SECTION("Tet")
+   {
+      auto mesh = DividingPlaneMesh(true, true);
+      mesh.EnsureNCMesh(true);
+      auto pmesh = CheckParMeshNBE(mesh);
+      pmesh->FinalizeTopology();
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CHECK(pmesh->bdr_attributes.Max() == mesh.bdr_attributes.Max());
+
+      auto attr = GENERATE(1,2);
+      auto ref_level = GENERATE(1,2);
+      CAPTURE(attr);
+      CAPTURE(ref_level);
+
+      const int initial_num_vert = 4;
+      const int initial_num_edge = 5;
+      const int initial_num_face = 2;
+      SECTION("H1Tet")
+      {
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 1,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 2,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + initial_num_edge);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 3,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + 2*initial_num_edge +
+               initial_num_face);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 4,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + 3*initial_num_edge +
+               3*initial_num_face);
+
+         RefineAttribute(*pmesh, attr, ref_level);
+
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 1,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 2,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + initial_num_edge);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 3,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + 2*initial_num_edge +
+               initial_num_face);
+         CHECK(ParCountEssentialDof<H1_FECollection>(*pmesh, 4,
+                                                     mesh.bdr_attributes.Max()) == initial_num_vert + 3*initial_num_edge +
+               3*initial_num_face);
+      }
+
+      SECTION("NDTet")
+      {
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 1,
+                                                     mesh.bdr_attributes.Max()) == 5);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 2,
+                                                     mesh.bdr_attributes.Max()) == 14);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 3,
+                                                     mesh.bdr_attributes.Max()) == 27);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 4,
+                                                     mesh.bdr_attributes.Max()) == 44);
+
+         RefineAttribute(*pmesh, attr, ref_level);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 1,
+                                                     mesh.bdr_attributes.Max()) == 5);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 2,
+                                                     mesh.bdr_attributes.Max()) == 14);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 3,
+                                                     mesh.bdr_attributes.Max()) == 27);
+         CHECK(ParCountEssentialDof<ND_FECollection>(*pmesh, 4,
+                                                     mesh.bdr_attributes.Max()) == 44);
+      }
+   }
+}
+
+TEST_CASE("ParTetFaceFlips", "[Parallel], [NCMesh]")
+{
+   /*
+      1. Define an ND space, and project a smooth non polynomial function onto the space.
+      2. Compute y-z components in the face, and check that they are equal when evaluated
+         from either side of the face. Tangential continuity of the ND space should ensure
+         they are identical, if orientations are correctly accounted for.
+      3. Mark the mesh as NC, build a new FESpace, and repeat. There should be no change as
+         the faces are "conformal" though they are within the NC structure.
+      3. Partition the mesh, create a ParFESpace and repeat the above. There should be no
+         difference in conformal parallel.
+      4. Construct the ParMesh from the NCMesh and repeat. As above, there should be no
+         change.
+      5. Perform NC refinement on one side of the internal face, the number of conformal dof
+         in the face will not change, so there should also be no difference. This will be
+         complicated by ensuring the slave evaluations are at the same points.
+   */
+
+   auto orientation = GENERATE(1,3,5);
+   auto smesh = OrientedTriFaceMesh(orientation);
+   smesh.EnsureNodes();
+
+   CHECK(smesh.GetNBE() == 1);
+
+   // A smooth function in each vector component
+   constexpr int order = 3, dim = 3, quadrature_order = 4;
+   constexpr double kappa = 2 * M_PI;
+   auto E_exact = [=](const Vector &x, Vector &E)
+   {
+      E(0) = cos(kappa * x(1));
+      E(1) = cos(kappa * x(2));
+      E(2) = cos(kappa * x(0));
+   };
+   VectorFunctionCoefficient E_coeff(dim, E_exact);
+
+   // Helper for evaluating the ND grid function on either side of the first conformal shared face.
+   // Specific to the pair of tet mesh described above, but can be generalized.
+   auto CheckParallelNDConformal = [&](ParMesh &mesh)
+   {
+      ND_FECollection fe_collection(order, dim);
+      ParFiniteElementSpace fe_space(&mesh, &fe_collection);
+      ParGridFunction E(&fe_space);
+
+      E.ProjectCoefficient(E_coeff);
+      E.ExchangeFaceNbrData();
+
+      auto *P = fe_space.GetProlongationMatrix();
+      if (P != nullptr)
+      {
+         // Projection does not respect the non-conformal constraints.
+         // Extract the true (conformal) and prolongate to get the NC respecting projection.
+         auto E_true = E.GetTrueVector();
+         P->Mult(E_true, E);
+         E.ExchangeFaceNbrData();
+      }
+      ParGridFunction * const coords = dynamic_cast<ParGridFunction*>
+                                       (mesh.GetNodes());
+
+      const auto &ir = IntRules.Get(Geometry::Type::TRIANGLE, quadrature_order);
+      IntegrationRule left_eir(ir.GetNPoints()),
+                      right_eir(ir.GetNPoints()); // element integration rules
+
+      for (int n = 0; n < mesh.GetNBE(); n++)
+      {
+         auto f = mesh.GetBdrElementFaceIndex(n);
+
+         auto finfo = mesh.GetFaceInformation(f);
+         auto &face_element_transform = finfo.IsShared()
+                                        ? *mesh.GetSharedFaceTransformationsByLocalIndex(f, true)
+                                        : *mesh.GetFaceElementTransformations(f);
+
+         face_element_transform.Loc1.Transform(ir, left_eir);
+         face_element_transform.Loc2.Transform(ir, right_eir);
+
+         constexpr double tol = 1e-14;
+         REQUIRE(left_eir.GetNPoints() == ir.GetNPoints());
+         REQUIRE(right_eir.GetNPoints() == ir.GetNPoints());
+         Vector left_val, right_val;
+         for (int i = 0; i < ir.GetNPoints(); i++)
+         {
+            face_element_transform.Elem1->SetIntPoint(&left_eir[i]);
+            coords->GetVectorValue(*face_element_transform.Elem1, left_eir[i], left_val);
+            coords->GetVectorValue(*face_element_transform.Elem1, left_eir[i], right_val);
+            REQUIRE(std::abs(left_val(0) - right_val(0)) < tol);
+            REQUIRE(std::abs(left_val(1) - right_val(1)) < tol);
+            REQUIRE(std::abs(left_val(2) - right_val(2)) < tol);
+            E.GetVectorValue(*face_element_transform.Elem1, left_eir[i], left_val);
+
+            face_element_transform.Elem2->SetIntPoint(&right_eir[i]);
+            E.GetVectorValue(*face_element_transform.Elem2, right_eir[i], right_val);
+
+            // Check that the second and third rows agree.
+            // The y and z should agree as the normal is in the x direction
+            CHECK(std::abs(left_val(1) - right_val(1)) < tol);
+            CHECK(std::abs(left_val(2) - right_val(2)) < tol);
+         }
+      }
+
+      return fe_space.GlobalTrueVSize();
+   };
+
+   SECTION("Conformal")
+   {
+      auto partition_flag = GENERATE(false, true);
+      CAPTURE(partition_flag);
+      auto partition = std::unique_ptr<int[]>(new int[2]);
+      if (Mpi::WorldSize() > 1)
+      {
+         partition[0] = partition_flag ? 0 : 1; partition[1] = partition_flag  ? 1 : 0;
+      }
+      else
+      {
+         partition[0] = 0; partition[1] = 0;
+      }
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("ConformalSerialUniformRefined")
+   {
+      smesh.UniformRefinement();
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("ConformalParallelUniformRefined")
+   {
+      auto partition_flag = GENERATE(false, true);
+      CAPTURE(partition_flag);
+      auto partition = std::unique_ptr<int[]>(new int[2]);
+      if (Mpi::WorldSize() > 1)
+      {
+         partition[0] = partition_flag ? 0 : 1; partition[1] = partition_flag  ? 1 : 0;
+      }
+      else
+      {
+         partition[0] = 0; partition[1] = 0;
+      }
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->UniformRefinement();
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("Nonconformal")
+   {
+      auto partition_flag = GENERATE(false, true);
+      CAPTURE(partition_flag);
+      auto partition = std::unique_ptr<int[]>(new int[2]);
+      if (Mpi::WorldSize() > 1)
+      {
+         partition[0] = partition_flag ? 0 : 1; partition[1] = partition_flag  ? 1 : 0;
+      }
+      else
+      {
+         partition[0] = 0; partition[1] = 0;
+      }
+      smesh.EnsureNCMesh(true);
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("NonconformalSerialUniformRefined")
+   {
+      smesh.UniformRefinement();
+      smesh.EnsureNCMesh(true);
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("NonconformalSerialRefined")
+   {
+      smesh.EnsureNCMesh(true);
+      int ref_level = GENERATE(1, 2);
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < smesh.GetNE(); n++)
+         {
+            if (smesh.GetAttribute(n) == 2)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         smesh.GeneralRefinement(el_to_refine);
+      }
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("NonconformalParallelUniformRefined")
+   {
+      auto partition_flag = GENERATE(false, true);
+      CAPTURE(partition_flag);
+      auto partition = std::unique_ptr<int[]>(new int[2]);
+      if (Mpi::WorldSize() > 1)
+      {
+         partition[0] = partition_flag ? 0 : 1; partition[1] = partition_flag  ? 1 : 0;
+      }
+      else
+      {
+         partition[0] = 0; partition[1] = 0;
+      }
+      smesh.EnsureNCMesh(true);
+      auto pmesh = CheckParMeshNBE(smesh);
+      pmesh->UniformRefinement();
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("NonconformalParallelRefined")
+   {
+      auto partition_flag = GENERATE(false, true);
+      CAPTURE(partition_flag);
+      auto partition = std::unique_ptr<int[]>(new int[2]);
+      if (Mpi::WorldSize() > 1)
+      {
+         partition[0] = partition_flag ? 0 : 1; partition[1] = partition_flag  ? 1 : 0;
+      }
+      else
+      {
+         partition[0] = 0; partition[1] = 0;
+      }
+      smesh.EnsureNCMesh(true);
+      auto pmesh = CheckParMeshNBE(smesh);
+      int ref_level = GENERATE(1, 2);
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < pmesh->GetNE(); n++)
+         {
+            if (pmesh->GetAttribute(n) == 2)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         pmesh->GeneralRefinement(el_to_refine);
+      }
+      pmesh->Finalize();
+      pmesh->ExchangeFaceNbrData();
+
+      CheckParallelNDConformal(*pmesh);
+   }
+
+   SECTION("NonconformalLevelTwoRefined")
+   {
+      smesh.EnsureNCMesh(true);
+      smesh.UniformRefinement();
+      Array<int> el_to_refine(1);
+      for (int n = 0; n < smesh.GetNE(); n++)
+      {
+         if (smesh.GetAttribute(n) == 2)
+         {
+            CAPTURE(n);
+            Mesh smesh2(smesh);
+            el_to_refine[0] = n;
+            smesh2.GeneralRefinement(el_to_refine);
+            for (int m = 0; m < smesh2.GetNE(); m++)
+            {
+               if (smesh2.GetAttribute(m) == 2)
+               {
+                  CAPTURE(m);
+                  Mesh smesh3(smesh2);
+                  el_to_refine[0] = m;
+                  smesh3.GeneralRefinement(el_to_refine);
+                  CheckParallelNDConformal(*CheckParMeshNBE(smesh3));
+               }
+            }
+         }
+      }
+   }
+
+}
+
+// Helper to check the identity PR = I on a ParFiniteElementSpace.
+void CheckRPIdentity(const ParFiniteElementSpace& pfespace)
+{
+   const SparseMatrix *R = pfespace.GetRestrictionMatrix();
+   HypreParMatrix *P = pfespace.Dof_TrueDof_Matrix();
+
+   REQUIRE(R != nullptr);
+   REQUIRE(P != nullptr);
+
+   HypreParMatrix *hR = new HypreParMatrix(
+      pfespace.GetComm(), pfespace.GlobalTrueVSize(),
+      pfespace.GlobalVSize(), pfespace.GetTrueDofOffsets(),
+      pfespace.GetDofOffsets(),
+      const_cast<SparseMatrix*>(R)); // Non owning so cast is ok
+
+   REQUIRE(hR->Height() == P->Width());
+   REQUIRE(hR->Width() == P->Height());
+
+   REQUIRE(hR != nullptr);
+   HypreParMatrix *I = ParMult(hR, P);
+
+   // Square matrix so the "diag" is the only bit we need.
+   SparseMatrix diag;
+   I->GetDiag(diag);
+   for (int i = 0; i < diag.Height(); i++)
+      for (int j = 0; j < diag.Width(); j++)
+      {
+         // cast to const to force a zero return rather than an abort.
+         CHECK(const_cast<const SparseMatrix&>(diag)(i, j)  == (i == j ? 1.0 : 0.0));
+      }
+
+   delete hR;
+   delete I;
+}
+
+TEST_CASE("Parallel RP=I", "[Parallel], [NCMesh]")
+{
+   const int order = GENERATE(1, 2, 3);
+   CAPTURE(order);
+   const int dim = 3;
+
+   SECTION("Hex")
+   {
+      // Split the hex into a pair, then isotropically refine one of them.
+      Mesh smesh("../../data/ref-cube.mesh");
+      Array<Refinement> refinements(1);
+      refinements[0].index = 0;
+      refinements[0].ref_type = Refinement::X;
+      smesh.GeneralRefinement(refinements);
+      refinements[0].ref_type = Refinement::XYZ;
+      smesh.GeneralRefinement(refinements);
+      ParMesh mesh(MPI_COMM_WORLD, smesh);
+      SECTION("ND")
+      {
+         ND_FECollection fec(order, dim);
+         ParFiniteElementSpace fespace(&mesh, &fec);
+         CheckRPIdentity(fespace);
+      }
+      SECTION("H1")
+      {
+         H1_FECollection fec(order, dim);
+         ParFiniteElementSpace fespace(&mesh, &fec);
+         CheckRPIdentity(fespace);
+      }
+   }
+
+   SECTION("Tet")
+   {
+      // Split the hex into a pair, then isotropically refine one of them.
+      Mesh smesh("../../data/ref-tetrahedron.mesh");
+      Array<Refinement> refinements(1);
+      refinements[0].index = 0;
+      refinements[0].ref_type = Refinement::X;
+      smesh.GeneralRefinement(refinements);
+      bool use_nc = GENERATE(false, true);
+      smesh.EnsureNCMesh(use_nc);
+      refinements[0].ref_type = Refinement::XYZ;
+      smesh.GeneralRefinement(refinements);
+      smesh.EnsureNCMesh(true); // Always checking NC
+      ParMesh mesh(MPI_COMM_WORLD, smesh);
+      SECTION("ND")
+      {
+         ND_FECollection fec(order, dim);
+         ParFiniteElementSpace fespace(&mesh, &fec);
+         CheckRPIdentity(fespace);
+      }
+      SECTION("H1")
+      {
+         H1_FECollection fec(order, dim);
+         ParFiniteElementSpace fespace(&mesh, &fec);
+         CheckRPIdentity(fespace);
+      }
+   }
+}
+
+#endif // MFEM_USE_MPI
+
+TEST_CASE("ReferenceCubeInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+
+   CheckPoisson(smesh, p);
+
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   int without_internal, with_internal;
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 1); break;
+      case 3:
+         CHECK(with_internal == without_internal + 4); break;
+   }
+
+   auto ref_type = char(GENERATE(//Refinement::Y, Refinement::Z, Refinement::YZ,
+                           Refinement::XYZ));
+
+   for (auto ref : {0,1})
+   {
+      refs[0].index = ref;
+
+      auto ssmesh = Mesh(smesh);
+
+      CAPTURE(ref_type);
+
+      // Now NC refine one of the attached elements, this should result in 2
+      // internal boundary elements.
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      if (ref_type == 2 /* Y */ || ref_type == 4 /* Z */)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 2 /* internal boundaries */
+               + (2 * 4) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 6)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 7)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3 + 4 * 2) /* external boundaries of refined elements */);
+      }
+      else
+      {
+         MFEM_ABORT("!");
+      }
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == (ref_type <= 4 ? 2 : 4));
+
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      without_internal = CheckPoisson(ssmesh, p,
+                                      ssmesh.bdr_attributes.Max()); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      // All slaves dofs that are introduced on the face are constrained by
+      // the master dofs, thus the additional constraints on the internal
+      // boundary are purely on the master face, which matches the initial
+      // unrefined case.
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal + 1); break;
+         case 3:
+            CHECK(with_internal == without_internal + 4); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedCubesInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.UniformRefinement();
+
+   // Introduce four internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   int without_internal = CheckPoisson(smesh, p,
+                                       7); // Exclude the internal boundary
+   int with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // There should now be 16 internal boundary elements, where there were 4 before
+
+   CHECK(smesh.GetNBE() == 5 * 4 /* external boundaries of unrefined domain  */
+         + 4 * 4 /* internal boundaries */
+         + 5 * 16 /* external boundaries of refined elements */);
+
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 16);
+
+
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+}
+
+TEST_CASE("ReferenceTetInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal); break;
+      case 3:
+         CHECK(with_internal == without_internal + 1); break;
+   }
+
+   // Now NC refine one of the attached elements, this should result in 2
+   // internal boundary elements.
+   for (int ref : {0, 1})
+   {
+      refs[0].index = ref;
+      refs[0].ref_type = Refinement::XYZ;
+      auto ssmesh = Mesh(smesh);
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(ssmesh.GetNBE() == 3 /* external boundaries of unrefined element  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined element */);
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == 4);
+
+      without_internal = CheckPoisson(ssmesh, p, 5); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal); break;
+         case 3:
+            CHECK(with_internal == without_internal + 1); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedTetsInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.UniformRefinement();
+
+   CHECK(smesh.GetNBE() == 2 * 3 * 4);
+
+   // Introduce internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+
+   // Now NC refine all elements with the 2 attribute.
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   // There should now be four internal boundary elements, where there was one
+   // before.
+   CHECK(smesh.GetNBE() == 3 * 4 /* external boundaries of unrefined elements  */
+         + 4 * 4 /* internal boundaries */
+         + (3 * 4 * 4) /* external boundaries of refined elements */);
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 4 * 4);
+
+   without_internal = CheckPoisson(smesh, p, 5); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+}
+
+TEST_CASE("PoissonOnReferenceCubeNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   // Check that Poisson can be solved on the domain
+   CheckPoisson(smesh, p);
+
+   auto ref_type = char(GENERATE(Refinement::X, Refinement::Y, Refinement::Z,
+                                 Refinement::XY, Refinement::XZ, Refinement::YZ,
+                                 Refinement::XYZ));
+   CAPTURE(ref_type);
+   for (auto refined_elem : {0}) // The left or the right element
+   {
+      refs[0].index = refined_elem;
+      auto ssmesh = Mesh(smesh);
+
+      // Now NC refine one of the attached elements
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("PoissonOnReferenceTetNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   CheckPoisson(smesh, p);
+
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Check that Poisson can be solved on the pair of tets
+   CheckPoisson(smesh, p);
+
+   auto nc = GENERATE(false, true);
+   CAPTURE(nc);
+
+   smesh.EnsureNCMesh(GENERATE(false, true));
+
+   for (auto refined_elem : {0, 1})
+   {
+      auto ssmesh = Mesh(smesh);
+
+      refs[0].index = refined_elem;
+      refs[0].ref_type = Refinement::XYZ;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("TetBoundaryRefinement", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   smesh.FinalizeTopology();
+   smesh.Finalize(true);
+   smesh.UniformRefinement();
+
+   smesh.EnsureNCMesh(true);
+
+   CHECK(smesh.GetNBE() == 4 * 4);
+
+   // Loop over elements and mark for refinement if any vertices match the
+   // original
+   auto refine_corners = [&]()
+   {
+      Array<int> vertices, elements;
+      // reference vertices of (0,0,0), (1,0,0), (0,1,0), (0,0,1) are [0,3]
+      auto original_vert = [](int i) { return i >= 0 && i <= 3; };
+      for (int n = 0; n < smesh.GetNE(); ++n)
+      {
+         smesh.GetElementVertices(n, vertices);
+         if (std::any_of(vertices.begin(), vertices.end(), original_vert))
+         {
+            elements.Append(n);
+         }
+      }
+
+      smesh.GeneralRefinement(elements);
+      smesh.FinalizeTopology();
+      smesh.Finalize();
+   };
+
+   constexpr int max_ref_levels = 4;
+   for (int r = 0; r < max_ref_levels; r++)
+   {
+      refine_corners();
+      CHECK(smesh.GetNBE() == 4 * (4 + 3 * 3 * (r + 1)));
+   }
+}
+
+TEST_CASE("TetInternalBoundaryRefinement", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   {
+      Array<Refinement> refs;
+      refs.Append(Refinement(0, Refinement::X));
+      smesh.GeneralRefinement(refs);
+   }
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   Array<int> original_boundary_vertices;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         new_elem->GetVertices(original_boundary_vertices);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize(true);
+   smesh.UniformRefinement();
+   smesh.EnsureNCMesh(true);
+
+   CHECK(smesh.GetNBE() == (2*3 + 1) * 4);
+
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 1,
+                                            smesh.bdr_attributes.Max()) == 6);
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 2,
+                                            smesh.bdr_attributes.Max()) == 6 + 3 * 3);
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 3,
+                                            smesh.bdr_attributes.Max()) == 10 + 3 * 6);
+
+   int refined_attribute = GENERATE(1,2);
+   int ref_level = GENERATE(1,2,3);
+   for (int r = 0; r < ref_level; r++)
+   {
+      Array<int> el_to_refine;
+      for (int n = 0; n < smesh.GetNE(); n++)
+      {
+         if (smesh.GetAttribute(n) == refined_attribute)
+         {
+            el_to_refine.Append(n);
+         }
+      }
+      smesh.GeneralRefinement(el_to_refine);
+   }
+
+   // Refining on only one side of the boundary face should not change the number of
+   // essential true dofs
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 1,
+                                            smesh.bdr_attributes.Max()) == 6);
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 2,
+                                            smesh.bdr_attributes.Max()) == 6 + 3 * 3);
+   CHECK(CountEssentialDof<H1_FECollection>(smesh, 3,
+                                            smesh.bdr_attributes.Max()) == 10 + 3 * 6);
+
+   // The number of boundary faces should have increased.
+   CHECK(smesh.GetNBE() == 3 * 4 + (3 + 1) * std::pow(4, 1+ref_level));
+}
+
+TEST_CASE("TetInternalBoundaryStarMesh", "[NCMesh]")
+{
+   auto smesh = StarMesh();
+   smesh.EnsureNCMesh(true);
+
+
+   SECTION("Unrefined")
+   {
+      CHECK(smesh.GetNBE() == 4 * 3 + 4);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 1,
+                                               smesh.bdr_attributes.Max()) == 4);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 2,
+                                               smesh.bdr_attributes.Max()) == 4 + 6);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 3,
+                                               smesh.bdr_attributes.Max()) == 4 + 6*2 + 4*1);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 4,
+                                               smesh.bdr_attributes.Max()) == 4 + 6*3 + 4*3);
+
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 1,
+                                               smesh.bdr_attributes.Max()) == 6);
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 2,
+                                               smesh.bdr_attributes.Max()) == 20);
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 3,
+                                               smesh.bdr_attributes.Max()) == 42);
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 4,
+                                               smesh.bdr_attributes.Max()) == 72);
+   }
+
+   SECTION("Refined")
+   {
+      int refined_attribute = GENERATE(1,2,3,4,5);
+      int ref_level = GENERATE(1,2,3);
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < smesh.GetNE(); n++)
+         {
+            if (smesh.GetAttribute(n) == refined_attribute)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         smesh.GeneralRefinement(el_to_refine);
+      }
+
+      // Refining on only one side of the boundary face should not change the number of
+      // essential true dofs
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 1,
+                                               smesh.bdr_attributes.Max()) == 4);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 2,
+                                               smesh.bdr_attributes.Max()) == 4 + 6);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 3,
+                                               smesh.bdr_attributes.Max()) == 4 + 6*2 + 4*1);
+      CHECK(CountEssentialDof<H1_FECollection>(smesh, 4,
+                                               smesh.bdr_attributes.Max()) == 4 + 6*3 + 4*3);
+
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 1,
+                                               smesh.bdr_attributes.Max()) == 6);
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 2,
+                                               smesh.bdr_attributes.Max()) == 6 * 2 + 4 * 2); // 2 per edge, 2 per face
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 3,
+                                               smesh.bdr_attributes.Max()) == 42);
+      CHECK(CountEssentialDof<ND_FECollection>(smesh, 4,
+                                               smesh.bdr_attributes.Max()) == 72);
+
+      // The number of boundary faces should have increased.
+      CHECK(smesh.GetNBE() == 3 * 4 + 4 * std::pow(4,ref_level));
+   }
+}
+
+TEST_CASE("DividingPlaneMesh", "[NCMesh]")
+{
+   auto RefineAttribute = [](Mesh& mesh, int attr, int ref_level)
+   {
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < mesh.GetNE(); n++)
+         {
+            if (mesh.GetAttribute(n) == attr)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         mesh.GeneralRefinement(el_to_refine);
+      }
+   };
+
+   SECTION("Hex")
+   {
+      auto mesh = DividingPlaneMesh(false);
+      mesh.EnsureNCMesh(true);
+
+      CHECK(mesh.GetNBE() == 2 * 5 + 1);
+      CHECK(mesh.GetNE() == 2);
+
+      auto attr = GENERATE(1,2);
+      auto ref_level = GENERATE(1,2);
+
+      const int num_vert = ref_level == 1 ? 5*5 : 9*9;
+      const int num_edge = ref_level == 1 ? 2*4*5 : 2*8*9;
+      const int num_face = ref_level == 1 ? 4*4 : 8*8;
+
+      SECTION("H1Hex")
+      {
+         mesh.UniformRefinement();
+         CHECK(CountEssentialDof<H1_FECollection, true>(mesh, 1,
+                                                        mesh.bdr_attributes.Max()) == 3*3);
+         CHECK(CountEssentialDof<H1_FECollection, true>(mesh, 2,
+                                                        mesh.bdr_attributes.Max()) == 5*5);
+         CHECK(CountEssentialDof<H1_FECollection, true>(mesh, 3,
+                                                        mesh.bdr_attributes.Max()) == 7*7);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == 3*3);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == 5*5);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == 7*7);
+
+         RefineAttribute(mesh, attr, ref_level);
+
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == 3*3);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == 5*5);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == 7*7);
+
+         // Add the slave face dofs, then subtract off the vertex dofs which are double
+         // counted due to being shared.
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == 3*3 + num_vert - 3*3);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == 5*5 + num_vert + num_edge + num_face - 3*3);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == 7*7 + num_vert + 2*num_edge + 4*num_face - 3*3);
+
+      }
+
+      SECTION("NDHex")
+      {
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 1,
+                                                        mesh.bdr_attributes.Max()) == 4);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 2,
+                                                        mesh.bdr_attributes.Max()) == 4*2 + 2*2);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 3,
+                                                        mesh.bdr_attributes.Max()) == 4*3 + 2*2*3);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == 4);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == 4*2 + 2*2);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == 4*3 + 2*2*3);
+
+         mesh.UniformRefinement();
+         const int initial_num_edge = 12;
+         const int initial_num_face = 4;
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 1,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 2,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge*2 + initial_num_face*2*2);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 3,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge*3 + initial_num_face*2*2*3);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == initial_num_edge);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == initial_num_edge*2 + initial_num_face*2*2);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == initial_num_edge*3 + initial_num_face*2*2*3);
+
+         RefineAttribute(mesh, attr, ref_level);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 1,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 2,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge*2 + initial_num_face*2*2);
+         CHECK(CountEssentialDof<ND_FECollection, true>(mesh, 3,
+                                                        mesh.bdr_attributes.Max()) == initial_num_edge*3 + initial_num_face*2*2*3);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == (num_edge+initial_num_edge));
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == (num_edge+initial_num_edge)*2 +
+               (num_face+initial_num_face)*2*2);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == (num_edge+initial_num_edge)*3 +
+               (num_face+initial_num_face)*2*2*3);
+      }
+   }
+
+   SECTION("Tet")
+   {
+      auto mesh = DividingPlaneMesh(true);
+      mesh.EnsureNCMesh(true);
+
+      CHECK(mesh.GetNBE() == 2 * 5 * 2 + 2);
+      CHECK(mesh.GetNE() == 2 * 6);
+
+      auto attr = GENERATE(1,2);
+      auto ref_level = GENERATE(1,2);
+      CAPTURE(attr);
+      CAPTURE(ref_level);
+
+      const int initial_num_vert = 4;
+      const int initial_num_edge = 5;
+      const int initial_num_face = 2;
+
+      const int num_vert = ref_level == 1 ? 9 : 25;
+      const int num_edge = ref_level == 1 ? 16 : 56;
+      const int num_face = ref_level == 1 ? 8 : 32;
+
+      SECTION("H1Tet")
+      {
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + initial_num_edge);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + 2*initial_num_edge +
+               initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + 3*initial_num_edge +
+               3*initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == initial_num_vert);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == initial_num_vert + initial_num_edge);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == initial_num_vert + 2*initial_num_edge +
+               initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 4,
+                                                         mesh.bdr_attributes.Max()) == initial_num_vert + 3*initial_num_edge +
+               3*initial_num_face);
+
+         RefineAttribute(mesh, attr, ref_level);
+
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + initial_num_edge);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + 2*initial_num_edge +
+               initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == initial_num_vert + 3*initial_num_edge +
+               3*initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == num_vert);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == num_vert + num_edge + initial_num_edge);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == num_vert + 2*num_edge + num_face +
+               2*initial_num_edge + initial_num_face);
+         CHECK(CountEssentialDof<H1_FECollection, false>(mesh, 4,
+                                                         mesh.bdr_attributes.Max()) == num_vert + 3*num_edge + 3*num_face +
+               3*initial_num_edge + 3*initial_num_face);
+      }
+
+      SECTION("NDTet")
+      {
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == 5);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == 14);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == 27);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == 44);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == 5);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == 14);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == 27);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 4,
+                                                         mesh.bdr_attributes.Max()) == 44);
+
+         RefineAttribute(mesh, attr, ref_level);
+
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 1,
+                                                  mesh.bdr_attributes.Max()) == 5);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 2,
+                                                  mesh.bdr_attributes.Max()) == 14);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 3,
+                                                  mesh.bdr_attributes.Max()) == 27);
+         CHECK(CountEssentialDof<ND_FECollection>(mesh, 4,
+                                                  mesh.bdr_attributes.Max()) == 44);
+
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 1,
+                                                         mesh.bdr_attributes.Max()) == 5 + num_edge);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 2,
+                                                         mesh.bdr_attributes.Max()) == 14 + 2 * num_edge + 2*num_face);
+         CHECK(CountEssentialDof<ND_FECollection, false>(mesh, 3,
+                                                         mesh.bdr_attributes.Max()) == 27 + 3 * num_edge + 2*3*num_face);
+      }
+   }
+}
+
+
+TEST_CASE("TetFaceFlips", "[NCMesh]")
+{
+   auto orientation = GENERATE(1,3,5);
+   CAPTURE(orientation);
+   auto smesh = OrientedTriFaceMesh(orientation, true);
+
+   // A smooth function in each vector component
+   constexpr int order = 3, dim = 3, quadrature_order = 4;
+   constexpr double kappa = 2 * M_PI;
+   auto E_exact = [=](const Vector &x, Vector &E)
+   {
+      E(0) = cos(kappa * x(1));
+      E(1) = cos(kappa * x(2));
+      E(2) = cos(kappa * x(0));
+   };
+   VectorFunctionCoefficient E_coeff(dim, E_exact);
+
+   auto CheckSerialNDConformal = [&](Mesh &mesh, int num_essential_tdof,
+                                     int num_essential_vdof)
+   {
+      ND_FECollection fe_collection(order, dim);
+      FiniteElementSpace fe_space(&mesh, &fe_collection);
+      GridFunction E(&fe_space);
+
+      E.ProjectCoefficient(E_coeff);
+
+      auto *P = fe_space.GetProlongationMatrix();
+      if (P != nullptr)
+      {
+         // Projection does not respect the non-conformal constraints.
+         // Extract the true (conformal) and prolongate to get the NC respecting projection.
+         auto E_true = E.GetTrueVector();
+         P->Mult(E_true, E);
+      }
+      mesh.EnsureNodes();
+      GridFunction * const coords = mesh.GetNodes();
+
+      const auto &ir = IntRules.Get(Geometry::Type::TRIANGLE, quadrature_order);
+      IntegrationRule left_eir(ir.GetNPoints()),
+                      right_eir(ir.GetNPoints()); // element integration rules
+
+      Array<int> bdr_attr_is_ess = mesh.bdr_attributes, tdof_list;
+      bdr_attr_is_ess = 0;
+      bdr_attr_is_ess.Last() = 1;
+      fe_space.GetEssentialTrueDofs(bdr_attr_is_ess, tdof_list);
+
+      Array<int> ess_vdof_marker, vdof_list;
+      fe_space.GetEssentialVDofs(bdr_attr_is_ess, ess_vdof_marker);
+      fe_space.MarkerToList(ess_vdof_marker, vdof_list);
+
+      CHECK(num_essential_tdof == tdof_list.Size());
+      if (num_essential_vdof != -1)
+      {
+         CHECK(num_essential_vdof == vdof_list.Size());
+      }
+
+      for (int n = 0; n < mesh.GetNBE(); n++)
+      {
+         // NOTE: only works for internal boundaries
+         if (bdr_attr_is_ess[mesh.GetBdrAttribute(n) - 1])
+         {
+            auto f = mesh.GetBdrElementFaceIndex(n);
+            auto &face_element_transform = *mesh.GetFaceElementTransformations(f);
+
+            if (face_element_transform.Elem2 == nullptr)
+            {
+               // not internal, nothing to check.
+               continue;
+            }
+
+            face_element_transform.Loc1.Transform(ir, left_eir);
+            face_element_transform.Loc2.Transform(ir, right_eir);
+
+            constexpr double tol = 1e-14;
+            REQUIRE(left_eir.GetNPoints() == ir.GetNPoints());
+            REQUIRE(right_eir.GetNPoints() == ir.GetNPoints());
+            Vector left_val, right_val;
+            for (int i = 0; i < ir.GetNPoints(); i++)
+            {
+               face_element_transform.Elem1->SetIntPoint(&left_eir[i]);
+               coords->GetVectorValue(*face_element_transform.Elem1, left_eir[i], left_val);
+               coords->GetVectorValue(*face_element_transform.Elem1, left_eir[i], right_val);
+               REQUIRE(std::abs(left_val(0) - right_val(0)) < tol);
+               REQUIRE(std::abs(left_val(1) - right_val(1)) < tol);
+               REQUIRE(std::abs(left_val(2) - right_val(2)) < tol);
+               E.GetVectorValue(*face_element_transform.Elem1, left_eir[i], left_val);
+
+               face_element_transform.Elem2->SetIntPoint(&right_eir[i]);
+               E.GetVectorValue(*face_element_transform.Elem2, right_eir[i], right_val);
+
+               // Check that the second and third rows agree.
+               // The y and z should agree as the normal is in the x direction
+               CHECK(std::abs(left_val(1) - right_val(1)) < tol);
+               CHECK(std::abs(left_val(2) - right_val(2)) < tol);
+            }
+         }
+      }
+   };
+
+   SECTION("Conformal")
+   {
+      const int ntdof = 3*3 + 3*2;
+      const int nvdof = ntdof;
+      CheckSerialNDConformal(smesh, ntdof, nvdof);
+   }
+
+   SECTION("Nonconformal")
+   {
+      smesh.EnsureNCMesh(true);
+      const int ntdof = 3*3 + 3*2;
+      const int nvdof = ntdof;
+      CheckSerialNDConformal(smesh, ntdof, nvdof);
+   }
+
+   SECTION("ConformalUniformRefined")
+   {
+      smesh.UniformRefinement();
+      const int ntdof = 9*3 + 4*3*2;
+      const int nvdof = ntdof;
+      CheckSerialNDConformal(smesh, ntdof, nvdof);
+   }
+
+   SECTION("NonconformalUniformRefined")
+   {
+      smesh.EnsureNCMesh(true);
+      smesh.UniformRefinement();
+      const int ntdof = 9*3 + 4*3*2;
+      const int nvdof = ntdof;
+      CheckSerialNDConformal(smesh, ntdof, nvdof);
+   }
+
+   SECTION("NonconformalRefined")
+   {
+      smesh.EnsureNCMesh(true);
+      int ref_level = GENERATE(1, 2);
+      CAPTURE(ref_level);
+      for (int r = 0; r < ref_level; r++)
+      {
+         Array<int> el_to_refine;
+         for (int n = 0; n < smesh.GetNE(); n++)
+         {
+            if (smesh.GetAttribute(n) == 2)
+            {
+               el_to_refine.Append(n);
+            }
+         }
+         smesh.GeneralRefinement(el_to_refine);
+      }
+      const int ntdof = 3*3 + 3*2;
+      const int nvdof = ntdof + (ref_level == 1 ? 9*3 + 4*3*2 : 30*3 + 16*3*2);
+      CheckSerialNDConformal(smesh, ntdof, nvdof);
+   }
+
+   SECTION("NonconformalLevelTwoRefined")
+   {
+      smesh.EnsureNCMesh(true);
+      Array<int> el_to_refine;
+
+      smesh.UniformRefinement();
+
+      const int ntdof = 9*3 + 4*3*2;
+      el_to_refine.SetSize(1);
+
+      auto n = GENERATE(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
+      auto m = GENERATE(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22);
+
+      if (n < smesh.GetNE() && smesh.GetAttribute(n) == 2)
+      {
+         el_to_refine[0] = n;
+         CAPTURE(n);
+         smesh.GeneralRefinement(el_to_refine);
+         CheckSerialNDConformal(smesh, ntdof, -1);
+
+         if (smesh.GetAttribute(m) == 2)
+         {
+            el_to_refine[0] = m;
+            CAPTURE(m);
+            smesh.GeneralRefinement(el_to_refine);
+            CheckSerialNDConformal(smesh, ntdof, -1);
+         }
+      }
+
+   }
+}
+
+TEST_CASE("RP=I", "[NCMesh]")
+{
+   auto CheckFESpace = [](const FiniteElementSpace& fespace)
+   {
+      auto * const R = fespace.GetConformingRestriction();
+      auto * const P = fespace.GetConformingProlongation();
+
+      REQUIRE(R != nullptr);
+      REQUIRE(P != nullptr);
+
+      // Vector notation
+      Vector e_i(R->Height()), e_j(P->Width());
+      Vector Rrow(R->Width()), Pcol(P->Height());
+      for (int i = 0; i < R->Height(); i++)
+      {
+         e_i = 0.0;
+         e_i(i) = 1.0;
+         R->MultTranspose(e_i, Rrow);
+         for (int j = 0; j < P->Width(); j++)
+         {
+            e_j = 0.0;
+            e_j(j) = 1.0;
+            P->Mult(e_j, Pcol);
+
+            CHECK(Rrow * Pcol == (i == j ? 1.0 : 0.0));
+         }
+      }
+
+      // Index notation
+      CHECK(R->Height() == P->Width());
+      CHECK(R->Width() == P->Height());
+      for (int i = 0; i < R->Height(); i++)
+         for (int j = 0; j < P->Width(); j++)
+         {
+            double dot = 0.0;
+            for (int k = 0; k < R->Width(); k++)
+            {
+               dot += (*R)(i,k)*(*P)(k,j);
+            }
+            CHECK(dot == (i == j ? 1.0 : 0.0));
+         }
+   };
+
+   SECTION("Hex")
+   {
+      const int dim = 3;
+      const int order = GENERATE(1, 2);
+      // Split the hex into a pair, then isotropically refine one of them.
+      Mesh mesh("../../data/ref-cube.mesh");
+      Array<Refinement> refinements(1);
+      refinements[0].index = 0;
+      refinements[0].ref_type = Refinement::X;
+      mesh.GeneralRefinement(refinements);
+      refinements[0].ref_type = Refinement::XYZ;
+      mesh.GeneralRefinement(refinements);
+      SECTION("ND")
+      {
+         ND_FECollection fec(order, dim);
+         FiniteElementSpace fespace(&mesh, &fec);
+         CheckFESpace(fespace);
+      }
+      SECTION("H1")
+      {
+         H1_FECollection fec(order, dim);
+         FiniteElementSpace fespace(&mesh, &fec);
+         CheckFESpace(fespace);
+      }
+   }
+
+   SECTION("Tet")
+   {
+      const int dim = 3;
+      const int order = GENERATE(1, 2);
+      // Split the hex into a pair, then isotropically refine one of them.
+      Mesh mesh("../../data/ref-tetrahedron.mesh");
+      Array<Refinement> refinements(1);
+      refinements[0].index = 0;
+      refinements[0].ref_type = Refinement::X;
+      mesh.GeneralRefinement(refinements);
+      mesh.EnsureNCMesh(true);
+      refinements[0].ref_type = Refinement::XYZ;
+      mesh.GeneralRefinement(refinements);
+      SECTION("ND")
+      {
+         ND_FECollection fec(order, dim);
+         FiniteElementSpace fespace(&mesh, &fec);
+         CheckFESpace(fespace);
+      }
+      SECTION("H1")
+      {
+         H1_FECollection fec(order, dim);
+         FiniteElementSpace fespace(&mesh, &fec);
+         CheckFESpace(fespace);
+      }
+   }
+}
 
 } // namespace mfem
