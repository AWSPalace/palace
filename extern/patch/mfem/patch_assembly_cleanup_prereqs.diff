diff --git a/.gitignore b/.gitignore
index 6e2ed719a..22e3e548b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -265,7 +265,6 @@ miniapps/navier/*_output
 miniapps/nurbs/nurbs_ex1
 miniapps/nurbs/nurbs_ex1p
 miniapps/nurbs/nurbs_ex11p
-miniapps/nurbs/nurbs_patch_ex1
 miniapps/nurbs/nurbs_curveint
 miniapps/nurbs/refined.mesh
 miniapps/nurbs/mesh.*
diff --git a/CHANGELOG b/CHANGELOG
index f7011929a..b68e7b053 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -78,11 +78,6 @@ Discretization improvements
 
 - VectorFEBoundaryFluxLFIntegrator is now supported on device/GPU.
 
-- Added support for partial assembly on NURBS patches and NURBS patch sparse
-  matrix assembly. Patch matrix assembly includes the option to use reduced
-  approximate integration rules, computed by the newly implemented non-negative
-  least-squares (NNLS) solver.
-
 - Added support for p-refined meshes in FindPointsGSLIB.
 
 - Support for parallel transfer of H1 fields using the low-order refined (LOR)
diff --git a/examples/ex10p.cpp b/examples/ex10p.cpp
index b465d33f9..b04bcaa0f 100644
--- a/examples/ex10p.cpp
+++ b/examples/ex10p.cpp
@@ -296,7 +296,7 @@ int main(int argc, char *argv[])
    {
       cout << "Number of velocity/deformation unknowns: " << glob_size << endl;
    }
-   int true_size = fespace.TrueVSize();
+   int true_size = fespace.GetTrueVSize();
    Array<int> true_offset(3);
    true_offset[0] = 0;
    true_offset[1] = true_size;
@@ -480,7 +480,7 @@ void visualize(ostream &os, ParMesh *mesh,
 ReducedSystemOperator::ReducedSystemOperator(
    ParBilinearForm *M_, ParBilinearForm *S_, ParNonlinearForm *H_,
    const Array<int> &ess_tdof_list_)
-   : Operator(M_->ParFESpace()->TrueVSize()), M(M_), S(S_), H(H_),
+   : Operator(M_->ParFESpace()->GetTrueVSize()), M(M_), S(S_), H(H_),
      Jacobian(NULL), dt(0.0), v(NULL), x(NULL), w(height), z(height),
      ess_tdof_list(ess_tdof_list_)
 { }
@@ -525,7 +525,7 @@ ReducedSystemOperator::~ReducedSystemOperator()
 HyperelasticOperator::HyperelasticOperator(ParFiniteElementSpace &f,
                                            Array<int> &ess_bdr, double visc,
                                            double mu, double K)
-   : TimeDependentOperator(2*f.TrueVSize(), 0.0), fespace(f),
+   : TimeDependentOperator(2*f.GetTrueVSize(), 0.0), fespace(f),
      M(&fespace), S(&fespace), H(&fespace),
      viscosity(visc), M_solver(f.GetComm()), newton_solver(f.GetComm()),
      z(height/2)
diff --git a/examples/ex19p.cpp b/examples/ex19p.cpp
index 907687ef5..1d61f9f63 100644
--- a/examples/ex19p.cpp
+++ b/examples/ex19p.cpp
@@ -323,8 +323,8 @@ int main(int argc, char *argv[])
    // 10. Define the block structure of the solution vector (u then p)
    Array<int> block_trueOffsets(3);
    block_trueOffsets[0] = 0;
-   block_trueOffsets[1] = R_space.TrueVSize();
-   block_trueOffsets[2] = W_space.TrueVSize();
+   block_trueOffsets[1] = R_space.GetTrueVSize();
+   block_trueOffsets[2] = W_space.GetTrueVSize();
    block_trueOffsets.PartialSum();
 
    BlockVector xp(block_trueOffsets);
@@ -528,7 +528,7 @@ RubberOperator::RubberOperator(Array<ParFiniteElementSpace *> &fes,
                                double abs_tol,
                                int iter,
                                Coefficient &c_mu)
-   : Operator(fes[0]->TrueVSize() + fes[1]->TrueVSize()),
+   : Operator(fes[0]->GetTrueVSize() + fes[1]->GetTrueVSize()),
      newton_solver(fes[0]->GetComm()),
      newton_monitor(fes[0]->GetComm(), "Newton", 1),
      j_monitor(fes[0]->GetComm(), "  GMRES", 3),
diff --git a/examples/ex5p.cpp b/examples/ex5p.cpp
index b0eb6d5cc..160e26490 100644
--- a/examples/ex5p.cpp
+++ b/examples/ex5p.cpp
@@ -179,8 +179,8 @@ int main(int argc, char *argv[])
 
    Array<int> block_trueOffsets(3); // number of variables + 1
    block_trueOffsets[0] = 0;
-   block_trueOffsets[1] = R_space->TrueVSize();
-   block_trueOffsets[2] = W_space->TrueVSize();
+   block_trueOffsets[1] = R_space->GetTrueVSize();
+   block_trueOffsets[2] = W_space->GetTrueVSize();
    block_trueOffsets.PartialSum();
 
    // 9. Define the coefficients, analytical solution, and rhs of the PDE.
diff --git a/examples/ex8p.cpp b/examples/ex8p.cpp
index a48b3afdf..ddf8f0873 100644
--- a/examples/ex8p.cpp
+++ b/examples/ex8p.cpp
@@ -212,9 +212,9 @@ int main(int argc, char *argv[])
    //    and rhs.
    enum {x0_var, xhat_var, NVAR};
 
-   int true_s0     = x0_space->TrueVSize();
-   int true_s1     = xhat_space->TrueVSize();
-   int true_s_test = test_space->TrueVSize();
+   int true_s0     = x0_space->GetTrueVSize();
+   int true_s1     = xhat_space->GetTrueVSize();
+   int true_s_test = test_space->GetTrueVSize();
 
    Array<int> true_offsets(NVAR+1);
    true_offsets[0] = 0;
diff --git a/examples/hiop/ex9p.cpp b/examples/hiop/ex9p.cpp
index 4facbb3c0..55c0c41c0 100644
--- a/examples/hiop/ex9p.cpp
+++ b/examples/hiop/ex9p.cpp
@@ -91,7 +91,7 @@ private:
 
 public:
    LinearScaleOperator(ParFiniteElementSpace &space, const Vector &weight)
-      : Operator(1, space.TrueVSize()),
+      : Operator(1, space.GetTrueVSize()),
         pfes(space), w(weight), grad(1, width)
    {
       Vector w_glob(width);
@@ -123,7 +123,7 @@ private:
 
 public:
    TanhSumOperator(ParFiniteElementSpace &space)
-      : Operator(1, space.TrueVSize()), grad(1, width) { }
+      : Operator(1, space.GetTrueVSize()), grad(1, width) { }
 
    virtual void Mult(const Vector &x, Vector &y) const
    {
diff --git a/examples/petsc/ex10p.cpp b/examples/petsc/ex10p.cpp
index ef5361486..9fd5de71d 100644
--- a/examples/petsc/ex10p.cpp
+++ b/examples/petsc/ex10p.cpp
@@ -328,7 +328,7 @@ int main(int argc, char *argv[])
    {
       cout << "Number of velocity/deformation unknowns: " << glob_size << endl;
    }
-   int true_size = fespace.TrueVSize();
+   int true_size = fespace.GetTrueVSize();
    Array<int> true_offset(3);
    true_offset[0] = 0;
    true_offset[1] = true_size;
@@ -510,7 +510,7 @@ void visualize(ostream &os, ParMesh *mesh, ParGridFunction *deformed_nodes,
 ReducedSystemOperator::ReducedSystemOperator(
    ParBilinearForm *M_, ParBilinearForm *S_, ParNonlinearForm *H_,
    const Array<int> &ess_tdof_list_)
-   : Operator(M_->ParFESpace()->TrueVSize()), M(M_), S(S_), H(H_),
+   : Operator(M_->ParFESpace()->GetTrueVSize()), M(M_), S(S_), H(H_),
      Jacobian(NULL), dt(0.0), v(NULL), x(NULL), w(height), z(height),
      ess_tdof_list(ess_tdof_list_)
 { }
@@ -558,7 +558,7 @@ HyperelasticOperator::HyperelasticOperator(ParFiniteElementSpace &f,
                                            Array<int> &ess_bdr, double visc,
                                            double mu, double K, bool use_petsc,
                                            bool use_petsc_factory)
-   : TimeDependentOperator(2*f.TrueVSize(), 0.0), fespace(f),
+   : TimeDependentOperator(2*f.GetTrueVSize(), 0.0), fespace(f),
      M(&fespace), S(&fespace), H(&fespace),
      viscosity(visc), M_solver(f.GetComm()),
      newton_solver(f.GetComm()), pnewton_solver(NULL), z(height/2)
diff --git a/examples/petsc/ex5p.cpp b/examples/petsc/ex5p.cpp
index 7d57e3c71..de99e6ea0 100644
--- a/examples/petsc/ex5p.cpp
+++ b/examples/petsc/ex5p.cpp
@@ -171,8 +171,8 @@ int main(int argc, char *argv[])
 
    Array<int> block_trueOffsets(3); // number of variables + 1
    block_trueOffsets[0] = 0;
-   block_trueOffsets[1] = R_space->TrueVSize();
-   block_trueOffsets[2] = W_space->TrueVSize();
+   block_trueOffsets[1] = R_space->GetTrueVSize();
+   block_trueOffsets[2] = W_space->GetTrueVSize();
    block_trueOffsets.PartialSum();
 
    // 8. Define the coefficients, analytical solution, and rhs of the PDE.
diff --git a/examples/sundials/ex10p.cpp b/examples/sundials/ex10p.cpp
index 147289b16..54e765b73 100644
--- a/examples/sundials/ex10p.cpp
+++ b/examples/sundials/ex10p.cpp
@@ -367,7 +367,7 @@ int main(int argc, char *argv[])
    {
       cout << "Number of velocity/deformation unknowns: " << glob_size << endl;
    }
-   int true_size = fespace.TrueVSize();
+   int true_size = fespace.GetTrueVSize();
    Array<int> true_offset(3);
    true_offset[0] = 0;
    true_offset[1] = true_size;
@@ -617,7 +617,7 @@ void visualize(ostream &os, ParMesh *mesh, ParGridFunction *deformed_nodes,
 ReducedSystemOperator::ReducedSystemOperator(
    ParBilinearForm *M_, ParBilinearForm *S_, ParNonlinearForm *H_,
    const Array<int> &ess_tdof_list_)
-   : Operator(M_->ParFESpace()->TrueVSize()), M(M_), S(S_), H(H_),
+   : Operator(M_->ParFESpace()->GetTrueVSize()), M(M_), S(S_), H(H_),
      Jacobian(NULL), dt(0.0), v(NULL), x(NULL), w(height), z(height),
      ess_tdof_list(ess_tdof_list_)
 { }
@@ -663,7 +663,7 @@ HyperelasticOperator::HyperelasticOperator(ParFiniteElementSpace &f,
                                            Array<int> &ess_bdr, double visc,
                                            double mu, double K,
                                            NonlinearSolverType nls_type)
-   : TimeDependentOperator(2*f.TrueVSize(), 0.0), fespace(f),
+   : TimeDependentOperator(2*f.GetTrueVSize(), 0.0), fespace(f),
      M(&fespace), S(&fespace), H(&fespace),
      viscosity(visc), M_solver(f.GetComm()), z(height/2),
      local_grad_H(NULL), Jacobian(NULL)
diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index 061857919..aea1f901d 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -23,7 +23,6 @@ set(SRCS
   integ/bilininteg_diffusion_mf.cpp
   integ/bilininteg_diffusion_pa.cpp
   integ/bilininteg_diffusion_ea.cpp
-  integ/bilininteg_diffusion_patch.cpp
   integ/bilininteg_divdiv_pa.cpp
   integ/bilininteg_gradient_pa.cpp
   integ/bilininteg_interp_pa.cpp
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index e7931b01a..206dff53d 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -13,7 +13,6 @@
 
 #include "fem.hpp"
 #include "../general/device.hpp"
-#include "../mesh/nurbs.hpp"
 #include <cmath>
 
 namespace mfem
@@ -64,8 +63,8 @@ void BilinearForm::AllocMat()
    dof_dof.LoseData();
 }
 
-BilinearForm::BilinearForm(FiniteElementSpace * f)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
@@ -82,8 +81,8 @@ BilinearForm::BilinearForm(FiniteElementSpace * f)
    ext = NULL;
 }
 
-BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
@@ -125,7 +124,7 @@ void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
       case AssemblyLevel::LEGACY:
          break;
       case AssemblyLevel::FULL:
-         SetDiagonalPolicy( DIAG_ONE ); // Only diagonal policy supported on device
+         SetDiagonalPolicy(DIAG_ONE); // Only diagonal policy supported on device
          ext = new FABilinearFormExtension(this);
          break;
       case AssemblyLevel::ELEMENT:
@@ -208,22 +207,71 @@ void BilinearForm::UseSparsity(SparseMatrix &A)
    UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
 }
 
-double& BilinearForm::Elem (int i, int j)
+double &BilinearForm::Elem(int i, int j)
 {
-   return mat -> Elem(i,j);
+   return mat->Elem(i,j);
 }
 
-const double& BilinearForm::Elem (int i, int j) const
+const double &BilinearForm::Elem(int i, int j) const
 {
-   return mat -> Elem(i,j);
+   return mat->Elem(i,j);
 }
 
-MatrixInverse * BilinearForm::Inverse() const
+void BilinearForm::Mult(const Vector &x, Vector &y) const
 {
-   return mat -> Inverse();
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
 }
 
-void BilinearForm::Finalize (int skip_zeros)
+void BilinearForm::AddMult(const Vector &x, Vector &y, const double a) const
+{
+   if (ext)
+   {
+      ext->AddMult(x, y, a);
+   }
+   else
+   {
+      mat->AddMult(x, y, a);
+   }
+}
+
+void BilinearForm::MultTranspose(const Vector &x, Vector &y) const
+{
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
+}
+
+void BilinearForm::AddMultTranspose(const Vector &x, Vector &y,
+                                    const double a) const
+{
+   if (ext)
+   {
+      ext->AddMultTranspose(x, y, a);
+   }
+   else
+   {
+      mat->AddMultTranspose(x, y, a);
+   }
+}
+
+MatrixInverse *BilinearForm::Inverse() const
+{
+   return mat->Inverse();
+}
+
+void BilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
@@ -247,22 +295,22 @@ void BilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi,
    domain_integs_marker.Append(&elem_marker);
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                          Array<int> &bdr_marker)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                         Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator * bfi)
+void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   interior_face_integs.Append (bfi);
+   interior_face_integs.Append(bfi);
 }
 
 void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -393,8 +441,8 @@ void BilinearForm::Assemble(int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * doftrans;
-   Mesh *mesh = fes -> GetMesh();
+   DofTransformation *doftrans;
+   Mesh *mesh = fes->GetMesh();
    DenseMatrix elmat, *elmat_p;
 
    if (mat == NULL)
@@ -422,30 +470,23 @@ void BilinearForm::Assemble(int skip_zeros)
                         "invalid element marker for domain integrator #"
                         << k << ", counting from zero");
          }
-
-         if (domain_integs[k]->Patchwise())
-         {
-            MFEM_VERIFY(fes->GetNURBSext(), "Patchwise integration requires a "
-                        << "NURBS FE space");
-         }
       }
 
-      // Element-wise integration
-      for (int i = 0; i < fes -> GetNE(); i++)
+      for (int i = 0; i < fes->GetNE(); i++)
       {
+         int elem_attr = fes->GetMesh()->GetAttribute(i);
+         doftrans = fes->GetElementVDofs(i, vdofs);
          if (element_matrices)
          {
             elmat_p = &(*element_matrices)(i);
          }
          else
          {
-            const int elem_attr = fes->GetMesh()->GetAttribute(i);
             elmat.SetSize(0);
             for (int k = 0; k < domain_integs.Size(); k++)
             {
-               if ((domain_integs_marker[k] == NULL ||
+               if ( domain_integs_marker[k] == NULL ||
                     (*(domain_integs_marker[k]))[elem_attr-1] == 1)
-                   && !domain_integs[k]->Patchwise())
                {
                   const FiniteElement &fe = *fes->GetFE(i);
                   eltrans = fes->GetElementTransformation(i);
@@ -468,7 +509,6 @@ void BilinearForm::Assemble(int skip_zeros)
             {
                elmat_p = &elmat;
             }
-            doftrans = fes->GetElementVDofs(i, vdofs);
             if (doftrans)
             {
                doftrans->TransformDual(elmat);
@@ -488,43 +528,6 @@ void BilinearForm::Assemble(int skip_zeros)
             }
          }
       }
-
-      // Patch-wise integration
-      if (fes->GetNURBSext())
-      {
-         for (int p=0; p<mesh->NURBSext->GetNP(); ++p)
-         {
-            bool vdofsSet = false;
-            for (int k = 0; k < domain_integs.Size(); k++)
-            {
-               if (domain_integs[k]->Patchwise())
-               {
-                  if (!vdofsSet)
-                  {
-                     fes->GetPatchVDofs(p, vdofs);
-                     vdofsSet = true;
-                  }
-
-                  SparseMatrix* spmat = nullptr;
-                  domain_integs[k]->AssemblePatchMatrix(p, *fes, spmat);
-                  Array<int> cols;
-                  Vector srow;
-
-                  for (int r=0; r<spmat->Height(); ++r)
-                  {
-                     spmat->GetRow(r, cols, srow);
-                     for (int i=0; i<cols.Size(); ++i)
-                     {
-                        cols[i] = vdofs[cols[i]];
-                     }
-                     mat->AddRow(vdofs[r], cols, srow);
-                  }
-
-                  delete spmat;
-               }
-            }
-         }
-      }
    }
 
    if (boundary_integs.Size())
@@ -550,14 +553,14 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
          const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes -> GetBdrElementVDofs (i, vdofs);
-         eltrans = fes -> GetBdrElementTransformation (i);
+         doftrans = fes->GetBdrElementVDofs(i, vdofs);
+         eltrans = fes->GetBdrElementTransformation(i);
          int k = 0;
          for (; k < boundary_integs.Size(); k++)
          {
@@ -604,19 +607,18 @@ void BilinearForm::Assemble(int skip_zeros)
       int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         tr = mesh -> GetInteriorFaceTransformations (i);
+         tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fes -> GetElementVDofs (tr -> Elem2No, vdofs2);
-            vdofs.Append (vdofs2);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fes->GetElementVDofs(tr->Elem2No, vdofs2);
+            vdofs.Append(vdofs2);
             for (int k = 0; k < interior_face_integs.Size(); k++)
             {
-               interior_face_integs[k]->
-               AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
-                                  *fes->GetFE(tr->Elem2No),
-                                  *tr, elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               interior_face_integs[k]->AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
+                                                           *fes->GetFE(tr->Elem2No),
+                                                           *tr, elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -648,16 +650,16 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         tr = mesh -> GetBdrFaceTransformations (i);
+         tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fe1 = fes -> GetFE (tr -> Elem1No);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
@@ -668,9 +670,9 @@ void BilinearForm::Assemble(int skip_zeros)
                    (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
                { continue; }
 
-               boundary_face_integs[k] -> AssembleFaceMatrix (*fe1, *fe2, *tr,
-                                                              elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                           elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -690,8 +692,9 @@ void BilinearForm::ConformingAssemble()
    // matrix which in turn will give rise to symmetric structure in the new
    // matrix. This ensures that subsequent calls to EliminateRowCol will work
    // correctly.
-   Finalize(0);
    MFEM_ASSERT(mat, "the BilinearForm is not assembled");
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
 
    const SparseMatrix *P = fes->GetConformingProlongation();
    if (!P) { return; } // conforming mesh
@@ -739,7 +742,6 @@ void BilinearForm::AssembleDiagonal(Vector &diag) const
       return;
    }
    // Here, we have extension, ext, and conforming prolongation, cP.
-
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
@@ -754,12 +756,26 @@ void BilinearForm::FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
-   const SparseMatrix *P = fes->GetConformingProlongation();
+
+   // Finish the matrix assembly and perform BC elimination, storing the
+   // eliminated part of the matrix.
    FormSystemMatrix(ess_tdof_list, A);
 
+   const SparseMatrix *P = fes->GetConformingProlongation();
+
    // Transform the system and perform the elimination in B, based on the
    // essential BC values from x. Restrict the BC part of x in X, and set the
    // non-BC part to zero. Since there is no good initial guess for the Lagrange
@@ -822,7 +838,23 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ConformingAssemble();
+         mat->EliminateBC(ess_tdof_list, DiagonalPolicy::DIAG_ONE);
+         A.Reset(mat, false);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -843,8 +875,7 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
    {
       if (!mat_e)
       {
-         const SparseMatrix *P = fes->GetConformingProlongation();
-         if (P) { ConformingAssemble(); }
+         ConformingAssemble();
          EliminateVDofs(ess_tdof_list, diag_policy);
          const int remove_zeros = 0;
          Finalize(remove_zeros);
@@ -995,8 +1026,8 @@ void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateEssentialBCDiag (const Array<int> &bdr_attr_is_ess,
-                                             double value)
+void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
+                                            double value)
 {
    Array<int> ess_dofs, conf_ess_dofs;
    fes->GetEssentialVDofs(bdr_attr_is_ess, ess_dofs);
@@ -1022,11 +1053,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, sol(vdof), rhs, dpolicy);
+         mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, sol(-1-vdof), rhs, dpolicy);
+         mat->EliminateRowCol(-1-vdof, sol(-1-vdof), rhs, dpolicy);
       }
    }
 }
@@ -1045,11 +1076,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(-1-vdof, *mat_e, dpolicy);
       }
    }
 }
@@ -1065,31 +1096,31 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, sol(i), rhs, dpolicy);
+         mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
-                                                 DiagonalPolicy dpolicy)
+void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
+                                                DiagonalPolicy dpolicy)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, dpolicy);
+         mat->EliminateRowCol(i, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofsDiag (const Array<int> &ess_dofs,
-                                                     double value)
+void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
+                                                    double value)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowColDiag (i, value);
+         mat->EliminateRowColDiag(i, value);
       }
 }
 
@@ -1100,31 +1131,6 @@ void BilinearForm::EliminateVDofsInRHS(
    mat->PartMult(vdofs_, x, b);
 }
 
-void BilinearForm::Mult(const Vector &x, Vector &y) const
-{
-   if (ext)
-   {
-      ext->Mult(x, y);
-   }
-   else
-   {
-      mat->Mult(x, y);
-   }
-}
-
-void BilinearForm::MultTranspose(const Vector & x, Vector & y) const
-{
-   if (ext)
-   {
-      ext->MultTranspose(x, y);
-   }
-   else
-   {
-      y = 0.0;
-      AddMultTranspose (x, y);
-   }
-}
-
 void BilinearForm::Update(FiniteElementSpace *nfes)
 {
    bool full_update;
@@ -1167,11 +1173,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
    if (ext) { ext->Update(); }
 }
 
-void BilinearForm::SetDiagonalPolicy(DiagonalPolicy policy)
-{
-   diag_policy = policy;
-}
-
 BilinearForm::~BilinearForm()
 {
    delete mat_e;
@@ -1195,8 +1196,8 @@ BilinearForm::~BilinearForm()
 }
 
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1208,9 +1209,9 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    ext = NULL;
 }
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes,
-                                      MixedBilinearForm * mbf)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes,
+                                     MixedBilinearForm *mbf)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1256,31 +1257,36 @@ void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
          ext = new PAMixedBilinearFormExtension(this);
          break;
       case AssemblyLevel::NONE:
-         mfem_error("Matrix-free action not supported yet... stay tuned!");
-         // ext = new MFMixedBilinearFormExtension(this);
+         ext = new MFMixedBilinearFormExtension(this);
          break;
       default:
          mfem_error("Unknown assembly level");
    }
 }
 
-double & MixedBilinearForm::Elem (int i, int j)
+double &MixedBilinearForm::Elem(int i, int j)
 {
    return (*mat)(i, j);
 }
 
-const double & MixedBilinearForm::Elem (int i, int j) const
+const double &MixedBilinearForm::Elem(int i, int j) const
 {
    return (*mat)(i, j);
 }
 
-void MixedBilinearForm::Mult(const Vector & x, Vector & y) const
+void MixedBilinearForm::Mult(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMult(x, y);
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMult(const Vector &x, Vector &y,
                                 const double a) const
 {
    if (ext)
@@ -1293,13 +1299,19 @@ void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
    }
 }
 
-void MixedBilinearForm::MultTranspose(const Vector & x, Vector & y) const
+void MixedBilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMultTranspose(x, y);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMultTranspose(const Vector &x, Vector &y,
                                          const double a) const
 {
    if (ext)
@@ -1312,7 +1324,7 @@ void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
    }
 }
 
-MatrixInverse * MixedBilinearForm::Inverse() const
+MatrixInverse *MixedBilinearForm::Inverse() const
 {
    if (assembly != AssemblyLevel::LEGACY)
    {
@@ -1322,15 +1334,15 @@ MatrixInverse * MixedBilinearForm::Inverse() const
    }
    else
    {
-      return mat -> Inverse ();
+      return mat->Inverse();
    }
 }
 
-void MixedBilinearForm::Finalize (int skip_zeros)
+void MixedBilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
-      mat -> Finalize (skip_zeros);
+      mat->Finalize(skip_zeros);
    }
 }
 
@@ -1346,27 +1358,27 @@ void MixedBilinearForm::GetBlocks(Array2D<SparseMatrix *> &blocks) const
    mat->GetBlocks(blocks);
 }
 
-void MixedBilinearForm::AddDomainIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi)
 {
-   domain_integs.Append (bfi);
+   domain_integs.Append(bfi);
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                               Array<int> &bdr_marker)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                              Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::AddTraceFaceIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddTraceFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   trace_face_integs.Append (bfi);
+   trace_face_integs.Append(bfi);
 }
 
 void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -1383,7 +1395,7 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::Assemble (int skip_zeros)
+void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
    {
@@ -1392,12 +1404,11 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
 
-   Mesh *mesh = test_fes -> GetMesh();
-
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
@@ -1405,26 +1416,26 @@ void MixedBilinearForm::Assemble (int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes -> GetNE(); i++)
+      for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes -> GetElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetElementTransformation (i);
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
          for (int k = 0; k < domain_integs.Size(); k++)
          {
-            domain_integs[k] -> AssembleElementMatrix2 (*trial_fes -> GetFE(i),
-                                                        *test_fes  -> GetFE(i),
-                                                        *eltrans, elemmat);
+            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1451,14 +1462,14 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < test_fes -> GetNBE(); i++)
+      for (int i = 0; i < test_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         dom_dof_trans = trial_fes -> GetBdrElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetBdrElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetBdrElementTransformation (i);
+         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetBdrElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1467,16 +1478,16 @@ void MixedBilinearForm::Assemble (int skip_zeros)
             if (boundary_integs_marker[k] &&
                 (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
 
-            boundary_integs[k]->AssembleElementMatrix2 (*trial_fes -> GetBE(i),
-                                                        *test_fes  -> GetBE(i),
-                                                        *eltrans, elemmat);
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1543,7 +1554,7 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < trial_fes -> GetNBE(); i++)
+      for (int i = 0; i < trial_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
@@ -1576,6 +1587,37 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 }
 
+void MixedBilinearForm::ConformingAssemble()
+{
+   if (assembly != AssemblyLevel::LEGACY)
+   {
+      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      return;
+   }
+
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
+
+   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
+   if (test_P)
+   {
+      SparseMatrix *RA = mfem::TransposeMult(*test_P, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+}
+
 void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
                                               Vector &diag) const
 {
@@ -1624,39 +1666,6 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ConformingAssemble()
-{
-   if (assembly != AssemblyLevel::LEGACY)
-   {
-      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
-      return;
-   }
-
-   Finalize();
-
-   const SparseMatrix *P2 = test_fes->GetConformingProlongation();
-   if (P2)
-   {
-      SparseMatrix *R = Transpose(*P2);
-      SparseMatrix *RA = mfem::Mult(*R, *mat);
-      delete R;
-      delete mat;
-      mat = RA;
-   }
-
-   const SparseMatrix *P1 = trial_fes->GetConformingProlongation();
-   if (P1)
-   {
-      SparseMatrix *RAP = mfem::Mult(*mat, *P1);
-      delete mat;
-      mat = RAP;
-   }
-
-   height = mat->Height();
-   width = mat->Width();
-}
-
-
 void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
 {
    if (domain_integs.Size())
@@ -1745,91 +1754,102 @@ void MixedBilinearForm::AssembleBdrElementMatrix(
    mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
 }
 
-void MixedBilinearForm::EliminateTrialDofs (
+void MixedBilinearForm::EliminateTrialDofs(
    const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
 {
    int i, j, k;
-   Array<int> tr_vdofs, cols_marker (trial_fes -> GetVSize());
+   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
 
    cols_marker = 0;
-   for (i = 0; i < trial_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
       {
-         trial_fes -> GetBdrElementVDofs (i, tr_vdofs);
+         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
          for (j = 0; j < tr_vdofs.Size(); j++)
          {
-            if ( (k = tr_vdofs[j]) < 0 )
+            if ((k = tr_vdofs[j]) < 0)
             {
                k = -1-k;
             }
             cols_marker[k] = 1;
          }
       }
-   mat -> EliminateCols (cols_marker, &sol, &rhs);
+   mat->EliminateCols(cols_marker, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs (
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
    const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
 {
-   mat -> EliminateCols (marked_vdofs, &sol, &rhs);
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateTestDofs (const Array<int> &bdr_attr_is_ess)
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
 {
    int i, j, k;
    Array<int> te_vdofs;
 
-   for (i = 0; i < test_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < test_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
       {
-         test_fes -> GetBdrElementVDofs (i, te_vdofs);
+         test_fes->GetBdrElementVDofs(i, te_vdofs);
          for (j = 0; j < te_vdofs.Size(); j++)
          {
-            if ( (k = te_vdofs[j]) < 0 )
+            if ((k = te_vdofs[j]) < 0)
             {
                k = -1-k;
             }
-            mat -> EliminateRow (k);
+            mat->EliminateRow(k);
          }
       }
 }
 
-void MixedBilinearForm::FormRectangularSystemMatrix(
+void MixedBilinearForm::FormRectangularLinearSystem(
    const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-
+   Vector &x, Vector &b,
+   OperatorHandle &A,
+   Vector &X, Vector &B)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
       return;
    }
 
-   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
-   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
-
-   mat->Finalize();
+   const Operator *Pi = this->GetProlongation();
+   const Operator *Po = this->GetOutputProlongation();
+   const Operator *Ri = this->GetRestriction();
+   InitTVectors(Po, Ri, Pi, x, b, X, B);
 
-   if (test_P && trial_P)
-   {
-      SparseMatrix *m = RAP(*test_P, *mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-   else if (test_P)
+   if (!mat_e)
    {
-      SparseMatrix *m = TransposeMult(*test_P, *mat);
-      delete mat;
-      mat = m;
+      // Set A = mat_e
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
    }
-   else if (trial_P)
+   // Eliminate essential BCs with B -= Ab xb
+   mat_e->AddMult(X, B, -1.0);
+
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
+void MixedBilinearForm::FormRectangularSystemMatrix(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   OperatorHandle &A)
+{
+   if (ext)
    {
-      SparseMatrix *m = mfem::Mult(*mat, *trial_P);
-      delete mat;
-      mat = m;
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
+      return;
    }
 
+   ConformingAssemble();
+
    Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
    FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
                                     ess_trial_tdof_marker);
@@ -1839,7 +1859,7 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    mat_e = new SparseMatrix(mat->Height(), mat->Width());
    mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
 
-   for (int i=0; i<test_tdof_list.Size(); ++i)
+   for (int i = 0; i < test_tdof_list.Size(); i++)
    {
       mat->EliminateRow(test_tdof_list[i]);
    }
@@ -1847,36 +1867,6 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    A.Reset(mat, false);
 }
 
-void MixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   if (ext)
-   {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
-   }
-
-   const Operator *Pi = this->GetProlongation();
-   const Operator *Po = this->GetOutputProlongation();
-   const Operator *Ri = this->GetRestriction();
-   InitTVectors(Po, Ri, Pi, x, b, X, B);
-
-   if (!mat_e)
-   {
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list,
-                                  A); // Set A = mat_e
-   }
-   // Eliminate essential BCs with B -= Ab xb
-   mat_e->AddMult(X, B, -1.0);
-
-   B.SetSubVector(test_tdof_list, 0.0);
-}
-
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1941,66 +1931,97 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   Array<int> dom_vdofs, ran_vdofs;
-   ElementTransformation *T;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
-   const FiniteElement *dom_fe, *ran_fe;
-   DenseMatrix totelmat, elmat;
+   ElementTransformation *eltrans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
+   DenseMatrix elmat;
 
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
    }
 
-   if (domain_integs.Size() > 0)
+   if (domain_integs.Size())
    {
       for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, dom_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, ran_vdofs);
-         T = test_fes->GetElementTransformation(i);
-         dom_fe = trial_fes->GetFE(i);
-         ran_fe = test_fes->GetFE(i);
-
-         domain_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                  totelmat);
-         for (int j = 1; j < domain_integs.Size(); j++)
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < domain_integs.Size(); j++)
          {
-            domain_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                     elmat);
-            totelmat += elmat;
+            domain_integs[j]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
+            elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
-            TransformPrimal(ran_dof_trans, dom_dof_trans, totelmat);
+            TransformPrimal(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = test_fes->GetMesh()->GetNumFaces();
+      const int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         trial_fes->GetFaceVDofs(i, dom_vdofs);
-         test_fes->GetFaceVDofs(i, ran_vdofs);
-         T = test_fes->GetMesh()->GetFaceTransformation(i);
-         dom_fe = trial_fes->GetFaceElement(i);
-         ran_fe = test_fes->GetFaceElement(i);
-
-         trace_face_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                      totelmat);
-         for (int j = 1; j < trace_face_integs.Size(); j++)
+         trial_fes->GetFaceVDofs(i, trial_vdofs);
+         test_fes->GetFaceVDofs(i, test_vdofs);
+         eltrans = mesh->GetFaceTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < trace_face_integs.Size(); j++)
          {
-            trace_face_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                         elmat);
-            totelmat += elmat;
+            trace_face_integs[j]->AssembleElementMatrix2(*trial_fes->GetFaceElement(i),
+                                                         *test_fes->GetFaceElement(i),
+                                                         *eltrans, elemmat);
+            elmat += elemmat;
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 }
 
+void DiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
+      return;
+   }
+
+   mat->Finalize();
+
+   const SparseMatrix *test_R = test_fes->GetConformingRestriction();
+   if (test_R)
+   {
+      SparseMatrix *RA = mfem::Mult(*test_R, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+
+   A.Reset(mat, false);
 }
+
+} // namespace mfem
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index b23df9280..0788d9185 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -127,13 +127,12 @@ protected:
    DiagonalPolicy diag_policy;
 
    int precompute_sparsity;
+
    // Allocate appropriate SparseMatrix and assign it to mat
    void AllocMat();
 
-   void ConformingAssemble();
-
    // may be used in the construction of derived classes
-   BilinearForm() : Matrix (0)
+   BilinearForm() : Matrix(0)
    {
       fes = NULL; sequence = -1;
       mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
@@ -184,6 +183,18 @@ public:
        If used, this method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
+   /// Sets diagonal policy used upon construction of the linear system.
+   /** Policies include:
+
+       - DIAG_ZERO (Set the diagonal values to zero)
+       - DIAG_ONE  (Set the diagonal values to one)
+       - DIAG_KEEP (Keep the diagonal values)
+   */
+   void SetDiagonalPolicy(DiagonalPolicy policy) { diag_policy = policy; }
+
    /** @brief Force the sparse matrix column indices to be sorted when using
        AssemblyLevel::FULL.
 
@@ -199,8 +210,16 @@ public:
       sort_sparse_matrix = enable_it;
    }
 
-   /// Returns the assembly level
-   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+   /// Indicate that integrators are not owned by the BilinearForm
+   void UseExternalIntegrators() { extern_bfs = 1; }
+
+   /// Enable hybridization.
+   /** For details see the description for class
+       Hybridization in fem/hybridization.hpp. This method should be called
+       before assembly. */
+   void EnableHybridization(FiniteElementSpace *constr_space,
+                            BilinearFormIntegrator *constr_integ,
+                            const Array<int> &ess_tdof_list);
 
    Hybridization *GetHybridization() const { return hybridization; }
 
@@ -218,14 +237,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /// Enable hybridization.
-   /** For details see the description for class
-       Hybridization in fem/hybridization.hpp. This method should be called
-       before assembly. */
-   void EnableHybridization(FiniteElementSpace *constr_space,
-                            BilinearFormIntegrator *constr_integ,
-                            const Array<int> &ess_tdof_list);
-
    /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
        (assuming dense element matrices) based on the types of integrators
        present in the bilinear form. */
@@ -251,38 +262,28 @@ public:
        finalized) and the entries are initialized with zeros. */
    void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
 
-   /// Access all the integrators added with AddDomainIntegrator().
-   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
-
-   /// Access all the integrators added with AddBoundaryIntegrator().
-   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
-   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
-
-   /// Access all integrators added with AddInteriorFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
-
-   /// Access all integrators added with AddBdrFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
-   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBFBFI_Marker()
-   { return &boundary_face_integs_marker; }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
    /// Returns a reference to: \f$ M_{ij} \f$
-   virtual double &Elem(int i, int j);
+   double &Elem(int i, int j) override;
 
    /// Returns constant reference to: \f$ M_{ij} \f$
-   virtual const double &Elem(int i, int j) const;
+   const double &Elem(int i, int j) const override;
 
    /// Matrix vector multiplication:  \f$ y = M x \f$
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
+
+   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
+   void AddMult(const Vector &x, Vector &y,
+                const double a = 1.0) const override;
+
+   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
+   void MultTranspose(const Vector &x, Vector &y) const override;
+
+   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /** @brief Matrix vector multiplication with the original uneliminated
        matrix.  The original matrix is \f$ M + M_e \f$ so we have:
@@ -290,39 +291,38 @@ public:
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
-   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const
-   { mat -> AddMult (x, y, a); }
-
    /** @brief Add the original uneliminated matrix vector multiple to a vector.
        The original matrix is \f$ M + Me \f$ so we have:
        \f$ y += M x + M_e x \f$ */
    void FullAddMult(const Vector &x, Vector &y) const
    { mat->AddMult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
-                                 const double a = 1.0) const
-   { mat->AddMultTranspose(x, y, a); }
-
    /** @brief Add the original uneliminated matrix transpose vector
        multiple to a vector. The original matrix is \f$ M + M_e \f$
        so we have: \f$ y += M^T x + {M_e}^T x \f$ */
-   void FullAddMultTranspose(const Vector & x, Vector & y) const
+   void FullAddMultTranspose(const Vector &x, Vector &y) const
    { mat->AddMultTranspose(x, y); mat_e->AddMultTranspose(x, y); }
 
-   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
+   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
+   double FullInnerProduct(const Vector &x, const Vector &y) const
+   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
+
+   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
+   MatrixInverse *Inverse() const override;
 
    /// Compute \f$ y^T M x \f$
    double InnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct (x, y); }
+   { return mat->InnerProduct(x, y); }
 
-   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
-   virtual MatrixInverse *Inverse() const;
+   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
+   void operator=(const double a)
+   {
+      if (mat != NULL) { *mat = a; }
+      if (mat_e != NULL) { *mat_e = a; }
+   }
 
    /// Finalizes the matrix initialization.
-   virtual void Finalize(int skip_zeros = 1);
+   void Finalize(int skip_zeros = 1) override;
 
    /** @brief Returns a const reference to the sparse matrix:  \f$ M \f$
 
@@ -345,15 +345,7 @@ public:
    /** @brief Returns true if the sparse matrix is not null, false otherwise.
 
        @sa SpMat(). */
-   bool HasSpMat()
-   {
-      return mat != nullptr;
-   }
-
-
-   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
-   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+   bool HasSpMat() const { return mat != nullptr; }
 
    /** @brief Returns a const reference to the sparse matrix of eliminated b.c.:
        \f$ M_e \f$
@@ -379,10 +371,11 @@ public:
         false otherwise.
 
         @sa SpMatElim(). */
-   bool HasSpMatElim()
-   {
-      return mat_e != nullptr;
-   }
+   bool HasSpMatElim() const { return mat_e != nullptr; }
+
+   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
+        to it.  Used for transferring ownership. */
+   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
@@ -416,16 +409,36 @@ public:
    void AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
                              Array<int> &bdr_marker);
 
-   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
-   void operator=(const double a)
-   {
-      if (mat != NULL) { *mat = a; }
-      if (mat_e != NULL) { *mat_e = a; }
-   }
+   /// Access all the integrators added with AddDomainIntegrator().
+   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
+
+   /// Access all the integrators added with AddBoundaryIntegrator().
+   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
+   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
+
+   /// Access all integrators added with AddInteriorFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
+
+   /// Access all integrators added with AddBdrFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
+   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBFBFI_Marker()
+   { return &boundary_face_integs_marker; }
 
    /// Assembles the form i.e. sums over all domain/bdr integrators.
    void Assemble(int skip_zeros = 1);
 
+   /** For a partially conforming FE space, complete the assembly process by
+       performing A := P^t A P where A is the internal sparse matrix; P is the
+       conforming prolongation matrices of the FE space. After this call the
+       BilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of the bilinear form into @a diag. Note that
        @a diag is a tdof Vector.
 
@@ -435,36 +448,24 @@ public:
        conforming prolongation, and |.| denotes the entry-wise absolute value.
        In general, this is just an approximation of the exact diagonal for this
        case. */
-   virtual void AssembleDiagonal(Vector &diag) const;
+   void AssembleDiagonal(Vector &diag) const override;
 
    /// Get the finite element space prolongation operator.
-   virtual const Operator *GetProlongation() const
-   { return fes->GetConformingProlongation(); }
+   const Operator *GetProlongation() const override
+   { return fes->GetProlongationMatrix(); }
+
    /// Get the finite element space restriction operator
-   virtual const Operator *GetRestriction() const
-   { return fes->GetConformingRestriction(); }
+   const Operator *GetRestriction() const override
+   { return fes->GetRestrictionMatrix(); }
+
    /// Get the output finite element space prolongation matrix
-   virtual const Operator *GetOutputProlongation() const
+   const Operator *GetOutputProlongation() const override
    { return GetProlongation(); }
-   /** @brief Returns the output fe space restriction matrix, transposed
 
-       Logically, this is the transpose of GetOutputRestriction, but in
-       practice it is convenient to have it in transposed form for
-       construction of RAP operators in matrix-free methods. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return GetOutputProlongation(); }
    /// Get the output finite element space restriction matrix
-   virtual const Operator *GetOutputRestriction() const
+   const Operator *GetOutputRestriction() const override
    { return GetRestriction(); }
 
-   /// @brief Compute serial RAP operator and store it in @a A as a SparseMatrix.
-   void SerialRAP(OperatorHandle &A)
-   {
-      MFEM_ASSERT(mat, "SerialRAP requires the SparseMatrix to be assembled.");
-      ConformingAssemble();
-      A.Reset(mat, false);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this bilinear
        form and the linear form @a b(.). */
    /** This method applies any necessary transformations to the linear system
@@ -539,7 +540,7 @@ public:
        FormLinearSystem() method to recover the solution as a GridFunction-size
        vector in @a x. Use the same arguments as in the FormLinearSystem() call.
    */
-   virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
+   void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x) override;
 
    /// Compute and store internally all element matrices.
    void ComputeElementMatrices();
@@ -645,34 +646,14 @@ public:
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x,
                             Vector &b);
 
-   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
-   double FullInnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
-
    /// Update the @a FiniteElementSpace and delete all data associated with the old one.
    virtual void Update(FiniteElementSpace *nfes = NULL);
 
-   /// (DEPRECATED) Return the FE space associated with the BilinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Return the FE space associated with the BilinearForm.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
    const FiniteElementSpace *FESpace() const { return fes; }
 
-   /// Sets diagonal policy used upon construction of the linear system.
-   /** Policies include:
-
-       - DIAG_ZERO (Set the diagonal values to zero)
-       - DIAG_ONE  (Set the diagonal values to one)
-       - DIAG_KEEP (Keep the diagonal values)
-   */
-   void SetDiagonalPolicy(DiagonalPolicy policy);
-
-   /// Indicate that integrators are not owned by the BilinearForm
-   void UseExternalIntegrators() { extern_bfs = 1; }
-
    /// Destroys bilinear form.
    virtual ~BilinearForm();
 };
@@ -760,26 +741,37 @@ public:
                      FiniteElementSpace *te_fes,
                      MixedBilinearForm *mbf);
 
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
+   /** This method must be called before assembly. */
+   void SetAssemblyLevel(AssemblyLevel assembly_level);
+
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
    /// Returns a reference to: \f$ M_{ij} \f$
-   virtual double &Elem(int i, int j);
+   double &Elem(int i, int j) override;
 
    /// Returns a reference to: \f$ M_{ij} \f$
-   virtual const double &Elem(int i, int j) const;
+   const double &Elem(int i, int j) const override;
 
    /// Matrix multiplication: \f$ y = M x \f$
-   virtual void Mult(const Vector & x, Vector & y) const;
+   void Mult(const Vector &x, Vector &y) const override;
+
+   void AddMult(const Vector &x, Vector &y,
+                const double a = 1.0) const override;
 
-   virtual void AddMult(const Vector & x, Vector & y,
-                        const double a = 1.0) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
-                                 const double a = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
-   virtual MatrixInverse *Inverse() const;
+   MatrixInverse *Inverse() const override;
+
+   /// Sets all sparse values of \f$ M \f$ to @a a.
+   void operator=(const double a) { *mat = a; }
 
    /// Finalizes the matrix initialization.
-   virtual void Finalize(int skip_zeros = 1);
+   void Finalize(int skip_zeros = 1) override;
 
    /** Extract the associated matrix as SparseMatrix blocks. The number of
        block rows and columns is given by the vector dimensions (vdim) of the
@@ -792,6 +784,9 @@ public:
    /// Returns a reference to the sparse matrix:  \f$ M \f$
    SparseMatrix &SpMat() { return *mat; }
 
+   /// Returns true if the sparse matrix is not null, false otherwise.
+   bool HasSpMat() const { return mat != nullptr; }
+
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
         to it.  Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
@@ -803,8 +798,8 @@ public:
    void AddBoundaryIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary integrator. Assumes ownership of @a bfi.
-   void AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                               Array<int> &bdr_marker);
+   void AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                              Array<int> &bdr_marker);
 
    /** @brief Add a trace face integrator. Assumes ownership of @a bfi.
 
@@ -814,11 +809,11 @@ public:
    void AddTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi,
-                                   Array<int> &bdr_marker);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
+                                  Array<int> &bdr_marker);
 
    /// Access all integrators added with AddDomainIntegrator().
    Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
@@ -842,42 +837,35 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   /// Sets all sparse values of \f$ M \f$ to @a a.
-   void operator=(const double a) { *mat = a; }
-
-   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
-   /** This method must be called before assembly. */
-   void SetAssemblyLevel(AssemblyLevel assembly_level);
-
    void Assemble(int skip_zeros = 1);
 
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
        bilinear form and D is a diagonal. */
    void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
 
    /// Get the input finite element space prolongation matrix
-   virtual const Operator *GetProlongation() const
+   const Operator *GetProlongation() const override
    { return trial_fes->GetProlongationMatrix(); }
 
    /// Get the input finite element space restriction matrix
-   virtual const Operator *GetRestriction() const
+   const Operator *GetRestriction() const override
    { return trial_fes->GetRestrictionMatrix(); }
 
    /// Get the test finite element space prolongation matrix
-   virtual const Operator *GetOutputProlongation() const
+   const Operator *GetOutputProlongation() const override
    { return test_fes->GetProlongationMatrix(); }
 
    /// Get the test finite element space restriction matrix
-   virtual const Operator *GetOutputRestriction() const
+   const Operator *GetOutputRestriction() const override
    { return test_fes->GetRestrictionMatrix(); }
 
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
    /// Compute the element matrix of the given element
    void ComputeElementMatrix(int i, DenseMatrix &elmat);
 
@@ -932,33 +920,6 @@ public:
 
    virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
 
-   /** @brief Return in @a A that is column-constrained.
-
-      This returns the same operator as FormRectangularLinearSystem(), but does
-      without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
-   /** @brief Form the column-constrained linear system matrix A.
-       See FormRectangularSystemMatrix() for details.
-
-       Version of the method FormRectangularSystemMatrix() where the system matrix is
-       returned in the variable @a A, of type OpType, holding a *reference* to
-       the system matrix (created with the method OpType::MakeRef()). The
-       reference will be invalidated when SetOperatorType(), Update(), or the
-       destructor is called. */
-   template <typename OpType>
-   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list, OpType &A)
-   {
-      OperatorHandle Ah;
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
-      OpType *A_ptr = Ah.Is<OpType>();
-      MFEM_VERIFY(A_ptr, "invalid OpType used");
-      A.MakeRef(*A_ptr);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
 
@@ -992,6 +953,41 @@ public:
       A.MakeRef(*A_ptr);
    }
 
+   /** @brief Return in @a A that is column-constrained.
+
+      This returns the same operator as FormRectangularLinearSystem(), but does
+      without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
+   /** @brief Form the column-constrained linear system matrix A.
+       See FormRectangularSystemMatrix() for details.
+
+       Version of the method FormRectangularSystemMatrix() where the system matrix is
+       returned in the variable @a A, of type OpType, holding a *reference* to
+       the system matrix (created with the method OpType::MakeRef()). The
+       reference will be invalidated when SetOperatorType(), Update(), or the
+       destructor is called. */
+   template <typename OpType>
+   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list, OpType &A)
+   {
+      OperatorHandle Ah;
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
+
+   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
+                           const Vector &sol, Vector &rhs);
+
+   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
+                                          const Vector &sol, Vector &rhs);
+
+   void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+
    void Update();
 
    /// Return the trial FE space associated with the BilinearForm.
@@ -1065,7 +1061,10 @@ public:
    { AddTraceFaceIntegrator(di); }
 
    /// Access all interpolators added with AddDomainInterpolator().
-   Array<BilinearFormIntegrator*> *GetDI() { return &domain_integs; }
+   Array<BilinearFormIntegrator*> *GetDI() { return GetDBFI(); }
+
+   /// Access all interpolators added with AddTraceFaceInterpolator().
+   Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
    /// Set the desired assembly level. The default is AssemblyLevel::FULL.
    /** This method must be called before assembly. */
@@ -1073,14 +1072,30 @@ public:
 
    /** @brief Construct the internal matrix representation of the discrete
        linear operator. */
-   virtual void Assemble(int skip_zeros = 1);
+   void Assemble(int skip_zeros = 1);
+
+   /** @brief Return in @a A that is column-constrained. */
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** @brief Form the column-constrained discrete linear operator matrix A.
+       See FormDiscreteOperatorMatrix() for details.
 
-   /** @brief Get the output finite element space restriction matrix in
-       transposed form. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return test_fes->GetRestrictionTransposeOperator(); }
+       Version of the method FormDiscreteOperatorMatrix() where the discrete
+       operator matrix is returned in the variable @a A, of type OpType,
+       holding a *reference* to the discrete operator  matrix (created with the
+       method OpType::MakeRef()). The reference will be invalidated when
+       SetOperatorType(), Update(), or the destructor is called. */
+   template <typename OpType>
+   void FormDiscreteOperatorMatrix(OpType &A)
+   {
+      OperatorHandle Ah;
+      FormDiscreteOperatorMatrix(Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
 };
 
-}
+} // namespace mfem
 
 #endif
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index c98806954..8d0256462 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -21,10 +21,10 @@
 namespace mfem
 {
 
+/// Base class for extensions to the BilinearForm class
 BilinearFormExtension::BilinearFormExtension(BilinearForm *form)
    : Operator(form->Size()), a(form)
 {
-   // empty
 }
 
 const Operator *BilinearFormExtension::GetProlongation() const
@@ -37,885 +37,1261 @@ const Operator *BilinearFormExtension::GetRestriction() const
    return a->GetRestriction();
 }
 
-// Data and methods for partially-assembled bilinear forms
+/// Data and methods for matrix-free bilinear forms
 MFBilinearFormExtension::MFBilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
+   : BilinearFormExtension(form)
 {
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
+   Update();
 }
 
-void MFBilinearFormExtension::Assemble()
+void MFBilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering ordering = UsesTensorBasis(*fes) ?
+                                 ElementDofOrdering::LEXICOGRAPHIC :
+                                 ElementDofOrdering::NATIVE;
+   elem_restrict = fes->GetElementRestriction(ordering);
+   if (elem_restrict)
    {
-      integrators[i]->AssembleMF(*a->FESpace());
+      local_x.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.UseDevice(true); // ensure 'local_y = 0.0' is done on device
    }
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0, "AddBoundaryIntegrator is not "
-               "currently supported in MFBilinearFormExtension");
-}
-
-void MFBilinearFormExtension::AssembleDiagonal(Vector &y) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (int_face_restrict_lex == nullptr && a->GetFBFI()->Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(localY);
-      }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
-      {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
-      }
-      else
-      {
-         elem_restrict->MultTranspose(localY, y);
-      }
+      int_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Interior);
+      int_face_x.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.UseDevice(true);
    }
-   else
+
+   if (bdr_face_restrict_lex == nullptr &&
+       (a->GetBFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0))
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(y);
-      }
+      bdr_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Boundary,
+                                 m);
+      bdr_face_x.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.UseDevice(true);
    }
 }
 
-void MFBilinearFormExtension::Update()
+void MFBilinearFormExtension::Assemble()
 {
-   FiniteElementSpace *fes = a->FESpace();
-   height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   elem_restrict = nullptr;
-   int_face_restrict_lex = nullptr;
-   bdr_face_restrict_lex = nullptr;
-}
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*fes);
+   }
 
-void MFBilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
-{
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
-}
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*fes);
+   }
 
-void MFBilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
 }
 
-void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(x, y);
+         integ->AssembleDiagonalMF(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(localX, localY);
+         integ->AssembleDiagonalMF(diag);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultMF(int_face_X, int_face_Y);
+            integ->AssembleDiagonalMF(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultMF(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalMF(diag);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(localX, localY);
+         integ->AddMultMF(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(x, y);
+         integ->AddMultMF(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
          {
-            intFaceIntegrators[i]->AddMultTransposeMF(int_face_X, int_face_Y);
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposeMF(bdr_face_X, bdr_face_Y);
+            integ->AddMultMF(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for partially-assembled bilinear forms
-PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
-{
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
-}
-
-void PABilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
+void MFBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if ( Device::Allows(Backend::CEED_MASK) ) { return; }
-   ElementDofOrdering ordering = UsesTensorBasis(*a->FESpace())?
-                                 ElementDofOrdering::LEXICOGRAPHIC:
-                                 ElementDofOrdering::NATIVE;
-   elem_restrict = trial_fes->GetElementRestriction(ordering);
-   if (elem_restrict)
-   {
-      localX.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.UseDevice(true); // ensure 'localY = 0.0' is done on device
-   }
-
-   // Construct face restriction operators only if the bilinear form has
-   // interior or boundary face integrators
-   if (int_face_restrict_lex == NULL && a->GetFBFI()->Size() > 0)
-   {
-      int_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Interior);
-      int_face_X.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.UseDevice(true); // ensure 'int_face_Y = 0.0' is done on device
-   }
-
-   const bool has_bdr_integs = (a->GetBFBFI()->Size() > 0 ||
-                                a->GetBBFI()->Size() > 0);
-   if (bdr_face_restrict_lex == NULL && has_bdr_integs)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      bdr_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Boundary,
-                                 m);
-      bdr_face_X.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.UseDevice(true); // ensure 'faceBoundY = 0.0' is done on device
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
+      }
    }
-}
-
-void PABilinearFormExtension::Assemble()
-{
-   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   for (BilinearFormIntegrator *integ : integrators)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      if (integ->Patchwise())
+      if (bdr_face_restrict_lex)
       {
-         MFEM_VERIFY(a->FESpace()->GetNURBSext(),
-                     "Patchwise integration requires a NURBS FE space");
-         integ->AssembleNURBSPA(*a->FESpace());
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
       }
       else
       {
-         integ->AssemblePA(*a->FESpace());
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
       }
    }
+}
 
-   Array<BilinearFormIntegrator*> &bdr_integrators = *a->GetBBFI();
-   for (BilinearFormIntegrator *integ : bdr_integrators)
+void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      integ->AssemblePABoundary(*a->FESpace());
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   for (BilinearFormIntegrator *integ : intFaceIntegrators)
+   else
    {
-      integ->AssemblePAInteriorFaces(*a->FESpace());
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(x, y);
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   for (BilinearFormIntegrator *integ : bdrFaceIntegrators)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      integ->AssemblePABoundaryFaces(*a->FESpace());
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(x, y);
+         }
+      }
    }
 }
 
-void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
+void MFBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      if (iSz > 0)
+      if (elem_restrict)
       {
-         localY = 0.0;
-         for (int i = 0; i < iSz; ++i)
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
          {
-            integrators[i]->AssembleDiagonalPA(localY);
+            integ->AddMultTransposeMF(local_x, local_y);
          }
-         const ElementRestriction* H1elem_restrict =
-            dynamic_cast<const ElementRestriction*>(elem_restrict);
-         if (H1elem_restrict)
+         if (c != 1.0)
          {
-            H1elem_restrict->MultTransposeUnsigned(localY, y);
-         }
-         else
-         {
-            elem_restrict->MultTranspose(localY, y);
+            local_y *= c;
          }
+         elem_restrict->AddMultTranspose(local_y, y);
       }
       else
       {
-         y = 0.0;
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
    }
-   else
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (bdr_face_restrict_lex)
       {
-         integrators[i]->AssembleDiagonalPA(y);
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
-   const int n_bdr_integs = bdr_integs.Size();
-   if (bdr_face_restrict_lex && n_bdr_integs > 0)
-   {
-      bdr_face_Y = 0.0;
-      for (int i = 0; i < n_bdr_integs; ++i)
+      else
       {
-         bdr_integs[i]->AssembleDiagonalPA(bdr_face_Y);
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
-      bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_Y, y);
    }
 }
 
-void PABilinearFormExtension::Update()
+void MFBilinearFormExtension::Update()
 {
-   FiniteElementSpace *fes = a->FESpace();
+   fes = a->FESpace();
    height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
 
    elem_restrict = nullptr;
    int_face_restrict_lex = nullptr;
    bdr_face_restrict_lex = nullptr;
 }
 
-void PABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
-{
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
-}
-
-void PABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
+/// Data and methods for partially-assembled bilinear forms
+PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
+   : MFBilinearFormExtension(form)
 {
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
 }
 
-void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void PABilinearFormExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   const int iSz = integrators.Size();
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssemblePA(*fes);
+   }
 
-   bool allPatchwise = true;
-   bool somePatchwise = false;
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssemblePABoundary(*fes);
+   }
 
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   for (BilinearFormIntegrator *integ : int_face_integrators)
    {
-      if (integrators[i]->Patchwise())
-      {
-         somePatchwise = true;
-      }
-      else
-      {
-         allPatchwise = false;
-      }
+      integ->AssemblePAInteriorFaces(*fes);
    }
 
-   MFEM_VERIFY(!(somePatchwise && !allPatchwise),
-               "All or none of the integrators should be patchwise");
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   for (BilinearFormIntegrator *integ : bdr_face_integrators)
+   {
+      integ->AssemblePABoundaryFaces(*fes);
+   }
+}
 
-   if (DeviceCanUseCeed() || !elem_restrict || allPatchwise)
+void PABilinearFormExtension::AssembleDiagonal(Vector &diag) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         if (integrators[i]->Patchwise())
-         {
-            integrators[i]->AddMultNURBSPA(x, y);
-         }
-         else
-         {
-            integrators[i]->AddMultPA(x, y);
-         }
+         integ->AssembleDiagonalPA(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      if (iSz)
-      {
-         elem_restrict->Mult(x, localX);
-         localY = 0.0;
-         for (int i = 0; i < iSz; ++i)
-         {
-            integrators[i]->AddMultPA(localX, localY);
-         }
-         elem_restrict->MultTranspose(localY, y);
-      }
-      else
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         y = 0.0;
+         integ->AssembleDiagonalPA(diag);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultPA(int_face_X, int_face_Y);
+            integ->AssembleDiagonalPA(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
-   Array<BilinearFormIntegrator*> &bdr_face_integs = *a->GetBFBFI();
-   const int n_bdr_integs = bdr_integs.Size();
-   const int n_bdr_face_integs = bdr_face_integs.Size();
-   const bool has_bdr_integs = (n_bdr_face_integs > 0 || n_bdr_integs > 0);
-   if (bdr_face_restrict_lex && has_bdr_integs)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < n_bdr_integs; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdr_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalPA(diag);
          }
-         for (int i = 0; i < n_bdr_face_integs; ++i)
-         {
-            bdr_face_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
-         }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(localX, localY);
+         integ->AddMultPA(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(x, y);
+         integ->AddMultPA(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         for (BilinearFormIntegrator *integ : int_face_integrators)
          {
-            intFaceIntegrators[i]->AddMultTransposePA(int_face_X, int_face_Y);
+            integ->AddMultPA(x, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposePA(bdr_face_X, bdr_face_Y);
+            integ->AddMultPA(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for element-assembled bilinear forms
-EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
-   : PABilinearFormExtension(form),
-     factorize_face_terms(false)
+void PABilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if (form->FESpace()->IsDGSpace() && form->FESpace()->Conforming())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      factorize_face_terms = true;
-   }
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
 }
 
-void EABilinearFormExtension::Assemble()
+void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   SetupRestrictionOperators(L2FaceValues::SingleValued);
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true);
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
+   }
 
-   ne = trial_fes->GetMesh()->GetNE();
-   elemDofs = trial_fes->GetFE(0)->GetDof();
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
 
-   ea_data.SetSize(ne*elemDofs*elemDofs, Device::GetMemoryType());
-   ea_data.UseDevice(true);
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
+}
 
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   if ( integratorCount == 0 )
+void PABilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      ea_data = 0.0;
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
-   for (int i = 0; i < integratorCount; ++i)
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      integrators[i]->AssembleEA(*a->FESpace(), ea_data, i);
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
 
-   faceDofs = trial_fes ->
-              GetTraceElement(0, trial_fes->GetMesh()->GetFaceGeometry(0)) ->
-              GetDof();
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
+   }
+}
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Element assembly does not support AddBoundaryIntegrator yet.");
+/// Data and methods for element-assembled bilinear forms
+EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
+   : PABilinearFormExtension(form),
+     factorize_face_terms(fes->IsDGSpace() && fes->Conforming())
+{
+}
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   if (intFaceIntegratorCount>0)
+void EABilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::SingleValued);
+
+   ne = fes->GetNE();
+   elem_dofs = fes->GetFE(0)->GetDof();
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      nf_int = trial_fes->GetNFbyType(FaceType::Interior);
-      ea_data_int.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_ext.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
+      ea_data.SetSize(ne * elem_dofs * elem_dofs, Device::GetMemoryType());
+      ea_data.UseDevice(true);
+      ea_data = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleEA(*fes, ea_data);
+      }
    }
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
-   {
-      intFaceIntegrators[i]->AssembleEAInteriorFaces(*a->FESpace(),
-                                                     ea_data_int,
-                                                     ea_data_ext,
-                                                     i);
+
+   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
+               "Element assembly does not support AddBoundaryIntegrator yet.");
+
+   nf_int = fes->GetNFbyType(FaceType::Interior);
+   nf_bdr = fes->GetNFbyType(FaceType::Boundary);
+   face_dofs = fes->GetTraceElement(0,
+                                    fes->GetMesh()->GetFaceGeometry(0))->GetDof();
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      ea_data_int.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_ext.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_int = 0.0;
+      ea_data_ext = 0.0;
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AssembleEAInteriorFaces(*fes, ea_data_int, ea_data_ext);
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   if (boundFaceIntegratorCount>0)
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_integrators.Size() > 0)
    {
-      nf_bdr = trial_fes->GetNFbyType(FaceType::Boundary);
-      ea_data_bdr.SetSize(nf_bdr*faceDofs*faceDofs, Device::GetMemoryType());
+      ea_data_bdr.SetSize(nf_bdr * face_dofs * face_dofs, Device::GetMemoryType());
       ea_data_bdr = 0.0;
-   }
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
-   {
-      bdrFaceIntegrators[i]->AssembleEABoundaryFaces(*a->FESpace(),ea_data_bdr,i);
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AssembleEABoundaryFaces(*fes, ea_data_bdr);
+      }
    }
 
    if (factorize_face_terms && int_face_restrict_lex)
    {
-      auto restFint = dynamic_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-      restFint->AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*int_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
    }
    if (factorize_face_terms && bdr_face_restrict_lex)
    {
-      auto restFbdr = dynamic_cast<const L2FaceRestriction*>(bdr_face_restrict_lex);
-      restFbdr->AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*bdr_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
    }
 }
 
 void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto Apply = [](const int nelem, const int ndofs, const Vector &data,
+                   const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(i, j, e)*X(i, e);
+            res += A(i, j, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      Apply(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         Apply(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 0, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 1, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFace(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFace(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(i, j, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         Apply(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
 void EABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices transposed
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto ApplyTranspose = [](const int nelem, const int ndofs, const Vector &data,
+                            const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(j, i, e)*X(i, e);
+            res += A(j, i, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      ApplyTranspose(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         ApplyTranspose(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 1, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 0, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFaceTranspose(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFaceTranspose(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(j, i, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         ApplyTranspose(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
-// Data and methods for fully-assembled bilinear forms
+/// Data and methods for fully-assembled bilinear forms
 FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
    : EABilinearFormExtension(form),
      mat(a->mat)
 {
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(form->FESpace())) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(form->FESpace())))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
    }
 #endif
 }
@@ -923,20 +1299,20 @@ FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
 void FABilinearFormExtension::Assemble()
 {
    EABilinearFormExtension::Assemble();
-   FiniteElementSpace &fes = *a->FESpace();
-   int width = fes.GetVSize();
-   int height = fes.GetVSize();
+
+   int width = fes->GetVSize();
+   int height = fes->GetVSize();
    bool keep_nbr_block = false;
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(&fes)) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(fes)))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
       width += pfes->GetFaceNbrVSize();
       dg_x.SetSize(width);
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          height += pfes->GetFaceNbrVSize();
          dg_y.SetSize(height);
@@ -946,15 +1322,14 @@ void FABilinearFormExtension::Assemble()
 #endif
    if (a->mat) // We reuse the sparse matrix memory
    {
-      if (fes.IsDGSpace())
+      if (fes->IsDGSpace())
       {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill J and Data
          // 1.1 Fill J and Data with Elem ea_data
          restE->FillJAndData(ea_data, *mat);
@@ -970,8 +1345,8 @@ void FABilinearFormExtension::Assemble()
       }
       else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction&>(*elem_restrict);
          rest.FillJAndData(ea_data, *mat);
       }
    }
@@ -979,15 +1354,14 @@ void FABilinearFormExtension::Assemble()
    {
       mat = new SparseMatrix;
       mat->OverrideSize(height, width);
-      if (fes.IsDGSpace())
-      {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+      if (fes->IsDGSpace())
+      {
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill I
          mat->GetMemoryI().New(height+1, mat->GetMemoryI().GetMemoryType());
          //  1.1 Increment with restE
@@ -1020,87 +1394,32 @@ void FABilinearFormExtension::Assemble()
          }
          I[0] = 0;
       }
-      else // continuous Galerkin case
+      else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction &>(*elem_restrict);
          rest.FillSparseMatrix(ea_data, *mat);
       }
       a->mat = mat;
    }
-   if ( a->sort_sparse_matrix )
+   if (a->sort_sparse_matrix)
    {
       a->mat->SortColumnIndices();
    }
 }
 
-
-void FABilinearFormExtension::RAP(OperatorHandle &A)
-{
-#ifdef MFEM_USE_MPI
-   if ( auto pa = dynamic_cast<ParBilinearForm*>(a) )
-   {
-      pa->ParallelRAP(*pa->mat, A);
-   }
-   else
-#endif
-   {
-      a->SerialRAP(A);
-   }
-}
-
-void FABilinearFormExtension::EliminateBC(const Array<int> &ess_dofs,
-                                          OperatorHandle &A)
-{
-   MFEM_VERIFY(a->diag_policy == DiagonalPolicy::DIAG_ONE,
-               "Only DiagonalPolicy::DIAG_ONE supported with"
-               " FABilinearFormExtension.");
-#ifdef MFEM_USE_MPI
-   if ( dynamic_cast<ParBilinearForm*>(a) )
-   {
-      A.As<HypreParMatrix>()->EliminateBC(ess_dofs,
-                                          DiagonalPolicy::DIAG_ONE);
-   }
-   else
-#endif
-   {
-      A.As<SparseMatrix>()->EliminateBC(ess_dofs,
-                                        DiagonalPolicy::DIAG_ONE);
-   }
-}
-
-void FABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_dofs,
-                                               OperatorHandle &A)
-{
-   RAP(A);
-   EliminateBC(ess_dofs, A);
-}
-
-void FABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *A_out;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, A_out, X, B, copy_interior);
-   delete A_out;
-   FormSystemMatrix(ess_tdof_list, A);
-}
-
 void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1113,8 +1432,8 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
       {
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
-      ParBilinearForm *pform = nullptr;
-      if ((pform = dynamic_cast<ParBilinearForm*>(a)) && (pform->keep_nbr_block))
+      ParBilinearForm *pb = nullptr;
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          mat->Mult(dg_x, dg_y);
          // DG Restriction
@@ -1139,7 +1458,7 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMult(x, y);
    }
@@ -1152,16 +1471,15 @@ void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1175,7 +1493,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && (pb->keep_nbr_block))
       {
          mat->MultTranspose(dg_x, dg_y);
          // DG Restriction
@@ -1200,7 +1518,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMultTranspose(x, y);
    }
@@ -1211,10 +1529,10 @@ void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 }
 
 
+/// Base class for extensions to the MixedBilinearForm class
 MixedBilinearFormExtension::MixedBilinearFormExtension(MixedBilinearForm *form)
    : Operator(form->Height(), form->Width()), a(form)
 {
-   // empty
 }
 
 const Operator *MixedBilinearFormExtension::GetProlongation() const
@@ -1222,392 +1540,723 @@ const Operator *MixedBilinearFormExtension::GetProlongation() const
    return a->GetProlongation();
 }
 
-const Operator *MixedBilinearFormExtension::GetRestriction() const
+const Operator *MixedBilinearFormExtension::GetRestriction() const
+{
+   return a->GetRestriction();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
+{
+   return a->GetOutputProlongation();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+{
+   return a->GetOutputRestriction();
+}
+
+/// Data and methods for matrix-free mixed bilinear forms
+MFMixedBilinearFormExtension::MFMixedBilinearFormExtension(
+   MixedBilinearForm *form)
+   : MixedBilinearFormExtension(form)
+{
+   Update();
+}
+
+void MFMixedBilinearFormExtension::SetupRestrictionOperators(
+   const L2FaceValues m)
+{
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering trial_ordering = UsesTensorBasis(*trial_fes) ?
+                                       ElementDofOrdering::LEXICOGRAPHIC :
+                                       ElementDofOrdering::NATIVE;
+   ElementDofOrdering test_ordering = UsesTensorBasis(*test_fes) ?
+                                      ElementDofOrdering::LEXICOGRAPHIC :
+                                      ElementDofOrdering::NATIVE;
+   elem_restrict_trial = trial_fes->GetElementRestriction(trial_ordering);
+   elem_restrict_test = test_fes->GetElementRestriction(test_ordering);
+   if (elem_restrict_trial)
+   {
+      local_trial.SetSize(elem_restrict_trial->Height(),
+                          Device::GetDeviceMemoryType());
+      local_trial.UseDevice(true); // ensure 'local_trial = 0.0' is done on device
+   }
+   if (elem_restrict_test)
+   {
+      local_test.SetSize(elem_restrict_test->Height(),
+                         Device::GetDeviceMemoryType());
+      local_test.UseDevice(true); // ensure 'local_test = 0.0' is done on device
+   }
+
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (a->GetTFBFI()->Size() > 0)
+   {
+      if (int_face_restrict_lex_trial == nullptr)
+      {
+         int_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Interior);
+         int_face_trial.SetSize(int_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         int_face_trial.UseDevice(true);
+      }
+      if (int_face_restrict_lex_test == nullptr)
+      {
+         int_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Interior);
+         int_face_test.SetSize(int_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         int_face_test.UseDevice(true);
+      }
+   }
+
+   if (a->GetBTFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial == nullptr)
+      {
+         bdr_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Boundary,
+                                          m);
+         bdr_face_trial.SetSize(bdr_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         bdr_face_trial.UseDevice(true);
+      }
+      if (bdr_face_restrict_lex_test == nullptr)
+      {
+         bdr_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Boundary,
+                                         m);
+         bdr_face_test.SetSize(bdr_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         bdr_face_test.UseDevice(true);
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*trial_fes, *test_fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*trial_fes, *test_fes);
+   }
+
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+}
+
+void MFMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+{
+   y = 0.0;
+   AddMult(x, y);
+}
+
+void MFMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                           const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::MultTranspose(const Vector &x,
+                                                 Vector &y) const
 {
-   return a->GetRestriction();
+   y = 0.0;
+   AddMultTranspose(x, y);
 }
 
-const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
+void MFMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                                    const double c) const
 {
-   return a->GetOutputProlongation();
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_test)
+      {
+         elem_restrict_test->Mult(x, local_test);
+      }
+      if (elem_restrict_trial)
+      {
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
+      }
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
+         }
+      }
+   }
 }
 
-const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+void MFMixedBilinearFormExtension::Update()
 {
-   return a->GetOutputRestriction();
+   trial_fes = a->TrialFESpace();
+   test_fes  = a->TestFESpace();
+   height = test_fes->GetVSize();
+   width  = trial_fes->GetVSize();
+
+   elem_restrict_trial = nullptr;
+   elem_restrict_test = nullptr;
+   int_face_restrict_lex_trial = nullptr;
+   int_face_restrict_lex_test = nullptr;
+   bdr_face_restrict_lex_trial = nullptr;
+   bdr_face_restrict_lex_test = nullptr;
 }
 
-// Data and methods for partially-assembled bilinear forms
-
+/// Data and methods for partially-assembled mixed bilinear forms
 PAMixedBilinearFormExtension::PAMixedBilinearFormExtension(
    MixedBilinearForm *form)
-   : MixedBilinearFormExtension(form),
-     trial_fes(form->TrialFESpace()),
-     test_fes(form->TestFESpace()),
-     elem_restrict_trial(NULL),
-     elem_restrict_test(NULL)
+   : MFMixedBilinearFormExtension(form)
 {
-   Update();
 }
 
 void PAMixedBilinearFormExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-   MFEM_VERIFY(a->GetTFBFI()->Size() == 0,
-               "Partial assembly does not support AddTraceFaceIntegrator yet.");
-   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0,
-               "Partial assembly does not support AddBdrTraceFaceIntegrator yet.");
-}
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-void PAMixedBilinearFormExtension::Update()
-{
-   trial_fes = a->TrialFESpace();
-   test_fes  = a->TestFESpace();
-   height = test_fes->GetVSize();
-   width = trial_fes->GetVSize();
-   elem_restrict_trial = trial_fes->GetElementRestriction(
-                            ElementDofOrdering::LEXICOGRAPHIC);
-   elem_restrict_test  =  test_fes->GetElementRestriction(
-                             ElementDofOrdering::LEXICOGRAPHIC);
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      localTrial.UseDevice(true);
-      localTrial.SetSize(elem_restrict_trial->Height(),
-                         Device::GetMemoryType());
+      integ->AssemblePA(*trial_fes, *test_fes);
    }
-   if (elem_restrict_test)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
    {
-      localTest.UseDevice(true); // ensure 'localY = 0.0' is done on device
-      localTest.SetSize(elem_restrict_test->Height(), Device::GetMemoryType());
+      integ->AssemblePABoundary(*trial_fes, *test_fes);
    }
-}
 
-void PAMixedBilinearFormExtension::FormRectangularSystemOperator(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-{
-   Operator * oper;
-   Operator::FormRectangularSystemOperator(trial_tdof_list, test_tdof_list,
-                                           oper);
-   A.Reset(oper); // A will own oper
-}
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 
-void PAMixedBilinearFormExtension::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   Operator *oper;
-   Operator::FormRectangularLinearSystem(trial_tdof_list, test_tdof_list, x, b,
-                                         oper, X, B);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 }
 
-void PAMixedBilinearFormExtension::SetupMultInputs(
-   const Operator *elem_restrict_x,
-   const Vector &x,
-   Vector &localX,
-   const Operator *elem_restrict_y,
-   Vector &y,
-   Vector &localY,
-   const double c) const
+void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
+                                                         Vector &diag) const
 {
-   // * G operation: localX = c*local(x)
-   if (elem_restrict_x)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      elem_restrict_x->Mult(x, localX);
-      if (c != 1.0)
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->MultUnsigned(D, local_trial);
+      }
+      if (elem_restrict_test)
       {
-         localX *= c;
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D,
+                                           local_test);
+         }
+         elem_restrict_test->MultTransposeUnsigned(local_test, diag);
       }
    }
    else
    {
-      if (c == 1.0)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D, diag);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->MultUnsigned(D, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
       {
-         localX.SyncAliasMemory(x);
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           bdr_face_test);
+         }
+         bdr_face_restrict_lex_test->AddMultTransposeUnsigned(bdr_face_test, diag);
       }
       else
       {
-         localX.Set(c, x);
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           diag);
+         }
       }
    }
-   if (elem_restrict_y)
-   {
-      localY = 0.0;
-   }
-   else
-   {
-      y.UseDevice(true);
-      localY.SyncAliasMemory(y);
-   }
-}
-
-void PAMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
-{
-   y = 0.0;
-   AddMult(x, y);
 }
 
 void PAMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
                                            const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
    }
 
-   // * G^T operation
-   if (elem_restrict_test)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_test->MultTranspose(localTest, tempY);
-      y += tempY;
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
    }
 }
 
-void PAMixedBilinearFormExtension::MultTranspose(const Vector &x,
-                                                 Vector &y) const
-{
-   y = 0.0;
-   AddMultTranspose(x, y);
-}
-
 void PAMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
                                                     const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_test, x, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
-   {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
-   }
-
-   // * G^T operation
-   if (elem_restrict_trial)
-   {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
-   }
-}
-
-void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
-                                                         Vector &diag) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      const ElementRestriction* H1elem_restrict_trial =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_trial);
-      if (H1elem_restrict_trial)
+      if (elem_restrict_test)
       {
-         H1elem_restrict_trial->MultUnsigned(D, localTrial);
+         elem_restrict_test->Mult(x, local_test);
       }
-      else
+      if (elem_restrict_trial)
       {
-         elem_restrict_trial->Mult(D, localTrial);
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
       }
-   }
-
-   if (elem_restrict_test)
-   {
-      localTest = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, localTest);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, localTest);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x, y);
+            }
          }
       }
-      const ElementRestriction* H1elem_restrict_test =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-      if (H1elem_restrict_test)
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
       {
-         H1elem_restrict_test->MultTransposeUnsigned(localTest, diag);
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
       }
-      else
+      if (bdr_face_restrict_lex_trial)
       {
-         elem_restrict_test->MultTranspose(localTest, diag);
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
       }
-   }
-   else
-   {
-      diag.UseDevice(true); // typically this is a large vector, so store on device
-      diag = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, diag);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, diag);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
          }
       }
    }
 }
 
+/// Data and methods for partially-assembled discrete linear operators
 PADiscreteLinearOperatorExtension::PADiscreteLinearOperatorExtension(
    DiscreteLinearOperator *linop) :
    PAMixedBilinearFormExtension(linop)
 {
 }
 
-const
-Operator *PADiscreteLinearOperatorExtension::GetOutputRestrictionTranspose()
-const
-{
-   return a->GetOutputRestrictionTranspose();
-}
-
 void PADiscreteLinearOperatorExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
+   PAMixedBilinearFormExtension::Assemble();
 
+   // Construct element vdof multiplicity (avoid use of elem_restrict_test
+   // because it might not exist for libCEED)
+   test_multiplicity.SetSize(height);
    test_multiplicity.UseDevice(true);
-   test_multiplicity.SetSize(elem_restrict_test->Width()); // l-vector
-   Vector ones(elem_restrict_test->Height()); // e-vector
-   ones = 1.0;
-
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
-   {
-      elem_restrict->MultTransposeUnsigned(ones, test_multiplicity);
-   }
-   else
+   test_multiplicity = 0.0;
+   Array<int> dofs;
+   auto d_mult = test_multiplicity.HostReadWrite();
+   for (int i = 0; i < test_fes->GetNE(); i++)
    {
-      mfem_error("A real ElementRestriction is required in this setting!");
+      test_fes->GetElementVDofs(i, dofs);
+      for (int j = 0; j < dofs.Size(); j++)
+      {
+         const int k = dofs[j];
+         d_mult[(k >= 0) ? k : -1 - k] += 1.0;
+      }
    }
-
-   auto tm = test_multiplicity.ReadWrite();
-   mfem::forall(test_multiplicity.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      tm[i] = 1.0 / tm[i];
-   });
+   test_multiplicity.Reciprocal();
 }
 
-void PADiscreteLinearOperatorExtension::AddMult(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
+                                                const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   if (elem_restrict_trial)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      elem_restrict_trial->Mult(x, local_trial);
    }
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G^T operation (kind of...)
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
+   if (elem_restrict_test)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict->MultLeftInverse(localTest, tempY);
-      y += tempY;
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, temp_test);
    }
    else
    {
-      mfem_error("In this setting you need a real ElementRestriction!");
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+      }
    }
+   temp_test *= test_multiplicity;
+   y.Add(c, temp_test);
 }
 
-void PADiscreteLinearOperatorExtension::AddMultTranspose(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
+                                                         Vector &y,
+                                                         const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G operation (kinda)
-   Vector xscaled(x);
-   MFEM_VERIFY(x.Size() == test_multiplicity.Size(), "Input vector of wrong size");
-   auto xs = xscaled.ReadWrite();
-   auto tm = test_multiplicity.Read();
-   mfem::forall(x.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      xs[i] *= tm[i];
-   });
-   SetupMultInputs(elem_restrict_test, xscaled, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test = x;
+   temp_test *= test_multiplicity;
+   if (elem_restrict_test)
    {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
+      elem_restrict_test->Mult(temp_test, local_test);
    }
-
-   // * G^T operation
    if (elem_restrict_trial)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
+      local_trial = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
+                                    local_trial);
+      }
+      if (c != 1.0)
+      {
+         local_trial *= c;
+      }
+      elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
-      mfem_error("Trial ElementRestriction not defined");
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0)
+      {
+         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
+                    "AddMultTranspose is not yet supported!");
+      }
+      else
+      {
+         for (BilinearFormIntegrator *interp : interpolators)
+         {
+            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
+         }
+      }
    }
 }
 
-void PADiscreteLinearOperatorExtension::FormRectangularSystemOperator(
-   const Array<int>& ess1, const Array<int>& ess2, OperatorHandle &A)
-{
-   const Operator *Pi = this->GetProlongation();
-   const Operator *RoT = this->GetOutputRestrictionTranspose();
-   Operator *rap = SetupRAP(Pi, RoT);
-
-   RectangularConstrainedOperator *Arco
-      = new RectangularConstrainedOperator(rap, ess1, ess2, rap != this);
-
-   A.Reset(Arco);
-}
-
 } // namespace mfem
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index ef54dc71c..db26eb801 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -25,8 +25,8 @@ class DiscreteLinearOperator;
 
 /// Class extending the BilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class BilinearFormExtension : public Operator
@@ -54,57 +54,59 @@ public:
       MFEM_ABORT("AssembleDiagonal not implemented for this assembly level!");
    }
 
-   virtual void FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                 OperatorHandle &A) = 0;
-   virtual void FormLinearSystem(const Array<int> &ess_tdof_list,
-                                 Vector &x, Vector &b,
-                                 OperatorHandle &A, Vector &X, Vector &B,
-                                 int copy_interior = 0) = 0;
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled bilinear forms
-class PABilinearFormExtension : public BilinearFormExtension
+/// Data and methods for matrix-free bilinear forms
+class MFBilinearFormExtension : public BilinearFormExtension
 {
 protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
+   const FiniteElementSpace *fes; // Not owned
+   mutable Vector local_x, local_y, temp_y;
+   mutable Vector int_face_x, int_face_y;
+   mutable Vector bdr_face_x, bdr_face_y;
+   const ElementRestriction *elem_restrict; // Not owned
    const FaceRestriction *int_face_restrict_lex; // Not owned
    const FaceRestriction *bdr_face_restrict_lex; // Not owned
 
 public:
-   PABilinearFormExtension(BilinearForm*);
+   MFBilinearFormExtension(BilinearForm *form);
 
    void Assemble();
    void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
 
 protected:
    void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled bilinear forms
+class PABilinearFormExtension : public MFBilinearFormExtension
+{
+public:
+   PABilinearFormExtension(BilinearForm *form);
+
+   void Assemble();
+   void AssembleDiagonal(Vector &diag) const;
+   void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
+
 /// Data and methods for element-assembled bilinear forms
 class EABilinearFormExtension : public PABilinearFormExtension
 {
 protected:
-   int ne;
-   int elemDofs;
-   // The element matrices are stored row major
-   Vector ea_data;
-   int nf_int, nf_bdr;
-   int faceDofs;
+   const bool factorize_face_terms;
+   int ne, elem_dofs;
+   Vector ea_data;  // The element matrices are stored row major
+   int nf_int, nf_bdr, face_dofs;
    Vector ea_data_int, ea_data_ext, ea_data_bdr;
-   bool factorize_face_terms;
 
 public:
    EABilinearFormExtension(BilinearForm *form);
@@ -125,15 +127,6 @@ public:
    FABilinearFormExtension(BilinearForm *form);
 
    void Assemble();
-   void RAP(OperatorHandle &A);
-   /** @note Always does `DIAG_ONE` policy to be consistent with
-       `Operator::FormConstrainedSystemOperator`. */
-   void EliminateBC(const Array<int> &ess_dofs, OperatorHandle &A);
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
    void MultTranspose(const Vector &x, Vector &y) const;
 
@@ -143,37 +136,10 @@ public:
    void DGMultTranspose(const Vector &x, Vector &y) const;
 };
 
-/// Data and methods for matrix-free bilinear forms
-class MFBilinearFormExtension : public BilinearFormExtension
-{
-protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
-   const FaceRestriction *int_face_restrict_lex; // Not owned
-   const FaceRestriction *bdr_face_restrict_lex; // Not owned
-
-public:
-   MFBilinearFormExtension(BilinearForm *form);
-
-   void Assemble();
-   void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void Update();
-};
-
 /// Class extending the MixedBilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class MixedBilinearFormExtension : public Operator
@@ -185,7 +151,7 @@ public:
    MixedBilinearFormExtension(MixedBilinearForm *form);
 
    virtual MemoryClass GetMemoryClass() const
-   { return Device::GetMemoryClass(); }
+   { return Device::GetDeviceMemoryClass(); }
 
    /// Get the finite element space prolongation matrix
    virtual const Operator *GetProlongation() const;
@@ -199,101 +165,70 @@ public:
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const;
 
+   /// Assemble at the level given for the BilinearFormExtension subclass
    virtual void Assemble() = 0;
-   virtual void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                              const Array<int> &test_tdof_list,
-                                              OperatorHandle &A) = 0;
-   virtual void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            Vector &x, Vector &b,
-                                            OperatorHandle &A, Vector &X, Vector &B) = 0;
 
-   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const = 0;
+   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const
+   {
+      MFEM_ABORT("AssembleDiagonal_ADAt not implemented for this assembly level!");
+   }
 
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled mixed bilinear forms
-class PAMixedBilinearFormExtension : public MixedBilinearFormExtension
+/// Data and methods for matrix-free mixed bilinear forms
+class MFMixedBilinearFormExtension : public MixedBilinearFormExtension
 {
 protected:
    const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localTrial, localTest, tempY;
-   const Operator *elem_restrict_trial; // Not owned
-   const Operator *elem_restrict_test;  // Not owned
-
-   /// Helper function to set up inputs/outputs for Mult or MultTranspose
-   void SetupMultInputs(const Operator *elem_restrict_x,
-                        const Vector &x, Vector &localX,
-                        const Operator *elem_restrict_y,
-                        Vector &y, Vector &localY, const double c) const;
+   mutable Vector local_trial, local_test, temp_trial, temp_test;
+   mutable Vector int_face_trial, int_face_test, int_face_y;
+   mutable Vector bdr_face_trial, bdr_face_test, bdr_face_y;
+   const ElementRestriction *elem_restrict_trial; // Not owned
+   const ElementRestriction *elem_restrict_test;  // Not owned
+   const FaceRestriction *int_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *int_face_restrict_lex_test;  // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_test;  // Not owned
 
 public:
-   PAMixedBilinearFormExtension(MixedBilinearForm *form);
+   MFMixedBilinearFormExtension(MixedBilinearForm *form);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-   /**
-      @brief Setup OperatorHandle A to contain constrained linear operator
-
-      OperatorHandle A contains matrix-free constrained operator formed for RAP
-      system where ess_tdof_list are in trial space and eliminated from
-      "columns" of A.
-   */
-   void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                      const Array<int> &test_tdof_list,
-                                      OperatorHandle &A);
-   /**
-      Setup OperatorHandle A to contain constrained linear operator and
-      eliminate columns corresponding to essential dofs from system,
-      updating RHS B vector with the results.
-   */
-   void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list,
-                                    Vector &x, Vector &b,
-                                    OperatorHandle &A, Vector &X, Vector &B);
-   /// y = A*x
    void Mult(const Vector &x, Vector &y) const;
-   /// y += c*A*x
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-   /// y = A^T*x
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
-   /// y += c*A^T*x
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-   /// Assemble the diagonal of ADA^T for a diagonal vector D.
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Update internals for when a new MixedBilinearForm is given to this class
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
+
+protected:
+   void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled mixed bilinear forms
+class PAMixedBilinearFormExtension : public MFMixedBilinearFormExtension
+{
+public:
+   PAMixedBilinearFormExtension(MixedBilinearForm *form);
 
-/**
-   @brief Partial assembly extension for DiscreteLinearOperator
+   void Assemble();
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
 
-   This acts very much like PAMixedBilinearFormExtension, but its
-   FormRectangularSystemOperator implementation emulates 'Set' rather than
-   'Add' in the assembly case.
-*/
+/// Data and methods for partially-assembled discrete linear operators
 class PADiscreteLinearOperatorExtension : public PAMixedBilinearFormExtension
 {
+private:
+   Vector test_multiplicity;
+
 public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void FormRectangularSystemOperator(const Array<int>&, const Array<int>&,
-                                      OperatorHandle& A);
-
-   const Operator * GetOutputRestrictionTranspose() const;
-
-private:
-   Vector test_multiplicity;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
 
 }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index 3eb8b704d..e6fc2a6ee 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -26,12 +26,6 @@ void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleNURBSPA(const FiniteElementSpace&)
-{
-   mfem_error ("BilinearFormIntegrator::AssembleNURBSPA(fes)\n"
-               "   is not implemented for this class.");
-}
-
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&,
                                         const FiniteElementSpace&)
 {
@@ -45,96 +39,120 @@ void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&)
               "   is not implemented for this class.");
 }
 
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes, fes)\n"
+              "   is not implemented for this class.");
+}
+
 void BilinearFormIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(fes)\n"
               "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA(Vector &)
+void BilinearFormIntegrator::AssembleDiagonalPA(Vector&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                        Vector &emat,
-                                        const bool add)
+void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector&, Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_int,
-                                                     Vector &ea_data_ext,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_bdr,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultTransposePA(const Vector&, Vector&) const
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&,
+                                        const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator:AddMultPA:(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes, fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultNURBSPA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AddMultNURBSPA(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposePA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes, fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void BilinearFormIntegrator::AssembleDiagonalMF(Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("BilinearFormIntegrator::AddMultMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposeMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultTransposeMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalMF(Vector &)
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        const FiniteElementSpace&,
+                                        Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+                                                     Vector&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
               "   is not implemented for this class.");
 }
 
@@ -154,13 +172,6 @@ void BilinearFormIntegrator::AssembleElementMatrix2(
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssemblePatchMatrix(
-   const int patch, const FiniteElementSpace &fes, SparseMatrix*& smat)
-{
-   mfem_error ("BilinearFormIntegrator::AssemblePatchMatrix(...)\n"
-               "   is not implemented for this class.");
-}
-
 void BilinearFormIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
@@ -216,30 +227,30 @@ void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void TransposeIntegrator::AssembleElementMatrix (
+void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleElementMatrix2 (
+void TransposeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix2 (test_fe, trial_fe, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleFaceMatrix (
+void TransposeIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleFaceMatrix (el1, el2, Trans, bfi_elmat);
+   bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
 void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
@@ -248,10 +259,10 @@ void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void LumpedIntegrator::AssembleElementMatrix (
+void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Lump();
 }
 
@@ -341,6 +352,15 @@ void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
    }
 }
 
+void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AssemblePA(trial_fes, test_fes);
+   }
+}
+
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
@@ -389,57 +409,63 @@ void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
    }
 }
 
-void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
+void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      integrators[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
-void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      integrators[i]->AssembleDiagonalMF(diag);
    }
 }
 
-void SumIntegrator::AssembleDiagonalMF(Vector &diag)
+void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      integrators[i]->AddMultTransposeMF(x, y);
    }
 }
 
-void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                               const bool add)
+void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat, add);
+      integrators[i]->AddMultMF(x, y);
+   }
+}
+
+void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AssembleEA(fes, emat);
    }
 }
 
 void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
-                                            Vector &ea_data_ext,
-                                            const bool add)
+                                            Vector &ea_data_ext)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes,ea_data_int,ea_data_ext,add);
+      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                            Vector &ea_data_bdr,
-                                            const bool add)
+                                            Vector &ea_data_bdr)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr, add);
+      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
@@ -667,15 +693,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          if (same_shapes)
          {
-            AddMult_a_AAt (w, test_shape, elmat);
+            AddMult_a_AAt(w, test_shape, elmat);
          }
          else
          {
-            AddMult_a_ABt (w, test_shape, trial_shape, elmat);
+            AddMult_a_ABt(w, test_shape, trial_shape, elmat);
          }
       }
    }
@@ -749,7 +775,7 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
       VQ->Eval(V, Trans, ip);
       V *= w;
 
-      if ( vdim == 2 && cross_2d )
+      if (vdim == 2 && cross_2d)
       {
          vtmp = V[0];
          V[0] = -V[1];
@@ -761,7 +787,6 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -818,19 +843,18 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(const FiniteElement
-                                                   &trial_fe,
-                                                   const FiniteElement &test_fe,
-                                                   ElementTransformation &Trans)
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans)
 {
    int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void DiffusionIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void DiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el, ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -867,19 +891,6 @@ void DiffusionIntegrator::AssembleElementMatrix
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
 
-   const NURBSFiniteElement *NURBSFE =
-      dynamic_cast<const NURBSFiniteElement *>(&el);
-
-   bool deleteRule = false;
-   if (NURBSFE && patchRules)
-   {
-      const int patch = NURBSFE->GetPatch();
-      const int* ijk = NURBSFE->GetIJK();
-      Array<const KnotVector*>& kv = NURBSFE->KnotVectors();
-      ir = &patchRules->GetElementRule(NURBSFE->GetElement(), patch, ijk, kv,
-                                       deleteRule);
-   }
-
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -914,11 +925,6 @@ void DiffusionIntegrator::AssembleElementMatrix
          AddMult_a_AAt(w, dshapedxt, elmat);
       }
    }
-
-   if (deleteRule)
-   {
-      delete ir;
-   }
 }
 
 void DiffusionIntegrator::AssembleElementMatrix2(
@@ -1087,10 +1093,14 @@ void DiffusionIntegrator::AssembleElementVector(
    }
 }
 
-void DiffusionIntegrator::ComputeElementFlux
-( const FiniteElement &el, ElementTransformation &Trans,
-  Vector &u, const FiniteElement &fluxelem, Vector &flux, bool with_coef,
-  const IntegrationRule *ir)
+void DiffusionIntegrator::ComputeElementFlux(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   Vector &u,
+   const FiniteElement &fluxelem,
+   Vector &flux,
+   bool with_coef,
+   const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1130,7 +1140,7 @@ void DiffusionIntegrator::ComputeElementFlux
       ir = &fluxelem.GetNodes();
    }
    fnd = ir->GetNPoints();
-   flux.SetSize( fnd * spaceDim );
+   flux.SetSize(fnd * spaceDim);
 
    for (int i = 0; i < fnd; i++)
    {
@@ -1138,7 +1148,7 @@ void DiffusionIntegrator::ComputeElementFlux
       el.CalcDShape(ip, dshape);
       dshape.MultTranspose(u, vec);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcInverse(Trans.Jacobian(), invdfdx);
       invdfdx.MultTranspose(vec, vecdxt);
 
@@ -1186,9 +1196,11 @@ void DiffusionIntegrator::ComputeElementFlux
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy
-( const FiniteElement &fluxelem, ElementTransformation &Trans,
-  Vector &flux, Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(
+   const FiniteElement &fluxelem,
+   ElementTransformation &Trans,
+   Vector &flux,
+   Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1263,7 +1275,8 @@ double DiffusionIntegrator::ComputeFluxEnergy
 }
 
 const IntegrationRule &DiffusionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe)
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe)
 {
    int order;
    if (trial_fe.Space() == FunctionSpace::Pk)
@@ -1275,7 +1288,6 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
       // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
       order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
    }
-
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1283,10 +1295,10 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void MassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void MassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    // int dim = el.GetDim();
@@ -1295,8 +1307,8 @@ void MassIntegrator::AssembleElementMatrix
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   elmat.SetSize(nd);
    shape.SetSize(nd);
+   elmat.SetSize(nd);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
 
@@ -1304,14 +1316,14 @@ void MassIntegrator::AssembleElementMatrix
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcPhysShape(Trans, shape);
 
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1343,11 +1355,11 @@ void MassIntegrator::AssembleElementMatrix2(
       trial_fe.CalcShape(ip, shape);
       test_fe.CalcShape(ip, te_shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       te_shape *= w;
@@ -1369,7 +1381,6 @@ const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void BoundaryMassIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
@@ -1409,7 +1420,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1463,9 +1474,18 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &fe,
+   ElementTransformation &Trans)
+{
+   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
+   return IntRules.Get(fe.GetGeomType(), order);
+}
 
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1516,24 +1536,10 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
-
-   return IntRules.Get(trial_fe.GetGeomType(), order);
-}
-
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &el, ElementTransformation &Trans)
-{
-   return GetRule(el,el,Trans);
-}
-
-void VectorMassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void VectorMassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1576,7 +1582,7 @@ void VectorMassIntegrator::AssembleElementMatrix
       const IntegrationPoint &ip = ir->IntPoint(s);
       el.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       norm = ip.weight * Trans.Weight();
 
       MultVVt(shape, partelmat);
@@ -1833,7 +1839,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
                "At least one of the finite elements must be in H(Curl)");
 
    int curl_nd, vec_nd;
-   if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+   if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
    {
       curl_nd = trial_nd;
       vec_nd  = test_nd;
@@ -1872,7 +1878,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       Trans.SetIntPoint(&ip);
       if (dim == 3)
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial);
             test_fe.CalcVShape(Trans, vshapeTest);
@@ -1886,7 +1892,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       else
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial_dFT);
             test_fe.CalcShape(ip, shapeTest);
@@ -1906,7 +1912,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       // Note: shapeTest points to the same data as vshapeTest
       vshapeTest *= w;
-      if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+      if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
       {
          AddMultABt(vshapeTest, curlshapeTrial_dFT, elmat);
       }
@@ -1917,7 +1923,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-void DerivativeIntegrator::AssembleElementMatrix2 (
+void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
    ElementTransformation &Trans,
@@ -1931,12 +1937,12 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
    int i, l;
    double det;
 
-   elmat.SetSize (test_nd,trial_nd);
-   dshape.SetSize (trial_nd,dim);
+   elmat.SetSize(test_nd,trial_nd);
+   dshape.SetSize(trial_nd,dim);
    dshapedxt.SetSize(trial_nd, spaceDim);
    dshapedxi.SetSize(trial_nd);
    invdfdx.SetSize(dim, spaceDim);
-   shape.SetSize (test_nd);
+   shape.SetSize(test_nd);
 
    const IntegrationRule *ir = IntRule;
    if (ir == NULL)
@@ -1968,10 +1974,10 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
 
       trial_fe.CalcDShape(ip, dshape);
 
-      Trans.SetIntPoint (&ip);
-      CalcInverse (Trans.Jacobian(), invdfdx);
+      Trans.SetIntPoint(&ip);
+      CalcInverse(Trans.Jacobian(), invdfdx);
       det = Trans.Weight();
-      Mult (dshape, invdfdx, dshapedxt);
+      Mult(dshape, invdfdx, dshapedxt);
 
       test_fe.CalcShape(ip, shape);
 
@@ -1981,13 +1987,14 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
       }
 
       shape *= Q->Eval(Trans,ip) * det * ip.weight;
-      AddMultVWt (shape, dshapedxi, elmat);
+      AddMultVWt(shape, dshapedxi, elmat);
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void CurlCurlIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -2002,6 +2009,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
+
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
@@ -2026,7 +2034,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       w = ip.weight * Trans.Weight();
       el.CalcPhysCurlShape(Trans, curlshape_dFt);
@@ -2133,10 +2141,10 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    }
 }
 
-void CurlCurlIntegrator
-::ComputeElementFlux(const FiniteElement &el, ElementTransformation &Trans,
-                     Vector &u, const FiniteElement &fluxelem, Vector &flux,
-                     bool with_coef, const IntegrationRule *ir)
+void CurlCurlIntegrator::ComputeElementFlux(
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
 #ifdef MFEM_THREAD_SAFE
    DenseMatrix projcurl;
@@ -2258,7 +2266,9 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
 }
 
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2448,7 +2458,6 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2486,7 +2495,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcVShape(Trans, trial_vshape);
 
@@ -2508,9 +2517,9 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval (Trans, ip);
          }
-         AddMult_a_AAt (w, trial_vshape, elmat);
+         AddMult_a_AAt(w, trial_vshape, elmat);
       }
    }
 }
@@ -2555,7 +2564,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcShape(ip, shape);
@@ -2641,7 +2650,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
       DenseMatrix tmp(test_vshape.Height(), K.Width());
 
-      elmat.SetSize (test_dof, trial_dof);
+      elmat.SetSize(test_dof, trial_dof);
 
       const IntegrationRule *ir = IntRule;
       if (ir == NULL)
@@ -2655,7 +2664,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcVShape(Trans, test_vshape);
@@ -2678,7 +2687,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q -> Eval (Trans, ip);
+               w *= Q->Eval (Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2702,42 +2711,42 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    int test_dof = test_fe.GetDof();
    double c;
 
-   dshape.SetSize (trial_dof, dim);
-   gshape.SetSize (trial_dof, dim);
-   Jadj.SetSize (dim);
-   divshape.SetSize (dim*trial_dof);
-   shape.SetSize (test_dof);
+   dshape.SetSize(trial_dof, dim);
+   gshape.SetSize(trial_dof, dim);
+   Jadj.SetSize(dim);
+   divshape.SetSize(dim*trial_dof);
+   shape.SetSize(test_dof);
 
-   elmat.SetSize (test_dof, dim*trial_dof);
+   elmat.SetSize(test_dof, dim*trial_dof);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
                                                             Trans);
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      trial_fe.CalcDShape (ip, dshape);
-      test_fe.CalcShape (ip, shape);
+      trial_fe.CalcDShape(ip, dshape);
+      test_fe.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcAdjugate(Trans.Jacobian(), Jadj);
 
-      Mult (dshape, Jadj, gshape);
+      Mult(dshape, Jadj, gshape);
 
       gshape.GradToDiv (divshape);
 
       c = ip.weight;
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
       shape *= c;
-      AddMultVWt (shape, divshape, elmat);
+      AddMultVWt(shape, divshape, elmat);
    }
 }
 
@@ -2750,7 +2759,6 @@ const IntegrationRule &VectorDivergenceIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void DivDivIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2774,23 +2782,22 @@ void DivDivIntegrator::AssembleElementMatrix(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      el.CalcDivShape (ip, divshape);
+      el.CalcDivShape(ip, divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
-      AddMult_a_VVt (c, divshape, elmat);
+      AddMult_a_VVt(c, divshape, elmat);
    }
 }
 
@@ -2822,20 +2829,19 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
       trial_fe.CalcDivShape(ip,divshape);
       test_fe.CalcDivShape(ip,te_divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       te_divshape *= c;
@@ -2879,7 +2885,7 @@ void VectorDiffusionIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
 
       const IntegrationPoint &ip = ir->IntPoint(i);
@@ -3015,7 +3021,6 @@ void VectorDiffusionIntegrator::AssembleElementVector(
    }
 }
 
-
 void ElasticityIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -3046,7 +3051,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
@@ -3081,7 +3086,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
             for (int k = 0; k < dof; k++)
                for (int l = 0; l < dof; l++)
                {
-                  elmat (dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
+                  elmat(dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
                }
          }
          for (int ii = 0; ii < dim; ii++)
@@ -3403,7 +3408,6 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-
 const IntegrationRule &DGTraceIntegrator::GetRule(
    Geometry::Type geom, int order, FaceElementTransformations &T)
 {
@@ -3646,8 +3650,6 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
    }
 }
 
-
-// static method
 void DGElasticityIntegrator::AssembleBlock(
    const int dim, const int row_ndofs, const int col_ndofs,
    const int row_offset, const int col_offset,
@@ -3870,7 +3872,6 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-
 void TraceJumpIntegrator::AssembleFaceMatrix(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
@@ -4286,7 +4287,6 @@ void NormalInterpolator::AssembleElementMatrix2(
    }
 }
 
-
 namespace internal
 {
 
@@ -4327,7 +4327,6 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4362,7 +4361,6 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4400,7 +4398,6 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4496,7 +4493,6 @@ VectorCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 namespace internal
 {
 
@@ -4526,8 +4522,7 @@ struct VDotVShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-VectorInnerProductInterpolator::AssembleElementMatrix2(
+void VectorInnerProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 3d6fffa64..209898714 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -27,7 +27,6 @@ constexpr int HCURL_MAX_Q1D = 5;
 #else
 constexpr int HCURL_MAX_Q1D = 6;
 #endif
-
 constexpr int HDIV_MAX_D1D = 5;
 constexpr int HDIV_MAX_Q1D = 6;
 
@@ -36,7 +35,7 @@ class BilinearFormIntegrator : public NonlinearFormIntegrator
 {
 protected:
    BilinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : NonlinearFormIntegrator(ir) { }
+      : NonlinearFormIntegrator(ir) {}
 
 public:
    // TODO: add support for other assembly levels (in addition to PA) and their
@@ -51,8 +50,6 @@ public:
    // make sense for the action of the nonlinear operator (but they all make
    // sense for its Jacobian).
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA() and AddMultTransposePA(). */
@@ -61,12 +58,10 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
-   /// Method defining partial assembly on NURBS patches.
-   /** The result of the partial assembly is stored internally so that it can be
-       used later in the method AddMultNURBSPA(). */
-   virtual void AssembleNURBSPA(const FiniteElementSpace &fes);
-
    virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
@@ -87,9 +82,6 @@ public:
        called. */
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   /// Method for partially assembled action on NURBS patches.
-   virtual void AddMultNURBSPA(const Vector&x, Vector&y) const;
-
    /// Method for partially assembled transposed action.
    /** Perform the transpose action of integrator on the input @a x and add the
        result to the output @a y. Both @a x and @a y are E-vectors, i.e. they
@@ -99,20 +91,21 @@ public:
        called. */
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   /// Method defining element assembly.
-   /** The result of the element assembly is added to the @a emat Vector if
-       @a add is true. Otherwise, if @a add is false, we set @a emat. */
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add = true);
-   /** Used with BilinearFormIntegrators that have different spaces. */
-   // virtual void AssembleEA(const FiniteElementSpace &trial_fes,
-   //                         const FiniteElementSpace &test_fes,
-   //                         Vector &emat);
-
    /// Method defining matrix-free assembly.
    /** The result of fully matrix-free assembly is stored internally so that it
        can be used later in the methods AddMultMF() and AddMultTransposeMF(). */
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   /// Assemble diagonal and add it to Vector @a diag.
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    /** Perform the action of integrator on the input @a x and add the result to
        the output @a y. Both @a x and @a y are E-vectors, i.e. they represent
@@ -130,17 +123,20 @@ public:
        called. */
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   /// Assemble diagonal and add it to Vector @a diag.
-   virtual void AssembleDiagonalMF(Vector &diag);
+   /// Method defining element assembly.
+   /** The result of the element assembly is added to the @a emat Vector. */
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleEA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add = true);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add = true);
+                                        Vector &ea_data_bdr);
 
    /// Given a particular Finite Element computes the element matrix elmat.
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -156,13 +152,6 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   /** Given a particular NURBS patch, computes the patch matrix as a
-       SparseMatrix @a smat.
-    */
-   virtual void AssemblePatchMatrix(const int patch,
-                                    const FiniteElementSpace &fes,
-                                    SparseMatrix*& smat);
-
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -251,7 +240,7 @@ public:
                                    Vector &u,
                                    const FiniteElement &fluxelem,
                                    Vector &flux, bool with_coef = true,
-                                   const IntegrationRule *ir = NULL) { }
+                                   const IntegrationRule *ir = NULL) {}
 
    /** @brief Virtual method required for Zienkiewicz-Zhu type error estimators.
 
@@ -277,7 +266,7 @@ public:
                                     Vector &flux, Vector *d_energy = NULL)
    { return 0.0; }
 
-   virtual ~BilinearFormIntegrator() { }
+   virtual ~BilinearFormIntegrator() {}
 };
 
 /** Wraps a given @a BilinearFormIntegrator and transposes the resulting element
@@ -285,13 +274,12 @@ public:
 class TransposeIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
-
    DenseMatrix bfi_elmat;
 
 public:
-   TransposeIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -311,17 +299,24 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssemblePA(const FiniteElementSpace& fes)
+   virtual void AssemblePA(const FiniteElementSpace &fes)
    {
       bfi->AssemblePA(fes);
    }
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes)
    {
-      bfi->AssemblePA(test_fes, trial_fes); // Reverse test and trial
+      bfi->AssemblePA(trial_fes, test_fes);
+   }
+
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes)
+   {
+      bfi->AssemblePABoundary(fes);
+   }
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes)
+   {
+      bfi->AssemblePABoundary(trial_fes, test_fes);
    }
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes)
@@ -339,22 +334,20 @@ public:
       bfi->AddMultPA(x, y);
    }
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const
+   virtual void AddMultPA(const Vector &x, Vector &y) const
    {
       bfi->AddMultTransposePA(x, y);
    }
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~TransposeIntegrator() { if (own_bfi) { delete bfi; } }
 };
@@ -362,11 +355,11 @@ public:
 class LumpedIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
 
 public:
-   LumpedIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -382,11 +375,11 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrator;
+   bool own_integrator;
    BilinearFormIntegrator *integrator;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, int own_integ = 1)
+   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
    { integrator = integ; own_integrator = own_integ; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -402,12 +395,12 @@ public:
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrators;
+   bool own_integrators;
    mutable DenseMatrix elem_mat;
    Array<BilinearFormIntegrator*> integrators;
 
 public:
-   SumIntegrator(int own_integs = 1) { own_integrators = own_integs; }
+   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
 
@@ -434,8 +427,9 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace& fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
@@ -445,27 +439,27 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalMF(Vector &diag);
-
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~SumIntegrator();
 };
@@ -475,7 +469,6 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -497,44 +490,39 @@ protected:
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
    Coefficient *Q;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector test_shape;
-   Vector trial_shape;
+   Vector test_shape, trial_shape;
 #endif
-
 };
 
 /** An abstract class for integrating the inner product of two vector basis
@@ -542,7 +530,6 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -571,39 +558,38 @@ protected:
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
    int space_dim;
@@ -613,16 +599,10 @@ protected:
    MatrixCoefficient *MQ;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
-   Vector D;
-   DenseMatrix M;
-   DenseMatrix test_shape;
-   DenseMatrix trial_shape;
-   DenseMatrix shape_tmp;
+   Vector V, D;
+   DenseMatrix M, test_shape, trial_shape, shape_tmp;
 #endif
-
 };
 
 /** An abstract class for integrating the product of a scalar basis function and
@@ -631,7 +611,6 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -648,14 +627,13 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
-
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -666,9 +644,9 @@ protected:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
-      if ( transpose )
+      if (transpose)
       {
          return "MixedScalarVectorIntegrator:  "
                 "Trial space must be a vector field "
@@ -682,23 +660,22 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape_)
+                                  DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape_)
+                                 Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
    VectorCoefficient *VQ;
@@ -707,14 +684,12 @@ protected:
    bool cross_2d;  // In 2D use a cross product rather than a dot product
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
    Vector V;
    DenseMatrix vshape;
    Vector      shape;
    Vector      vshape_tmp;
 #endif
-
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q u, v) in either 1D, 2D,
@@ -749,24 +724,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -784,15 +759,15 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -800,9 +775,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -822,28 +797,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -858,14 +833,14 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -874,14 +849,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -897,28 +872,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   virtual void CalcTestShape(const FiniteElement & test_fe,
+   virtual void CalcTestShape(const FiniteElement &test_fe,
                               ElementTransformation &Trans,
-                              Vector & shape)
+                              Vector &shape)
    {
       test_fe.CalcPhysDivShape(Trans, shape);
       shape *= -1.0;
@@ -937,29 +912,29 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -969,7 +944,8 @@ protected:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    // PA extension
@@ -993,24 +969,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1051,14 +1027,14 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1076,15 +1052,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1093,14 +1069,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1113,8 +1089,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1122,19 +1098,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1153,8 +1129,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1162,15 +1138,15 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    {
       // Same as DiffusionIntegrator
@@ -1179,20 +1155,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1205,8 +1181,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1214,27 +1190,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1253,8 +1229,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1263,27 +1239,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1296,8 +1272,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && trial_fe.GetVDim() == 3 &&
               test_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
@@ -1307,27 +1283,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1340,8 +1316,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1350,27 +1326,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1383,8 +1359,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
@@ -1393,27 +1369,27 @@ public:
               test_fe.GetDerivType() == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1427,8 +1403,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1436,19 +1412,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1462,8 +1438,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1471,16 +1447,16 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1497,8 +1473,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1506,24 +1482,24 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1537,8 +1513,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1546,19 +1522,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1572,8 +1548,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1581,16 +1557,16 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1606,8 +1582,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1615,19 +1591,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1640,15 +1616,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1665,24 +1641,24 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1695,27 +1671,27 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1728,8 +1704,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
@@ -1737,24 +1713,24 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1767,8 +1743,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
@@ -1777,24 +1753,24 @@ public:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1807,27 +1783,27 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1848,40 +1824,40 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
-private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1906,40 +1882,41 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -1965,40 +1942,41 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -2024,26 +2002,26 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2066,6 +2044,7 @@ private:
    DenseMatrix gshape;
    DenseMatrix Jadj;
    DenseMatrix elmat_comp;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2076,13 +2055,13 @@ private:
 public:
    GradientIntegrator() :
       Q{NULL}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient *q_) :
       Q{q_}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient &q) :
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2094,6 +2073,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2119,94 +2099,41 @@ private:
 #endif
 
    // PA extension
-   const FiniteElementSpace *fespace;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
    int dim, ne, dofs1D, quad1D;
    Vector pa_data;
    bool symmetric = true; ///< False if using a nonsymmetric matrix coefficient
 
-   // Data for NURBS patch PA
-
-   // Type for a variable-row-length 2D array, used for data related to 1D
-   // quadrature rules in each dimension.
-   typedef std::vector<std::vector<int>> IntArrayVar2D;
-
-   int numPatches = 0;
-   static constexpr int numTypes = 2;  // Number of rule types
-
-   // In the case integrationMode == Mode::PATCHWISE_REDUCED, an approximate
-   // integration rule with sparse nonzero weights is computed by NNLSSolver,
-   // for each 1D basis function on each patch, in each spatial dimension. For a
-   // fixed 1D basis function b_i with DOF index i, in the tensor product basis
-   // of patch p, the prescribed exact 1D rule is of the form
-   // \sum_k a_{i,j,k} w_k for some integration points indexed by k, with
-   // weights w_k and coefficients a_{i,j,k} depending on Q(x), an element
-   // transformation, b_i, and b_j, for all 1D basis functions b_j whose support
-   // overlaps that of b_i. Define the constraint matrix G = [g_{j,k}] with
-   // g_{j,k} = a_{i,j,k} and the vector of exact weights w = [w_k]. A reduced
-   // rule should have different weights w_r, many of them zero, and should
-   // approximately satisfy Gw_r = Gw. A sparse approximate solution to this
-   // underdetermined system is computed by NNLSSolver, and its data is stored
-   // in the following members.
-
-   // For each patch p, spatial dimension d (total dim), and rule type t (total
-   // numTypes), an std::vector<Vector> of reduced quadrature weights for all
-   // basis functions is stored in reducedWeights[t + numTypes * (d + dim * p)],
-   // reshaped as rw(t,d,p). Note that nd may vary with respect to the patch and
-   // spatial dimension. Array reducedIDs is treated similarly.
-   std::vector<std::vector<Vector>> reducedWeights;
-   std::vector<IntArrayVar2D> reducedIDs;
-   std::vector<Array<int>> pQ1D, pD1D;
-   std::vector<std::vector<Array2D<double>>> pB, pG;
-   std::vector<IntArrayVar2D> pminD, pmaxD, pminQ, pmaxQ, pminDD, pmaxDD;
-
-   std::vector<Array<const IntegrationRule*>> pir1d;
-
-   void SetupPatchPA(const int patch, Mesh *mesh, bool unitWeights=false);
-
-   void SetupPatchBasisData(Mesh *mesh, unsigned int patch);
-
-   /** Called by AssemblePatchMatrix for sparse matrix assembly on a NURBS patch
-    with full 1D quadrature rules. */
-   void AssemblePatchMatrix_fullQuadrature(const int patch,
-                                           const FiniteElementSpace &fes,
-                                           SparseMatrix*& smat);
-
-   /** Called by AssemblePatchMatrix for sparse matrix assembly on a NURBS patch
-    with reduced 1D quadrature rules. */
-   void AssemblePatchMatrix_reducedQuadrature(const int patch,
-                                              const FiniteElementSpace &fes,
-                                              SparseMatrix*& smat);
-
 public:
    /// Construct a diffusion integrator with coefficient Q = 1
    DiffusionIntegrator(const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a scalar coefficient q
    DiffusionIntegrator(Coefficient &q, const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a vector coefficient q
    DiffusionIntegrator(VectorCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a matrix coefficient q
    DiffusionIntegrator(MatrixCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /** Given a trial and test Finite Element computes the element stiffness
        matrix elmat. */
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
@@ -2214,14 +2141,6 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   virtual void AssemblePatchMatrix(const int patch,
-                                    const FiniteElementSpace &fes,
-                                    SparseMatrix*& smat);
-
-   virtual void AssembleNURBSPA(const FiniteElementSpace &fes);
-
-   void AssemblePatchPA(const int patch, const FiniteElementSpace &fes);
-
    /// Perform the local action of the BilinearFormIntegrator
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &Tr,
@@ -2238,27 +2157,23 @@ public:
                                     Vector &flux, Vector *d_energy = NULL);
 
    using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
-
    virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultNURBSPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   void AddMultPatchPA(const int patch, const Vector &x, Vector &y) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe);
@@ -2271,14 +2186,16 @@ public:
 /** Class for local mass matrix assembling a(u,v) := (Q u, v) */
 class MassIntegrator: public BilinearFormIntegrator
 {
+private:
    friend class DGMassInverse;
+
 protected:
 #ifndef MFEM_THREAD_SAFE
    Vector shape, te_shape;
 #endif
    Coefficient *Q;
+
    // PA extension
-   const FiniteElementSpace *fespace;
    Vector pa_data;
    const DofToQuad *maps;                 ///< Not owned
    const GeometricFactors *geom;          ///< Not owned
@@ -2287,42 +2204,44 @@ protected:
 
 public:
    MassIntegrator(const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a mass integrator with coefficient q
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
    virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
-
    virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe,
@@ -2337,7 +2256,7 @@ public:
 class BoundaryMassIntegrator : public MassIntegrator
 {
 public:
-   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) { }
+   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
 
@@ -2353,6 +2272,7 @@ class ConvectionIntegrator : public BilinearFormIntegrator
 protected:
    VectorCoefficient *Q;
    double alpha;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2369,34 +2289,30 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &,
-                                      ElementTransformation &,
-                                      DenseMatrix &);
+   virtual void AssembleElementMatrix(const FiniteElement &fes,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace&);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &el,
-                                         ElementTransformation &Trans);
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
+   static const IntegrationRule &GetRule(const FiniteElement &fe,
                                          ElementTransformation &Trans);
 
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
@@ -2410,7 +2326,7 @@ class ConservativeConvectionIntegrator : public TransposeIntegrator
 {
 public:
    ConservativeConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
-      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) { }
+      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) {}
 };
 
 /// alpha (q . grad u, v) using the "group" FE discretization
@@ -2427,6 +2343,7 @@ private:
 public:
    GroupConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -2448,6 +2365,7 @@ protected:
    Coefficient *Q;
    VectorCoefficient *VQ;
    MatrixCoefficient *MQ;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2457,21 +2375,21 @@ protected:
 public:
    /// Construct an integrator with coefficient 1.0
    VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
    VectorMassIntegrator(Coefficient &q, int qo = 0)
-      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) {}
    VectorMassIntegrator(Coefficient &q, const IntegrationRule *ir)
       : BilinearFormIntegrator(ir), vdim(-1), Q_order(0), Q(&q), VQ(NULL),
-        MQ(NULL) { }
+        MQ(NULL) {}
    /// Construct an integrator with diagonal coefficient q
    VectorMassIntegrator(VectorCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) {}
    /// Construct an integrator with matrix coefficient q
    VectorMassIntegrator(MatrixCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) {}
 
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
@@ -2479,21 +2397,29 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
-
 /** Class for integrating (div u, p) where u is a vector field given by
     VectorFiniteElement through Piola transformation (for RT elements); p is
     scalar function given by FiniteElement through standard transformation.
@@ -2507,13 +2433,6 @@ class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
@@ -2529,17 +2448,26 @@ private:
 public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
    virtual void AssembleDiagonalPA_ADAt(const Vector &D, Vector &diag);
-};
 
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+};
 
 /** Integrator for `(-Q u, grad v)` for Nedelec (`u`) and H1 (`v`) elements.
     This is equivalent to a weak divergence of the Nedelec basis functions. */
@@ -2559,9 +2487,11 @@ private:
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2585,9 +2515,11 @@ private:
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2606,11 +2538,13 @@ private:
    Vector shape, dshapedxi;
 
 public:
-   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) { }
+   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
    { AssembleElementMatrix2(el,el,Trans,elmat); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2646,12 +2580,12 @@ public:
    CurlCurlIntegrator() { Q = NULL; DQ = NULL; MQ = NULL; }
    /// Construct a bilinear form integrator for Nedelec elements
    CurlCurlIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) {}
    CurlCurlIntegrator(DiagonalMatrixCoefficient &dq,
                       const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) {}
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
@@ -2676,8 +2610,10 @@ public:
 
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2697,7 +2633,7 @@ protected:
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
 
-   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) { }
+   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2728,9 +2664,9 @@ private:
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
 public:
-   MixedCurlIntegrator() : Q{NULL} { }
-   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} { }
-   MixedCurlIntegrator(Coefficient &q) :  Q{&q} { }
+   MixedCurlIntegrator() : Q{NULL} {}
+   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
+   MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2784,18 +2720,21 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes) { AssemblePA(fes, fes); }
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2813,6 +2752,7 @@ private:
    DenseMatrix dshape;
    DenseMatrix gshape;
    DenseMatrix Jadj;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2826,10 +2766,10 @@ public:
    {  }
    VectorDivergenceIntegrator(Coefficient *q_) :
       Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
    VectorDivergenceIntegrator(Coefficient &q) :
       Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2841,6 +2781,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2854,11 +2795,6 @@ class DivDivIntegrator: public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, te_divshape;
@@ -2874,7 +2810,7 @@ private:
 public:
    DivDivIntegrator() { Q = NULL; }
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q) { }
+      BilinearFormIntegrator(ir), Q(&q) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -2885,6 +2821,13 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2921,7 +2864,7 @@ private:
    Vector vcoeff;
 
 public:
-   VectorDiffusionIntegrator() { }
+   VectorDiffusionIntegrator() {}
 
    /** \brief Integrator with unit coefficient for caller-specified vector
        dimension.
@@ -2929,13 +2872,13 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) { }
+      : vdim(vector_dimension) {}
 
    VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) { }
+      : Q(&q) {}
 
    VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) { }
+      : BilinearFormIntegrator(ir), Q(&q) {}
 
    /** \brief Integrator with scalar coefficient for caller-specified vector
        dimension.
@@ -2946,7 +2889,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) { }
+      : Q(&q), vdim(vector_dimension) {}
 
    /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2958,7 +2901,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) { }
+      : VQ(&vq), vdim(vq.GetVDim()) {}
 
    /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2970,21 +2913,30 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) { }
+      : MQ(&mq), vdim(mq.GetVDim()) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &Tr,
                                       const Vector &elfun, Vector &elvect);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
@@ -3079,6 +3031,7 @@ protected:
    Coefficient *rho;
    VectorCoefficient *u;
    double alpha, beta;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;             ///< Not owned
@@ -3107,24 +3060,20 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    static const IntegrationRule &GetRule(Geometry::Type geom, int order,
                                          FaceElementTransformations &T);
@@ -3147,14 +3096,14 @@ class NonconservativeDGTraceIntegrator : public TransposeIntegrator
 {
 public:
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) {}
 
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) {}
 
    NonconservativeDGTraceIntegrator(Coefficient &rho, VectorCoefficient &u,
                                     double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) {}
 };
 
 /** Integrator for the DG form:
@@ -3182,11 +3131,12 @@ protected:
 
 public:
    DGDiffusionIntegrator(const double s, const double k)
-      : Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(Coefficient &q, const double s, const double k)
-      : Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
-      : Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -3318,11 +3268,11 @@ class DGElasticityIntegrator : public BilinearFormIntegrator
 {
 public:
    DGElasticityIntegrator(double alpha_, double kappa_)
-      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) { }
+      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) {}
 
    DGElasticityIntegrator(Coefficient &lambda_, Coefficient &mu_,
                           double alpha_, double kappa_)
-      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
@@ -3373,7 +3323,8 @@ private:
    Vector face_shape, shape1, shape2;
 
 public:
-   TraceJumpIntegrator() { }
+   TraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3392,7 +3343,8 @@ private:
    DenseMatrix shape1, shape2;
 
 public:
-   NormalTraceJumpIntegrator() { }
+   NormalTraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3484,8 +3436,7 @@ public:
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator { };
-
+class DiscreteInterpolator : public BilinearFormIntegrator {};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3493,7 +3444,7 @@ class DiscreteInterpolator : public BilinearFormIntegrator { };
 class GradientInterpolator : public DiscreteInterpolator
 {
 public:
-   GradientInterpolator() : dofquad_fe(NULL) { }
+   GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
@@ -3502,17 +3453,17 @@ public:
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   using BilinearFormIntegrator::AssemblePA;
-
    /** @brief Setup method for PA data.
 
        @param[in] trial_fes   H1 Lagrange space
        @param[in] test_fes    H(curl) Nedelec space
     */
+   using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 private:
@@ -3525,7 +3476,6 @@ private:
    int dim, ne, o_dofs1D, c_dofs1D;
 };
 
-
 /** Class for constructing the identity map as a DiscreteLinearOperator. This
     is the discrete embedding matrix when the domain space is a subspace of
     the range space. Otherwise, a dof projection matrix is constructed. */
@@ -3541,11 +3491,11 @@ public:
    { ran_fe.Project(dom_fe, Trans, elmat); }
 
    using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual ~IdentityInterpolator() { delete dofquad_fe; }
@@ -3561,7 +3511,6 @@ private:
    Vector pa_data;
 };
 
-
 /** Class for constructing the (local) discrete curl matrix which can be used
     as an integrator in a DiscreteLinearOperator object to assemble the global
     discrete curl matrix. */
@@ -3575,7 +3524,6 @@ public:
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
 };
 
-
 /** Class for constructing the (local) discrete divergence matrix which can
     be used as an integrator in a DiscreteLinearOperator object to assemble
     the global discrete divergence matrix.
@@ -3594,7 +3542,6 @@ public:
    { ran_fe.ProjectDiv(dom_fe, Trans, elmat); }
 };
 
-
 /** A trace face interpolator class for interpolating the normal component of
     the domain space, e.g. vector H1, into the range space, e.g. the trace of
     RT which uses FiniteElement::INTEGRAL map type. */
@@ -3613,7 +3560,7 @@ public:
 class ScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarProductInterpolator(Coefficient & sc) : Q(&sc) { }
+   ScalarProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3630,13 +3577,14 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient & sc)
-      : Q(&sc) { }
+   ScalarVectorProductInterpolator(Coefficient &sc)
+      : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    Coefficient *Q;
 };
@@ -3647,13 +3595,14 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorScalarProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3663,13 +3612,14 @@ protected:
 class ScalarCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   ScalarCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3680,13 +3630,14 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3697,12 +3648,13 @@ protected:
 class VectorInnerProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorInnerProductInterpolator(VectorCoefficient & vc) : VQ(&vc) { }
+   VectorInnerProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &rt_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index d122c2ab5..b65fd2197 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -217,7 +217,7 @@ const IntegrationRule & GetRule<ConvectionIntegrator>(
    const FiniteElement &test_fe,
    ElementTransformation &trans)
 {
-   return ConvectionIntegrator::GetRule(trial_fe, test_fe, trans);
+   return ConvectionIntegrator::GetRule(trial_fe, trans);
 }
 
 template <>
diff --git a/fem/fe/fe_nurbs.hpp b/fem/fe/fe_nurbs.hpp
index d919dcbcb..f65d688af 100644
--- a/fem/fe/fe_nurbs.hpp
+++ b/fem/fe/fe_nurbs.hpp
@@ -56,10 +56,6 @@ public:
    Vector              &Weights    ()         const { return weights; }
    /// Update the NURBSFiniteElement according to the currently set knot vectors
    virtual void         SetOrder   ()         const { }
-
-   /// Returns the indices (i,j) in 2D or (i,j,k) in 3D of this element in the
-   /// tensor product ordering of the patch.
-   const int* GetIJK() const { return ijk; }
 };
 
 
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index c141956b5..c898d4983 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -311,12 +311,6 @@ FiniteElementSpace::GetBdrElementVDofs(int i, Array<int> &vdofs) const
    }
 }
 
-void FiniteElementSpace::GetPatchVDofs(int i, Array<int> &vdofs) const
-{
-   GetPatchDofs(i, vdofs);
-   DofsToVDofs(vdofs);
-}
-
 void FiniteElementSpace::GetFaceVDofs(int i, Array<int> &vdofs) const
 {
    GetFaceDofs(i, vdofs);
@@ -453,15 +447,6 @@ void FiniteElementSpace::BuildFaceToDofTable() const
    face_dof = fc_dof;
 }
 
-void FiniteElementSpace::RebuildElementToDofTable()
-{
-   delete elem_dof;
-   delete elem_fos;
-   elem_dof = NULL;
-   elem_fos = NULL;
-   BuildElementToDofTable();
-}
-
 void FiniteElementSpace::ReorderElementToDofTable()
 {
    Array<int> dof_marker(ndofs);
@@ -1279,7 +1264,7 @@ int FiniteElementSpace::GetNConformingDofs() const
    return P ? (P->Width() / vdim) : ndofs;
 }
 
-const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
+const ElementRestriction *FiniteElementSpace::GetElementRestriction(
    ElementDofOrdering e_ordering) const
 {
    // Check if we have a discontinuous space using the FE collection:
@@ -1294,22 +1279,22 @@ const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
          // The output E-vector layout is: ND x VDIM x NE.
          L2E_nat.Reset(new L2ElementRestriction(*this));
       }
-      return L2E_nat.Is<ElementRestrictionOperator>();
+      return L2E_nat.Is<ElementRestriction>();
    }
    if (e_ordering == ElementDofOrdering::LEXICOGRAPHIC)
    {
       if (L2E_lex.Ptr() == NULL)
       {
-         L2E_lex.Reset(new ElementRestriction(*this, e_ordering));
+         L2E_lex.Reset(new ConformingElementRestriction(*this, e_ordering));
       }
-      return L2E_lex.Is<ElementRestrictionOperator>();
+      return L2E_lex.Is<ElementRestriction>();
    }
    // e_ordering == ElementDofOrdering::NATIVE
    if (L2E_nat.Ptr() == NULL)
    {
-      L2E_nat.Reset(new ElementRestriction(*this, e_ordering));
+      L2E_nat.Reset(new ConformingElementRestriction(*this, e_ordering));
    }
-   return L2E_nat.Is<ElementRestrictionOperator>();
+   return L2E_nat.Is<ElementRestriction>();
 }
 
 const FaceRestriction *FiniteElementSpace::GetFaceRestriction(
@@ -3114,13 +3099,6 @@ void FiniteElementSpace::GetEdgeInteriorDofs(int i, Array<int> &dofs) const
    }
 }
 
-void FiniteElementSpace::GetPatchDofs(int patch, Array<int> &dofs) const
-{
-   MFEM_ASSERT(NURBSext,
-               "FiniteElementSpace::GetPatchDofs needs a NURBSExtension");
-   NURBSext->GetPatchDofs(patch, dofs);
-}
-
 const FiniteElement *FiniteElementSpace::GetFE(int i) const
 {
    if (i < 0 || !mesh->GetNE()) { return NULL; }
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 23d737294..8b6834da8 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -429,8 +429,8 @@ protected:
                          Table *old_elem_fos/*takes ownership*/, int old_ndofs);
       RefinementOperator(const FiniteElementSpace *fespace,
                          const FiniteElementSpace *coarse_fes);
-      virtual void Mult(const Vector &x, Vector &y) const;
-      virtual void MultTranspose(const Vector &x, Vector &y) const;
+      void Mult(const Vector &x, Vector &y) const override;
+      void MultTranspose(const Vector &x, Vector &y) const override;
       virtual ~RefinementOperator();
    };
 
@@ -450,7 +450,7 @@ protected:
       DerefinementOperator(const FiniteElementSpace *f_fes,
                            const FiniteElementSpace *c_fes,
                            BilinearFormIntegrator *mass_integ);
-      virtual void Mult(const Vector &x, Vector &y) const;
+      void Mult(const Vector &x, Vector &y) const override;
       virtual ~DerefinementOperator();
    };
 
@@ -552,14 +552,14 @@ public:
    FiniteElementSpace& operator=(const FiniteElementSpace&) = delete;
 
    /// Returns the mesh
-   inline Mesh *GetMesh() const { return mesh; }
+   Mesh *GetMesh() const { return mesh; }
 
    const NURBSExtension *GetNURBSext() const { return NURBSext; }
    NURBSExtension *GetNURBSext() { return NURBSext; }
    NURBSExtension *StealNURBSext();
 
-   bool Conforming() const { return mesh->Conforming() && cP == NULL; }
-   bool Nonconforming() const { return mesh->Nonconforming() || cP != NULL; }
+   virtual bool Conforming() const { return mesh->Conforming() && cP == NULL; }
+   virtual bool Nonconforming() const { return mesh->Nonconforming() || cP != NULL; }
 
    /// Sets the order of the i'th finite element.
    /** By default, all elements are assumed to be of fec->GetOrder(). Once
@@ -593,18 +593,6 @@ public:
    virtual const Operator *GetProlongationMatrix() const
    { return GetConformingProlongation(); }
 
-   /// Return an operator that performs the transpose of GetRestrictionOperator
-   /** The returned operator is owned by the FiniteElementSpace. In serial this
-       is the same as GetProlongationMatrix() */
-   virtual const Operator *GetRestrictionTransposeOperator() const
-   { return GetConformingProlongation(); }
-
-   /// An abstract operator that performs the same action as GetRestrictionMatrix
-   /** In some cases this is an optimized matrix-free implementation. The
-       returned operator is owned by the FiniteElementSpace. */
-   virtual const Operator *GetRestrictionOperator() const
-   { return GetConformingRestriction(); }
-
    /// The returned SparseMatrix is owned by the FiniteElementSpace.
    virtual const SparseMatrix *GetRestrictionMatrix() const
    { return GetConformingRestriction(); }
@@ -630,7 +618,7 @@ public:
        L2ElementRestriction class.
 
        The returned Operator is owned by the FiniteElementSpace. */
-   const ElementRestrictionOperator *GetElementRestriction(
+   const ElementRestriction *GetElementRestriction(
       ElementDofOrdering e_ordering) const;
 
    /// Return an Operator that converts L-vectors to E-vectors on each face.
@@ -692,14 +680,14 @@ public:
    int GetFaceOrder(int face, int variant = 0) const;
 
    /// Returns vector dimension.
-   inline int GetVDim() const { return vdim; }
+   int GetVDim() const { return vdim; }
 
    /// @brief Returns number of degrees of freedom.
    /// This is the number of @ref ldof "Local Degrees of Freedom"
-   inline int GetNDofs() const { return ndofs; }
+   int GetNDofs() const { return ndofs; }
 
    /// @brief Return the number of vector dofs, i.e. GetNDofs() x GetVDim().
-   inline int GetVSize() const { return vdim * ndofs; }
+   int GetVSize() const { return vdim * ndofs; }
 
    /// @brief Return the number of vector true (conforming) dofs.
    virtual int GetTrueVSize() const { return GetConformingVSize(); }
@@ -711,7 +699,7 @@ public:
    int GetConformingVSize() const { return vdim * GetNConformingDofs(); }
 
    /// Return the ordering method.
-   inline Ordering::Type GetOrdering() const { return ordering; }
+   Ordering::Type GetOrdering() const { return ordering; }
 
    const FiniteElementCollection *FEColl() const { return fec; }
 
@@ -723,19 +711,19 @@ public:
    int GetNFDofs() const { return nfdofs; }
 
    /// Returns number of vertices in the mesh.
-   inline int GetNV() const { return mesh->GetNV(); }
+   int GetNV() const { return mesh->GetNV(); }
 
    /// Returns number of elements in the mesh.
-   inline int GetNE() const { return mesh->GetNE(); }
+   int GetNE() const { return mesh->GetNE(); }
 
    /// Returns number of faces (i.e. co-dimension 1 entities) in the mesh.
    /** The co-dimension 1 entities are those that have dimension 1 less than the
        mesh dimension, e.g. for a 2D mesh, the faces are the 1D entities, i.e.
        the edges. */
-   inline int GetNF() const { return mesh->GetNumFaces(); }
+   int GetNF() const { return mesh->GetNumFaces(); }
 
    /// Returns number of boundary elements in the mesh.
-   inline int GetNBE() const { return mesh->GetNBE(); }
+   int GetNBE() const { return mesh->GetNBE(); }
 
    /// Returns the number of faces according to the requested type.
    /** If type==Boundary returns only the "true" number of boundary faces
@@ -743,19 +731,19 @@ public:
        visualization for GLVis.
        Similarly, if type==Interior, the "fake" boundary faces associated to
        visualization are counted as interior faces. */
-   inline int GetNFbyType(FaceType type) const
+   int GetNFbyType(FaceType type) const
    { return mesh->GetNFbyType(type); }
 
    /// Returns the type of element i.
-   inline int GetElementType(int i) const
+   int GetElementType(int i) const
    { return mesh->GetElementType(i); }
 
    /// Returns the vertices of element i.
-   inline void GetElementVertices(int i, Array<int> &vertices) const
+   void GetElementVertices(int i, Array<int> &vertices) const
    { mesh->GetElementVertices(i, vertices); }
 
    /// Returns the type of boundary element i.
-   inline int GetBdrElementType(int i) const
+   int GetBdrElementType(int i) const
    { return mesh->GetBdrElementType(i); }
 
    /// Returns ElementTransformation for the @a i-th element.
@@ -903,11 +891,6 @@ public:
    void GetEdgeInteriorDofs(int i, Array<int> &dofs) const;
    ///@}
 
-   /** @brief Returns indices of degrees of freedom for NURBS patch index
-    @a patch. Cartesian ordering is used, for the tensor-product degrees of
-    freedom. */
-   void GetPatchDofs(int patch, Array<int> &dofs) const;
-
    /// @anchor dof2vdof @name DoF To VDoF Conversion methods
    /// These methods convert between local dof and local vector dof using the
    /// appropriate relationship based on the Ordering::Type defined in this
@@ -1000,15 +983,15 @@ public:
    static void AdjustVDofs(Array<int> &vdofs);
 
    /// Helper to encode a sign flip into a DOF index (for Hcurl/Hdiv shapes).
-   static inline int EncodeDof(int entity_base, int idx)
+   static int EncodeDof(int entity_base, int idx)
    { return (idx >= 0) ? (entity_base + idx) : (-1-(entity_base + (-1-idx))); }
 
    /// Helper to return the DOF associated with a sign encoded DOF
-   static inline int DecodeDof(int dof)
+   static int DecodeDof(int dof)
    { return (dof >= 0) ? dof : (-1 - dof); }
 
    /// Helper to determine the DOF and sign of a sign encoded DOF
-   static inline int DecodeDof(int dof, double& sign)
+   static int DecodeDof(int dof, double& sign)
    { return (dof >= 0) ? (sign = 1, dof) : (sign = -1, (-1 - dof)); }
 
    /// @anchor getvdof @name Local Vector DoF Access Members
@@ -1049,9 +1032,6 @@ public:
    /// @note The returned object should NOT be deleted by the caller.
    DofTransformation *GetBdrElementVDofs(int i, Array<int> &vdofs) const;
 
-   /// Returns indices of degrees of freedom in @a vdofs for NURBS patch @a i.
-   void GetPatchVDofs(int i, Array<int> &vdofs) const;
-
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
@@ -1089,9 +1069,6 @@ public:
    void GetEdgeInteriorVDofs(int i, Array<int> &vdofs) const;
    /// @}
 
-   /// (@deprecated) Use the Update() method if the space or mesh changed.
-   MFEM_DEPRECATED void RebuildElementToDofTable();
-
    /** @brief Reorder the scalar DOFs based on the element ordering.
 
        The new ordering is constructed as follows: 1) loop over all elements as
@@ -1251,6 +1228,9 @@ public:
        Safe to call multiple times, does nothing if space already up to date. */
    virtual void Update(bool want_transform = true);
 
+   /// Free the GridFunction update operator (if any), to save memory.
+   virtual void UpdatesFinished() { Th.Clear(); }
+
    /// Get the GridFunction update operator.
    const Operator* GetUpdateOperator() { Update(); return Th.Ptr(); }
 
@@ -1272,9 +1252,6 @@ public:
        @note This operation destroys the current update operator (if owned). */
    void SetUpdateOperatorType(Operator::Type tid) { Th.SetType(tid); }
 
-   /// Free the GridFunction update operator (if any), to save memory.
-   virtual void UpdatesFinished() { Th.Clear(); }
-
    /** Return update counter, similar to Mesh::GetSequence(). Used by
        GridFunction to check if it is up to date with the space. */
    long GetSequence() const { return sequence; }
@@ -1321,6 +1298,6 @@ inline bool UsesTensorBasis(const FiniteElementSpace& fes)
           dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0))!=nullptr;
 }
 
-}
+} // namespace mfem
 
 #endif
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index 928b4e2ad..cb58b6033 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -4583,4 +4583,4 @@ GridFunction *Extrude1DGridFunction(Mesh *mesh, Mesh *mesh2d,
    return sol2d;
 }
 
-}
+} // namespace mfem
diff --git a/fem/hybridization.cpp b/fem/hybridization.cpp
index f9d4699c2..10ba8b907 100644
--- a/fem/hybridization.cpp
+++ b/fem/hybridization.cpp
@@ -256,7 +256,7 @@ void Hybridization::Init(const Array<int> &ess_tdof_list)
    Array<int> free_tdof_marker;
 #ifdef MFEM_USE_MPI
    ParFiniteElementSpace *pfes = dynamic_cast<ParFiniteElementSpace*>(fes);
-   free_tdof_marker.SetSize(pfes ? pfes->TrueVSize() :
+   free_tdof_marker.SetSize(pfes ? pfes->GetTrueVSize() :
                             fes->GetConformingVSize());
 #else
    free_tdof_marker.SetSize(fes->GetConformingVSize());
diff --git a/fem/integ/bilininteg_convection_ea.cpp b/fem/integ/bilininteg_convection_ea.cpp
index b2dba388a..08422ce86 100644
--- a/fem/integ/bilininteg_convection_ea.cpp
+++ b/fem/integ/bilininteg_convection_ea.cpp
@@ -22,7 +22,6 @@ static void EAConvectionAssemble1D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -55,14 +54,7 @@ static void EAConvectionAssemble1D(const int NE,
             {
                val += r_Bj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -74,7 +66,6 @@ static void EAConvectionAssemble2D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -130,14 +121,7 @@ static void EAConvectionAssemble2D(const int NE,
                                * r_B[k1][j1]* r_B[k2][j2];
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -151,7 +135,6 @@ static void EAConvectionAssemble3D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -208,14 +191,7 @@ static void EAConvectionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -226,8 +202,7 @@ static void EAConvectionAssemble3D(const int NE,
 }
 
 void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                      Vector &ea_data,
-                                      const bool add)
+                                      Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -237,15 +212,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -253,15 +228,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -269,14 +244,14 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 7bfd65059..25928f002 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -112,26 +112,6 @@ static void PAConvectionSetup3D(const int NQ,
    });
 }
 
-static void PAConvectionSetup(const int dim,
-                              const int NQ,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const Vector &coeff,
-                              const double alpha,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAConvectionSetup"); }
-   if (dim == 2)
-   {
-      PAConvectionSetup2D(NQ, NE, W, J, coeff, alpha, op);
-   }
-   if (dim == 3)
-   {
-      PAConvectionSetup3D(NQ, NE, W, J, coeff, alpha, op);
-   }
-}
-
 void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -170,8 +150,20 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
-                     vel, alpha, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in ConvectionIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAConvectionSetup2D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAConvectionSetup3D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
 }
 
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
@@ -188,17 +180,17 @@ void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply2D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply2D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -307,17 +299,17 @@ void PAConvectionApply2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApply2D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApply2D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -435,17 +427,17 @@ void SmemPAConvectionApply2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply3D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply3D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -616,17 +608,17 @@ void PAConvectionApply3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApply3D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApply3D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -820,17 +812,17 @@ void SmemPAConvectionApply3D(const int ne,
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT2D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT2D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -935,17 +927,17 @@ void PAConvectionApplyT2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApplyT2D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApplyT2D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1058,17 +1050,17 @@ void SmemPAConvectionApplyT2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT3D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT3D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1234,17 +1226,17 @@ void PAConvectionApplyT3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApplyT3D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApplyT3D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1549,7 +1541,7 @@ void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("AddMultPA not yet implemented with libCEED for"
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
                  " ConvectionIntegrator.");
    }
    else
diff --git a/fem/integ/bilininteg_dgtrace_ea.cpp b/fem/integ/bilininteg_dgtrace_ea.cpp
index 695820489..602c266ab 100644
--- a/fem/integ/bilininteg_dgtrace_ea.cpp
+++ b/fem/integ/bilininteg_dgtrace_ea.cpp
@@ -20,8 +20,7 @@ static void EADGTraceAssemble1DInt(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_int,
-                                   Vector &eadata_ext,
-                                   const bool add)
+                                   Vector &eadata_ext)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_int = Reshape(eadata_int.ReadWrite(), 2, NF);
@@ -33,41 +32,23 @@ static void EADGTraceAssemble1DInt(const int NF,
       val_ext10 = D(1, 0, f);
       val_ext01 = D(0, 1, f);
       val_int1  = D(1, 1, f);
-      if (add)
-      {
-         A_int(0, f) += val_int0;
-         A_int(1, f) += val_int1;
-         A_ext(0, f) += val_ext01;
-         A_ext(1, f) += val_ext10;
-      }
-      else
-      {
-         A_int(0, f) = val_int0;
-         A_int(1, f) = val_int1;
-         A_ext(0, f) = val_ext01;
-         A_ext(1, f) = val_ext10;
-      }
+      A_int(0, f) += val_int0;
+      A_int(1, f) += val_int1;
+      A_ext(0, f) += val_ext01;
+      A_ext(1, f) += val_ext10;
    });
 }
 
 static void EADGTraceAssemble1DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
-                                   Vector &eadata_bdr,
-                                   const bool add)
+                                   Vector &eadata_bdr)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_bdr = Reshape(eadata_bdr.ReadWrite(), NF);
    mfem::forall(NF, [=] MFEM_HOST_DEVICE (int f)
    {
-      if (add)
-      {
-         A_bdr(f) += D(0, 0, f);
-      }
-      else
-      {
-         A_bdr(f) = D(0, 0, f);
-      }
+      A_bdr(f) += D(0, 0, f);
    });
 }
 
@@ -77,7 +58,6 @@ static void EADGTraceAssemble2DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -108,20 +88,10 @@ static void EADGTraceAssemble2DInt(const int NF,
                val_ext10 += B(k1,i1) * B(k1,j1) * D(k1, 1, 0, f);
                val_int1  += B(k1,i1) * B(k1,j1) * D(k1, 1, 1, f);
             }
-            if (add)
-            {
-               A_int(i1, j1, 0, f) += val_int0;
-               A_int(i1, j1, 1, f) += val_int1;
-               A_ext(i1, j1, 0, f) += val_ext01;
-               A_ext(i1, j1, 1, f) += val_ext10;
-            }
-            else
-            {
-               A_int(i1, j1, 0, f) = val_int0;
-               A_int(i1, j1, 1, f) = val_int1;
-               A_ext(i1, j1, 0, f) = val_ext01;
-               A_ext(i1, j1, 1, f) = val_ext10;
-            }
+            A_int(i1, j1, 0, f) += val_int0;
+            A_int(i1, j1, 1, f) += val_int1;
+            A_ext(i1, j1, 0, f) += val_ext01;
+            A_ext(i1, j1, 1, f) += val_ext10;
          }
       }
    });
@@ -132,7 +102,6 @@ static void EADGTraceAssemble2DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -156,14 +125,7 @@ static void EADGTraceAssemble2DBdr(const int NF,
             {
                val_bdr  += B(k1,i1) * B(k1,j1) * D(k1, 0, 0, f);
             }
-            if (add)
-            {
-               A_bdr(i1, j1, f) += val_bdr;
-            }
-            else
-            {
-               A_bdr(i1, j1, f) = val_bdr;
-            }
+            A_bdr(i1, j1, f) += val_bdr;
          }
       }
    });
@@ -175,7 +137,6 @@ static void EADGTraceAssemble3DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -246,20 +207,10 @@ static void EADGTraceAssemble3DInt(const int NF,
                                     * s_D[k1][k2][1][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) += val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) += val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
-                  }
-                  else
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) = val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) = val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) = val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) = val_ext10;
-                  }
+                  A_int(i1, i2, j1, j2, 0, f) += val_int0;
+                  A_int(i1, i2, j1, j2, 1, f) += val_int1;
+                  A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
+                  A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
                }
             }
          }
@@ -272,7 +223,6 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -330,14 +280,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    * s_D[k1][k2][0][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_bdr(i1, i2, j1, j2, f) += val_bdr;
-                  }
-                  else
-                  {
-                     A_bdr(i1, i2, j1, j2, f) = val_bdr;
-                  }
+                  A_bdr(i1, i2, j1, j2, f) += val_bdr;
                }
             }
          }
@@ -347,8 +290,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
 
 void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                                 Vector &ea_data_int,
-                                                Vector &ea_data_ext,
-                                                const bool add)
+                                                Vector &ea_data_ext)
 {
    SetupPA(fes, FaceType::Interior);
    nf = fes.GetNFbyType(FaceType::Interior);
@@ -356,7 +298,7 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext,add);
+      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext);
    }
    else if (dim == 2)
    {
@@ -364,31 +306,31 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x22:
             return EADGTraceAssemble2DInt<2,2>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x33:
             return EADGTraceAssemble2DInt<3,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x44:
             return EADGTraceAssemble2DInt<4,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x55:
             return EADGTraceAssemble2DInt<5,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x66:
             return EADGTraceAssemble2DInt<6,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x77:
             return EADGTraceAssemble2DInt<7,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x88:
             return EADGTraceAssemble2DInt<8,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x99:
             return EADGTraceAssemble2DInt<9,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble2DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
@@ -397,36 +339,35 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x23:
             return EADGTraceAssemble3DInt<2,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x34:
             return EADGTraceAssemble3DInt<3,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x45:
             return EADGTraceAssemble3DInt<4,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x56:
             return EADGTraceAssemble3DInt<5,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x67:
             return EADGTraceAssemble3DInt<6,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x78:
             return EADGTraceAssemble3DInt<7,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x89:
             return EADGTraceAssemble3DInt<8,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble3DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
 void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                Vector &ea_data_bdr,
-                                                const bool add)
+                                                Vector &ea_data_bdr)
 {
    SetupPA(fes, FaceType::Boundary);
    nf = fes.GetNFbyType(FaceType::Boundary);
@@ -434,37 +375,37 @@ void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr,add);
+      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr);
    }
    else if (dim == 2)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr);
+         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index 17dbc3994..f4b8d837c 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -110,30 +110,6 @@ static void PADGTraceSetup3D(const int Q1D,
    });
 }
 
-static void PADGTraceSetup(const int dim,
-                           const int D1D,
-                           const int Q1D,
-                           const int NF,
-                           const Array<double> &W,
-                           const Vector &det,
-                           const Vector &nor,
-                           const Vector &rho,
-                           const Vector &u,
-                           const double alpha,
-                           const double beta,
-                           Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADGTraceSetup"); }
-   if (dim == 2)
-   {
-      PADGTraceSetup2D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-   if (dim == 3)
-   {
-      PADGTraceSetup3D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-}
-
 void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -229,9 +205,21 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       }
       MFEM_VERIFY(f_ind==nf, "Incorrect number of faces.");
    }
-   PADGTraceSetup(dim, dofs1D, quad1D, nf, ir->GetWeights(),
-                  geom->detJ, geom->normal, r, vel,
-                  alpha, beta, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in DGTraceIntegrator::SetupPA");
+   }
+   else if (dim == 2)
+   {
+      PADGTraceSetup2D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADGTraceSetup3D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
 }
 
 void DGTraceIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace& fes)
@@ -245,15 +233,15 @@ void DGTraceIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace& fes)
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply2D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply2D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -336,15 +324,15 @@ void PADGTraceApply2D(const int NF,
 }
 
 // PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply3D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply3D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -481,15 +469,15 @@ void PADGTraceApply3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApply3D(const int NF,
-                          const Array<double> &b,
-                          const Array<double> &bt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApply3D(const int NF,
+                                 const Array<double> &b,
+                                 const Array<double> &bt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -646,15 +634,15 @@ static void PADGTraceApply(const int dim,
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose2D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose2D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -742,15 +730,15 @@ void PADGTraceApplyTranspose2D(const int NF,
 }
 
 // PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose3D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose3D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -898,15 +886,15 @@ void PADGTraceApplyTranspose3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApplyTranspose3D(const int NF,
-                                   const Array<double> &b,
-                                   const Array<double> &bt,
-                                   const Vector &op_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApplyTranspose3D(const int NF,
+                                          const Array<double> &b,
+                                          const Array<double> &bt,
+                                          const Vector &op_,
+                                          const Vector &x_,
+                                          Vector &y_,
+                                          const int d1d = 0,
+                                          const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1075,7 +1063,6 @@ static void PADGTraceApplyTranspose(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA DGTraceIntegrator Apply kernel
 void DGTraceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    PADGTraceApply(dim, dofs1D, quad1D, nf,
diff --git a/fem/integ/bilininteg_diffusion_ea.cpp b/fem/integ/bilininteg_diffusion_ea.cpp
index 0e59b33f9..aa36233c4 100644
--- a/fem/integ/bilininteg_diffusion_ea.cpp
+++ b/fem/integ/bilininteg_diffusion_ea.cpp
@@ -22,7 +22,6 @@ static void EADiffusionAssemble1D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -54,14 +53,7 @@ static void EADiffusionAssemble1D(const int NE,
             {
                val += r_Gj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -73,7 +65,6 @@ static void EADiffusionAssemble2D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -129,14 +120,7 @@ static void EADiffusionAssemble2D(const int NE,
                                + gbi * D11 * gbj;
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -150,7 +134,6 @@ static void EADiffusionAssemble3D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -225,14 +208,7 @@ static void EADiffusionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -243,8 +219,7 @@ static void EADiffusionAssemble3D(const int NE,
 }
 
 void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data,
-                                     const bool add)
+                                     Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -254,15 +229,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -270,15 +245,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -286,14 +261,14 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 449246a02..0896b8bf9 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index 52521bf0f..a966c8520 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -12,7 +12,6 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
-#include "../../mesh/nurbs.hpp"
 #include "../ceed/integrators/diffusion/diffusion.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 
@@ -24,7 +23,6 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -75,29 +73,6 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
                               ir->GetWeights(), geom->J, coeff, pa_data);
 }
 
-void DiffusionIntegrator::AssembleNURBSPA(const FiniteElementSpace &fes)
-{
-   fespace = &fes;
-   Mesh *mesh = fes.GetMesh();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(3 == dim, "Only 3D so far");
-
-   numPatches = mesh->NURBSext->GetNP();
-   for (int p=0; p<numPatches; ++p)
-   {
-      AssemblePatchPA(p, fes);
-   }
-}
-
-void DiffusionIntegrator::AssemblePatchPA(const int patch,
-                                          const FiniteElementSpace &fes)
-{
-   Mesh *mesh = fes.GetMesh();
-   SetupPatchBasisData(mesh, patch);
-
-   SetupPatchPA(patch, mesh);  // For full quadrature, unitWeights = false
-}
-
 void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -106,7 +81,6 @@ void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      if (pa_data.Size()==0) { AssemblePA(*fespace); }
       internal::PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
                                             maps->B, maps->G, pa_data, diag);
    }
@@ -128,231 +102,22 @@ void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 
 void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (symmetric)
+   if (DeviceCanUseCeed())
    {
-      AddMultPA(x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " DiffusionIntegrator.");
    }
    else
    {
-      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
-                 "the symmetric case.")
-   }
-}
-
-// This version uses full 1D quadrature rules, taking into account the
-// minimum interaction between basis functions and integration points.
-void DiffusionIntegrator::AddMultPatchPA(const int patch, const Vector &x,
-                                         Vector &y) const
-{
-   MFEM_VERIFY(3 == dim, "Only 3D so far");
-
-   const Array<int>& Q1D = pQ1D[patch];
-   const Array<int>& D1D = pD1D[patch];
-
-   const std::vector<Array2D<double>>& B = pB[patch];
-   const std::vector<Array2D<double>>& G = pG[patch];
-
-   const IntArrayVar2D& minD = pminD[patch];
-   const IntArrayVar2D& maxD = pmaxD[patch];
-   const IntArrayVar2D& minQ = pminQ[patch];
-   const IntArrayVar2D& maxQ = pmaxQ[patch];
-
-   auto X = Reshape(x.Read(), D1D[0], D1D[1], D1D[2]);
-   auto Y = Reshape(y.ReadWrite(), D1D[0], D1D[1], D1D[2]);
-
-   const auto qd = Reshape(pa_data.Read(), Q1D[0]*Q1D[1]*Q1D[2],
-                           (symmetric ? 6 : 9));
-
-   // NOTE: the following is adapted from AssemblePatchMatrix_fullQuadrature
-   std::vector<Array3D<double>> grad(dim);
-   // TODO: Can an optimal order of dimensions be determined, for each patch?
-   Array3D<double> gradXY(3, std::max(Q1D[0], D1D[0]), std::max(Q1D[1], D1D[1]));
-   Array2D<double> gradX(3, std::max(Q1D[0], D1D[0]));
-
-   for (int d=0; d<dim; ++d)
-   {
-      grad[d].SetSize(Q1D[0], Q1D[1], Q1D[2]);
-
-      for (int qz = 0; qz < Q1D[2]; ++qz)
-      {
-         for (int qy = 0; qy < Q1D[1]; ++qy)
-         {
-            for (int qx = 0; qx < Q1D[0]; ++qx)
-            {
-               grad[d](qx,qy,qz) = 0.0;
-            }
-         }
-      }
-   }
-
-   for (int dz = 0; dz < D1D[2]; ++dz)
-   {
-      for (int qy = 0; qy < Q1D[1]; ++qy)
-      {
-         for (int qx = 0; qx < Q1D[0]; ++qx)
-         {
-            for (int d=0; d<dim; ++d)
-            {
-               gradXY(d,qx,qy) = 0.0;
-            }
-         }
-      }
-      for (int dy = 0; dy < D1D[1]; ++dy)
-      {
-         for (int qx = 0; qx < Q1D[0]; ++qx)
-         {
-            gradX(0,qx) = 0.0;
-            gradX(1,qx) = 0.0;
-         }
-         for (int dx = 0; dx < D1D[0]; ++dx)
-         {
-            const double s = X(dx,dy,dz);
-            for (int qx = minD[0][dx]; qx <= maxD[0][dx]; ++qx)
-            {
-               gradX(0,qx) += s * B[0](qx,dx);
-               gradX(1,qx) += s * G[0](qx,dx);
-            }
-         }
-         for (int qy = minD[1][dy]; qy <= maxD[1][dy]; ++qy)
-         {
-            const double wy  = B[1](qy,dy);
-            const double wDy = G[1](qy,dy);
-            // This full range of qx values is generally necessary.
-            for (int qx = 0; qx < Q1D[0]; ++qx)
-            {
-               const double wx  = gradX(0,qx);
-               const double wDx = gradX(1,qx);
-               gradXY(0,qx,qy) += wDx * wy;
-               gradXY(1,qx,qy) += wx  * wDy;
-               gradXY(2,qx,qy) += wx  * wy;
-            }
-         }
-      }
-      for (int qz = minD[2][dz]; qz <= maxD[2][dz]; ++qz)
-      {
-         const double wz  = B[2](qz,dz);
-         const double wDz = G[2](qz,dz);
-         for (int qy = 0; qy < Q1D[1]; ++qy)
-         {
-            for (int qx = 0; qx < Q1D[0]; ++qx)
-            {
-               grad[0](qx,qy,qz) += gradXY(0,qx,qy) * wz;
-               grad[1](qx,qy,qz) += gradXY(1,qx,qy) * wz;
-               grad[2](qx,qy,qz) += gradXY(2,qx,qy) * wDz;
-            }
-         }
-      }
-   }
-
-   for (int qz = 0; qz < Q1D[2]; ++qz)
-   {
-      for (int qy = 0; qy < Q1D[1]; ++qy)
-      {
-         for (int qx = 0; qx < Q1D[0]; ++qx)
-         {
-            const int q = qx + ((qy + (qz * Q1D[1])) * Q1D[0]);
-            const double O00 = qd(q,0);
-            const double O01 = qd(q,1);
-            const double O02 = qd(q,2);
-            const double O10 = symmetric ? O01 : qd(q,3);
-            const double O11 = symmetric ? qd(q,3) : qd(q,4);
-            const double O12 = symmetric ? qd(q,4) : qd(q,5);
-            const double O20 = symmetric ? O02 : qd(q,6);
-            const double O21 = symmetric ? O12 : qd(q,7);
-            const double O22 = symmetric ? qd(q,5) : qd(q,8);
-
-            const double grad0 = grad[0](qx,qy,qz);
-            const double grad1 = grad[1](qx,qy,qz);
-            const double grad2 = grad[2](qx,qy,qz);
-
-            grad[0](qx,qy,qz) = (O00*grad0)+(O01*grad1)+(O02*grad2);
-            grad[1](qx,qy,qz) = (O10*grad0)+(O11*grad1)+(O12*grad2);
-            grad[2](qx,qy,qz) = (O20*grad0)+(O21*grad1)+(O22*grad2);
-         } // qx
-      } // qy
-   } // qz
-
-   for (int qz = 0; qz < Q1D[2]; ++qz)
-   {
-      for (int dy = 0; dy < D1D[1]; ++dy)
+      if (symmetric)
       {
-         for (int dx = 0; dx < D1D[0]; ++dx)
-         {
-            for (int d=0; d<3; ++d)
-            {
-               gradXY(d,dx,dy) = 0.0;
-            }
-         }
+         AddMultPA(x, y);
       }
-      for (int qy = 0; qy < Q1D[1]; ++qy)
+      else
       {
-         for (int dx = 0; dx < D1D[0]; ++dx)
-         {
-            for (int d=0; d<3; ++d)
-            {
-               gradX(d,dx) = 0.0;
-            }
-         }
-         for (int qx = 0; qx < Q1D[0]; ++qx)
-         {
-            const double gX = grad[0](qx,qy,qz);
-            const double gY = grad[1](qx,qy,qz);
-            const double gZ = grad[2](qx,qy,qz);
-            for (int dx = minQ[0][qx]; dx <= maxQ[0][qx]; ++dx)
-            {
-               const double wx  = B[0](qx,dx);
-               const double wDx = G[0](qx,dx);
-               gradX(0,dx) += gX * wDx;
-               gradX(1,dx) += gY * wx;
-               gradX(2,dx) += gZ * wx;
-            }
-         }
-         for (int dy = minQ[1][qy]; dy <= maxQ[1][qy]; ++dy)
-         {
-            const double wy  = B[1](qy,dy);
-            const double wDy = G[1](qy,dy);
-            for (int dx = 0; dx < D1D[0]; ++dx)
-            {
-               gradXY(0,dx,dy) += gradX(0,dx) * wy;
-               gradXY(1,dx,dy) += gradX(1,dx) * wDy;
-               gradXY(2,dx,dy) += gradX(2,dx) * wy;
-            }
-         }
+         MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
+                    "the symmetric case.")
       }
-      for (int dz = minQ[2][qz]; dz <= maxQ[2][qz]; ++dz)
-      {
-         const double wz  = B[2](qz,dz);
-         const double wDz = G[2](qz,dz);
-         for (int dy = 0; dy < D1D[1]; ++dy)
-         {
-            for (int dx = 0; dx < D1D[0]; ++dx)
-            {
-               Y(dx,dy,dz) +=
-                  ((gradXY(0,dx,dy) * wz) +
-                   (gradXY(1,dx,dy) * wz) +
-                   (gradXY(2,dx,dy) * wDz));
-            }
-         }
-      } // dz
-   } // qz
-}
-
-void DiffusionIntegrator::AddMultNURBSPA(const Vector &x, Vector &y) const
-{
-   Vector xp, yp;
-
-   for (int p=0; p<numPatches; ++p)
-   {
-      Array<int> vdofs;
-      fespace->GetPatchVDofs(p, vdofs);
-
-      x.GetSubVector(vdofs, xp);
-      yp.SetSize(vdofs.Size());
-      yp = 0.0;
-
-      AddMultPatchPA(p, xp, yp);
-
-      y.AddElementVector(vdofs, yp);
    }
 }
 
diff --git a/fem/integ/bilininteg_diffusion_patch.cpp b/fem/integ/bilininteg_diffusion_patch.cpp
deleted file mode 100644
index 148ccc5c4..000000000
--- a/fem/integ/bilininteg_diffusion_patch.cpp
+++ /dev/null
@@ -1,1249 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-
-#include "../fem.hpp"
-#include "../../mesh/nurbs.hpp"
-#include "../../general/tic_toc.hpp"
-
-#include "../../linalg/dtensor.hpp"  // For Reshape
-#include "../../general/forall.hpp"
-
-using namespace std;
-
-namespace mfem
-{
-
-// Adapted from PADiffusionSetup3D
-void SetupPatch3D(const int Q1Dx,
-                  const int Q1Dy,
-                  const int Q1Dz,
-                  const int coeffDim,
-                  const bool symmetric,
-                  const Array<double> &w,
-                  const Vector &j,
-                  const Vector &c,
-                  Vector &d)
-{
-   const bool const_c = (c.Size() == 1);
-   MFEM_VERIFY(coeffDim < 6 ||
-               !const_c, "Constant matrix coefficient not supported");
-
-   const auto W = Reshape(w.Read(), Q1Dx,Q1Dy,Q1Dz);
-   const auto J = Reshape(j.Read(), Q1Dx,Q1Dy,Q1Dz,3,3);
-   const auto C = const_c ? Reshape(c.Read(), 1,1,1,1) :
-                  Reshape(c.Read(), coeffDim,Q1Dx,Q1Dy,Q1Dz);
-   d.SetSize(Q1Dx * Q1Dy * Q1Dz * (symmetric ? 6 : 9));
-   auto D = Reshape(d.Write(), Q1Dx,Q1Dy,Q1Dz, symmetric ? 6 : 9);
-   const int NE = 1;  // TODO: MFEM_FORALL_3D without e?
-   MFEM_FORALL_3D(e, NE, Q1Dx, Q1Dy, Q1Dz,
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1Dx)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1Dy)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1Dz)
-            {
-               const double J11 = J(qx,qy,qz,0,0);
-               const double J21 = J(qx,qy,qz,1,0);
-               const double J31 = J(qx,qy,qz,2,0);
-               const double J12 = J(qx,qy,qz,0,1);
-               const double J22 = J(qx,qy,qz,1,1);
-               const double J32 = J(qx,qy,qz,2,1);
-               const double J13 = J(qx,qy,qz,0,2);
-               const double J23 = J(qx,qy,qz,1,2);
-               const double J33 = J(qx,qy,qz,2,2);
-               const double detJ = J11 * (J22 * J33 - J32 * J23) -
-               /* */               J21 * (J12 * J33 - J32 * J13) +
-               /* */               J31 * (J12 * J23 - J22 * J13);
-               const double w_detJ = W(qx,qy,qz) / detJ;
-               // adj(J)
-               const double A11 = (J22 * J33) - (J23 * J32);
-               const double A12 = (J32 * J13) - (J12 * J33);
-               const double A13 = (J12 * J23) - (J22 * J13);
-               const double A21 = (J31 * J23) - (J21 * J33);
-               const double A22 = (J11 * J33) - (J13 * J31);
-               const double A23 = (J21 * J13) - (J11 * J23);
-               const double A31 = (J21 * J32) - (J31 * J22);
-               const double A32 = (J31 * J12) - (J11 * J32);
-               const double A33 = (J11 * J22) - (J12 * J21);
-
-               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-               {
-                  // Compute entries of R = MJ^{-T} = M adj(J)^T, without det J.
-                  const double M11 = C(0, qx,qy,qz);
-                  const double M12 = C(1, qx,qy,qz);
-                  const double M13 = C(2, qx,qy,qz);
-                  const double M21 = (!symmetric) ? C(3, qx,qy,qz) : M12;
-                  const double M22 = (!symmetric) ? C(4, qx,qy,qz) : C(3, qx,qy,qz);
-                  const double M23 = (!symmetric) ? C(5, qx,qy,qz) : C(4, qx,qy,qz);
-                  const double M31 = (!symmetric) ? C(6, qx,qy,qz) : M13;
-                  const double M32 = (!symmetric) ? C(7, qx,qy,qz) : M23;
-                  const double M33 = (!symmetric) ? C(8, qx,qy,qz) : C(5, qx,qy,qz);
-
-                  const double R11 = M11*A11 + M12*A12 + M13*A13;
-                  const double R12 = M11*A21 + M12*A22 + M13*A23;
-                  const double R13 = M11*A31 + M12*A32 + M13*A33;
-                  const double R21 = M21*A11 + M22*A12 + M23*A13;
-                  const double R22 = M21*A21 + M22*A22 + M23*A23;
-                  const double R23 = M21*A31 + M22*A32 + M23*A33;
-                  const double R31 = M31*A11 + M32*A12 + M33*A13;
-                  const double R32 = M31*A21 + M32*A22 + M33*A23;
-                  const double R33 = M31*A31 + M32*A32 + M33*A33;
-
-                  // Now set D to J^{-1} R = adj(J) R
-                  D(qx,qy,qz,0) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
-                  const double D12 = w_detJ * (A11*R12 + A12*R22 + A13*R32);
-                  D(qx,qy,qz,1) = D12; // 1,2
-                  D(qx,qy,qz,2) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
-
-                  const double D21 = w_detJ * (A21*R11 + A22*R21 + A23*R31);
-                  const double D22 = w_detJ * (A21*R12 + A22*R22 + A23*R32);
-                  const double D23 = w_detJ * (A21*R13 + A22*R23 + A23*R33);
-
-                  const double D33 = w_detJ * (A31*R13 + A32*R23 + A33*R33);
-
-                  D(qx,qy,qz,3) = symmetric ? D22 : D21; // 2,2 or 2,1
-                  D(qx,qy,qz,4) = symmetric ? D23 : D22; // 2,3 or 2,2
-                  D(qx,qy,qz,5) = symmetric ? D33 : D23; // 3,3 or 2,3
-
-                  if (!symmetric)
-                  {
-                     D(qx,qy,qz,6) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
-                     D(qx,qy,qz,7) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
-                     D(qx,qy,qz,8) = D33; // 3,3
-                  }
-               }
-               else  // Vector or scalar coefficient version
-               {
-                  const double C1 = const_c ? C(0,0,0,0) : C(0,qx,qy,qz);
-                  const double C2 = const_c ? C(0,0,0,0) :
-                                    (coeffDim == 3 ? C(1,qx,qy,qz) : C(0,qx,qy,qz));
-                  const double C3 = const_c ? C(0,0,0,0) :
-                                    (coeffDim == 3 ? C(2,qx,qy,qz) : C(0,qx,qy,qz));
-
-                  // detJ J^{-1} J^{-T} = (1/detJ) adj(J) adj(J)^T
-                  D(qx,qy,qz,0) = w_detJ * (C1*A11*A11 + C2*A12*A12 + C3*A13*A13); // 1,1
-                  D(qx,qy,qz,1) = w_detJ * (C1*A11*A21 + C2*A12*A22 + C3*A13*A23); // 2,1
-                  D(qx,qy,qz,2) = w_detJ * (C1*A11*A31 + C2*A12*A32 + C3*A13*A33); // 3,1
-                  D(qx,qy,qz,3) = w_detJ * (C1*A21*A21 + C2*A22*A22 + C3*A23*A23); // 2,2
-                  D(qx,qy,qz,4) = w_detJ * (C1*A21*A31 + C2*A22*A32 + C3*A23*A33); // 3,2
-                  D(qx,qy,qz,5) = w_detJ * (C1*A31*A31 + C2*A32*A32 + C3*A33*A33); // 3,3
-               }
-            }
-         }
-      }
-   });
-}
-
-// Compute a reduced integration rule, using NNLSSolver, for DiffusionIntegrator
-// on a NURBS patch with partial assembly.
-void GetReducedRule(const int nq, const int nd,
-                    Array2D<double> const& B,
-                    Array2D<double> const& G,
-                    std::vector<int> minQ,
-                    std::vector<int> maxQ,
-                    std::vector<int> minD,
-                    std::vector<int> maxD,
-                    std::vector<int> minDD,
-                    std::vector<int> maxDD,
-                    const IntegrationRule *ir,
-                    const bool zeroOrder,
-                    std::vector<Vector> & reducedWeights,
-                    std::vector<std::vector<int>> & reducedIDs)
-{
-   MFEM_VERIFY(B.NumRows() == nq, "");
-   MFEM_VERIFY(B.NumCols() == nd, "");
-   MFEM_VERIFY(G.NumRows() == nq, "");
-   MFEM_VERIFY(G.NumCols() == nd, "");
-   MFEM_VERIFY(ir->GetNPoints() == nq, "");
-
-   for (int dof=0; dof<nd; ++dof)
-   {
-      // Integrate diffusion for B(:,dof) against all other B(:,i)
-
-      const int nc_dof = maxDD[dof] - minDD[dof] + 1;
-      const int nw_dof = maxD[dof] - minD[dof] + 1;
-
-      // G is of size nc_dof x nw_dof
-      MFEM_VERIFY(nc_dof <= nw_dof, "The NNLS system for the reduced "
-                  "integration rule requires more full integration points. Try"
-                  " increasing the order of the full integration rule.");
-      DenseMatrix Gmat(nc_dof, nw_dof);
-      Gmat = 0.0;
-
-      Vector w(nw_dof);
-      w = 0.0;
-
-      for (int qx = minD[dof]; qx <= maxD[dof]; ++qx)
-      {
-         const double Bq = zeroOrder ? B(qx,dof) : G(qx,dof);
-
-         const IntegrationPoint &ip = ir->IntPoint(qx);
-         const double w_qx = ip.weight;
-         w[qx - minD[dof]] = w_qx;
-
-         for (int dx = minQ[qx]; dx <= maxQ[qx]; ++dx)
-         {
-            const double Bd = zeroOrder ? B(qx,dx) : G(qx,dx);
-
-            Gmat(dx - minDD[dof], qx - minD[dof]) = Bq * Bd;
-         }
-      }
-
-      Vector sol(Gmat.NumCols());
-
-#ifdef MFEM_USE_LAPACK
-      NNLSSolver nnls;
-      nnls.SetOperator(Gmat);
-
-      nnls.Mult(w, sol);
-#else
-      MFEM_ABORT("NNLSSolver requires building with LAPACK");
-#endif
-
-      int nnz = 0;
-      for (int i=0; i<sol.Size(); ++i)
-      {
-         if (sol(i) != 0.0)
-         {
-            nnz++;
-         }
-      }
-
-      MFEM_VERIFY(nnz > 0, "");
-
-      Vector wred(nnz);
-      std::vector<int> idnnz(nnz);
-      nnz = 0;
-      for (int i=0; i<sol.Size(); ++i)
-      {
-         if (sol(i) != 0.0)
-         {
-            wred[nnz] = sol[i];
-            idnnz[nnz] = i;
-            nnz++;
-         }
-      }
-
-      reducedWeights.push_back(wred);
-      reducedIDs.push_back(idnnz);
-   }
-}
-
-// Adapted from AssemblePA
-void DiffusionIntegrator::SetupPatchPA(const int patch, Mesh *mesh,
-                                       bool unitWeights)
-{
-   const Array<int>& Q1D = pQ1D[patch];
-   const Array<int>& D1D = pD1D[patch];
-   const std::vector<Array2D<double>>& B = pB[patch];
-   const std::vector<Array2D<double>>& G = pG[patch];
-
-   const IntArrayVar2D& minD = pminD[patch];
-   const IntArrayVar2D& maxD = pmaxD[patch];
-   const IntArrayVar2D& minQ = pminQ[patch];
-   const IntArrayVar2D& maxQ = pmaxQ[patch];
-
-   const IntArrayVar2D& minDD = pminDD[patch];
-   const IntArrayVar2D& maxDD = pmaxDD[patch];
-
-   const Array<const IntegrationRule*>& ir1d = pir1d[patch];
-
-   MFEM_VERIFY(Q1D.Size() == 3, "");
-
-   const int dims = dim;  // TODO: generalize
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-
-   int nq = Q1D[0];
-   for (int i=1; i<dim; ++i)
-   {
-      nq *= Q1D[i];
-   }
-
-   int coeffDim = 1;
-   Vector coeff;
-   Array<double> weights(nq);
-   const int MQfullDim = MQ ? MQ->GetHeight() * MQ->GetWidth() : 0;
-   IntegrationPoint ip;
-
-   Vector jac(dim * dim * nq);  // Computed as in GeometricFactors::Compute
-
-   for (int qz=0; qz<Q1D[2]; ++qz)
-   {
-      for (int qy=0; qy<Q1D[1]; ++qy)
-      {
-         for (int qx=0; qx<Q1D[0]; ++qx)
-         {
-            const int p = qx + (qy * Q1D[0]) + (qz * Q1D[0] * Q1D[1]);
-            patchRules->GetIntegrationPointFrom1D(patch, qx, qy, qz, ip);
-            const int e = patchRules->GetPointElement(patch, qx, qy, qz);
-            ElementTransformation *tr = mesh->GetElementTransformation(e);
-
-            weights[p] = ip.weight;
-
-            tr->SetIntPoint(&ip);
-
-            const DenseMatrix& Jp = tr->Jacobian();
-            for (int i=0; i<dim; ++i)
-               for (int j=0; j<dim; ++j)
-               {
-                  jac[p + ((i + (j * dim)) * nq)] = Jp(i,j);
-               }
-         }
-      }
-   }
-
-   if (auto *SMQ = dynamic_cast<SymmetricMatrixCoefficient *>(MQ))
-   {
-      MFEM_VERIFY(SMQ->GetSize() == dim, "");
-      coeffDim = symmDims;
-      coeff.SetSize(symmDims * nq);
-
-      DenseSymmetricMatrix sym_mat;
-      sym_mat.SetSize(dim);
-
-      auto C = Reshape(coeff.HostWrite(), symmDims, nq);
-      for (int qz=0; qz<Q1D[2]; ++qz)
-      {
-         for (int qy=0; qy<Q1D[1]; ++qy)
-         {
-            for (int qx=0; qx<Q1D[0]; ++qx)
-            {
-               const int p = qx + (qy * Q1D[0]) + (qz * Q1D[0] * Q1D[1]);
-               const int e = patchRules->GetPointElement(patch, qx, qy, qz);
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               patchRules->GetIntegrationPointFrom1D(patch, qx, qy, qz, ip);
-
-               SMQ->Eval(sym_mat, *tr, ip);
-               int cnt = 0;
-               for (int i=0; i<dim; ++i)
-                  for (int j=i; j<dim; ++j, ++cnt)
-                  {
-                     C(cnt, p) = sym_mat(i,j);
-                  }
-            }
-         }
-      }
-   }
-   else if (MQ)
-   {
-      symmetric = false;
-      MFEM_VERIFY(MQ->GetHeight() == dim && MQ->GetWidth() == dim, "");
-
-      coeffDim = MQfullDim;
-
-      coeff.SetSize(MQfullDim * nq);
-
-      DenseMatrix mat;
-      mat.SetSize(dim);
-
-      auto C = Reshape(coeff.HostWrite(), MQfullDim, nq);
-      for (int qz=0; qz<Q1D[2]; ++qz)
-      {
-         for (int qy=0; qy<Q1D[1]; ++qy)
-         {
-            for (int qx=0; qx<Q1D[0]; ++qx)
-            {
-               const int p = qx + (qy * Q1D[0]) + (qz * Q1D[0] * Q1D[1]);
-               const int e = patchRules->GetPointElement(patch, qx, qy, qz);
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               patchRules->GetIntegrationPointFrom1D(patch, qx, qy, qz, ip);
-
-               MQ->Eval(mat, *tr, ip);
-               for (int i=0; i<dim; ++i)
-                  for (int j=0; j<dim; ++j)
-                  {
-                     C(j+(i*dim), p) = mat(i,j);
-                  }
-            }
-         }
-      }
-   }
-   else if (VQ)
-   {
-      MFEM_VERIFY(VQ->GetVDim() == dim, "");
-      coeffDim = VQ->GetVDim();
-      coeff.SetSize(coeffDim * nq);
-      auto C = Reshape(coeff.HostWrite(), coeffDim, nq);
-      Vector DM(coeffDim);
-      for (int qz=0; qz<Q1D[2]; ++qz)
-      {
-         for (int qy=0; qy<Q1D[1]; ++qy)
-         {
-            for (int qx=0; qx<Q1D[0]; ++qx)
-            {
-               const int p = qx + (qy * Q1D[0]) + (qz * Q1D[0] * Q1D[1]);
-               const int e = patchRules->GetPointElement(patch, qx, qy, qz);
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               patchRules->GetIntegrationPointFrom1D(patch, qx, qy, qz, ip);
-
-               VQ->Eval(DM, *tr, ip);
-               for (int i=0; i<coeffDim; ++i)
-               {
-                  C(i, p) = DM[i];
-               }
-            }
-         }
-      }
-   }
-   else if (Q == nullptr)
-   {
-      coeff.SetSize(1);
-      coeff(0) = 1.0;
-   }
-   else if (ConstantCoefficient* cQ = dynamic_cast<ConstantCoefficient*>(Q))
-   {
-      coeff.SetSize(1);
-      coeff(0) = cQ->constant;
-   }
-   else if (dynamic_cast<QuadratureFunctionCoefficient*>(Q))
-   {
-      MFEM_ABORT("QuadratureFunction not supported yet\n");
-   }
-   else
-   {
-      coeff.SetSize(nq);
-      auto C = Reshape(coeff.HostWrite(), nq);
-      for (int qz=0; qz<Q1D[2]; ++qz)
-      {
-         for (int qy=0; qy<Q1D[1]; ++qy)
-         {
-            for (int qx=0; qx<Q1D[0]; ++qx)
-            {
-               const int p = qx + (qy * Q1D[0]) + (qz * Q1D[0] * Q1D[1]);
-               const int e = patchRules->GetPointElement(patch, qx, qy, qz);
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               patchRules->GetIntegrationPointFrom1D(patch, qx, qy, qz, ip);
-
-               C(p) = Q->Eval(*tr, ip);
-            }
-         }
-      }
-   }
-
-   if (unitWeights)
-   {
-      weights = 1.0;
-   }
-
-   SetupPatch3D(Q1D[0], Q1D[1], Q1D[2], coeffDim, symmetric, weights, jac,
-                coeff, pa_data);
-
-   numPatches = mesh->NURBSext->GetNP();
-
-   if (integrationMode != PATCHWISE_REDUCED)
-   {
-      return;
-   }
-
-   // Solve for reduced 1D quadrature rules
-   const int totalDim = numPatches * dim * numTypes;
-   reducedWeights.resize(totalDim);
-   reducedIDs.resize(totalDim);
-
-   auto rw = Reshape(reducedWeights.data(), numTypes, dim, numPatches);
-   auto rid = Reshape(reducedIDs.data(), numTypes, dim, numPatches);
-
-   for (int d=0; d<dim; ++d)
-   {
-      // The reduced rules could be cached to avoid repeated computation, but
-      // the cost of this setup seems low.
-      GetReducedRule(Q1D[d], D1D[d], B[d], G[d],
-                     minQ[d], maxQ[d],
-                     minD[d], maxD[d],
-                     minDD[d], maxDD[d], ir1d[d], true,
-                     rw(0,d,patch), rid(0,d,patch));
-      GetReducedRule(Q1D[d], D1D[d], B[d], G[d],
-                     minQ[d], maxQ[d],
-                     minD[d], maxD[d],
-                     minDD[d], maxDD[d], ir1d[d], false,
-                     rw(1,d,patch), rid(1,d,patch));
-   }
-}
-
-// This version uses full 1D quadrature rules, taking into account the
-// minimum interaction between basis functions and integration points.
-void DiffusionIntegrator::AssemblePatchMatrix_fullQuadrature(
-   const int patch, const FiniteElementSpace &fes, SparseMatrix*& smat)
-{
-   MFEM_VERIFY(patchRules, "patchRules must be defined");
-   dim = patchRules->GetDim();
-   const int spaceDim = dim;  // TODO: generalize?
-
-   Mesh *mesh = fes.GetMesh();
-
-   if (VQ)
-   {
-      MFEM_VERIFY(VQ->GetVDim() == spaceDim,
-                  "Unexpected dimension for VectorCoefficient");
-   }
-   if (MQ)
-   {
-      MFEM_VERIFY(MQ->GetWidth() == spaceDim,
-                  "Unexpected width for MatrixCoefficient");
-      MFEM_VERIFY(MQ->GetHeight() == spaceDim,
-                  "Unexpected height for MatrixCoefficient");
-   }
-
-#ifdef MFEM_THREAD_SAFE
-   DenseMatrix M(MQ ? spaceDim : 0);
-   Vector D(VQ ? VQ->GetVDim() : 0);
-#else
-   M.SetSize(MQ ? spaceDim : 0);
-   D.SetSize(VQ ? VQ->GetVDim() : 0);
-#endif
-
-   SetupPatchBasisData(mesh, patch);
-
-   SetupPatchPA(patch, mesh);
-
-   const Array<int>& Q1D = pQ1D[patch];
-   const Array<int>& D1D = pD1D[patch];
-   const std::vector<Array2D<double>>& B = pB[patch];
-   const std::vector<Array2D<double>>& G = pG[patch];
-
-   const IntArrayVar2D& minD = pminD[patch];
-   const IntArrayVar2D& maxD = pmaxD[patch];
-   const IntArrayVar2D& minQ = pminQ[patch];
-   const IntArrayVar2D& maxQ = pmaxQ[patch];
-
-   const IntArrayVar2D& minDD = pminDD[patch];
-   const IntArrayVar2D& maxDD = pmaxDD[patch];
-
-   int ndof = D1D[0];
-   for (int d=1; d<dim; ++d)
-   {
-      ndof *= D1D[d];
-   }
-
-   MFEM_VERIFY(3 == dim, "Only 3D so far");
-
-   // Setup quadrature point data.
-   const auto qd = Reshape(pa_data.Read(), Q1D[0]*Q1D[1]*Q1D[2],
-                           (symmetric ? 6 : 9));
-
-   // NOTE: the following is adapted from PADiffusionApply3D.
-   std::vector<Array3D<double>> grad(dim);
-
-   for (int d=0; d<dim; ++d)
-   {
-      grad[d].SetSize(Q1D[0], Q1D[1], Q1D[2]);
-   }
-
-   Array3D<double> gradDXY(D1D[0], D1D[1], dim);
-   Array2D<double> gradDX(D1D[0], dim);
-
-   int nd[3];
-   Array3D<int> cdofs;
-
-   int *smati = nullptr;
-   int *smatj = nullptr;
-   double *smata = nullptr;
-   int nnz = 0;
-
-   Array<int> maxw(dim);
-   maxw = 0;
-
-   for (int d=0; d<dim; ++d)
-   {
-      for (int i=0; i<D1D[d]; ++i)
-      {
-         maxw[d] = std::max(maxw[d], maxDD[d][i] - minDD[d][i] + 1);
-      }
-   }
-
-   cdofs.SetSize(maxw[0], maxw[1], maxw[2]);
-
-   // Compute sparsity of the sparse matrix
-   smati = new int[ndof+1];
-   smati[0] = 0;
-
-   for (int dof_j=0; dof_j<ndof; ++dof_j)
-   {
-      const int jdz = dof_j / (D1D[0] * D1D[1]);
-      const int jdy = (dof_j - (jdz * D1D[0] * D1D[1])) / D1D[0];
-      const int jdx = dof_j - (jdz * D1D[0] * D1D[1]) - (jdy * D1D[0]);
-
-      MFEM_VERIFY(jdx + (D1D[0] * (jdy + (D1D[1] * jdz))) == dof_j, "");
-
-      const int jd[3] = {jdx, jdy, jdz};
-      int ndd = 1;
-      for (int i=0; i<dim; ++i)
-      {
-         nd[i] = maxDD[i][jd[i]] - minDD[i][jd[i]] + 1;
-         ndd *= nd[i];
-      }
-
-      smati[dof_j + 1] = smati[dof_j] + ndd;
-      nnz += ndd;
-   }
-
-   smatj = new int[nnz];
-   smata = new double[nnz];
-
-   for (int i=0; i<nnz; ++i)
-   {
-      smatj[i] = -1;
-      smata[i] = 0.0;
-   }
-
-   for (int dof_j=0; dof_j<ndof; ++dof_j)
-   {
-      const int jdz = dof_j / (D1D[0] * D1D[1]);
-      const int jdy = (dof_j - (jdz * D1D[0] * D1D[1])) / D1D[0];
-      const int jdx = dof_j - (jdz * D1D[0] * D1D[1]) - (jdy * D1D[0]);
-
-      const int jd[3] = {jdx, jdy, jdz};
-      for (int i=0; i<dim; ++i)
-      {
-         nd[i] = maxDD[i][jd[i]] - minDD[i][jd[i]] + 1;
-      }
-
-      for (int i=0; i<nd[0]; ++i)
-         for (int j=0; j<nd[1]; ++j)
-            for (int k=0; k<nd[2]; ++k)
-            {
-               cdofs(i,j,k) = minDD[0][jdx] + i + (D1D[0] *
-                                                   (minDD[1][jdy] + j + (D1D[1] * (minDD[2][jdz] + k))));
-            }
-
-      for (int d=0; d<dim; ++d)
-         for (int qz = minD[2][jdz]; qz <= maxD[2][jdz]; ++qz)
-         {
-            for (int qy = minD[1][jdy]; qy <= maxD[1][jdy]; ++qy)
-            {
-               for (int qx = minD[0][jdx]; qx <= maxD[0][jdx]; ++qx)
-               {
-                  grad[d](qx,qy,qz) = 0.0;
-               }
-            }
-         }
-
-      for (int qz = minD[2][jdz]; qz <= maxD[2][jdz]; ++qz)
-      {
-         const double wz  = B[2](qz,jdz);
-         const double wDz = G[2](qz,jdz);
-
-         for (int qy = minD[1][jdy]; qy <= maxD[1][jdy]; ++qy)
-         {
-            const double wy  = B[1](qy,jdy);
-            const double wDy = G[1](qy,jdy);
-
-            for (int qx = minD[0][jdx]; qx <= maxD[0][jdx]; ++qx)
-            {
-               const int q = qx + ((qy + (qz * Q1D[1])) * Q1D[0]);
-               const double O11 = qd(q,0);
-               const double O12 = qd(q,1);
-               const double O13 = qd(q,2);
-               const double O21 = symmetric ? O12 : qd(q,3);
-               const double O22 = symmetric ? qd(q,3) : qd(q,4);
-               const double O23 = symmetric ? qd(q,4) : qd(q,5);
-               const double O31 = symmetric ? O13 : qd(q,6);
-               const double O32 = symmetric ? O23 : qd(q,7);
-               const double O33 = symmetric ? qd(q,5) : qd(q,8);
-
-               const double wx  = B[0](qx,jdx);
-               const double wDx = G[0](qx,jdx);
-
-               const double gradX = wDx * wy * wz;
-               const double gradY = wx  * wDy * wz;
-               const double gradZ = wx  * wy * wDz;
-
-               grad[0](qx,qy,qz) = (O11*gradX)+(O12*gradY)+(O13*gradZ);
-               grad[1](qx,qy,qz) = (O21*gradX)+(O22*gradY)+(O23*gradZ);
-               grad[2](qx,qy,qz) = (O31*gradX)+(O32*gradY)+(O33*gradZ);
-            }
-         }
-      }
-
-      for (int qz = minD[2][jdz]; qz <= maxD[2][jdz]; ++qz)
-      {
-         for (int dy = minDD[1][jdy]; dy <= maxDD[1][jdy]; ++dy)
-         {
-            for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-            {
-               for (int d=0; d<dim; ++d)
-               {
-                  gradDXY(dx,dy,d) = 0.0;
-               }
-            }
-         }
-         for (int qy = minD[1][jdy]; qy <= maxD[1][jdy]; ++qy)
-         {
-            for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-            {
-               for (int d=0; d<dim; ++d)
-               {
-                  gradDX(dx,d) = 0.0;
-               }
-            }
-            for (int qx = minD[0][jdx]; qx <= maxD[0][jdx]; ++qx)
-            {
-               const double gX = grad[0](qx,qy,qz);
-               const double gY = grad[1](qx,qy,qz);
-               const double gZ = grad[2](qx,qy,qz);
-               for (int dx = minQ[0][qx]; dx <= maxQ[0][qx]; ++dx)
-               {
-                  const double wx  = B[0](qx,dx);
-                  const double wDx = G[0](qx,dx);
-                  gradDX(dx,0) += gX * wDx;
-                  gradDX(dx,1) += gY * wx;
-                  gradDX(dx,2) += gZ * wx;
-               }
-            }
-            for (int dy = minQ[1][qy]; dy <= maxQ[1][qy]; ++dy)
-            {
-               const double wy  = B[1](qy,dy);
-               const double wDy = G[1](qy,dy);
-               for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-               {
-                  gradDXY(dx,dy,0) += gradDX(dx,0) * wy;
-                  gradDXY(dx,dy,1) += gradDX(dx,1) * wDy;
-                  gradDXY(dx,dy,2) += gradDX(dx,2) * wy;
-               }
-            }
-         }
-         for (int dz = minQ[2][qz]; dz <= maxQ[2][qz]; ++dz)
-         {
-            const double wz  = B[2](qz,dz);
-            const double wDz = G[2](qz,dz);
-            for (int dy = minDD[1][jdy]; dy <= maxDD[1][jdy]; ++dy)
-            {
-               for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-               {
-                  const double v = (gradDXY(dx,dy,0) * wz) +
-                                   (gradDXY(dx,dy,1) * wz) +
-                                   (gradDXY(dx,dy,2) * wDz);
-
-                  const int loc = dx - minDD[0][jd[0]] + (nd[0] * (dy - minDD[1][jd[1]] +
-                                                                   (nd[1] * (dz - minDD[2][jd[2]]))));
-
-                  const int odof = cdofs(dx - minDD[0][jd[0]],
-                                         dy - minDD[1][jd[1]],
-                                         dz - minDD[2][jd[2]]);
-
-                  const int m = smati[dof_j] + loc;
-                  MFEM_ASSERT(smatj[m] == odof || smatj[m] == -1, "");
-                  smatj[m] = odof;
-                  smata[m] += v;
-               } // dx
-            } // dy
-         } // dz
-      } // qz
-   } // dof_j
-
-   // Note that smat takes ownership of its input data.
-   smat = new SparseMatrix(smati, smatj, smata, ndof, ndof);
-}
-
-void DiffusionIntegrator::SetupPatchBasisData(Mesh *mesh, unsigned int patch)
-{
-   MFEM_VERIFY(pB.size() == patch && pG.size() == patch, "");
-   MFEM_VERIFY(pQ1D.size() == patch && pD1D.size() == patch, "");
-   MFEM_VERIFY(pminQ.size() == patch && pmaxQ.size() == patch, "");
-   MFEM_VERIFY(pminD.size() == patch && pmaxD.size() == patch, "");
-   MFEM_VERIFY(pminDD.size() == patch && pmaxDD.size() == patch, "");
-   MFEM_VERIFY(pir1d.size() == patch, "");
-
-   // Set basis functions and gradients for this patch
-   Array<const KnotVector*> pkv;
-   mesh->NURBSext->GetPatchKnotVectors(patch, pkv);
-   MFEM_VERIFY(pkv.Size() == dim, "");
-
-   Array<int> Q1D(dim);
-   Array<int> orders(dim);
-   Array<int> D1D(dim);
-   std::vector<Array2D<double>> B(dim);
-   std::vector<Array2D<double>> G(dim);
-   Array<const IntegrationRule*> ir1d(dim);
-
-   IntArrayVar2D minD(dim);
-   IntArrayVar2D maxD(dim);
-   IntArrayVar2D minQ(dim);
-   IntArrayVar2D maxQ(dim);
-
-   IntArrayVar2D minDD(dim);
-   IntArrayVar2D maxDD(dim);
-
-   for (int d=0; d<dim; ++d)
-   {
-      ir1d[d] = patchRules->GetPatchRule1D(patch, d);
-
-      Q1D[d] = ir1d[d]->GetNPoints();
-
-      orders[d] = pkv[d]->GetOrder();
-      D1D[d] = pkv[d]->GetNCP();
-
-      Vector shapeKV(orders[d]+1);
-      Vector dshapeKV(orders[d]+1);
-
-      B[d].SetSize(Q1D[d], D1D[d]);
-      G[d].SetSize(Q1D[d], D1D[d]);
-
-      minD[d].assign(D1D[d], Q1D[d]);
-      maxD[d].assign(D1D[d], 0);
-
-      minQ[d].assign(Q1D[d], D1D[d]);
-      maxQ[d].assign(Q1D[d], 0);
-
-      B[d] = 0.0;
-      G[d] = 0.0;
-
-      const Array<int>& knotSpan1D = patchRules->GetPatchRule1D_KnotSpan(patch, d);
-      MFEM_VERIFY(knotSpan1D.Size() == Q1D[d], "");
-
-      for (int i = 0; i < Q1D[d]; i++)
-      {
-         const IntegrationPoint &ip = ir1d[d]->IntPoint(i);
-         const int ijk = knotSpan1D[i];
-         const double kv0 = (*pkv[d])[orders[d] + ijk];
-         double kv1 = (*pkv[d])[0];
-         for (int j = orders[d] + ijk + 1; j < pkv[d]->Size(); ++j)
-         {
-            if ((*pkv[d])[j] > kv0)
-            {
-               kv1 = (*pkv[d])[j];
-               break;
-            }
-         }
-
-         MFEM_VERIFY(kv1 > kv0, "");
-
-         pkv[d]->CalcShape(shapeKV, ijk, (ip.x - kv0) / (kv1 - kv0));
-         pkv[d]->CalcDShape(dshapeKV, ijk, (ip.x - kv0) / (kv1 - kv0));
-
-         // Put shapeKV into array B storing shapes for all points.
-         // TODO: This should be based on NURBS3DFiniteElement::CalcShape and CalcDShape.
-         // For now, it works under the assumption that all NURBS weights are 1.
-         for (int j=0; j<orders[d]+1; ++j)
-         {
-            B[d](i,ijk + j) = shapeKV[j];
-            G[d](i,ijk + j) = dshapeKV[j];
-
-            minD[d][ijk + j] = std::min(minD[d][ijk + j], i);
-            maxD[d][ijk + j] = std::max(maxD[d][ijk + j], i);
-         }
-
-         minQ[d][i] = std::min(minQ[d][i], ijk);
-         maxQ[d][i] = std::max(maxQ[d][i], ijk + orders[d]);
-      }
-
-      // Determine which DOFs each DOF interacts with, in 1D.
-      minDD[d].resize(D1D[d]);
-      maxDD[d].resize(D1D[d]);
-      for (int i=0; i<D1D[d]; ++i)
-      {
-         const int qmin = minD[d][i];
-         minDD[d][i] = minQ[d][qmin];
-
-         const int qmax = maxD[d][i];
-         maxDD[d][i] = maxQ[d][qmax];
-      }
-   }
-
-   // Push patch data to global data structures
-   pB.push_back(B);
-   pG.push_back(G);
-
-   pQ1D.push_back(Q1D);
-   pD1D.push_back(D1D);
-
-   pminQ.push_back(minQ);
-   pmaxQ.push_back(maxQ);
-
-   pminD.push_back(minD);
-   pmaxD.push_back(maxD);
-
-   pminDD.push_back(minDD);
-   pmaxDD.push_back(maxDD);
-
-   pir1d.push_back(ir1d);
-}
-
-// This version uses reduced 1D quadrature rules.
-void DiffusionIntegrator::AssemblePatchMatrix_reducedQuadrature(
-   const int patch, const FiniteElementSpace &fes, SparseMatrix*& smat)
-{
-   MFEM_VERIFY(patchRules, "patchRules must be defined");
-   dim = patchRules->GetDim();
-   const int spaceDim = dim;  // TODO: generalize?
-
-   Mesh *mesh = fes.GetMesh();
-
-   if (VQ)
-   {
-      MFEM_VERIFY(VQ->GetVDim() == spaceDim,
-                  "Unexpected dimension for VectorCoefficient");
-   }
-   if (MQ)
-   {
-      MFEM_VERIFY(MQ->GetWidth() == spaceDim,
-                  "Unexpected width for MatrixCoefficient");
-      MFEM_VERIFY(MQ->GetHeight() == spaceDim,
-                  "Unexpected height for MatrixCoefficient");
-   }
-
-#ifdef MFEM_THREAD_SAFE
-   DenseMatrix M(MQ ? spaceDim : 0);
-   Vector D(VQ ? VQ->GetVDim() : 0);
-#else
-   M.SetSize(MQ ? spaceDim : 0);
-   D.SetSize(VQ ? VQ->GetVDim() : 0);
-#endif
-
-   SetupPatchBasisData(mesh, patch);
-
-   MFEM_VERIFY(3 == dim, "Only 3D so far");
-
-   // Setup quadrature point data.
-   // For each point in patchRules, get the corresponding element and element
-   // reference point, in order to use element transformations. This requires
-   // data set up in NURBSPatchRule::SetPointToElement.
-   SetupPatchPA(patch, mesh, true);
-
-   const Array<int>& Q1D = pQ1D[patch];
-   const Array<int>& D1D = pD1D[patch];
-   const std::vector<Array2D<double>>& B = pB[patch];
-   const std::vector<Array2D<double>>& G = pG[patch];
-
-   const IntArrayVar2D& minD = pminD[patch];
-   const IntArrayVar2D& maxD = pmaxD[patch];
-   const IntArrayVar2D& minQ = pminQ[patch];
-   const IntArrayVar2D& maxQ = pmaxQ[patch];
-
-   const IntArrayVar2D& minDD = pminDD[patch];
-   const IntArrayVar2D& maxDD = pmaxDD[patch];
-
-   int ndof = D1D[0];
-   for (int d=1; d<dim; ++d)
-   {
-      ndof *= D1D[d];
-   }
-
-   auto rw = Reshape(reducedWeights.data(), numTypes, dim, numPatches);
-   auto rid = Reshape(reducedIDs.data(), numTypes, dim, numPatches);
-
-   const auto qd = Reshape(pa_data.Read(), Q1D[0]*Q1D[1]*Q1D[2],
-                           (symmetric ? 6 : 9));
-
-   // NOTE: the following is adapted from PADiffusionApply3D.
-   std::vector<Array3D<double>> grad(dim);
-   for (int d=0; d<dim; ++d)
-   {
-      grad[d].SetSize(Q1D[0], Q1D[1], Q1D[2]);
-   }
-
-   // Note that this large 3D array, most of which is unused,
-   // seems inefficient, but testing showed that it is faster
-   // than using a set<int> to store 1D indices of the used points.
-   Array3D<bool> gradUsed;
-   gradUsed.SetSize(Q1D[0], Q1D[1], Q1D[2]);
-
-   Array3D<double> gradDXY(D1D[0], D1D[1], dim);
-   Array2D<double> gradDX(D1D[0], dim);
-
-   int nd[3];
-   Array3D<int> cdofs;
-
-   int *smati = nullptr;
-   int *smatj = nullptr;
-   double *smata = nullptr;
-   bool bugfound = false;
-   int nnz = 0;
-
-   Array<int> maxw(dim);
-   maxw = 0;
-
-   for (int d=0; d<dim; ++d)
-   {
-      for (int i=0; i<D1D[d]; ++i)
-      {
-         maxw[d] = std::max(maxw[d], maxDD[d][i] - minDD[d][i] + 1);
-      }
-   }
-
-   cdofs.SetSize(maxw[0], maxw[1], maxw[2]);
-
-   // Compute sparsity of the sparse matrix
-   smati = new int[ndof+1];
-   smati[0] = 0;
-
-   for (int dof_j=0; dof_j<ndof; ++dof_j)
-   {
-      const int jdz = dof_j / (D1D[0] * D1D[1]);
-      const int jdy = (dof_j - (jdz * D1D[0] * D1D[1])) / D1D[0];
-      const int jdx = dof_j - (jdz * D1D[0] * D1D[1]) - (jdy * D1D[0]);
-
-      MFEM_VERIFY(jdx + (D1D[0] * (jdy + (D1D[1] * jdz))) == dof_j, "");
-
-      const int jd[3] = {jdx, jdy, jdz};
-      int ndd = 1;
-      for (int i=0; i<dim; ++i)
-      {
-         nd[i] = maxDD[i][jd[i]] - minDD[i][jd[i]] + 1;
-         ndd *= nd[i];
-      }
-
-      smati[dof_j + 1] = smati[dof_j] + ndd;
-      nnz += ndd;
-   }
-
-   smatj = new int[nnz];
-   smata = new double[nnz];
-
-   for (int i=0; i<nnz; ++i)
-   {
-      smatj[i] = -1;
-      smata[i] = 0.0;
-   }
-
-   for (int dof_j=0; dof_j<ndof; ++dof_j)
-   {
-      const int jdz = dof_j / (D1D[0] * D1D[1]);
-      const int jdy = (dof_j - (jdz * D1D[0] * D1D[1])) / D1D[0];
-      const int jdx = dof_j - (jdz * D1D[0] * D1D[1]) - (jdy * D1D[0]);
-
-      const int jd[3] = {jdx, jdy, jdz};
-      for (int i=0; i<dim; ++i)
-      {
-         nd[i] = maxDD[i][jd[i]] - minDD[i][jd[i]] + 1;
-      }
-
-      for (int i=0; i<nd[0]; ++i)
-         for (int j=0; j<nd[1]; ++j)
-            for (int k=0; k<nd[2]; ++k)
-            {
-               cdofs(i,j,k) = minDD[0][jdx] + i + (D1D[0] *
-                                                   (minDD[1][jdy] + j + (D1D[1] * (minDD[2][jdz] + k))));
-            }
-
-      for (int qz = minD[2][jdz]; qz <= maxD[2][jdz]; ++qz)
-      {
-         for (int qy = minD[1][jdy]; qy <= maxD[1][jdy]; ++qy)
-         {
-            for (int qx = minD[0][jdx]; qx <= maxD[0][jdx]; ++qx)
-            {
-               gradUsed(qx,qy,qz) = false;
-            }
-         }
-      }
-
-      for (int zquad = 0; zquad<2; ++zquad)
-      {
-         // Reduced quadrature in z
-         const int nwz = rid(zquad,2,patch)[jdz].size();
-         for (int irz=0; irz < nwz; ++irz)
-         {
-            const int qz = rid(zquad,2,patch)[jdz][irz] + minD[2][jdz];
-            const double zw = rw(zquad,2,patch)[jdz][irz];
-
-            const double gwz  = B[2](qz,jdz);
-            const double gwDz = G[2](qz,jdz);
-
-            for (int dy = minDD[1][jdy]; dy <= maxDD[1][jdy]; ++dy)
-            {
-               for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-               {
-                  for (int d=0; d<dim; ++d)
-                  {
-                     gradDXY(dx,dy,d) = 0.0;
-                  }
-               }
-            }
-
-            for (int yquad = 0; yquad<2; ++yquad)
-            {
-               // Reduced quadrature in y
-               const int nwy = rid(yquad,1,patch)[jdy].size();
-               for (int iry=0; iry < nwy; ++iry)
-               {
-                  const int qy = rid(yquad,1,patch)[jdy][iry] + minD[1][jdy];
-                  const double yw = rw(yquad,1,patch)[jdy][iry];
-
-                  const double gwy  = B[1](qy,jdy);
-                  const double gwDy = G[1](qy,jdy);
-
-                  for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-                  {
-                     for (int d=0; d<dim; ++d)
-                     {
-                        gradDX(dx,d) = 0.0;
-                     }
-                  }
-
-                  // Reduced quadrature in x
-                  for (int xquad=0; xquad<2; ++xquad)
-                  {
-                     const int nwx = rid(xquad,0,patch)[jdx].size();
-                     for (int irx=0; irx < nwx; ++irx)
-                     {
-                        const int qx = rid(xquad,0,patch)[jdx][irx] + minD[0][jdx];
-
-                        if (!gradUsed(qx,qy,qz))
-                        {
-                           const double gwx  = B[0](qx,jdx);
-                           const double gwDx = G[0](qx,jdx);
-
-                           const int q = qx + ((qy + (qz * Q1D[1])) * Q1D[0]);
-                           const double O11 = qd(q,0);
-                           const double O12 = qd(q,1);
-                           const double O13 = qd(q,2);
-                           const double O21 = symmetric ? O12 : qd(q,3);
-                           const double O22 = symmetric ? qd(q,3) : qd(q,4);
-                           const double O23 = symmetric ? qd(q,4) : qd(q,5);
-                           const double O31 = symmetric ? O13 : qd(q,6);
-                           const double O32 = symmetric ? O23 : qd(q,7);
-                           const double O33 = symmetric ? qd(q,5) : qd(q,8);
-
-                           const double gradX = gwDx * gwy * gwz;
-                           const double gradY = gwx * gwDy * gwz;
-                           const double gradZ = gwx * gwy * gwDz;
-
-                           grad[0](qx,qy,qz) = (O11*gradX)+(O12*gradY)+(O13*gradZ);
-                           grad[1](qx,qy,qz) = (O21*gradX)+(O22*gradY)+(O23*gradZ);
-                           grad[2](qx,qy,qz) = (O31*gradX)+(O32*gradY)+(O33*gradZ);
-
-                           gradUsed(qx,qy,qz) = true;
-                        }
-                     }
-                  }
-
-                  // 00 terms
-                  const int nw = rid(0,0,patch)[jdx].size();
-                  for (int irx=0; irx < nw; ++irx)
-                  {
-                     const int qx = rid(0,0,patch)[jdx][irx] + minD[0][jdx];
-
-                     const double gY = grad[1](qx,qy,qz);
-                     const double gZ = grad[2](qx,qy,qz);
-                     const double xw = rw(0,0,patch)[jdx][irx];
-                     for (int dx = minQ[0][qx]; dx <= maxQ[0][qx]; ++dx)
-                     {
-                        const double wx  = B[0](qx,dx);
-                        if (yquad == 1)
-                        {
-                           gradDX(dx,1) += gY * wx * xw;
-                        }
-                        if (zquad == 1)
-                        {
-                           gradDX(dx,2) += gZ * wx * xw;
-                        }
-                     }
-                  }
-
-                  // 11 terms
-                  const int nw11 = rid(1,0,patch)[jdx].size();
-
-                  for (int irx=0; irx < nw11; ++irx)
-                  {
-                     const int qx = rid(1,0,patch)[jdx][irx] + minD[0][jdx];
-
-                     const double gX = grad[0](qx,qy,qz);
-                     const double xw = rw(1,0,patch)[jdx][irx];
-                     for (int dx = minQ[0][qx]; dx <= maxQ[0][qx]; ++dx)
-                     {
-                        const double wDx = G[0](qx,dx);
-                        gradDX(dx,0) += gX * wDx * xw;
-                     }
-                  }
-
-                  for (int dy = minQ[1][qy]; dy <= maxQ[1][qy]; ++dy)
-                  {
-                     const double wy  = B[1](qy,dy);
-                     const double wDy = G[1](qy,dy);
-                     for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-                     {
-                        if (yquad == 0)
-                        {
-                           if (zquad == 1)
-                           {
-                              gradDXY(dx,dy,2) += gradDX(dx,2) * wy * yw;
-                           }
-                           else
-                           {
-                              gradDXY(dx,dy,0) += gradDX(dx,0) * wy * yw;
-                           }
-                        }
-                        else if (zquad == 0)
-                        {
-                           gradDXY(dx,dy,1) += gradDX(dx,1) * wDy * yw;
-                        }
-                     }
-                  }
-               } // qy
-            } // y quadrature type
-            for (int dz = minQ[2][qz]; dz <= maxQ[2][qz]; ++dz)
-            {
-               const double wz  = B[2](qz,dz);
-               const double wDz = G[2](qz,dz);
-               for (int dy = minDD[1][jdy]; dy <= maxDD[1][jdy]; ++dy)
-               {
-                  for (int dx = minDD[0][jdx]; dx <= maxDD[0][jdx]; ++dx)
-                  {
-                     double v = (zquad == 0) ? (gradDXY(dx,dy,0) * wz) +
-                                (gradDXY(dx,dy,1) * wz) : gradDXY(dx,dy,2) * wDz;
-
-                     v *= zw;
-
-                     const int loc = dx - minDD[0][jd[0]] + (nd[0] * (dy - minDD[1][jd[1]] +
-                                                                      (nd[1] * (dz - minDD[2][jd[2]]))));
-
-                     const int odof = cdofs(dx - minDD[0][jd[0]],
-                                            dy - minDD[1][jd[1]],
-                                            dz - minDD[2][jd[2]]);
-
-                     const int m = smati[dof_j] + loc;
-                     if (!(smatj[m] == odof || smatj[m] == -1))
-                     {
-                        bugfound = true;
-                     }
-
-                     smatj[m] = odof;
-                     smata[m] += v;
-                  } // dx
-               } // dy
-            } // dz
-         } // qz
-      } // zquad
-   } // dof_j
-
-   MFEM_VERIFY(!bugfound, "");
-
-   for (int i=0; i<nnz; ++i)
-   {
-      if (smata[i] == 0.0)
-      {
-         // This prevents failure of SparseMatrix EliminateRowCol.
-         // TODO: is there a better solution?
-         smata[i] = 1.0e-16;
-      }
-   }
-
-   // Note that smat takes ownership of its input data.
-   smat = new SparseMatrix(smati, smatj, smata, ndof, ndof);
-}
-
-void DiffusionIntegrator::AssemblePatchMatrix(const int patch,
-                                              const FiniteElementSpace &fes,
-                                              SparseMatrix*& smat)
-{
-   if (integrationMode == PATCHWISE_REDUCED)
-   {
-      AssemblePatchMatrix_reducedQuadrature(patch, fes, smat);
-   }
-   else
-   {
-      AssemblePatchMatrix_fullQuadrature(patch, fes, smat);
-   }
-}
-
-}
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 7d6b8c5df..20ef4684d 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -158,27 +158,6 @@ static void PAGradientSetup3D(const int Q1D,
    });
 }
 
-static void PAGradientSetup(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &W,
-                            const Vector &J,
-                            const Vector &COEFF,
-                            Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAGradientSetup"); }
-   if (dim == 2)
-   {
-      PAGradientSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PAGradientSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                     const FiniteElementSpace &test_fes)
 {
@@ -209,8 +188,18 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAGradientSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                   ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in GradientIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAGradientSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAGradientSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Gradient Apply 2D kernel
@@ -787,40 +776,21 @@ static void SmemPAGradientApply3D(const int NE,
    });
 }
 
-static void PAGradientApply(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &B,
-                            const Array<double> &G,
-                            const Array<double> &Bt,
-                            const Vector &op,
-                            const Vector &x,
-                            Vector &y,
-                            bool transpose=false)
+void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-
    if (dim == 2)
    {
-      return PAGradientApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      return PAGradientApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Gradient Apply kernel
-void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PAGradientApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                   trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                   false);
-}
-
-// PA Gradient Apply kernel
 void GradientIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    MFEM_ABORT("PA Gradient AddMultTransposePA not implemented.");
diff --git a/fem/integ/bilininteg_mass_ea.cpp b/fem/integ/bilininteg_mass_ea.cpp
index 4cafa68f3..315b9da8f 100644
--- a/fem/integ/bilininteg_mass_ea.cpp
+++ b/fem/integ/bilininteg_mass_ea.cpp
@@ -21,7 +21,6 @@ static void EAMassAssemble1D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -53,14 +52,7 @@ static void EAMassAssemble1D(const int NE,
             {
                val += r_Bi[k1] * r_Bj[k1] * D(k1, e);
             }
-            if (add)
-            {
-               M(i1, j1, e) += val;
-            }
-            else
-            {
-               M(i1, j1, e) = val;
-            }
+            M(i1, j1, e) += val;
          }
       }
    });
@@ -71,7 +63,6 @@ static void EAMassAssemble2D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -123,14 +114,7 @@ static void EAMassAssemble2D(const int NE,
                                * s_D[k1][k2];
                      }
                   }
-                  if (add)
-                  {
-                     M(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     M(i1, i2, j1, j2, e) = val;
-                  }
+                  M(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -143,7 +127,6 @@ static void EAMassAssemble3D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -237,14 +220,7 @@ static void EAMassAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        M(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -255,8 +231,7 @@ static void EAMassAssemble3D(const int NE,
 }
 
 void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                Vector &ea_data,
-                                const bool add)
+                                Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -265,15 +240,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -281,15 +256,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -297,14 +272,14 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data,add);
-         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data,add);
-         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data,add);
-         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data,add);
-         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data,add);
-         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data,add);
-         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,add,
+         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data);
+         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data);
+         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data);
+         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data);
+         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data);
+         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data);
+         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_mass_kernels.hpp b/fem/integ/bilininteg_mass_kernels.hpp
index 991a5ff99..488d843cb 100644
--- a/fem/integ/bilininteg_mass_kernels.hpp
+++ b/fem/integ/bilininteg_mass_kernels.hpp
@@ -468,7 +468,6 @@ void SmemPAMassApply2D_Element(const int e,
    double (*QQ)[MQ1] = (double (*)[MQ1]) (sm0 + tidz);
    double (*QD)[MD1] = (double (*)[MD1]) (sm1 + tidz);
 
-
    MFEM_FOREACH_THREAD(dy,y,D1D)
    {
       MFEM_FOREACH_THREAD(dx,x,D1D)
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index 18a0edfca..b1e98f682 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index 7695403e7..ea52b6953 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -25,7 +25,6 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
                          Device::GetDeviceMemoryType() : pa_mt;
 
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -79,7 +78,7 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             {
                const double detJ = J(qx,qy,e);
                const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
             }
          }
       });
@@ -119,7 +118,6 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
                          Device::GetDeviceMemoryType() : pa_mt;
 
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNBE() == 0) { return; }
    const FiniteElement &el = *fes.GetBE(0);
@@ -157,7 +155,7 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
          {
             const double detJ = J(qx,e);
             const double coeff = const_c ? C(0,0) : C(qx,e);
-            v(qx,e) =  W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
+            v(qx,e) = W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
          }
       });
    }
@@ -176,7 +174,7 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
             {
                const double detJ = J(qx,qy,e);
                const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
             }
          }
       });
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index 8be2134dd..a3c113982 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -265,9 +265,9 @@ void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
    }
 }
 
-void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorWeakCurlIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index 4f50dcc92..f9e6d3ee8 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -656,9 +656,9 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with a vector test space and H^1 trial space.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_transpose_ea.cpp b/fem/integ/bilininteg_transpose_ea.cpp
index 4ff8be04b..e1ac154fc 100644
--- a/fem/integ/bilininteg_transpose_ea.cpp
+++ b/fem/integ/bilininteg_transpose_ea.cpp
@@ -16,171 +16,91 @@ namespace mfem
 {
 
 void TransposeIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data, const bool add)
+                                     Vector &ea_data)
 {
-   if (add)
-   {
-      Vector ea_data_tmp(ea_data.Size());
-      bfi->AssembleEA(fes, ea_data_tmp, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
-      auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
-      {
-         for (int i = 0; i < dofs; i++)
-         {
-            for (int j = 0; j < dofs; j++)
-            {
-               const double a = A(i, j, e);
-               AT(j, i, e) += a;
-            }
-         }
-      });
-   }
-   else
+   const int ne = fes.GetNE();
+   if (ne == 0) { return; }
+
+   const int dofs = fes.GetFE(0)->GetDof();
+   Vector ea_data_tmp(ea_data.Size());
+   ea_data_tmp = 0.0;
+   bfi->AssembleEA(fes, ea_data_tmp);
+   auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
+   auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
+   mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
    {
-      bfi->AssembleEA(fes, ea_data, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
+      for (int i = 0; i < dofs; i++)
       {
-         for (int i = 0; i < dofs; i++)
+         for (int j = 0; j < dofs; j++)
          {
-            for (int j = i+1; j < dofs; j++)
-            {
-               const double aij = A(i, j, e);
-               const double aji = A(j, i, e);
-               A(j, i, e) = aij;
-               A(i, j, e) = aji;
-            }
+            const double a = A(i, j, e);
+            AT(j, i, e) += a;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
+void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                                   Vector &ea_data_int,
-                                                  Vector &ea_data_ext,
-                                                  const bool add)
+                                                  Vector &ea_data_ext)
 {
    const int nf = fes.GetNFbyType(FaceType::Interior);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_int_tmp(ea_data_int.Size());
-      Vector ea_data_ext_tmp(ea_data_ext.Size());
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto AT_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto AT_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_int0 = A_int(i, j, 0, f);
-               const double a_int1 = A_int(i, j, 1, f);
-               const double a_ext0 = A_ext(i, j, 0, f);
-               const double a_ext1 = A_ext(i, j, 1, f);
-               AT_int(j, i, 0, f) += a_int0;
-               AT_int(j, i, 1, f) += a_int1;
-               AT_ext(j, i, 0, f) += a_ext1;
-               AT_ext(j, i, 1, f) += a_ext0;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_int_tmp(ea_data_int.Size());
+   Vector ea_data_ext_tmp(ea_data_ext.Size());
+   ea_data_int_tmp = 0.0;
+   ea_data_ext_tmp = 0.0;
+   bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp);
+   auto A_int = Reshape(ea_data_int_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto A_ext = Reshape(ea_data_ext_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto AT_int = Reshape(ea_data_int.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   auto AT_ext = Reshape(ea_data_ext.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_int0 = A_int(i, j, 0, f);
-               const double aij_int1 = A_int(i, j, 1, f);
-               const double aji_int0 = A_int(j, i, 0, f);
-               const double aji_int1 = A_int(j, i, 1, f);
-               A_int(j, i, 0, f) = aij_int0;
-               A_int(j, i, 1, f) = aij_int1;
-               A_int(i, j, 0, f) = aji_int0;
-               A_int(i, j, 1, f) = aji_int1;
-            }
-         }
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double aij_ext0 = A_ext(i, j, 0, f);
-               const double aji_ext1 = A_ext(j, i, 1, f);
-               A_ext(j, i, 1, f) = aij_ext0;
-               A_ext(i, j, 0, f) = aji_ext1;
-            }
+            const double a_int0 = A_int(i, j, 0, f);
+            const double a_int1 = A_int(i, j, 1, f);
+            const double a_ext0 = A_ext(i, j, 0, f);
+            const double a_ext1 = A_ext(i, j, 1, f);
+            AT_int(j, i, 0, f) += a_int0;
+            AT_int(j, i, 1, f) += a_int1;
+            AT_ext(j, i, 0, f) += a_ext1;
+            AT_ext(j, i, 1, f) += a_ext0;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                  Vector &ea_data_bdr,
-                                                  const bool add)
+void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
+                                                  Vector &ea_data_bdr)
 {
    const int nf = fes.GetNFbyType(FaceType::Boundary);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_bdr_tmp(ea_data_bdr.Size());
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), faceDofs, faceDofs, nf);
-      auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_bdr = A_bdr(i, j, f);
-               AT_bdr(j, i, f) += a_bdr;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_bdr_tmp(ea_data_bdr.Size());
+   ea_data_bdr_tmp = 0.0;
+   bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp);
+   auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), face_dofs, face_dofs, nf);
+   auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), face_dofs, face_dofs, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_bdr = A_bdr(i, j, f);
-               const double aji_bdr = A_bdr(j, i, f);
-               A_bdr(j, i, f) = aij_bdr;
-               A_bdr(i, j, f) = aji_bdr;
-            }
+            const double a_bdr = A_bdr(i, j, f);
+            AT_bdr(j, i, f) += a_bdr;
          }
-      });
-   }
+      }
+   });
 }
 
 }
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 88d0b136f..84e4d5b2a 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -36,7 +36,6 @@ static void PAVectorDiffusionSetup2D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ, NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -72,7 +71,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ,NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -114,28 +112,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    });
 }
 
-static void PAVectorDiffusionSetup(const int dim,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
-{
-   if (!(dim == 2 || dim == 3))
-   {
-      MFEM_ABORT("Dimension not supported.");
-   }
-   if (dim == 2)
-   {
-      PAVectorDiffusionSetup2D(Q1D, NE, W, J, C, op);
-   }
-   if (dim == 3)
-   {
-      PAVectorDiffusionSetup3D(Q1D, NE, W, J, C, op);
-   }
-}
-
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assumes tensor-product elements
@@ -179,7 +155,10 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const Array<double> &w = ir->GetWeights();
    const Vector &j = geom->J;
    Vector &d = pa_data;
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAVectorDiffusionSetup"); }
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDiffusionIntegrator::AssemblePA");
+   }
    if (dim == 2 && sdim == 3)
    {
       constexpr int DIM = 2;
@@ -218,7 +197,15 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
    else
    {
-      PAVectorDiffusionSetup(dim, quad1D, ne, w, j, coeff, d);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionSetup2D(quad1D, ne, w, j, coeff, d);
+      }
+      if (dim == 3)
+      {
+         return PAVectorDiffusionSetup3D(quad1D, ne, w, j, coeff, d);
+      }
+      MFEM_ABORT("Dimension not supported.");
    }
 }
 
@@ -391,26 +378,6 @@ static void PAVectorDiffusionDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorDiffusionAssembleDiagonal(const int dim,
-                                              const int D1D,
-                                              const int Q1D,
-                                              const int NE,
-                                              const Array<double> &B,
-                                              const Array<double> &G,
-                                              const Vector &op,
-                                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -419,25 +386,35 @@ void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorDiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                        maps->B, maps->G,
-                                        pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionDiagonal2D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorDiffusionDiagonal3D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
 // PA Diffusion Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0> static
-void PAVectorDiffusionApply2D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0,
-                              const int vdim = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0>
+static void PAVectorDiffusionApply2D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &d_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0,
+                                     const int vdim = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -548,17 +525,16 @@ void PAVectorDiffusionApply2D(const int NE,
 }
 
 // PA Diffusion Apply 3D kernel
-template<const int T_D1D = 0,
-         const int T_Q1D = 0> static
-void PAVectorDiffusionApply3D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              int d1d = 0, int q1d = 0)
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorDiffusionApply3D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     int d1d = 0, int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -741,7 +717,6 @@ void PAVectorDiffusionApply3D(const int NE,
    });
 }
 
-// PA Diffusion Apply kernel
 void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -771,11 +746,13 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
          }
       }
       if (dim == 2 && sdim == 2)
-      { return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim); }
-
+      {
+         return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim);
+      }
       if (dim == 3 && sdim == 3)
-      { return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D); }
-
+      {
+         return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D);
+      }
       MFEM_ABORT("Unknown kernel.");
    }
 }
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index cc282a49a..63f7a3308 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -96,27 +96,6 @@ static void PADivergenceSetup3D(const int Q1D,
    });
 }
 
-static void PADivergenceSetup(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const double COEFF,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADivergenceSetup"); }
-   if (dim == 2)
-   {
-      PADivergenceSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PADivergenceSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                             const FiniteElementSpace &test_fes)
 {
@@ -143,6 +122,7 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    MFEM_ASSERT(quad1D == test_maps->nqpt,
                "PA requires test and trial space to have same number of quadrature points!");
    pa_data.SetSize(nq * dimsToStore * ne, Device::GetMemoryType());
+
    double coeff = 1.0;
    if (Q)
    {
@@ -150,8 +130,19 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_VERIFY(cQ != NULL, "only ConstantCoefficient is supported!");
       coeff = cQ->constant;
    }
-   PADivergenceSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                     ne, ir->GetWeights(), geom->J, coeff, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDivergenceIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PADivergenceSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADivergenceSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Divergence Apply 2D kernel
@@ -1021,59 +1012,37 @@ static void SmemPADivergenceApply3D(const int NE,
    });
 }
 
-static void PADivergenceApply(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &G,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y,
-                              bool transpose=false)
+void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (dim == 2)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Divergence Apply kernel
-void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                     false);
-}
-
-// PA Divergence Apply kernel
 void VectorDivergenceIntegrator::AddMultTransposePA(const Vector &x,
                                                     Vector &y) const
 {
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->Bt, trial_maps->Gt, test_maps->B, pa_data, x, y,
-                     true);
+   if (dim == 2)
+   {
+      return PADivergenceApplyTranspose2D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   if (dim == 3)
+   {
+      return PADivergenceApplyTranspose3D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   MFEM_ABORT("Unknown kernel.");
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index faafdf14d..b1c20b4c4 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -78,7 +78,7 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             const double J21 = J(q,0,1,e);
             const double J22 = J(q,1,1,e);
             const double detJ = (J11*J22)-(J21*J12);
-            v(q,e) =  w[q] * constant * detJ;
+            v(q,e) = w[q] * constant * detJ;
          }
       });
    }
@@ -234,26 +234,6 @@ static void PAVectorMassAssembleDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorMassAssembleDiagonal(const int dim,
-                                         const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &B,
-                                         const Array<double> &Bt,
-                                         const Vector &op,
-                                         Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -262,9 +242,19 @@ void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorMassAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                   maps->B, maps->Bt,
-                                   pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorMassAssembleDiagonal2D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorMassAssembleDiagonal3D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
@@ -509,27 +499,6 @@ static void PAVectorMassApply3D(const int NE,
    });
 }
 
-static void PAVectorMassApply(const int dim,
-                              const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassApply2D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   if (dim == 3)
-   {
-      return PAVectorMassApply3D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
 void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -538,7 +507,17 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
    else
    {
-      PAVectorMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
+      if (dim == 2)
+      {
+         return PAVectorMassApply2D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      if (dim == 3)
+      {
+         return PAVectorMassApply3D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      MFEM_ABORT("Unknown kernel.");
    }
 }
 
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index f8d6f63d4..c07e9f816 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -20,11 +20,6 @@
 namespace mfem
 {
 
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   AssemblePA(fes, fes);
-}
-
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index 98cee62a6..b9f047817 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -16,10 +16,10 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -50,10 +50,10 @@ void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 9bf3af218..5cca01a1d 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -16,11 +16,12 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -108,12 +109,13 @@ void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff,
-                       double *output)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff,
+                              double *output)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index faee69c96..00561ff75 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -16,7 +16,6 @@
 // Formulas at http://nines.cs.kuleuven.be/research/ecf/ecf.html
 
 #include "fem.hpp"
-#include "../mesh/nurbs.hpp"
 #include <cmath>
 
 #ifdef MFEM_USE_MPFR
@@ -174,51 +173,6 @@ void IntegrationRule::GrundmannMollerSimplexRule(int s, int n)
    }
 }
 
-IntegrationRule*
-IntegrationRule::ApplyToKnotIntervals(KnotVector const& kv) const
-{
-   const int np = this->GetNPoints();
-   const int ne = kv.GetNE();
-
-   IntegrationRule *kvir = new IntegrationRule(ne * np);
-
-   double x0 = kv[0];
-   double x1 = x0;
-
-   int id = 0;
-   for (int e=0; e<ne; ++e)
-   {
-      x0 = x1;
-
-      if (e == ne-1)
-      {
-         x1 = kv[kv.Size() - 1];
-      }
-      else
-      {
-         // Find the next unique knot
-         while (id < kv.Size() - 1)
-         {
-            id++;
-            if (kv[id] != x0)
-            {
-               x1 = kv[id];
-               break;
-            }
-         }
-      }
-
-      const double s = x1 - x0;
-
-      for (int j=0; j<this->GetNPoints(); ++j)
-      {
-         const double x = x0 + (s * (*this)[j].x);
-         (*kvir)[(e * np) + j].Set1w(x, (*this)[j].weight);
-      }
-   }
-
-   return kvir;
-}
 
 #ifdef MFEM_USE_MPFR
 
@@ -1796,235 +1750,4 @@ IntegrationRule *IntegrationRules::CubeIntegrationRule(int Order)
    return CubeIntRules[Order];
 }
 
-IntegrationRule& NURBSMeshRules::GetElementRule(const int elem,
-                                                const int patch, const int *ijk,
-                                                Array<const KnotVector*> const& kv,
-                                                bool & deleteRule) const
-{
-   deleteRule = false;
-
-   // First check whether a rule has been assigned to element index elem.
-   auto search = elementToRule.find(elem);
-   if (search != elementToRule.end())
-   {
-      return *elementRule[search->second];
-   }
-
-   MFEM_VERIFY(patchRules1D.NumRows(),
-               "Undefined rule in NURBSMeshRules::GetElementRule");
-
-   // Use a tensor product of rules on the patch.
-   MFEM_VERIFY(kv.Size() == dim, "");
-
-   int np = 1;
-   std::vector<std::vector<double>> el(dim);
-
-   std::vector<int> npd;
-   npd.assign(3, 0);
-
-   for (int d=0; d<dim; ++d)
-   {
-      const int order = kv[d]->GetOrder();
-
-      const double kv0 = (*kv[d])[order + ijk[d]];
-      const double kv1 = (*kv[d])[order + ijk[d] + 1];
-
-      const bool rightEnd = (order + ijk[d] + 1) == (kv[d]->Size() - 1);
-
-      for (int i=0; i<patchRules1D(patch,d)->Size(); ++i)
-      {
-         const IntegrationPoint& ip = (*patchRules1D(patch,d))[i];
-         if (kv0 <= ip.x && (ip.x < kv1 || rightEnd))
-         {
-            const double x = (ip.x - kv0) / (kv1 - kv0);
-            el[d].push_back(x);
-            el[d].push_back(ip.weight);
-         }
-      }
-
-      npd[d] = el[d].size() / 2;
-      np *= npd[d];
-   }
-
-   IntegrationRule *irp = new IntegrationRule(np);
-   deleteRule = true;
-
-   // Set (*irp)[i + j*npd[0] + k*npd[0]*npd[1]] =
-   //     (el[0][2*i], el[1][2*j], el[2][2*k])
-
-   MFEM_VERIFY(npd[0] > 0 && npd[1] > 0, "Assuming 2D or 3D");
-
-   for (int i = 0; i < npd[0]; ++i)
-   {
-      for (int j = 0; j < npd[1]; ++j)
-      {
-         for (int k = 0; k < std::max(npd[2], 1); ++k)
-         {
-            const int id = i + j*npd[0] + k*npd[0]*npd[1];
-            (*irp)[id].x = el[0][2*i];
-            (*irp)[id].y = el[1][2*j];
-
-            (*irp)[id].weight = el[0][(2*i)+1];
-            (*irp)[id].weight *= el[1][(2*j)+1];
-
-            if (npd[2] > 0)
-            {
-               (*irp)[id].z = el[2][2*k];
-               (*irp)[id].weight *= el[2][(2*k)+1];
-            }
-         }
-      }
-   }
-
-   return *irp;
-}
-
-void NURBSMeshRules::GetIntegrationPointFrom1D(const int patch, int i, int j,
-                                               int k, IntegrationPoint & ip)
-{
-   MFEM_VERIFY(patchRules1D.NumRows() > 0,
-               "Assuming patchRules1D is set.");
-
-   ip.weight = (*patchRules1D(patch,0))[i].weight;
-   ip.x = (*patchRules1D(patch,0))[i].x;
-
-   if (dim > 1)
-   {
-      ip.weight *= (*patchRules1D(patch,1))[j].weight;
-      ip.y = (*patchRules1D(patch,1))[j].x;  // 1D rule only has x
-   }
-
-   if (dim > 2)
-   {
-      ip.weight *= (*patchRules1D(patch,2))[k].weight;
-      ip.z = (*patchRules1D(patch,2))[k].x;  // 1D rule only has x
-   }
-}
-
-void NURBSMeshRules::Finalize(Mesh const& mesh)
-{
-   if ((int) pointToElem.size() == npatches) { return; }  // Already set
-
-   MFEM_VERIFY(elementToRule.empty() && patchRules1D.NumRows() > 0
-               && npatches > 0, "Assuming patchRules1D is set.");
-   MFEM_VERIFY(mesh.NURBSext, "");
-   MFEM_VERIFY(mesh.Dimension() == dim, "");
-
-   pointToElem.resize(npatches);
-   patchRules1D_KnotSpan.resize(npatches);
-
-   // First, find all the elements in each patch.
-   std::vector<std::vector<int>> patchElements(npatches);
-
-   for (int e=0; e<mesh.GetNE(); ++e)
-   {
-      patchElements[mesh.NURBSext->GetElementPatch(e)].push_back(e);
-   }
-
-   Array<int> ijk(3);
-   Array<int> maxijk(3);
-   Array<int> np(3);  // Number of points in each dimension
-   ijk = 0;
-
-   Array<const KnotVector*> pkv;
-
-   for (int p=0; p<npatches; ++p)
-   {
-      patchRules1D_KnotSpan[p].resize(dim);
-
-      // For each patch, get the range of ijk.
-      mesh.NURBSext->GetPatchKnotVectors(p, pkv);
-      MFEM_VERIFY((int) pkv.Size() == dim, "");
-
-      maxijk = 1;
-      np = 1;
-      for (int d=0; d<dim; ++d)
-      {
-         maxijk[d] = pkv[d]->GetNKS();
-         np[d] = patchRules1D(p,d)->Size();
-      }
-
-      // For each patch, set a map from ijk to element index.
-      Array3D<int> ijk2elem(maxijk[0], maxijk[1], maxijk[2]);
-      ijk2elem = -1;
-
-      for (auto elem : patchElements[p])
-      {
-         mesh.NURBSext->GetElementIJK(elem, ijk);
-         MFEM_VERIFY(ijk2elem(ijk[0], ijk[1], ijk[2]) == -1, "");
-         ijk2elem(ijk[0], ijk[1], ijk[2]) = elem;
-      }
-
-      // For each point, find its ijk and from that its element index.
-      // It is assumed here that the NURBSFiniteElement kv the same as the
-      // patch kv.
-
-      for (int d=0; d<dim; ++d)
-      {
-         patchRules1D_KnotSpan[p][d].SetSize(patchRules1D(p,d)->Size());
-
-         for (int r=0; r<patchRules1D(p,d)->Size(); ++r)
-         {
-            const IntegrationPoint& ip = (*patchRules1D(p,d))[r];
-
-            const int order = pkv[d]->GetOrder();
-
-            // Find ijk_d such that ip.x is in the corresponding knot-span.
-            int ijk_d = 0;
-            bool found = false;
-            while (!found)
-            {
-               const double kv0 = (*pkv[d])[order + ijk_d];
-               const double kv1 = (*pkv[d])[order + ijk_d + 1];
-
-               const bool rightEnd = (order + ijk_d + 1) == (pkv[d]->Size() - 1);
-
-               if (kv0 <= ip.x && (ip.x < kv1 || rightEnd))
-               {
-                  found = true;
-               }
-               else
-               {
-                  ijk_d++;
-               }
-            }
-
-            patchRules1D_KnotSpan[p][d][r] = ijk_d;
-         }
-      }
-
-      pointToElem[p].SetSize(np[0], np[1], np[2]);
-      for (int i=0; i<np[0]; ++i)
-         for (int j=0; j<np[1]; ++j)
-            for (int k=0; k<np[2]; ++k)
-            {
-               const int elem = ijk2elem(patchRules1D_KnotSpan[p][0][i],
-                                         patchRules1D_KnotSpan[p][1][j],
-                                         patchRules1D_KnotSpan[p][2][k]);
-               MFEM_VERIFY(elem >= 0, "");
-               pointToElem[p](i,j,k) = elem;
-            }
-   } // Loop (p) over patches
-}
-
-void NURBSMeshRules::SetPatchRules1D(const int patch,
-                                     std::vector<const IntegrationRule*> & ir1D)
-{
-   MFEM_VERIFY((int) ir1D.size() == dim, "Wrong dimension");
-
-   for (int i=0; i<dim; ++i)
-   {
-      patchRules1D(patch,i) = ir1D[i];
-   }
-}
-
-NURBSMeshRules::~NURBSMeshRules()
-{
-   for (int i=0; i<patchRules1D.NumRows(); ++i)
-      for (int j=0; j<patchRules1D.NumCols(); ++j)
-      {
-         delete patchRules1D(i, j);
-      }
-}
-
 }
diff --git a/fem/intrules.hpp b/fem/intrules.hpp
index 5ff8e5de7..4fadbd291 100644
--- a/fem/intrules.hpp
+++ b/fem/intrules.hpp
@@ -18,15 +18,9 @@
 #include <omp.h>
 #endif
 
-#include <vector>
-#include <map>
-
 namespace mfem
 {
 
-class KnotVector;
-class Mesh;
-
 /* Classes for IntegrationPoint, IntegrationRule, and container class
    IntegrationRules.  Declares the global variable IntRules */
 
@@ -266,105 +260,10 @@ public:
        a call like this: `IntPoint(i).weight`. */
    const Array<double> &GetWeights() const;
 
-   /// @brief Return an integration rule for KnotVector @a kv, defined by
-   /// applying this rule on each knot interval.
-   IntegrationRule* ApplyToKnotIntervals(KnotVector const& kv) const;
-
    /// Destroys an IntegrationRule object
    ~IntegrationRule() { }
 };
 
-/// Class for defining different integration rules on each NURBS patch.
-class NURBSMeshRules
-{
-public:
-   /// Construct a rule for each patch, using SetPatchRules1D.
-   NURBSMeshRules(const int numPatches, const int dim_) :
-      patchRules1D(numPatches, dim_),
-      npatches(numPatches), dim(dim_) { }
-
-   /// Returns a rule for the element.
-   IntegrationRule &GetElementRule(const int elem, const int patch,
-                                   const int *ijk,
-                                   Array<const KnotVector*> const& kv,
-                                   bool & deleteRule) const;
-
-   /// Add a rule to be used for individual elements. Returns the rule index.
-   std::size_t AddElementRule(IntegrationRule *ir_element)
-   {
-      elementRule.push_back(ir_element);
-      return elementRule.size() - 1;
-   }
-
-   /// @brief Set the integration rule for the element of the given index. This
-   /// rule is used instead of the rule for the patch containing the element.
-   void SetElementRule(const std::size_t element,
-                       const std::size_t elementRuleIndex)
-   {
-      elementToRule[element] = elementRuleIndex;
-   }
-
-   /// @brief Set 1D integration rules to be used as a tensor product rule on
-   /// the patch with index @a patch. This class takes ownership of these rules.
-   void SetPatchRules1D(const int patch,
-                        std::vector<const IntegrationRule*> & ir1D);
-
-   /// @brief For tensor product rules defined on each patch by
-   /// SetPatchRules1D(), return a pointer to the 1D rule in the specified
-   /// @a dimension.
-   const IntegrationRule* GetPatchRule1D(const int patch,
-                                         const int dimension) const
-   {
-      return patchRules1D(patch, dimension);
-   }
-
-   /// @brief For tensor product rules defined on each patch by
-   /// SetPatchRules1D(), return the integration point with index (i,j,k).
-   void GetIntegrationPointFrom1D(const int patch, int i, int j, int k,
-                                  IntegrationPoint & ip);
-
-   /// @brief Finalize() must be called before this class can be used for
-   /// assembly. In particular, it defines data used by GetPointElement().
-   void Finalize(Mesh const& mesh);
-
-   /// @brief For tensor product rules defined on each patch by
-   /// SetPatchRules1D(), returns the index of the element containing
-   /// integration point (i,j,k) for patch index @a patch. Finalize() must be
-   /// called first.
-   int GetPointElement(int patch, int i, int j, int k) const
-   {
-      return pointToElem[patch](i,j,k);
-   }
-
-   int GetDim() const { return dim; }
-
-   /// @brief For tensor product rules defined on each patch by
-   /// SetPatchRules1D(), returns an array of knot span indices for each
-   /// integration point in the specified @a dimension.
-   const Array<int>& GetPatchRule1D_KnotSpan(const int patch,
-                                             const int dimension) const
-   {
-      return patchRules1D_KnotSpan[patch][dimension];
-   }
-
-   ~NURBSMeshRules();
-
-private:
-   /// Tensor-product rules defined on all patches independently.
-   Array2D<const IntegrationRule*> patchRules1D;
-
-   /// Integration rules defined on elements.
-   std::vector<IntegrationRule*> elementRule;
-
-   std::map<std::size_t, std::size_t> elementToRule;
-
-   std::vector<Array3D<int>> pointToElem;
-   std::vector<std::vector<Array<int>>> patchRules1D_KnotSpan;
-
-   const int npatches;
-   const int dim;
-};
-
 /// A Class that defines 1-D numerical quadrature rules on [0,1].
 class QuadratureFunctions1D
 {
diff --git a/fem/linearform.hpp b/fem/linearform.hpp
index c24118426..29f816db1 100644
--- a/fem/linearform.hpp
+++ b/fem/linearform.hpp
@@ -121,10 +121,6 @@ public:
    LinearForm &operator=(const LinearForm &rhs)
    { return operator=((const Vector &)rhs); }
 
-   /// (DEPRECATED) Return the FE space associated with the LinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Read+write access to the associated FiniteElementSpace.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
diff --git a/fem/linearform_ext.cpp b/fem/linearform_ext.cpp
index f70a7b6e3..3475574fd 100644
--- a/fem/linearform_ext.cpp
+++ b/fem/linearform_ext.cpp
@@ -164,10 +164,8 @@ void LinearFormExtension::Update()
          }
       }
 
-      bdr_restrict_lex =
-         dynamic_cast<const FaceRestriction*>(
-            fes.GetFaceRestriction(ordering, FaceType::Boundary,
-                                   L2FaceValues::SingleValued));
+      bdr_restrict_lex = fes.GetFaceRestriction(ordering, FaceType::Boundary,
+                                                L2FaceValues::SingleValued);
       MFEM_VERIFY(bdr_restrict_lex, "Face restriction not available");
       bdr_b.SetSize(bdr_restrict_lex->Height(), Device::GetMemoryType());
       bdr_b.UseDevice(true);
diff --git a/fem/linearform_ext.hpp b/fem/linearform_ext.hpp
index 2cc861cea..46acf637d 100644
--- a/fem/linearform_ext.hpp
+++ b/fem/linearform_ext.hpp
@@ -34,7 +34,7 @@ class LinearFormExtension
    LinearForm *lf;
 
    /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
-   const ElementRestrictionOperator *elem_restrict_lex; // Not owned
+   const ElementRestriction *elem_restrict_lex; // Not owned
 
    /// Operator that converts L-vectors to boundary E-vectors.
    const FaceRestriction *bdr_restrict_lex; // Not owned
diff --git a/fem/lor/lor_ads.cpp b/fem/lor/lor_ads.cpp
index 3ba4816ee..f962f8469 100644
--- a/fem/lor/lor_ads.cpp
+++ b/fem/lor/lor_ads.cpp
@@ -103,9 +103,9 @@ void BatchedLOR_ADS::FormCurlMatrix()
    Form3DFaceToEdge(face2edge);
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_f = dynamic_cast<const ElementRestriction*>(
+   const auto *R_f = dynamic_cast<const ConformingElementRestriction*>(
                         face_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_f != NULL && R_e != NULL, "");
 
diff --git a/fem/lor/lor_ams.cpp b/fem/lor/lor_ams.cpp
index 1c37f165b..0d7ac222f 100644
--- a/fem/lor/lor_ams.cpp
+++ b/fem/lor/lor_ams.cpp
@@ -163,9 +163,9 @@ void BatchedLOR_AMS::FormGradientMatrix()
    else { Form3DEdgeToVertex(edge2vertex); }
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_v = dynamic_cast<const ElementRestriction*>(
+   const auto *R_v = dynamic_cast<const ConformingElementRestriction*>(
                         vert_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_v != NULL && R_e != NULL, "");
 
@@ -268,7 +268,7 @@ void BatchedLOR_AMS::FormCoordinateVectors(const Vector &X_vert)
    // Create the H1 vertex space and get the element restriction
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = vert_fes.GetElementRestriction(ordering);
-   const auto *el_restr = dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr = dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != NULL, "");
    const SparseMatrix *R = vert_fes.GetRestrictionMatrix();
 
diff --git a/fem/lor/lor_batched.cpp b/fem/lor/lor_batched.cpp
index fe0494880..0050c3de5 100644
--- a/fem/lor/lor_batched.cpp
+++ b/fem/lor/lor_batched.cpp
@@ -145,8 +145,8 @@ int BatchedLORAssembly::FillI(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
@@ -235,8 +235,8 @@ void BatchedLORAssembly::FillJAndData(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
diff --git a/fem/nonlinearform.hpp b/fem/nonlinearform.hpp
index d15d09e04..60cae2055 100644
--- a/fem/nonlinearform.hpp
+++ b/fem/nonlinearform.hpp
@@ -330,7 +330,6 @@ public:
    virtual ~BlockNonlinearForm();
 };
 
-
 }
 
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index e1558fda4..5ee1febea 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,68 +15,69 @@
 namespace mfem
 {
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
-{
-   mfem_error ("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
-               "   is not implemented for this class.");
-   return 0.0;
-}
-
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace &,
-                                         const FiniteElementSpace &)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
+                                             const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+double NonlinearFormIntegrator::GetElementEnergy(
+   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
+              " is not overloaded!");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleElementVector(
    const FiniteElement &el, ElementTransformation &Tr,
    const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -84,7 +85,7 @@ void NonlinearFormIntegrator::AssembleFaceVector(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -92,7 +93,7 @@ void NonlinearFormIntegrator::AssembleElementGrad(
    const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -101,18 +102,10 @@ void NonlinearFormIntegrator::AssembleFaceGrad(
    FaceElementTransformations &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
-{
-   mfem_error("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
-}
-
 
 void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const FiniteElement *> &el,
@@ -120,7 +113,7 @@ void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvec)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -131,7 +124,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvect)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -141,7 +134,7 @@ void BlockNonlinearFormIntegrator::AssembleElementGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -152,7 +145,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
@@ -161,7 +154,7 @@ double BlockNonlinearFormIntegrator::GetElementEnergy(
    ElementTransformation &Tr,
    const Array<const Vector *>&elfun)
 {
-   mfem_error("BlockNonlinearFormIntegrator::GetElementEnergy"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
               " is not overloaded!");
    return 0.0;
 }
@@ -497,6 +490,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
    ElementTransformation &Tr,
@@ -504,7 +498,7 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
                  " has incorrect block finite element space size!");
    }
 
@@ -549,7 +543,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " has finite element space of incorrect block number");
    }
 
@@ -561,11 +555,10 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
    if (dim != spaceDim)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " is not defined on manifold meshes");
    }
 
-
    DSh_u.SetSize(dof_u, dim);
    DS_u.SetSize(dof_u, dim);
    J0i.SetSize(dim);
@@ -731,6 +724,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
 
 }
 
+
 const IntegrationRule&
 VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
                                        ElementTransformation &T)
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index fa3d2c75c..38b133244 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -26,44 +26,21 @@ namespace mfem
     assemble the local gradient operator and to compute the local energy. */
 class NonlinearFormIntegrator
 {
-public:
-   enum Mode
-   {
-      ELEMENTWISE = 0,       /**< Element-wise integration (default) */
-      PATCHWISE = 1,         /**< Patch-wise integration (NURBS meshes) */
-      PATCHWISE_REDUCED = 2, /**< Patch-wise integration (NURBS meshes) with
-                                  reduced integration rules. */
-   };
-
 protected:
    const IntegrationRule *IntRule;
 
-   Mode integrationMode = Mode::ELEMENTWISE;
-
-   // Prescribed integration rules (not reduced approximate rules).
-   NURBSMeshRules *patchRules = nullptr;
-
-   // CEED extension
-   ceed::Operator* ceedOp;
+   ceed::Operator *ceedOp;  // libCEED extension
 
    MemoryType pa_mt = MemoryType::DEFAULT;
 
    NonlinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : IntRule(ir), ceedOp(NULL) { }
+      : IntRule(ir), ceedOp(NULL) {}
 
 public:
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
        let the integrator choose (when @a ir == NULL). */
    virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
 
-   void SetIntegrationMode(Mode m) { integrationMode = m; }
-
-   /// For patchwise integration, SetNURBSPatchIntRule must be called.
-   void SetNURBSPatchIntRule(NURBSMeshRules *pr) { patchRules = pr; }
-   bool HasNURBSPatchIntRule() const { return patchRules != nullptr; }
-
-   bool Patchwise() const { return integrationMode != Mode::ELEMENTWISE; }
-
    /// Prescribe a fixed IntegrationRule to use.
    void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
 
@@ -74,46 +51,11 @@ public:
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
-   /// Perform the local action of the NonlinearFormIntegrator
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
-   /// from a face integral term.
-   virtual void AssembleFaceVector(const FiniteElement &el1,
-                                   const FiniteElement &el2,
-                                   FaceElementTransformations &Tr,
-                                   const Vector &elfun, Vector &elvect);
-
-   /// Assemble the local gradient matrix
-   virtual void AssembleElementGrad(const FiniteElement &el,
-                                    ElementTransformation &Tr,
-                                    const Vector &elfun, DenseMatrix &elmat);
-
-   /// @brief Assemble the local action of the gradient of the
-   /// NonlinearFormIntegrator resulting from a face integral term.
-   virtual void AssembleFaceGrad(const FiniteElement &el1,
-                                 const FiniteElement &el2,
-                                 FaceElementTransformations &Tr,
-                                 const Vector &elfun, DenseMatrix &elmat);
-
-   /// Compute the local energy
-   virtual double GetElementEnergy(const FiniteElement &el,
-                                   ElementTransformation &Tr,
-                                   const Vector &elfun);
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA().
-       Used with BilinearFormIntegrators that have different spaces. */
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
    /** @brief Prepare the integrator for partial assembly (PA) gradient
        evaluations on the given FE space @a fes at the state @a x. */
    /** The result of the partial assembly is stored internally so that it can be
@@ -121,10 +63,12 @@ public:
        The state Vector @a x is an E-vector. */
    virtual void AssembleGradPA(const Vector &x, const FiniteElementSpace &fes);
 
-   /// Compute the local (to the MPI rank) energy with partial assembly.
-   /** Here the state @a x is an E-vector. This method can be called only after
-       the method AssemblePA() has been called. */
-   virtual double GetLocalStateEnergyPA(const Vector &x) const;
+   /// Method for computing the diagonal of the gradient with partial assembly.
+   /** The result Vector @a diag is an E-Vector. This method can be called only
+       after the method AssembleGradPA() has been called.
+
+       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
+   virtual void AssembleGradDiagonalPA(Vector &diag) const;
 
    /// Method for partially assembled action.
    /** Perform the action of integrator on the input @a x and add the result to
@@ -143,15 +87,10 @@ public:
        @param[in,out] y  The result Vector: @f$ y += G x @f$. */
    virtual void AddMultGradPA(const Vector &x, Vector &y) const;
 
-   /// Method for computing the diagonal of the gradient with partial assembly.
-   /** The result Vector @a diag is an E-Vector. This method can be called only
-       after the method AssembleGradPA() has been called.
-
-       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
-   virtual void AssembleGradDiagonalPA(Vector &diag) const;
-
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
+   /// Compute the local (to the MPI rank) energy with partial assembly.
+   /** Here the state @a x is an E-vector. This method can be called only after
+       the method AssemblePA() has been called. */
+   virtual double GetLocalStateEnergyPA(const Vector &x) const;
 
    /// Method defining fully unassembled operator.
    virtual void AssembleMF(const FiniteElementSpace &fes);
@@ -164,7 +103,39 @@ public:
        called. */
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   ceed::Operator& GetCeedOp() { return *ceedOp; }
+   /// Compute the local energy
+   virtual double GetElementEnergy(const FiniteElement &el,
+                                   ElementTransformation &Tr,
+                                   const Vector &elfun);
+
+   /// Perform the local action of the NonlinearFormIntegrator
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
+   /// from a face integral term.
+   virtual void AssembleFaceVector(const FiniteElement &el1,
+                                   const FiniteElement &el2,
+                                   FaceElementTransformations &Tr,
+                                   const Vector &elfun, Vector &elvect);
+
+   /// Assemble the local gradient matrix
+   virtual void AssembleElementGrad(const FiniteElement &el,
+                                    ElementTransformation &Tr,
+                                    const Vector &elfun, DenseMatrix &elmat);
+
+   /// @brief Assemble the local action of the gradient of the
+   /// NonlinearFormIntegrator resulting from a face integral term.
+   virtual void AssembleFaceGrad(const FiniteElement &el1,
+                                 const FiniteElement &el2,
+                                 FaceElementTransformations &Tr,
+                                 const Vector &elfun, DenseMatrix &elmat);
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
 
    virtual ~NonlinearFormIntegrator()
    {
@@ -172,6 +143,7 @@ public:
    }
 };
 
+
 /** The abstract base class BlockNonlinearFormIntegrator is
     a generalization of the NonlinearFormIntegrator class suitable
     for block state vectors. */
@@ -207,7 +179,7 @@ public:
                                  const Array<const Vector *> &elfun,
                                  const Array2D<DenseMatrix *> &elmats);
 
-   virtual ~BlockNonlinearFormIntegrator() { }
+   virtual ~BlockNonlinearFormIntegrator() {}
 };
 
 
@@ -219,8 +191,8 @@ protected:
                                     transformation. */
 
 public:
-   HyperelasticModel() : Ttr(NULL) { }
-   virtual ~HyperelasticModel() { }
+   HyperelasticModel() : Ttr(NULL) {}
+   virtual ~HyperelasticModel() {}
 
    /// A reference-element to target-element transformation that can be used to
    /// evaluate Coefficient%s.
@@ -299,7 +271,7 @@ public:
 
    NeoHookeanModel(Coefficient &mu_, Coefficient &K_, Coefficient *g_ = NULL)
       : mu(0.0), K(0.0), g(1.0), c_mu(&mu_), c_K(&K_), c_g(g_),
-        have_coeffs(true) { }
+        have_coeffs(true) {}
 
    virtual double EvalW(const DenseMatrix &J) const;
 
@@ -336,7 +308,7 @@ private:
 
 public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
-   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) { }
+   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
    /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
        @param[in] el     Type of FiniteElement.
@@ -355,6 +327,7 @@ public:
                                     const Vector &elfun, DenseMatrix &elmat);
 };
 
+
 /** Hyperelastic incompressible Neo-Hookean integrator with the PK1 stress
     \f$P = \mu F - p F^{-T}\f$ where \f$\mu\f$ is the shear modulus,
     \f$p\f$ is the pressure, and \f$F\f$ is the deformation gradient */
@@ -367,7 +340,7 @@ private:
    Vector Sh_p;
 
 public:
-   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) { }
+   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -393,6 +366,7 @@ private:
    Coefficient *Q{};
    DenseMatrix dshape, dshapex, EF, gradEF, ELV, elmat_comp;
    Vector shape;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -400,7 +374,7 @@ private:
    int dim, ne, nq;
 
 public:
-   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    VectorConvectionNLFIntegrator() = default;
 
@@ -417,14 +391,12 @@ public:
                                     const Vector &elfun,
                                     DenseMatrix &elmat);
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
@@ -440,7 +412,7 @@ private:
    Vector shape;
 
 public:
-   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    ConvectiveVectorConvectionNLFIntegrator() = default;
 
@@ -463,7 +435,7 @@ private:
    Vector shape;
 
 public:
-   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    SkewSymmetricVectorConvectionNLFIntegrator() = default;
 
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index ee1030c48..86d81f566 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -151,7 +151,8 @@ void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
    }
 }
 
-void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
+void ParBilinearForm::ParallelAssemble(OperatorHandle &A,
+                                       SparseMatrix *A_local) const
 {
    A.Clear();
 
@@ -201,6 +202,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
 
    // TODO - assemble the Dof_TrueDof_Matrix directly in the required format?
    Ph.ConvertFrom(pfes->Dof_TrueDof_Matrix());
+
    // TODO: When Ph.Type() == Operator::ANY_TYPE we want to use the Operator
    // returned by pfes->GetProlongationMatrix(), however that Operator is a
    // const Operator, so we cannot store it in OperatorHandle. We need a const
@@ -209,7 +211,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
    A.MakePtAP(dA, Ph);
 }
 
-HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m)
+HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m) const
 {
    OperatorHandle Mh(Operator::Hypre_ParCSR);
    ParallelAssemble(Mh, m);
@@ -246,10 +248,9 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
       vdofs_all.Append(vdofs2);
       for (int k = 0; k < interior_face_integs.Size(); k++)
       {
-         interior_face_integs[k]->
-         AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
-                            *pfes->GetFaceNbrFE(Elem2NbrNo),
-                            *T, elemmat);
+         interior_face_integs[k]->AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
+                                                     *pfes->GetFaceNbrFE(Elem2NbrNo),
+                                                     *T, elemmat);
          if (keep_nbr_block)
          {
             mat->AddSubMatrix(vdofs_all, vdofs_all, elemmat, skip_zeros);
@@ -301,29 +302,23 @@ void ParBilinearForm::AssembleDiagonal(Vector &diag) const
    // Here, we have extension, ext, and parallel/conforming prolongation, P.
    Vector local_diag(P->Height());
    ext->AssembleDiagonal(local_diag);
-   if (fes->Conforming())
+   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
+   if (!HP)
    {
+      // This is a parallel prolongation
       P->MultTranspose(local_diag, diag);
       return;
    }
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
-   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
-   if (HP)
-   {
-      HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
-   }
-   else
-   {
-      MFEM_ABORT("unsupported prolongation matrix type.");
-   }
+   HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
 }
 
-void ParBilinearForm
-::ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                               HypreParMatrix &A, const HypreParVector &X,
-                               HypreParVector &B) const
+void ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A, const HypreParVector &X,
+   HypreParVector &B) const
 {
    Array<int> dof_list;
 
@@ -333,9 +328,9 @@ void ParBilinearForm
    A.EliminateRowsCols(dof_list, X, B);
 }
 
-HypreParMatrix *ParBilinearForm::
-ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                             HypreParMatrix &A) const
+HypreParMatrix *ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A) const
 {
    Array<int> dof_list;
 
@@ -374,7 +369,17 @@ void ParBilinearForm::FormLinearSystem(
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -418,18 +423,28 @@ void ParBilinearForm::FormLinearSystem(
    }
 }
 
-void ParBilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs, const Vector &x, Vector &b)
-{
-   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
-}
-
 void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
                                        OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ParallelRAP(*mat, A);
+         A.As<HypreParMatrix>()->EliminateBC(ess_tdof_list,
+                                             DiagonalPolicy::DIAG_ONE);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -460,6 +475,7 @@ void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
          delete mat_e;
          mat_e = NULL;
          p_mat_e.EliminateRowsCols(p_mat, ess_tdof_list);
+         A = p_mat;
       }
       if (hybridization)
       {
@@ -521,30 +537,22 @@ void ParBilinearForm::Update(FiniteElementSpace *nfes)
    p_mat_e.Clear();
 }
 
-
-HypreParMatrix *ParMixedBilinearForm::ParallelAssemble()
+void ParBilinearForm::EliminateVDofsInRHS(
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
-   // construct the block-diagonal matrix A
-   HypreParMatrix *A =
-      new HypreParMatrix(trial_pfes->GetComm(),
-                         test_pfes->GlobalVSize(),
-                         trial_pfes->GlobalVSize(),
-                         test_pfes->GetDofOffsets(),
-                         trial_pfes->GetDofOffsets(),
-                         mat);
+   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
+}
 
-   HypreParMatrix *rap = RAP(test_pfes->Dof_TrueDof_Matrix(), A,
-                             trial_pfes->Dof_TrueDof_Matrix());
+void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A) const
+{
+   A.Clear();
 
-   delete A;
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
 
-   return rap;
-}
+   OperatorHandle dA(A.Type()), P_test(A.Type()), P_trial(A.Type());
 
-void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
-{
    // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
    dA.MakeRectangularBlockDiag(trial_pfes->GetComm(),
                                test_pfes->GlobalVSize(),
                                trial_pfes->GlobalVSize(),
@@ -552,8 +560,6 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
                                trial_pfes->GetDofOffsets(),
                                mat);
 
-   OperatorHandle P_test(A.Type()), P_trial(A.Type());
-
    // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
    P_test.ConvertFrom(test_pfes->Dof_TrueDof_Matrix());
    P_trial.ConvertFrom(trial_pfes->Dof_TrueDof_Matrix());
@@ -561,6 +567,14 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
    A.MakeRAP(P_test, dA, P_trial);
 }
 
+HypreParMatrix *ParMixedBilinearForm::ParallelAssemble() const
+{
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
+}
+
 /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
 void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
                                        const double a) const
@@ -576,21 +590,55 @@ void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
    test_pfes->Dof_TrueDof_Matrix()->MultTranspose(a, Yaux, 1.0, y);
 }
 
+void ParMixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list, Vector &x,
+   Vector &b, OperatorHandle &A, Vector &X,
+   Vector &B)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
+      return;
+   }
+
+   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
+
+   const Operator *test_P = test_pfes->GetProlongationMatrix();
+   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+
+   X.SetSize(trial_pfes->GetTrueVSize());
+   B.SetSize(test_pfes->GetTrueVSize());
+   test_P->MultTranspose(b, B);
+   trial_R->Mult(x, X);
+
+   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
 void ParMixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int>
-   &trial_tdof_list,
+   const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
    OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
       return;
    }
 
    if (mat)
    {
-      Finalize();
+      const int remove_zeros = 0;
+      Finalize(remove_zeros);
+      MFEM_VERIFY(p_mat.Ptr() == NULL && p_mat_e.Ptr() == NULL,
+                  "The ParMixedBilinearFormBilinearForm must be updated "
+                  "with Update() before re-assembling the ParMixedBilinearFormBilinearForm.");
       ParallelAssemble(p_mat);
       delete mat;
       mat = NULL;
@@ -600,97 +648,89 @@ void ParMixedBilinearForm::FormRectangularSystemMatrix(
          p_mat.As<HypreParMatrix>()->EliminateCols(trial_tdof_list);
       p_mat.As<HypreParMatrix>()->EliminateRows(test_tdof_list);
       p_mat_e.Reset(temp, true);
+      A = p_mat;
    }
-
-   A = p_mat;
 }
 
-void ParMixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int>
-   &trial_tdof_list,
-   const Array<int> &test_tdof_list, Vector &x,
-   Vector &b, OperatorHandle &A, Vector &X,
-   Vector &B)
+void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A) const
 {
-   if (ext)
+   A.Clear();
+
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
+
+   if (A.Type() == Operator::Hypre_ParCSR)
    {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
+      const SparseMatrix *R = range_fes->GetRestrictionMatrix();
+      const HypreParMatrix *P = domain_fes->Dof_TrueDof_Matrix();
+      SparseMatrix *RA = mfem::Mult(*R, *mat);
+      A.Reset(P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets()));
+      delete RA;
    }
+   else
+   {
+      OperatorHandle dA(A.Type()), P_trial(A.Type()), Rt_test(A.Type());
 
-   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
-
-   const Operator *test_P = test_pfes->GetProlongationMatrix();
-   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+      // construct the rectangular block-diagonal matrix dA
+      dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
+                                  range_fes->GlobalVSize(),
+                                  domain_fes->GlobalVSize(),
+                                  range_fes->GetDofOffsets(),
+                                  domain_fes->GetDofOffsets(),
+                                  mat);
 
-   X.SetSize(trial_pfes->TrueVSize());
-   B.SetSize(test_pfes->TrueVSize());
-   test_P->MultTranspose(b, B);
-   trial_R->Mult(x, X);
+      SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
+      Rt_test.MakeRectangularBlockDiag(range_fes->GetComm(),
+                                       range_fes->GlobalVSize(),
+                                       range_fes->GlobalTrueVSize(),
+                                       range_fes->GetDofOffsets(),
+                                       range_fes->GetTrueDofOffsets(),
+                                       Rt);
 
-   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
-   B.SetSubVector(test_tdof_list, 0.0);
-}
+      // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
+      P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
 
-HypreParMatrix* ParDiscreteLinearOperator::ParallelAssemble() const
-{
-   MFEM_ASSERT(mat, "Matrix is not assembled");
-   MFEM_ASSERT(mat->Finalized(), "Matrix is not finalized");
-   SparseMatrix* RA = mfem::Mult(*range_fes->GetRestrictionMatrix(), *mat);
-   HypreParMatrix* P = domain_fes->Dof_TrueDof_Matrix();
-   HypreParMatrix* RAP = P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets());
-   delete RA;
-   return RAP;
+      A.MakeRAP(Rt_test, dA, P_trial);
+      delete Rt;
+   }
 }
 
-void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A)
+HypreParMatrix *ParDiscreteLinearOperator::ParallelAssemble() const
 {
-   // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
-   dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
-                               range_fes->GlobalVSize(),
-                               domain_fes->GlobalVSize(),
-                               range_fes->GetDofOffsets(),
-                               domain_fes->GetDofOffsets(),
-                               mat);
-
-   SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
-   OperatorHandle R_test_transpose(A.Type());
-   R_test_transpose.MakeRectangularBlockDiag(range_fes->GetComm(),
-                                             range_fes->GlobalVSize(),
-                                             range_fes->GlobalTrueVSize(),
-                                             range_fes->GetDofOffsets(),
-                                             range_fes->GetTrueDofOffsets(),
-                                             Rt);
-
-   // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
-   OperatorHandle P_trial(A.Type());
-   P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
-
-   A.MakeRAP(R_test_transpose, dA, P_trial);
-   delete Rt;
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
 }
 
-void ParDiscreteLinearOperator::FormRectangularSystemMatrix(OperatorHandle &A)
+void ParDiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
 {
    if (ext)
    {
-      Array<int> empty;
-      ext->FormRectangularSystemOperator(empty, empty, A);
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
       return;
    }
 
-   mfem_error("not implemented!");
+   if (mat)
+   {
+      Finalize();
+      ParallelAssemble(A);
+      delete mat;
+      mat = NULL;
+      delete mat_e;
+      mat_e = NULL;
+   }
 }
 
-void ParDiscreteLinearOperator::GetParBlocks(Array2D<HypreParMatrix *> &blocks)
-const
+void ParDiscreteLinearOperator::GetParBlocks(
+   Array2D<HypreParMatrix *> &blocks)
 {
    MFEM_VERIFY(mat->Finalized(), "Local matrix needs to be finalized for "
                "GetParBlocks");
 
-   HypreParMatrix* RLP = ParallelAssemble();
+   HypreParMatrix *RLP = ParallelAssemble();
 
    blocks.SetSize(range_fes->GetVDim(), domain_fes->GetVDim());
 
@@ -701,6 +741,6 @@ const
    delete RLP;
 }
 
-}
+} // namespace mfem
 
 #endif
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index c8fef567b..712c29234 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -28,6 +28,7 @@ namespace mfem
 class ParBilinearForm : public BilinearForm
 {
    friend FABilinearFormExtension;
+
 protected:
    ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
 
@@ -99,44 +100,44 @@ public:
        of the parallel/conforming prolongation, and |.| denotes the entry-wise
        absolute value. In general, this is just an approximation of the exact
        diagonal for this case. */
-   virtual void AssembleDiagonal(Vector &diag) const;
+   void AssembleDiagonal(Vector &diag) const override;
 
    /// Returns the matrix assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble() { return ParallelAssemble(mat); }
+   HypreParMatrix *ParallelAssemble() const { return ParallelAssemble(mat); }
 
    /// Returns the eliminated matrix assembled on the true dofs, i.e. P^t A_e P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssembleElim() { return ParallelAssemble(mat_e); }
+   HypreParMatrix *ParallelAssembleElim() const { return ParallelAssemble(mat_e); }
 
    /// Return the matrix @a m assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble(SparseMatrix *m);
-
-   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
-
-       @param[in] loc_A The rank-local `SparseMatrix`.
-       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
-       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
-                              the memory objects in @a loc_A.
-       */
-   void ParallelRAP(SparseMatrix &loc_A,
-                    OperatorHandle &A,
-                    bool steal_loc_A = false);
+   HypreParMatrix *ParallelAssemble(SparseMatrix *m) const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P^t A_local P, in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A) { ParallelAssemble(A, mat); }
+   void ParallelAssemble(OperatorHandle &A) const { ParallelAssemble(A, mat); }
 
    /** Returns the eliminated matrix assembled on the true dofs, i.e.
        @a A_elim = P^t A_elim_local P in the format (type id) specified by @a A.
     */
-   void ParallelAssembleElim(OperatorHandle &A_elim)
+   void ParallelAssembleElim(OperatorHandle &A_elim) const
    { ParallelAssemble(A_elim, mat_e); }
 
    /** Returns the matrix @a A_local assembled on the true dofs, i.e.
        @a A = P^t A_local P in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local);
+   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local) const;
+
+   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
+
+       @param[in] loc_A The rank-local `SparseMatrix`.
+       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
+       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
+                              the memory objects in @a loc_A.
+       */
+   void ParallelRAP(SparseMatrix &loc_A,
+                    OperatorHandle &A,
+                    bool steal_loc_A = false);
 
    /// Eliminate essential boundary DOFs from a parallel assembled system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
@@ -180,36 +181,26 @@ public:
    ParFiniteElementSpace *SCParFESpace() const
    { return static_cond ? static_cond->GetParTraceFESpace() : NULL; }
 
-   /// Get the parallel finite element space prolongation matrix
-   virtual const Operator *GetProlongation() const
-   { return pfes->GetProlongationMatrix(); }
-   /// Get the transpose of GetRestriction, useful for matrix-free RAP
-   virtual const Operator *GetRestrictionTranspose() const
-   { return pfes->GetRestrictionTransposeOperator(); }
-   /// Get the parallel finite element space restriction matrix
-   virtual const Operator *GetRestriction() const
-   { return pfes->GetRestrictionMatrix(); }
-
    using BilinearForm::FormLinearSystem;
    using BilinearForm::FormSystemMatrix;
 
-   virtual void FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
-                                 Vector &b, OperatorHandle &A, Vector &X,
-                                 Vector &B, int copy_interior = 0);
+   void FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
+                         Vector &b, OperatorHandle &A, Vector &X,
+                         Vector &B, int copy_interior = 0) override;
 
-   virtual void FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                 OperatorHandle &A);
+   void FormSystemMatrix(const Array<int> &ess_tdof_list,
+                         OperatorHandle &A) override;
 
    /** Call this method after solving a linear system constructed using the
        FormLinearSystem method to recover the solution as a ParGridFunction-size
        vector in x. Use the same arguments as in the FormLinearSystem call. */
-   virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
+   void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x) override;
 
-   virtual void Update(FiniteElementSpace *nfes = NULL);
+   void Update(FiniteElementSpace *nfes = NULL) override;
 
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x, Vector &b);
 
-   virtual ~ParBilinearForm() { }
+   virtual ~ParBilinearForm() {}
 };
 
 /// Class for parallel bilinear form using different test and trial FE spaces.
@@ -258,7 +249,7 @@ public:
        by the newly constructed ParMixedBilinearForm. */
    ParMixedBilinearForm(ParFiniteElementSpace *trial_fes,
                         ParFiniteElementSpace *test_fes,
-                        ParMixedBilinearForm * mbf)
+                        ParMixedBilinearForm *mbf)
       : MixedBilinearForm(trial_fes, test_fes, mbf),
         p_mat(Operator::Hypre_ParCSR), p_mat_e(Operator::Hypre_ParCSR)
    {
@@ -267,39 +258,39 @@ public:
    }
 
    /// Returns the matrix assembled on the true dofs, i.e. P_test^t A P_trial.
-   HypreParMatrix *ParallelAssemble();
+   HypreParMatrix *ParallelAssemble() const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P_test^t A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
    using MixedBilinearForm::FormRectangularSystemMatrix;
    using MixedBilinearForm::FormRectangularLinearSystem;
 
-   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
-
-       This returns the same operator as FormRectangularLinearSystem(), but does
-       without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
    /** @brief Form the parallel linear system A X = B, corresponding to this mixed
        bilinear form and the linear form @a b(.).
 
        Return in @a A a *reference* to the system matrix that is column-constrained.
        The reference will be invalidated when SetOperatorType(), Update(), or the
        destructor is called. */
-   virtual void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list, Vector &x,
-                                            Vector &b, OperatorHandle &A, Vector &X,
-                                            Vector &B);
+   void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list, Vector &x,
+                                    Vector &b, OperatorHandle &A, Vector &X,
+                                    Vector &B) override;
+
+   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
+
+       This returns the same operator as FormRectangularLinearSystem(), but does
+       without the transformations of the right-hand side. */
+   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list,
+                                    OperatorHandle &A) override;
 
    /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
    void TrueAddMult(const Vector &x, Vector &y, const double a = 1.0) const;
 
-   virtual ~ParMixedBilinearForm() { }
+   virtual ~ParMixedBilinearForm() {}
 };
 
 /** The parallel matrix representation a linear operator between parallel finite
@@ -335,21 +326,21 @@ public:
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = R_test A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
-
-   /** Extract the parallel blocks corresponding to the vector dimensions of the
-       domain and range parallel finite element spaces */
-   void GetParBlocks(Array2D<HypreParMatrix *> &blocks) const;
+   void ParallelAssemble(OperatorHandle &A) const;
 
-   using MixedBilinearForm::FormRectangularSystemMatrix;
+   using DiscreteLinearOperator::FormDiscreteOperatorMatrix;
 
    /** @brief Return in @a A a parallel (on truedofs) version of this operator. */
-   virtual void FormRectangularSystemMatrix(OperatorHandle &A);
+   void FormDiscreteOperatorMatrix(OperatorHandle &A) override;
+
+   /** Extract the parallel blocks corresponding to the vector dimensions of the
+       domain and range parallel finite element spaces */
+   void GetParBlocks(Array2D<HypreParMatrix *> &blocks);
 
-   virtual ~ParDiscreteLinearOperator() { }
+   virtual ~ParDiscreteLinearOperator() {}
 };
 
-}
+} // namespace mfem
 
 #endif // MFEM_USE_MPI
 
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 4d64559c6..fb0c7cf9f 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -101,8 +101,6 @@ void ParFiniteElementSpace::ParInit(ParMesh *pm)
    P = NULL;
    Pconf = NULL;
    nonconf_P = false;
-   Rconf = NULL;
-   R_transpose = NULL;
    R = NULL;
 
    num_face_nbr_dofs = -1;
@@ -675,7 +673,7 @@ void ParFiniteElementSpace::GenerateGlobalOffsets() const
    Array<HYPRE_BigInt> *offsets[2] = { &dof_offsets, &tdof_offsets };
 
    ldof[0] = GetVSize();
-   ldof[1] = TrueVSize();
+   ldof[1] = GetTrueVSize();
 
    pmesh->GenerateOffsets(2, ldof, offsets);
 
@@ -745,7 +743,7 @@ void ParFiniteElementSpace::CheckNDSTriaDofs()
    nd_strias = glb_nd_strias > 0;
 }
 
-void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
+void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const
 {
    MFEM_ASSERT(Conforming(), "wrong code path");
 
@@ -755,7 +753,7 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    {
       // Safe to assume 1-1 correspondence between shared dofs
       int ldof  = GetVSize();
-      int ltdof = TrueVSize();
+      int ltdof = GetTrueVSize();
 
       HYPRE_Int *i_diag = Memory<HYPRE_Int>(ldof+1);
       HYPRE_Int *j_diag = Memory<HYPRE_Int>(ltdof);
@@ -807,7 +805,7 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    {
       // Some shared dofs will be linear combinations of others
       HYPRE_BigInt ldof  = GetVSize();
-      HYPRE_BigInt ltdof = TrueVSize();
+      HYPRE_BigInt ltdof = GetTrueVSize();
 
       HYPRE_BigInt gdof  = -1;
       HYPRE_BigInt gtdof = -1;
@@ -973,6 +971,34 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    R = Transpose(Pdiag);
 }
 
+const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
+{
+   if (Conforming() && !nd_strias)
+   {
+      if (Pconf) { return Pconf; }
+      if (NRanks == 1)
+      {
+         Pconf = new IdentityOperator(GetTrueVSize());
+      }
+      else
+      {
+         if (!Device::Allows(Backend::DEVICE_MASK))
+         {
+            Pconf = new ConformingProlongationOperator(*this);
+         }
+         else
+         {
+            Pconf = new DeviceConformingProlongationOperator(*this);
+         }
+      }
+      return Pconf;
+   }
+   else
+   {
+      return Dof_TrueDof_Matrix();
+   }
+}
+
 HypreParMatrix *ParFiniteElementSpace::GetPartialConformingInterpolation()
 {
    HypreParMatrix *P_pc;
@@ -1162,76 +1188,6 @@ HYPRE_BigInt ParFiniteElementSpace::GetMyTDofOffset() const
    return HYPRE_AssumedPartitionCheck()? tdof_offsets[0] : tdof_offsets[MyRank];
 }
 
-const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
-{
-   if (Conforming())
-   {
-      if (Pconf) { return Pconf; }
-
-      if (nd_strias) { return Dof_TrueDof_Matrix(); }
-
-      if (NRanks == 1)
-      {
-         Pconf = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            Pconf = new ConformingProlongationOperator(*this);
-         }
-         else
-         {
-            Pconf = new DeviceConformingProlongationOperator(*this);
-         }
-      }
-      return Pconf;
-   }
-   else
-   {
-      return Dof_TrueDof_Matrix();
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionOperator() const
-{
-   if (Conforming())
-   {
-      if (Rconf) { return Rconf; }
-
-      if (NRanks == 1)
-      {
-         R_transpose = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            R_transpose = new ConformingProlongationOperator(*this, true);
-         }
-         else
-         {
-            R_transpose =
-               new DeviceConformingProlongationOperator(*this, true);
-         }
-      }
-      Rconf = new TransposeOperator(R_transpose);
-      return Rconf;
-   }
-   else
-   {
-      Dof_TrueDof_Matrix();
-      R_transpose = new TransposeOperator(R);
-      return R;
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionTransposeOperator() const
-{
-   GetRestrictionOperator();
-   return R_transpose;
-}
-
 void ParFiniteElementSpace::ExchangeFaceNbrData()
 {
    if (num_face_nbr_dofs >= 0) { return; }
@@ -3241,8 +3197,6 @@ void ParFiniteElementSpace::Destroy()
 
    delete P; P = NULL;
    delete Pconf; Pconf = NULL;
-   delete Rconf; Rconf = NULL;
-   delete R_transpose; R_transpose = NULL;
    delete R; R = NULL;
 
    delete gcomm; gcomm = NULL;
@@ -3448,8 +3402,8 @@ void ParFiniteElementSpace::UpdateMeshPointer(Mesh *new_mesh)
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   int lsize, const GroupCommunicator &gc_, bool local_)
-   : gc(gc_), local(local_)
+   int lsize, const GroupCommunicator &gc_)
+   : gc(gc_)
 {
    const Table &group_ldof = gc.GroupLDofTable();
 
@@ -3484,11 +3438,10 @@ const
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : Operator(pfes.GetVSize(), pfes.GetTrueVSize()),
      external_ldofs(),
-     gc(pfes.GroupComm()),
-     local(local_)
+     gc(pfes.GroupComm())
 {
    MFEM_VERIFY(pfes.Conforming(), "");
    const Table &group_ldof = gc.GroupLDofTable();
@@ -3537,14 +3490,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    const int m = external_ldofs.Size();
 
    const int in_layout = 2; // 2 - input is ltdofs array
-   if (local)
-   {
-      y = 0.0;
-   }
-   else
-   {
-      gc.BcastBegin(const_cast<double*>(xdata), in_layout);
-   }
+   gc.BcastBegin(const_cast<double*>(xdata), in_layout);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3556,10 +3502,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    std::copy(xdata+j-m, xdata+Width(), ydata+j);
 
    const int out_layout = 0; // 0 - output is ldofs array
-   if (!local)
-   {
-      gc.BcastEnd(ydata, out_layout);
-   }
+   gc.BcastEnd(ydata, out_layout);
 }
 
 void ConformingProlongationOperator::MultTranspose(
@@ -3572,10 +3515,7 @@ void ConformingProlongationOperator::MultTranspose(
    double *ydata = y.HostWrite();
    const int m = external_ldofs.Size();
 
-   if (!local)
-   {
-      gc.ReduceBegin(xdata);
-   }
+   gc.ReduceBegin(xdata);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3587,15 +3527,12 @@ void ConformingProlongationOperator::MultTranspose(
    std::copy(xdata+j, xdata+Height(), ydata+j-m);
 
    const int out_layout = 2; // 2 - output is an array on all ltdofs
-   if (!local)
-   {
-      gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
-   }
+   gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const GroupCommunicator &gc_, const SparseMatrix *R, bool local_)
-   : ConformingProlongationOperator(R->Width(), gc_, local_),
+   const GroupCommunicator &gc_, const SparseMatrix *R)
+   : ConformingProlongationOperator(R->Width(), gc_),
      mpi_gpu_aware(Device::GetGPUAwareMPI())
 {
    MFEM_ASSERT(R->Finalized(), "");
@@ -3660,10 +3597,9 @@ DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : DeviceConformingProlongationOperator(pfes.GroupComm(),
-                                          pfes.GetRestrictionMatrix(),
-                                          local_)
+                                          pfes.GetRestrictionMatrix())
 {
    MFEM_ASSERT(pfes.Conforming(), "internal error");
    MFEM_ASSERT(pfes.GetRestrictionMatrix()->Height() == pfes.GetTrueVSize(), "");
@@ -3727,48 +3663,36 @@ void DeviceConformingProlongationOperator::Mult(const Vector &x,
                                                 Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
-   int req_counter = 0;
    // Make sure 'y' is marked as valid on device and for use on device.
    // This ensures that there is no unnecessary host to device copy when the
-   // input 'y' is valid on host (in 'y.SetSubVector(ext_ldof, 0.0)' when local
-   // is true) or BcastLocalCopy (when local is false).
+   // input 'y' is valid on host.
    y.Write();
-   if (local)
-   {
-      // done on device since we've marked ext_ldof for use on device:
-      y.SetSubVector(ext_ldof, 0.0);
-   }
-   else
+   BcastBeginCopy(x); // copy to 'shr_buf'
+   int req_counter = 0;
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      BcastBeginCopy(x); // copy to 'shr_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = shr_buf_offsets[nbr];
+      const int send_size = shr_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = shr_buf_offsets[nbr];
-         const int send_size = shr_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = ext_buf_offsets[nbr];
-         const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = ext_buf_offsets[nbr];
+      const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    BcastLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      BcastEndCopy(y); // copy from 'ext_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   BcastEndCopy(y); // copy from 'ext_buf'
 }
 
 DeviceConformingProlongationOperator::~DeviceConformingProlongationOperator()
@@ -3829,38 +3753,32 @@ void DeviceConformingProlongationOperator::MultTranspose(const Vector &x,
                                                          Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
+   ReduceBeginCopy(x); // copy to 'ext_buf'
    int req_counter = 0;
-   if (!local)
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      ReduceBeginCopy(x); // copy to 'ext_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = ext_buf_offsets[nbr];
+      const int send_size = ext_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = ext_buf_offsets[nbr];
-         const int send_size = ext_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = shr_buf_offsets[nbr];
-         const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = shr_buf_offsets[nbr];
+      const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    ReduceLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      ReduceEndAssemble(y); // assemble from 'shr_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   ReduceEndAssemble(y); // assemble from 'shr_buf'
 }
 
 } // namespace mfem
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index ee82b0891..3b940f2af 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -70,6 +70,7 @@ private:
 
    /// The matrix P (interpolation from true dof to dof). Owned.
    mutable HypreParMatrix *P;
+
    /// Optimized action-only prolongation operator for conforming meshes. Owned.
    mutable Operator *Pconf;
 
@@ -80,12 +81,6 @@ private:
 
    /// The (block-diagonal) matrix R (restriction of dof to true dof). Owned.
    mutable SparseMatrix *R;
-   /// Optimized action-only restriction operator for conforming meshes. Owned.
-   mutable Operator *Rconf;
-   /** Transpose of R or Rconf. For conforming mesh, this is a matrix-free
-       (Device)ConformingProlongationOperator, for a non-conforming mesh
-       this is a TransposeOperator wrapping R. */
-   mutable Operator *R_transpose;
 
    /// Flag indicating the existence of shared triangles with interior ND dofs
    bool nd_strias;
@@ -194,15 +189,15 @@ private:
    /// Updates the internal mesh pointer. @warning @a new_mesh must be
    /// <b>topologically identical</b> to the existing mesh. Used if the address
    /// of the Mesh object has changed, e.g. in @a Mesh::Swap.
-   virtual void UpdateMeshPointer(Mesh *new_mesh);
+   void UpdateMeshPointer(Mesh *new_mesh) override;
 
    /// Copies the prolongation and restriction matrices from @a fes.
    ///
    /// Used for low order preconditioning on non-conforming meshes. If the DOFs
    /// require a permutation, it will be supplied by non-NULL @a perm. NULL @a
    /// perm indicates that no permutation is required.
-   virtual void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
-                                               const Array<int> *perm);
+   void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
+                                       const Array<int> *perm) override;
 
 public:
    // Face-neighbor data
@@ -271,7 +266,7 @@ public:
    int GetNRanks() const { return NRanks; }
    int GetMyRank() const { return MyRank; }
 
-   inline ParMesh *GetParMesh() const { return pmesh; }
+   ParMesh *GetParMesh() const { return pmesh; }
 
    int GetDofSign(int i)
    { return NURBSext || Nonconforming() ? 1 : ldof_sign[VDofToDof(i)]; }
@@ -282,61 +277,82 @@ public:
    HYPRE_BigInt GlobalTrueVSize() const
    { return Dof_TrueDof_Matrix()->GetGlobalNumCols(); }
 
+   bool Conforming() const override { return pmesh->pncmesh == NULL && !nonconf_P; }
+   bool Nonconforming() const override { return pmesh->pncmesh != NULL || nonconf_P; }
+
+   /// The true dof-to-dof interpolation matrix
+   HypreParMatrix *Dof_TrueDof_Matrix() const
+   { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
+
+   /// Get the P matrix which prolongates a true dof vector to local dof vector.
+   const Operator *GetProlongationMatrix() const override;
+
+   /// Get the R matrix which restricts a local dof vector to true dof vector.
+   const SparseMatrix *GetRestrictionMatrix() const override
+   { Dof_TrueDof_Matrix(); return R; }
+
+   /** @brief Returns an Operator that converts L-vectors to E-vectors on each
+       face. The parallel version is different from the serial one because of
+       the presence of shared faces. Shared faces are treated as interior faces,
+       the returned operator handles the communication needed to get the
+       shared face values from other MPI ranks */
+   const FaceRestriction *GetFaceRestriction(
+      ElementDofOrdering f_ordering, FaceType type,
+      L2FaceValues mul = L2FaceValues::DoubleValued) const override;
+
+   /** @brief For a non-conforming mesh, construct and return the interpolation
+       matrix from the partially conforming true dofs to the local dofs. */
+   /** @note The returned pointer must be deleted by the caller. */
+   HypreParMatrix *GetPartialConformingInterpolation();
+
    /// Return the number of local vector true dofs.
-   virtual int GetTrueVSize() const { return ltdof_size; }
+   int GetTrueVSize() const override { return ltdof_size; }
 
    /// Returns indexes of degrees of freedom in array dofs for i'th element.
-   virtual DofTransformation *GetElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetElementDofs(int i, Array<int> &dofs) const override;
 
    /// Returns indexes of degrees of freedom in array dofs for i'th element and
    /// returns the DofTransformation data in a user-provided object.
-   virtual void GetElementDofs(int i, Array<int> &dofs,
-                               DofTransformation &doftrans) const;
+   void GetElementDofs(int i, Array<int> &dofs,
+                       DofTransformation &doftrans) const override;
 
    /// Returns indexes of degrees of freedom for i'th boundary element.
-   virtual DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const override;
 
-   /// Returns indexes of degrees of freedom for i'th boundary element and
-   /// returns the DofTransformation data in a user-provided object.
-   virtual void GetBdrElementDofs(int i, Array<int> &dofs,
-                                  DofTransformation &doftrans) const;
+   /** @brief Returns indexes of degrees of freedom for i'th boundary element and
+       returns the DofTransformation data in a user-provided object. */
+   void GetBdrElementDofs(int i, Array<int> &dofs,
+                          DofTransformation &doftrans) const override;
 
-   /** Returns the indexes of the degrees of freedom for i'th face
+   /** @brief Returns the indexes of the degrees of freedom for i'th face
        including the dofs for the edges and the vertices of the face. */
-   virtual int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const;
+   int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const override;
 
-   /** Returns pointer to the FiniteElement in the FiniteElementCollection
-       associated with i'th element in the mesh object. If @a i is greater than
-       or equal to the number of local mesh elements, @a i will be interpreted
-       as a shifted index of a face neighbor element. */
-   virtual const FiniteElement *GetFE(int i) const;
+   /** @brief Returns pointer to the FiniteElement in the
+       FiniteElementCollection associated with i'th element in the mesh object.
+       If @a i is greater than or equal to the number of local mesh elements,
+       @a i will be interpreted as a shifted index of a face neighbor element. */
+   const FiniteElement *GetFE(int i) const override;
 
-   /** Returns an Operator that converts L-vectors to E-vectors on each face.
-       The parallel version is different from the serial one because of the
-       presence of shared faces. Shared faces are treated as interior faces,
-       the returned operator handles the communication needed to get the
-       shared face values from other MPI ranks */
-   virtual const FaceRestriction *GetFaceRestriction(
-      ElementDofOrdering f_ordering, FaceType type,
-      L2FaceValues mul = L2FaceValues::DoubleValued) const;
-
-   void GetSharedEdgeDofs(int group, int ei, Array<int> &dofs) const;
-   void GetSharedTriangleDofs(int group, int fi, Array<int> &dofs) const;
-   void GetSharedQuadrilateralDofs(int group, int fi, Array<int> &dofs) const;
+   /// Determine the boundary degrees of freedom
+   void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
+                          Array<int> &ess_dofs,
+                          int component = -1) const override;
 
-   /// The true dof-to-dof interpolation matrix
-   HypreParMatrix *Dof_TrueDof_Matrix() const
-   { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
+   /** @brief Get a list of essential true dofs, ess_tdof_list, corresponding to
+       the boundary attributes marked in the array bdr_attr_is_ess. */
+   void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
+                             Array<int> &ess_tdof_list,
+                             int component = -1) override;
 
-   /** @brief For a non-conforming mesh, construct and return the interpolation
-       matrix from the partially conforming true dofs to the local dofs. */
-   /** @note The returned pointer must be deleted by the caller. */
-   HypreParMatrix *GetPartialConformingInterpolation();
-
-   /** Create and return a new HypreParVector on the true dofs, which is
+   /** @brief Create and return a new HypreParVector on the true dofs, which is
        owned by (i.e. it must be destroyed by) the calling function. */
    HypreParVector *NewTrueDofVector()
-   { return (new HypreParVector(MyComm,GlobalTrueVSize(),GetTrueDofOffsets()));}
+   { return new HypreParVector(MyComm,GlobalTrueVSize(),GetTrueDofOffsets()); }
+
+   void GetSharedEdgeDofs(int group, int ei, Array<int> &dofs) const;
+   void GetSharedTriangleDofs(int group, int fi, Array<int> &dofs) const;
+   void GetSharedQuadrilateralDofs(int group, int fi, Array<int> &dofs) const;
 
    /// Scale a vector of true dofs
    void DivideByGroupSize(double *vec);
@@ -357,45 +373,19 @@ public:
        "partially conforming") space. */
    void Synchronize(Array<int> &ldof_marker) const;
 
-   /// Determine the boundary degrees of freedom
-   virtual void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
-                                  Array<int> &ess_dofs,
-                                  int component = -1) const;
-
-   /** Get a list of essential true dofs, ess_tdof_list, corresponding to the
-       boundary attributes marked in the array bdr_attr_is_ess. */
-   virtual void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
-                                     Array<int> &ess_tdof_list,
-                                     int component = -1);
-
    /** If the given ldof is owned by the current processor, return its local
        tdof number, otherwise return -1 */
    int GetLocalTDofNumber(int ldof) const;
    /// Returns the global tdof number of the given local degree of freedom
    HYPRE_BigInt GetGlobalTDofNumber(int ldof) const;
-   /** Returns the global tdof number of the given local degree of freedom in
-       the scalar version of the current finite element space. The input should
-       be a scalar local dof. */
+   /** @brief Returns the global tdof number of the given local degree of
+       freedom in the scalar version of the current finite element space. The
+       input should be a scalar local dof. */
    HYPRE_BigInt GetGlobalScalarTDofNumber(int sldof);
 
    HYPRE_BigInt GetMyDofOffset() const;
    HYPRE_BigInt GetMyTDofOffset() const;
 
-   virtual const Operator *GetProlongationMatrix() const;
-   /** @brief Return logical transpose of restriction matrix, but in
-       non-assembled optimized matrix-free form.
-
-       The implementation is like GetProlongationMatrix, but it sets local
-       DOFs to the true DOF values if owned locally, otherwise zero. */
-   virtual const Operator *GetRestrictionTransposeOperator() const;
-   /** Get an Operator that performs the action of GetRestrictionMatrix(),
-       but potentially with a non-assembled optimized matrix-free
-       implementation. */
-   virtual const Operator *GetRestrictionOperator() const;
-   /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
-   { Dof_TrueDof_Matrix(); return R; }
-
    // Face-neighbor functions
    void ExchangeFaceNbrData();
    int GetFaceNbrVSize() const { return num_face_nbr_dofs; }
@@ -411,62 +401,55 @@ public:
    void LoseDofOffsets() { dof_offsets.LoseData(); }
    void LoseTrueDofOffsets() { tdof_offsets.LoseData(); }
 
-   bool Conforming() const { return pmesh->pncmesh == NULL && !nonconf_P; }
-   bool Nonconforming() const { return pmesh->pncmesh != NULL || nonconf_P; }
-
    bool SharedNDTriangleDofs() const { return nd_strias; }
 
-   // Transfer parallel true-dof data from coarse_fes, defined on a coarse mesh,
-   // to this FE space, defined on a refined mesh. See full documentation in the
-   // base class, FiniteElementSpace::GetTrueTransferOperator.
-   virtual void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
-                                        OperatorHandle &T) const;
+   /** @brief Transfer parallel true-dof data from coarse_fes, defined on a
+       coarse mesh, to this FE space, defined on a refined mesh. See full
+       documentation in the base class, FiniteElementSpace::
+       GetTrueTransferOperator. */
+   void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
+                                OperatorHandle &T) const override;
 
-   /** Reflect changes in the mesh. Calculate one of the refinement/derefinement
-       /rebalance matrices, unless want_transform is false. */
-   virtual void Update(bool want_transform = true);
+   /** @brief Reflect changes in the mesh. Calculate one of the refinement/
+       derefinement/rebalance matrices, unless want_transform is false. */
+   void Update(bool want_transform = true) override;
 
    /// Free ParGridFunction transformation matrix (if any), to save memory.
-   virtual void UpdatesFinished()
+   void UpdatesFinished() override
    {
       FiniteElementSpace::UpdatesFinished();
       old_dof_offsets.DeleteAll();
    }
 
-   virtual ~ParFiniteElementSpace() { Destroy(); }
-
+   /** @brief Print some statistics associated with the mesh and finite element
+       space partitioning to mfem::out. */
    void PrintPartitionStats();
 
-   /// Obsolete, kept for backward compatibility
-   int TrueVSize() const { return ltdof_size; }
+   virtual ~ParFiniteElementSpace() { Destroy(); }
 };
 
-
 /// Auxiliary class used by ParFiniteElementSpace.
 class ConformingProlongationOperator : public Operator
 {
 protected:
    Array<int> external_ldofs;
    const GroupCommunicator &gc;
-   bool local;
 
 public:
-   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_,
-                                  bool local_=false);
+   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_);
 
-   ConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                  bool local_=false);
+   ConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
-class DeviceConformingProlongationOperator: public
-   ConformingProlongationOperator
+class DeviceConformingProlongationOperator :
+   public ConformingProlongationOperator
 {
 protected:
    bool mpi_gpu_aware;
@@ -502,17 +485,16 @@ protected:
    void ReduceEndAssemble(Vector &dst) const;
 
 public:
-   DeviceConformingProlongationOperator(
-      const GroupCommunicator &gc_, const SparseMatrix *R, bool local_=false);
+   DeviceConformingProlongationOperator(const GroupCommunicator &gc_,
+                                        const SparseMatrix *R);
 
-   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                        bool local_=false);
+   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    virtual ~DeviceConformingProlongationOperator();
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 }
diff --git a/fem/pgridfunc.hpp b/fem/pgridfunc.hpp
index e582f29d1..c13341a4c 100644
--- a/fem/pgridfunc.hpp
+++ b/fem/pgridfunc.hpp
@@ -476,7 +476,7 @@ double L2ZZErrorEstimator(BilinearFormIntegrator &flux_integrator,
                           Vector &errors, int norm_p = 2, double solver_tol = 1e-12,
                           int solver_max_it = 200);
 
-}
+} // namespace mfem
 
 #endif // MFEM_USE_MPI
 
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index b383af103..0b90c85d0 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -331,7 +331,7 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
    auto d_x_shared = Reshape(x_gf.FaceNbrData().Read(),
                              t?vd:nsdofs, t?nsdofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index da4eab5fa..15f4e8089 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -12,27 +12,24 @@
 #include "restriction.hpp"
 #include "gridfunc.hpp"
 #include "fespace.hpp"
-#include "../general/forall.hpp"
-#include <climits>
-
 #ifdef MFEM_USE_MPI
-
 #include "pfespace.hpp"
-
 #endif
+#include "../general/forall.hpp"
+#include <climits>
 
 namespace mfem
 {
 
-ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
-                                       ElementDofOrdering e_ordering)
+ConformingElementRestriction::ConformingElementRestriction(
+   const FiniteElementSpace &f,
+   ElementDofOrdering e_ordering)
    : fes(f),
      ne(fes.GetNE()),
      vdim(fes.GetVDim()),
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      ndofs(fes.GetNDofs()),
      dof(ne > 0 ? fes.GetFE(0)->GetDof() : 0),
-     nedofs(ne*dof),
      offsets(ndofs+1),
      indices(ne*dof),
      gather_map(ne*dof)
@@ -104,7 +101,7 @@ ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
    offsets[0] = 0;
 }
 
-void ElementRestriction::Mult(const Vector& x, Vector& y) const
+void ConformingElementRestriction::Mult(const Vector& x, Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -126,7 +123,8 @@ void ElementRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultUnsigned(const Vector& x,
+                                                Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -135,7 +133,6 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nd, vd, ne);
    auto d_gather_map = gather_map.Read();
-
    mfem::forall(dof*ne, [=] MFEM_HOST_DEVICE (int i)
    {
       const int gid = d_gather_map[i];
@@ -148,12 +145,13 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
 }
 
 template <bool ADD>
-void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
+static inline void TAddMultTranspose(const int nd, const int vd, const bool t,
+                                     const int ndofs, const int ne,
+                                     const Array<int>& offsets,
+                                     const Array<int>& indices,
+                                     const Vector& x, Vector& y)
 {
    // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = offsets.Read();
    auto d_indices = indices.Read();
    auto d_x = Reshape(x.Read(), nd, vd, ne);
@@ -177,21 +175,23 @@ void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultTranspose(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTranspose(const Vector& x,
+                                                 Vector& y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
-                                          const double a) const
+void ConformingElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                                    const double a) const
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultLeftInverse(const Vector& x,
+                                                   Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -203,22 +203,21 @@ void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
    auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
-      const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
       for (int c = 0; c < vd; ++c)
       {
          double dof_value = 0;
-         for (int j = offset; j < next_offset; ++j)
-         {
-            const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-            dof_value += d_x(idx_j % nd, c, idx_j / nd);
-         }
+         const int j = next_offset - 1;
+         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
+         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
+                     -d_x(idx_j % nd, c, idx_j / nd);
          d_y(t?c:i,t?i:c) = dof_value;
       }
    });
 }
 
-void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTransposeUnsigned(const Vector& x,
+                                                         Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -230,29 +229,29 @@ void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
    auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
+      const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
       for (int c = 0; c < vd; ++c)
       {
          double dof_value = 0;
-         const int j = next_offset - 1;
-         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
-                     -d_x(idx_j % nd, c, idx_j / nd);
+         for (int j = offset; j < next_offset; ++j)
+         {
+            const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
+            dof_value += d_x(idx_j % nd, c, idx_j / nd);
+         }
          d_y(t?c:i,t?i:c) = dof_value;
       }
    });
 }
 
-void ElementRestriction::BooleanMask(Vector& y) const
+void ConformingElementRestriction::BooleanMask(Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
    const int vd = vdim;
    const bool t = byvdim;
-
    Array<char> processed(vd * ndofs);
    processed = 0;
-
    auto d_offsets = offsets.HostRead();
    auto d_indices = indices.HostRead();
    auto d_x = Reshape(processed.HostReadWrite(), t?vd:ndofs, t?ndofs:vd);
@@ -280,8 +279,8 @@ void ElementRestriction::BooleanMask(Vector& y) const
    }
 }
 
-void ElementRestriction::FillSparseMatrix(const Vector &mat_ea,
-                                          SparseMatrix &mat) const
+void ConformingElementRestriction::FillSparseMatrix(const Vector &mat_ea,
+                                                    SparseMatrix &mat) const
 {
    mat.GetMemoryI().New(mat.Height()+1, mat.GetMemoryI().GetMemoryType());
    const int nnz = FillI(mat);
@@ -319,7 +318,7 @@ static MFEM_HOST_DEVICE int GetAndIncrementNnzIndex(const int i_L, int* I)
    return ind;
 }
 
-int ElementRestriction::FillI(SparseMatrix &mat) const
+int ConformingElementRestriction::FillI(SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -396,8 +395,8 @@ int ElementRestriction::FillI(SparseMatrix &mat) const
    return h_I[nTdofs];
 }
 
-void ElementRestriction::FillJAndData(const Vector &ea_data,
-                                      SparseMatrix &mat) const
+void ConformingElementRestriction::FillJAndData(const Vector &ea_data,
+                                                SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -523,11 +522,10 @@ void L2ElementRestriction::Mult(const Vector &x, Vector &y) const
 }
 
 template <bool ADD>
-void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
+static void L2TAddMultTranspose(const int nd, const int vd, const bool t,
+                                const int ndofs, const int ne,
+                                const Vector &x, Vector &y)
 {
-   const int nd = ndof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_x = Reshape(x.Read(), nd, vd, ne);
    auto d_y = Reshape(ADD ? y.ReadWrite() : y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
@@ -546,7 +544,7 @@ void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
 void L2ElementRestriction::MultTranspose(const Vector &x, Vector &y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
@@ -554,7 +552,7 @@ void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::FillI(SparseMatrix &mat) const
@@ -609,7 +607,6 @@ ConformingFaceRestriction::ConformingFaceRestriction(
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      face_dofs(nf > 0 ? fes.GetFaceElement(0)->GetDof() : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      scatter_indices(nf*face_dofs),
      gather_offsets(ndofs+1),
@@ -651,30 +648,47 @@ ConformingFaceRestriction::ConformingFaceRestriction(
    : ConformingFaceRestriction(fes, f_ordering, type, true)
 { }
 
-void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+static void ConformingFaceRestriction_Mult(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &scatter_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs)
 {
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_indices = scatter_indices.Read();
-   auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
-   auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   auto d_x = Reshape(x.Read(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
+   auto d_y = Reshape(y.Write(), face_dofs, vdim, nf);
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
-      const int s_idx = d_indices[i];
-      const int sgn = (s_idx >= 0) ? 1 : -1;
-      const int idx = (s_idx >= 0) ? s_idx : -1 - s_idx;
-      const int dof = i % nface_dofs;
-      const int face = i / nface_dofs;
-      for (int c = 0; c < vd; ++c)
+      const int s_idx_j = d_indices[i];
+      const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
+      const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
+      for (int c = 0; c < vdim; ++c)
       {
-         d_y(dof, c, face) = sgn*d_x(t?c:idx, t?idx:c);
+         d_y(i % face_dofs, c, i / face_dofs) =
+            sgn*d_x(by_vdim?c:idx_j, by_vdim?idx_j:c);
       }
    });
 }
 
+void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, true);
+}
+
+void ConformingFaceRestriction::MultUnsigned(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, false);
+}
+
 static void ConformingFaceRestriction_AddMultTranspose(
    const int ndofs,
    const int face_dofs,
@@ -1042,7 +1056,6 @@ L2FaceRestriction::L2FaceRestriction(const FiniteElementSpace &fes,
                fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0))->GetDof()
                : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      type(type),
      m(m),
@@ -1084,7 +1097,7 @@ void L2FaceRestriction::SingleValuedConformingMult(const Vector& x,
    auto d_indices1 = scatter_indices1.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1110,7 +1123,7 @@ void L2FaceRestriction::DoubleValuedConformingMult(const Vector& x,
    auto d_indices2 = scatter_indices2.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1161,7 +1174,7 @@ void L2FaceRestriction::SingleValuedConformingAddMultTranspose(
          for (int j = offset; j < next_offset; ++j)
          {
             int idx_j = d_indices[j];
-            dof_value +=  d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1175,7 +1188,7 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
    const int nface_dofs = face_dofs;
    const int vd = vdim;
    const bool t = byvdim;
-   const int dofs = nfdofs;
+   const int dofs = face_dofs*nf;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
    auto d_x = Reshape(x.Read(), nface_dofs, vd, 2, nf);
@@ -1192,9 +1205,8 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
             int idx_j = d_indices[j];
             bool isE1 = idx_j < dofs;
             idx_j = isE1 ? idx_j : idx_j - dofs;
-            dof_value +=  isE1 ?
-                          d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
-                          :d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs);
+            dof_value += (isE1 ? d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
+                          : d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs));
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1589,7 +1601,7 @@ void L2FaceRestriction::PermuteAndSetFaceDofsGatherIndices2(
       const int global_dof_elem2 = elem_map[elem_index*elem_dofs + volume_dof_elem2];
       const int restriction_dof_elem2 = face_dofs*face_index + face_dof_elem1;
       // We shift restriction_dof_elem2 to express that it's elem2 of the face
-      gather_indices[gather_offsets[global_dof_elem2]++] = nfdofs +
+      gather_indices[gather_offsets[global_dof_elem2]++] = face_dofs*nf +
                                                            restriction_dof_elem2;
    }
 }
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index 6ee367cde..405ee30b8 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -22,19 +22,51 @@ class FiniteElementSpace;
 enum class ElementDofOrdering;
 
 /// Abstract base class that defines an interface for element restrictions.
-class ElementRestrictionOperator : public Operator
+class ElementRestriction : public Operator
 {
 public:
-   /// @brief Add the E-vector degrees of freedom @a x to the L-vector degrees
-   /// of freedom @a y.
+   /** @brief Extract the degrees of freedom from @a x into @a y. */
+   void Mult(const Vector &x, Vector &y) const override = 0;
+
+   /** @brief Set the degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x. */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override = 0;
+
+   /** @brief Compute MultTranspose by setting (rather than adding) element
+       contributions, the left inverse of the Mult() operation. */
+   virtual void MultLeftInverse(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultTransposeUnsigned(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
 };
 
 /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
 /** Objects of this type are typically created and owned by FiniteElementSpace
     objects, see FiniteElementSpace::GetElementRestriction(). */
-class ElementRestriction : public ElementRestrictionOperator
+class ConformingElementRestriction : public ElementRestriction
 {
 private:
    /** This number defines the maximum number of elements any dof can belong to
@@ -48,26 +80,25 @@ protected:
    const bool byvdim;
    const int ndofs;
    const int dof;
-   const int nedofs;
    Array<int> offsets;
    Array<int> indices;
    Array<int> gather_map;
 
 public:
-   ElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+   ConformingElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
-   /// Compute Mult without applying signs based on DOF orientations.
-   void MultUnsigned(const Vector &x, Vector &y) const;
-   /// Compute MultTranspose without applying signs based on DOF orientations.
-   void MultTransposeUnsigned(const Vector &x, Vector &y) const;
+   void MultLeftInverse(const Vector &x, Vector &y) const override;
 
-   /// Compute MultTranspose by setting (rather than adding) element
-   /// contributions; this is a left inverse of the Mult() operation
-   void MultLeftInverse(const Vector &x, Vector &y) const;
+   void MultUnsigned(const Vector &x, Vector &y) const override;
+
+   void MultTransposeUnsigned(const Vector &x, Vector &y) const override;
 
    /// @brief Fills the E-vector y with `boolean` values 0.0 and 1.0 such that each
    /// each entry of the L-vector is uniquely represented in `y`.
@@ -81,16 +112,13 @@ public:
    void FillSparseMatrix(const Vector &mat_ea, SparseMatrix &mat) const;
 
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
-       given by this ElementRestriction. */
+       given by this ConformingElementRestriction. */
    int FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
-       pattern given by this ElementRestriction, and the values of ea_data. */
+       pattern given by this ConformingElementRestriction, and the values of
+       ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 
    /// @name Low-level access to the underlying element-dof mappings
    ///@{
@@ -105,37 +133,39 @@ public:
     objects, see FiniteElementSpace::GetElementRestriction(). L-vectors
     corresponding to grid functions in L2 finite element spaces differ from
     E-vectors only in the ordering of the degrees of freedom. */
-class L2ElementRestriction : public ElementRestrictionOperator
+class L2ElementRestriction : public ElementRestriction
 {
+private:
    const int ne;
    const int vdim;
    const bool byvdim;
    const int ndof;
    const int ndofs;
+
 public:
    L2ElementRestriction(const FiniteElementSpace&);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
+
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
        given by this ElementRestriction. */
    void FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
        pattern given by this L2FaceRestriction, and the values of ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /** An enum type to specify if only e1 value is requested (SingleValued) or both
     e1 and e2 (DoubleValued). */
 enum class L2FaceValues : bool {SingleValued, DoubleValued};
 
-/** @brief Base class for operators that extracts Face degrees of freedom.
+/** @brief Abstract base class for operators that extracts Face degrees of freedom.
 
     In order to compute quantities on the faces of a mesh, it is often useful to
     extract the degrees of freedom on the faces of the elements. This class
@@ -173,6 +203,19 @@ public:
    */
    void Mult(const Vector &x, Vector &y) const override = 0;
 
+   /** @brief Set the face degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x.
+
+       @param[in]     x The face degrees of freedom on the face.
+       @param[in,out] y The L-vector of degrees of freedom to which we add the
+                        face degrees of freedom.
+   */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y.
 
@@ -181,8 +224,15 @@ public:
                         face degrees of freedom.
        @param[in]     a Scalar coefficient for addition.
    */
-   virtual void AddMultTranspose(const Vector &x, Vector &y,
-                                 const double a = 1.0) const override = 0;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override = 0;
+
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
 
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y ignoring the signs from DOF orientation. */
@@ -196,7 +246,7 @@ public:
        freedom @a y. Perform the same computation as AddMultTranspose, but
        @a x is invalid after calling this method.
 
-       @param[in,out]     x The face degrees of freedom on the face.
+       @param[in,out] x The face degrees of freedom on the face.
        @param[in,out] y The L-vector of degrees of freedom to which we add the
                         face degrees of freedom.
 
@@ -207,19 +257,6 @@ public:
    {
       AddMultTranspose(x, y);
    }
-
-   /** @brief Set the face degrees of freedom in the element degrees of freedom
-       @a y to the values given in @a x.
-
-       @param[in]     x The face degrees of freedom on the face.
-       @param[in,out] y The L-vector of degrees of freedom to which we add the
-                        face degrees of freedom.
-   */
-   void MultTranspose(const Vector &x, Vector &y) const override
-   {
-      y = 0.0;
-      AddMultTranspose(x, y);
-   }
 };
 
 /// @brief Operator that extracts face degrees of freedom for H1, ND, or RT
@@ -236,7 +273,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of face E-vector dofs
    const int ndofs; // Total number of dofs
    Array<int> scatter_indices; // Scattering indices for element 1 on each face
    Array<int> gather_offsets; // offsets for the gathering indices of each dof
@@ -256,6 +292,7 @@ protected:
                              const ElementDofOrdering f_ordering,
                              const FaceType type,
                              bool build);
+
 public:
    /** @brief Construct a ConformingFaceRestriction.
 
@@ -278,19 +315,23 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTransposeInPlace;
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation.
+
+       @sa Mult(). */
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
-       @param[in]  x The face E-Vector degrees of freedom with the given format:
-                     face_dofs x vdim x nf
-                     where nf is the number of interior or boundary faces
-                     requested by @a type in the constructor.
-                     The face_dofs should be ordered according to the given
-                     ElementDofOrdering
+       @param[in]     x The face E-Vector degrees of freedom with the given format:
+                        face_dofs x vdim x nf
+                        where nf is the number of interior or boundary faces
+                        requested by @a type in the constructor.
+                        The face_dofs should be ordered according to the given
+                        ElementDofOrdering
        @param[in,out] y The L-vector degrees of freedom.
-       @param[in]  a Scalar coefficient for addition. */
+       @param[in]     a Scalar coefficient for addition. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
@@ -371,7 +412,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of dofs on the faces
    const int ndofs; // Total number of dofs
    const FaceType type;
    const L2FaceValues m;
@@ -423,8 +463,6 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTranspose;
-
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
@@ -821,6 +859,7 @@ protected:
                        const FaceType type,
                        const L2FaceValues m,
                        bool build);
+
 public:
    /** @brief Constructs an NCL2FaceRestriction, this is a specialization of a
        L2FaceRestriction for nonconforming meshes.
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 9ca9e5f3c..dec7771f1 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -92,9 +92,9 @@ const Operator &GridTransfer::MakeTrueOperator(
    else // Parallel() == true
    {
 #ifdef MFEM_USE_MPI
+      const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
       if (oper_type == Operator::Hypre_ParCSR)
       {
-         const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
          const ParFiniteElementSpace *pfes_in =
             dynamic_cast<const ParFiniteElementSpace *>(&fes_in);
          const ParFiniteElementSpace *pfes_out =
@@ -122,7 +122,6 @@ const Operator &GridTransfer::MakeTrueOperator(
       }
       else if (oper_type == Operator::ANY_TYPE)
       {
-         const Operator *out_R = fes_out.GetRestrictionOperator();
          t_oper.Reset(new TripleProductOperator(
                          out_R, &oper, fes_in.GetProlongationMatrix(),
                          false, false, false));
@@ -914,7 +913,7 @@ std::unique_ptr<SparseMatrix>>
 void L2ProjectionGridTransfer::L2ProjectionH1Space::GetTDofs(
    const FiniteElementSpace& fes, const Vector& x, Vector& X) const
 {
-   const Operator* res = fes.GetRestrictionOperator();
+   const Operator* res = fes.GetRestrictionMatrix();
    if (res)
    {
       res->Mult(x, X);
@@ -956,7 +955,7 @@ void L2ProjectionGridTransfer::L2ProjectionH1Space::GetTDofsTranspose(
 void L2ProjectionGridTransfer::L2ProjectionH1Space::SetFromTDofsTranspose(
    const FiniteElementSpace& fes, const Vector &X, Vector& x) const
 {
-   const Operator *R_op = fes.GetRestrictionOperator();
+   const Operator *R_op = fes.GetRestrictionMatrix();
    if (R_op)
    {
       R_op->MultTranspose(X, x);
@@ -1397,12 +1396,12 @@ TensorProductPRefinementTransferOperator(
    localL.UseDevice(true);
    localH.UseDevice(true);
 
-   MFEM_VERIFY(dynamic_cast<const ElementRestriction*>(elem_restrict_lex_h),
+   const auto *elem_restrict =
+      dynamic_cast<const ConformingElementRestriction*>(elem_restrict_lex_h);
+   MFEM_VERIFY(elem_restrict,
                "High order element restriction is of unsupported type");
-
    mask.SetSize(localH.Size(), Device::GetMemoryType());
-   static_cast<const ElementRestriction*>(elem_restrict_lex_h)
-   ->BooleanMask(mask);
+   elem_restrict->BooleanMask(mask);
    mask.UseDevice(true);
 }
 
diff --git a/general/array.hpp b/general/array.hpp
index a19b099a1..552fc34a2 100644
--- a/general/array.hpp
+++ b/general/array.hpp
@@ -465,9 +465,6 @@ public:
 
    inline const T &operator()(int i, int j, int k) const;
    inline       T &operator()(int i, int j, int k);
-
-   inline void operator=(const T &a)
-   { array1d = a; }
 };
 
 
diff --git a/general/communication.hpp b/general/communication.hpp
index 46d4f9f21..98dd649d4 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -230,7 +230,6 @@ protected:
    int group_buf_size;
    mutable Array<char> group_buf;
    MPI_Request *requests;
-   // MPI_Status  *statuses;
    // comm_lock: 0 - no lock, 1 - locked for Bcast, 2 - locked for Reduce
    mutable int comm_lock;
    mutable int num_requests;
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 003e52695..22c2aa8e0 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -460,14 +460,14 @@ MatrixFreeAMS::MatrixFreeAMS(
    pa_grad->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_grad->AddDomainInterpolator(new GradientInterpolator);
    pa_grad->Assemble();
-   pa_grad->FormRectangularSystemMatrix(Gradient);
+   pa_grad->FormDiscreteOperatorMatrix(Gradient);
 
    // build Pi operator
    pa_interp = new ParDiscreteLinearOperator(h1_fespace_d, &nd_fespace);
    pa_interp->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_interp->AddDomainInterpolator(new IdentityInterpolator);
    pa_interp->Assemble();
-   pa_interp->FormRectangularSystemMatrix(Pi);
+   pa_interp->FormDiscreteOperatorMatrix(Pi);
 
    // build LOR space
    ParMesh mesh_lor = ParMesh::MakeRefined(*mesh, order, BasisType::GaussLobatto);
diff --git a/linalg/handle.hpp b/linalg/handle.hpp
index 818294985..96f658d6a 100644
--- a/linalg/handle.hpp
+++ b/linalg/handle.hpp
@@ -207,7 +207,6 @@ public:
                     const Vector &X, Vector &B) const;
 };
 
-
 /// Add an alternative name for OperatorHandle -- OperatorPtr.
 typedef OperatorHandle OperatorPtr;
 
diff --git a/linalg/hypre.hpp b/linalg/hypre.hpp
index d727c42cc..e636cdfe6 100644
--- a/linalg/hypre.hpp
+++ b/linalg/hypre.hpp
@@ -720,7 +720,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMult(int alpha, const int *x, int beta, int *y)
+   void BooleanMult(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvec(A, alpha, const_cast<int*>(x),
@@ -730,7 +730,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A^T * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y)
+   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvecT(A, alpha, const_cast<int*>(x),
diff --git a/linalg/matrix.cpp b/linalg/matrix.cpp
index 638ad8061..62f9e7ffe 100644
--- a/linalg/matrix.cpp
+++ b/linalg/matrix.cpp
@@ -9,20 +9,18 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-// Implementation of class matrix
-
 #include "matrix.hpp"
+
 #include <iostream>
 #include <iomanip>
 
-
 namespace mfem
 {
 
-void Matrix::Print (std::ostream & os, int width_) const
+void Matrix::Print(std::ostream &os, int width_) const
 {
-   using namespace std;
    // output flags = scientific + show sign
+   using namespace std;
    os << setiosflags(ios::scientific | ios::showpos);
    for (int i = 0; i < height; i++)
    {
@@ -40,4 +38,4 @@ void Matrix::Print (std::ostream & os, int width_) const
    os << '\n';
 }
 
-}
+} // namespace mfem
diff --git a/linalg/matrix.hpp b/linalg/matrix.hpp
index e6cbb2cab..68e13c14a 100644
--- a/linalg/matrix.hpp
+++ b/linalg/matrix.hpp
@@ -27,8 +27,8 @@ class MatrixInverse;
 class Matrix : public Operator
 {
    friend class MatrixInverse;
-public:
 
+public:
    /// Creates a square matrix of size s.
    explicit Matrix(int s) : Operator(s) { }
 
@@ -51,7 +51,7 @@ public:
    virtual void Finalize(int) { }
 
    /// Prints matrix to stream out.
-   virtual void Print (std::ostream & out = mfem::out, int width_ = 4) const;
+   virtual void Print(std::ostream &out = mfem::out, int width_ = 4) const;
 
    /// Destroys matrix.
    virtual ~Matrix() { }
@@ -97,11 +97,14 @@ public:
 
    /// Matrix-Vector Multiplication y = A*x
    virtual void Mult(const Vector &x, Vector &y) const = 0;
+
    /// Matrix-Vector Multiplication y = y + val*A*x
    virtual void AddMult(const Vector &x, Vector &y,
                         const double val = 1.) const = 0;
+
    /// MatrixTranspose-Vector Multiplication y = A'*x
    virtual void MultTranspose(const Vector &x, Vector &y) const = 0;
+
    /// MatrixTranspose-Vector Multiplication y = y + val*A'*x
    virtual void AddMultTranspose(const Vector &x, Vector &y,
                                  const double val = 1.) const = 0;
@@ -110,6 +113,6 @@ public:
    virtual ~AbstractSparseMatrix() { }
 };
 
-}
+} // namespace mfem
 
 #endif
diff --git a/linalg/operator.cpp b/linalg/operator.cpp
index 1f214ece7..64f75c8a4 100644
--- a/linalg/operator.cpp
+++ b/linalg/operator.cpp
@@ -165,7 +165,7 @@ void Operator::RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x)
    }
 }
 
-Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
+Operator *Operator::SetupRAP(const Operator *Pi, const Operator *Po)
 {
    Operator *rap;
    if (!IsIdentityProlongation(Pi))
@@ -176,15 +176,15 @@ Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
       }
       else
       {
-         rap = new ProductOperator(this, Pi, false,false);
+         rap = new ProductOperator(this, Pi, false, false);
       }
    }
    else
    {
       if (!IsIdentityProlongation(Po))
       {
-         TransposeOperator * PoT = new TransposeOperator(Po);
-         rap = new ProductOperator(PoT, this, true,false);
+         TransposeOperator *PoT = new TransposeOperator(Po);
+         rap = new ProductOperator(PoT, this, true, false);
       }
       else
       {
@@ -245,10 +245,10 @@ void Operator::FormDiscreteOperator(Operator* &Aout)
 {
    const Operator *Pin  = this->GetProlongation();
    const Operator *Rout = this->GetOutputRestriction();
-   Aout = new TripleProductOperator(Rout, this, Pin,false, false, false);
+   Aout = new TripleProductOperator(Rout, this, Pin, false, false, false);
 }
 
-void Operator::PrintMatlab(std::ostream & os, int n, int m) const
+void Operator::PrintMatlab(std::ostream &os, int n, int m) const
 {
    using namespace std;
    if (n == 0) { n = width; }
diff --git a/linalg/operator.hpp b/linalg/operator.hpp
index baa9bf767..cdf700e17 100644
--- a/linalg/operator.hpp
+++ b/linalg/operator.hpp
@@ -29,8 +29,8 @@ protected:
 
    /// see FormSystemOperator()
    /** @note Uses DiagonalPolicy::DIAG_ONE. */
-   void FormConstrainedSystemOperator(
-      const Array<int> &ess_tdof_list, ConstrainedOperator* &Aout);
+   void FormConstrainedSystemOperator(const Array<int> &ess_tdof_list,
+                                      ConstrainedOperator* &Aout);
 
    /// see FormRectangularSystemOperator()
    void FormRectangularConstrainedSystemOperator(
@@ -38,10 +38,6 @@ protected:
       const Array<int> &test_tdof_list,
       RectangularConstrainedOperator* &Aout);
 
-   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
-       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
-   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
-
 public:
    /// Defines operator diagonal policy upon elimination of rows and/or columns.
    enum DiagonalPolicy
@@ -149,12 +145,6 @@ public:
       return GetProlongation(); // Assume square unless specialized
    }
 
-   /** @brief Transpose of GetOutputRestriction, directly available in this
-       form to facilitate matrix-free RAP-type operators.
-
-       `NULL` means identity. */
-   virtual const Operator *GetOutputRestrictionTranspose() const { return NULL; }
-
    /** @brief Restriction operator from output vectors for the operator to linear
        algebra (linear system) vectors. `NULL` means identity. */
    virtual const Operator *GetOutputRestriction() const
@@ -239,6 +229,10 @@ public:
        forms, though currently @a b is not used in the implementation. */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
+   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
+       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
+   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
+
    /** @brief Return in @a A a parallel (on truedofs) version of this square
        operator.
 
@@ -270,10 +264,10 @@ public:
    void FormDiscreteOperator(Operator* &A);
 
    /// Prints operator with input size n and output size m in Matlab format.
-   void PrintMatlab(std::ostream & out, int n, int m = 0) const;
+   void PrintMatlab(std::ostream &out, int n, int m = 0) const;
 
    /// Prints operator in Matlab format.
-   virtual void PrintMatlab(std::ostream & out) const;
+   virtual void PrintMatlab(std::ostream &out) const;
 
    /// Virtual destructor.
    virtual ~Operator() { }
@@ -722,6 +716,7 @@ inline bool IsIdentityProlongation(const Operator *P)
    return !P || dynamic_cast<const IdentityOperator*>(P);
 }
 
+
 /// Scaled Operator B: x -> a A(x).
 class ScaledOperator : public Operator
 {
@@ -928,6 +923,7 @@ public:
    virtual ~ConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief Rectangular Operator for imposing essential boundary conditions on
     the input space using only the action, Mult(), of a given unconstrained
     Operator.
@@ -981,6 +977,7 @@ public:
    virtual ~RectangularConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief PowerMethod helper class to estimate the largest eigenvalue of an
            operator using the iterative power method. */
 class PowerMethod
diff --git a/linalg/solvers.cpp b/linalg/solvers.cpp
index 810e36e9f..6b8c62b03 100644
--- a/linalg/solvers.cpp
+++ b/linalg/solvers.cpp
@@ -3538,829 +3538,4 @@ void AuxSpaceSmoother::Mult(const Vector &x, Vector &y, bool transpose) const
 }
 #endif // MFEM_USE_MPI
 
-#ifdef MFEM_USE_LAPACK
-// LAPACK routines for NNLSSolver
-extern "C" void
-dormqr_(char *, char *, int *, int *, int *, double *, int*, double *,
-        double *, int *, double *, int*, int*);
-
-extern "C" void
-dgeqrf_(int *, int *, double *, int *, double *, double *, int *, int *);
-
-extern "C" void
-dgemv_(char *, int *, int *, double *, double *, int *, double *, int *,
-       double *, double *, int *);
-
-extern "C" void
-dtrsm_(char *side, char *uplo, char *transa, char *diag, int *m, int *n,
-       double *alpha, double *a, int *lda, double *b, int *ldb);
-
-NNLSSolver::NNLSSolver()
-   : Solver(0), mat(nullptr), const_tol_(1.0e-14), min_nnz_(0),
-     max_nnz_(0), verbosity_(0), res_change_termination_tol_(1.0e-4),
-     zero_tol_(1.0e-14), rhs_delta_(1.0e-11), n_outer_(100000),
-     n_inner_(100000), nStallCheck_(100), normalize_(true),
-     NNLS_qrres_on_(false), qr_residual_mode_(QRresidualMode::hybrid)
-{}
-
-void NNLSSolver::SetOperator(const Operator &op)
-{
-   mat = dynamic_cast<const DenseMatrix*>(&op);
-   MFEM_VERIFY(mat, "NNLSSolver operator must be of type DenseMatrix");
-
-   // The size of this operator is that of the transpose of op.
-   height = op.Width();
-   width = op.Height();
-
-   row_scaling_.SetSize(mat->NumRows());
-   row_scaling_ = 1.0;
-}
-
-void NNLSSolver::SetQRResidualMode(const QRresidualMode qr_residual_mode)
-{
-   qr_residual_mode_ = qr_residual_mode;
-   if (qr_residual_mode_ == QRresidualMode::on)
-   {
-      NNLS_qrres_on_ = true;
-   }
-}
-
-void NNLSSolver::NormalizeConstraints(Vector& rhs_lb, Vector& rhs_ub) const
-{
-   // Scale everything so that rescaled half gap is the same for all constraints
-   const int m = mat->NumRows();
-
-   MFEM_VERIFY(rhs_lb.Size() == m && rhs_ub.Size() == m, "");
-
-   Vector rhs_avg = rhs_ub;
-   rhs_avg += rhs_lb;
-   rhs_avg *= 0.5;
-
-   Vector rhs_halfgap = rhs_ub;
-   rhs_halfgap -= rhs_lb;
-   rhs_halfgap *= 0.5;
-
-   Vector rhs_avg_glob = rhs_avg;
-   Vector rhs_halfgap_glob = rhs_halfgap;
-   Vector halfgap_target(m);
-   halfgap_target = 1.0e3 * const_tol_;
-
-   row_scaling_.SetSize(m);
-
-   for (int i=0; i<m; ++i)
-   {
-      const double s = halfgap_target(i) / rhs_halfgap_glob(i);
-      row_scaling_[i] = s;
-
-      rhs_lb(i) = (rhs_avg(i) * s) - halfgap_target(i);
-      rhs_ub(i) = (rhs_avg(i) * s) + halfgap_target(i);
-   }
-}
-
-void NNLSSolver::Mult(const Vector &w, Vector &sol) const
-{
-   MFEM_VERIFY(mat, "NNLSSolver operator must be of type DenseMatrix");
-   Vector rhs_ub(mat->NumRows());
-   mat->Mult(w, rhs_ub);
-   rhs_ub *= row_scaling_;
-
-   Vector rhs_lb(rhs_ub);
-   Vector rhs_Gw(rhs_ub);
-
-   for (int i=0; i<rhs_ub.Size(); ++i)
-   {
-      rhs_lb(i) -= rhs_delta_;
-      rhs_ub(i) += rhs_delta_;
-   }
-
-   if (normalize_) { NormalizeConstraints(rhs_lb, rhs_ub); }
-   Solve(rhs_lb, rhs_ub, sol);
-
-   if (verbosity_ > 1)
-   {
-      int nnz = 0;
-      for (int i=0; i<sol.Size(); ++i)
-      {
-         if (sol(i) != 0.0)
-         {
-            nnz++;
-         }
-      }
-
-      mfem::out << "Number of nonzeros in NNLSSolver solution: " << nnz
-                << ", out of " << sol.Size() << endl;
-
-      // Check residual of NNLS solution
-      Vector res(mat->NumRows());
-      mat->Mult(sol, res);
-      res *= row_scaling_;
-
-      const double normGsol = res.Norml2();
-      const double normRHS = rhs_Gw.Norml2();
-
-      res -= rhs_Gw;
-      const double relNorm = res.Norml2() / std::max(normGsol, normRHS);
-      mfem::out << "Relative residual norm for NNLSSolver solution of Gs = Gw: "
-                << relNorm << endl;
-   }
-}
-
-void NNLSSolver::Solve(const Vector& rhs_lb, const Vector& rhs_ub,
-                       Vector& soln) const
-{
-   int m = mat->NumRows();
-   int n = mat->NumCols();
-
-   MFEM_VERIFY(rhs_lb.Size() == m && rhs_lb.Size() == m && soln.Size() == n, "");
-   MFEM_VERIFY(n >= m, "NNLSSolver system cannot be over-determined.");
-
-   if (max_nnz_ == 0)
-   {
-      max_nnz_ = mat->NumCols();
-   }
-
-   // Prepare right hand side
-   Vector rhs_avg(rhs_ub);
-   rhs_avg += rhs_lb;
-   rhs_avg *= 0.5;
-
-   Vector rhs_halfgap(rhs_ub);
-   rhs_halfgap -= rhs_lb;
-   rhs_halfgap *= 0.5;
-
-   Vector rhs_avg_glob(rhs_avg);
-   Vector rhs_halfgap_glob(rhs_halfgap);
-
-   int ione = 1;
-   double fone = 1.0;
-
-   char lside = 'L';
-   char trans = 'T';
-   char notrans = 'N';
-
-   std::vector<unsigned int> nz_ind(m);
-   Vector res_glob(m);
-   Vector mu(n);
-   Vector mu2(n);
-   int n_nz_ind = 0;
-   int n_glob = 0;
-   int m_update;
-   int min_nnz_cap = std::min(static_cast<int>(min_nnz_), std::min(m,n));
-   int info;
-   std::vector<double> l2_res_hist;
-   std::vector<unsigned int> stalled_indices;
-   int stalledFlag = 0;
-   int num_stalled = 0;
-   int nz_ind_zero = 0;
-
-   Vector soln_nz_glob(m);
-   Vector soln_nz_glob_up(m);
-
-   // The following matrices are stored in column-major format as Vectors
-   Vector mat_0_data(m * n);
-   Vector mat_qr_data(m * n);
-   Vector submat_data(m * n);
-
-   Vector tau(n);
-   Vector sub_tau = tau;
-   Vector vec1(m);
-
-   // Temporary work arrays
-   int lwork;
-   std::vector<double> work;
-   int n_outer_iter = 0;
-   int n_total_inner_iter = 0;
-   int i_qr_start;
-   int n_update;
-   // 0 = converged; 1 = maximum iterations reached;
-   // 2 = NNLS stalled (no change in residual for many iterations)
-   int exit_flag = 1;
-
-   res_glob = rhs_avg_glob;
-   Vector qt_rhs_glob = rhs_avg_glob;
-   Vector qqt_rhs_glob = qt_rhs_glob;
-   Vector sub_qt = rhs_avg_glob;
-
-   // Compute threshold tolerance for the Lagrange multiplier mu
-   double mu_tol = 0.0;
-
-   {
-      Vector rhs_scaled(rhs_halfgap_glob);
-      Vector tmp(n);
-      rhs_scaled *= row_scaling_;
-      mat->MultTranspose(rhs_scaled, tmp);
-
-      mu_tol = 1.0e-15 * tmp.Max();
-   }
-
-   double rmax = 0.0;
-   double mumax = 0.0;
-
-   for (int oiter = 0; oiter < n_outer_; ++oiter)
-   {
-      stalledFlag = 0;
-
-      rmax = fabs(res_glob(0)) - rhs_halfgap_glob(0);
-      for (int i=1; i<m; ++i)
-      {
-         rmax = std::max(rmax, fabs(res_glob(i)) - rhs_halfgap_glob(i));
-      }
-
-      l2_res_hist.push_back(res_glob.Norml2());
-
-      if (verbosity_ > 1)
-      {
-         mfem::out << "NNLS " << oiter << " " << n_total_inner_iter << " " << m
-                   << " " << n << " " << n_glob << " " << rmax << " "
-                   << l2_res_hist[oiter] << endl;
-      }
-      if (rmax <= const_tol_ && n_glob >= min_nnz_cap)
-      {
-         if (verbosity_ > 1)
-         {
-            mfem::out << "NNLS target tolerance met" << endl;
-         }
-         exit_flag = 0;
-         break;
-      }
-
-      if (n_glob >= max_nnz_)
-      {
-         if (verbosity_ > 1)
-         {
-            mfem::out << "NNLS target nnz met" << endl;
-         }
-         exit_flag = 0;
-         break;
-      }
-
-      if (n_glob >= m)
-      {
-         if (verbosity_ > 1)
-         {
-            mfem::out << "NNLS system is square... exiting" << endl;
-         }
-         exit_flag = 3;
-         break;
-      }
-
-      // Check for stall after the first nStallCheck iterations
-      if (oiter > nStallCheck_)
-      {
-         double mean0 = 0.0;
-         double mean1 = 0.0;
-         for (int i=0; i<nStallCheck_/2; ++i)
-         {
-            mean0 += l2_res_hist[oiter - i];
-            mean1 += l2_res_hist[oiter - (nStallCheck_) - i];
-         }
-
-         double mean_res_change = (mean1 / mean0) - 1.0;
-         if (std::abs(mean_res_change) < res_change_termination_tol_)
-         {
-            if (verbosity_ > 1)
-            {
-               mfem::out << "NNLSSolver stall detected... exiting" << endl;
-            }
-            exit_flag = 2;
-            break;
-         }
-      }
-
-      // Find the next index
-      res_glob *= row_scaling_;
-      mat->MultTranspose(res_glob, mu);
-
-      for (int i = 0; i < n_nz_ind; ++i)
-      {
-         mu(nz_ind[i]) = 0.0;
-      }
-      for (unsigned int i = 0; i < stalled_indices.size(); ++i)
-      {
-         mu(stalled_indices[i]) = 0.0;
-      }
-
-      mumax = mu.Max();
-
-      if (mumax < mu_tol)
-      {
-         num_stalled = stalled_indices.size();
-         if (num_stalled > 0)
-         {
-            if (verbosity_ > 0)
-            {
-               mfem::out << "NNLS Lagrange multiplier is below the minimum "
-                         << "threshold: mumax = " << mumax << ", mutol = "
-                         << mu_tol << "\n" << " Resetting stalled indices "
-                         << "vector of size " << num_stalled << "\n";
-            }
-            stalled_indices.resize(0);
-
-            mat->MultTranspose(res_glob, mu);
-
-            for (int i = 0; i < n_nz_ind; ++i)
-            {
-               mu(nz_ind[i]) = 0.0;
-            }
-
-            mumax = mu.Max();
-         }
-      }
-
-      int imax = 0;
-      {
-         double tmax = mu(0);
-         for (int i=1; i<n; ++i)
-         {
-            if (mu(i) > tmax)
-            {
-               tmax = mu(i);
-               imax = i;
-            }
-         }
-      }
-
-      // Record the local value of the next index
-      nz_ind[n_nz_ind] = imax;
-      ++n_nz_ind;
-
-      if (verbosity_ > 2)
-      {
-         mfem::out << "Found next index: " << imax << " " << mumax << endl;
-      }
-
-      for (int i=0; i<m; ++i)
-      {
-         mat_0_data(i + (n_glob*m)) = (*mat)(i,imax) * row_scaling_[i];
-         mat_qr_data(i + (n_glob*m)) = mat_0_data(i + (n_glob*m));
-      }
-
-      i_qr_start = n_glob;
-      ++n_glob; // Increment the size of the global matrix
-
-      if (verbosity_ > 2)
-      {
-         mfem::out << "Updated matrix with new index" << endl;
-      }
-
-      for (int iiter = 0; iiter < n_inner_; ++iiter)
-      {
-         ++n_total_inner_iter;
-
-         // Initialize
-         const bool incremental_update = true;
-         n_update = n_glob - i_qr_start;
-         m_update = m - i_qr_start;
-         if (incremental_update)
-         {
-            // Apply Householder reflectors to compute Q^T new_cols
-            lwork = -1;
-            work.resize(10);
-
-            dormqr_(&lside, &trans, &m, &n_update, &i_qr_start,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    mat_qr_data.GetData() + (i_qr_start * m), &m,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // Q^T A update work calculation failed
-            lwork = static_cast<int>(work[0]);
-            work.resize(lwork);
-            dormqr_(&lside, &trans, &m, &n_update, &i_qr_start,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    mat_qr_data.GetData() + (i_qr_start * m), &m,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // Q^T A update failed
-            // Compute QR factorization of the submatrix
-            lwork = -1;
-            work.resize(10);
-
-            // Copy m_update-by-n_update submatrix of mat_qr_data,
-            // starting at (i_qr_start, i_qr_start)
-            for (int i=0; i<m_update; ++i)
-               for (int j=0; j<n_update; ++j)
-               {
-                  submat_data[i + (j * m_update)] =
-                     mat_qr_data[i + i_qr_start + ((j + i_qr_start) * m)];
-               }
-
-            // Copy tau subvector of length n_update, starting at i_qr_start
-            for (int j=0; j<n_update; ++j)
-            {
-               sub_tau[j] = tau[i_qr_start + j];
-            }
-
-            dgeqrf_(&m_update, &n_update,
-                    submat_data.GetData(), &m_update, sub_tau.GetData(),
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // QR update factorization work calc
-            lwork = static_cast<int>(work[0]);
-            if (lwork == 0) { lwork = 1; }
-            work.resize(lwork);
-            dgeqrf_(&m_update, &n_update,
-                    submat_data.GetData(), &m_update, sub_tau.GetData(),
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // QR update factorization failed
-
-            // Copy result back
-            for (int i=0; i<m_update; ++i)
-               for (int j=0; j<n_update; ++j)
-               {
-                  mat_qr_data[i + i_qr_start + ((j + i_qr_start)* m)] =
-                     submat_data[i + (j * m_update)];
-               }
-
-            for (int j=0; j<n_update; ++j)
-            {
-               tau[i_qr_start + j] = sub_tau[j];
-            }
-         }
-         else
-         {
-            // Copy everything to mat_qr then do full QR
-            for (int i=0; i<m; ++i)
-               for (int j=0; j<n_glob; ++j)
-               {
-                  mat_qr_data(i + (j*m)) = mat_0_data(i + (j*m));
-               }
-
-            // Compute qr factorization (first find the size of work and then
-            // perform qr)
-            lwork = -1;
-            work.resize(10);
-            dgeqrf_(&m, &n_glob,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // QR factorization work calculation
-            lwork = static_cast<int>(work[0]);
-            work.resize(lwork);
-            dgeqrf_(&m, &n_glob,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // QR factorization failed
-         }
-
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Updated QR " << iiter << endl;
-         }
-
-         // Apply Householder reflectors to compute Q^T b
-         if (incremental_update && iiter == 0)
-         {
-            lwork = -1;
-            work.resize(10);
-
-            // Copy submatrix of mat_qr_data starting at
-            //   (i_qr_start, i_qr_start), of size m_update-by-1
-            // Copy submatrix of qt_rhs_glob starting at (i_qr_start, 0),
-            //   of size m_update-by-1
-
-            for (int i=0; i<m_update; ++i)
-            {
-               submat_data[i] = mat_qr_data[i + i_qr_start + (i_qr_start * m)];
-               sub_qt[i] = qt_rhs_glob[i + i_qr_start];
-            }
-
-            sub_tau[0] = tau[i_qr_start];
-
-            dormqr_(&lside, &trans, &m_update, &ione, &ione,
-                    submat_data.GetData(), &m_update, sub_tau.GetData(),
-                    sub_qt.GetData(), &m_update,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // H_last y work calculation failed
-            lwork = static_cast<int>(work[0]);
-            work.resize(lwork);
-            dormqr_(&lside, &trans, &m_update, &ione, &ione,
-                    submat_data.GetData(), &m_update, sub_tau.GetData(),
-                    sub_qt.GetData(), &m_update,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // H_last y failed
-            // Copy result back
-            for (int i=0; i<m_update; ++i)
-            {
-               qt_rhs_glob[i + i_qr_start] = sub_qt[i];
-            }
-         }
-         else
-         {
-            // Compute Q^T b from scratch
-            qt_rhs_glob = rhs_avg_glob;
-            lwork = -1;
-            work.resize(10);
-            dormqr_(&lside, &trans, &m, &ione, &n_glob,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    qt_rhs_glob.GetData(), &m,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // Q^T b work calculation failed
-            lwork = static_cast<int>(work[0]);
-            work.resize(lwork);
-            dormqr_(&lside, &trans, &m, &ione, &n_glob,
-                    mat_qr_data.GetData(), &m, tau.GetData(),
-                    qt_rhs_glob.GetData(), &m,
-                    work.data(), &lwork, &info);
-            MFEM_VERIFY(info == 0, ""); // Q^T b failed
-         }
-
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Updated rhs " << iiter << endl;
-         }
-
-         // Apply R^{-1}; first n_glob entries of vec1 are overwritten
-         char upper = 'U';
-         char nounit = 'N';
-         vec1 = qt_rhs_glob;
-         dtrsm_(&lside, &upper, &notrans, &nounit,
-                &n_glob, &ione, &fone,
-                mat_qr_data.GetData(), &m,
-                vec1.GetData(), &n_glob);
-
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Solved triangular system " << iiter << endl;
-         }
-
-         // Check if all entries are positive
-         int pos_ibool = 0;
-         double smin = n_glob > 0 ? vec1(0) : 0.0;
-         for (int i=0; i<n_glob; ++i)
-         {
-            soln_nz_glob_up(i) = vec1(i);
-            smin = std::min(smin, soln_nz_glob_up(i));
-         }
-
-         if (smin > zero_tol_)
-         {
-            pos_ibool = 1;
-            for (int i=0; i<n_glob; ++i)
-            {
-               soln_nz_glob(i) = soln_nz_glob_up(i);
-            }
-         }
-
-         if (pos_ibool == 1)
-         {
-            break;
-         }
-
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Start pruning " << iiter << endl;
-            for (int i = 0; i < n_glob; ++i)
-            {
-               if (soln_nz_glob_up(i) <= zero_tol_)
-               {
-                  mfem::out << i << " " << n_glob << " " << soln_nz_glob_up(i) << endl;
-               }
-            }
-         }
-
-         if (soln_nz_glob_up(n_glob - 1) <= zero_tol_)
-         {
-            stalledFlag = 1;
-            if (verbosity_ > 2)
-            {
-               if (qr_residual_mode_ == QRresidualMode::hybrid)
-               {
-                  mfem::out << "Detected stall due to adding and removing same "
-                            << "column. Switching to QR residual calculation "
-                            << "method." << endl;
-               }
-               else
-               {
-                  mfem::out << "Detected stall due to adding and removing same"
-                            << " column. Exiting now." << endl;
-               }
-            }
-         }
-
-         if (stalledFlag == 1 && qr_residual_mode_ == QRresidualMode::hybrid)
-         {
-            NNLS_qrres_on_ = true;
-            break;
-         }
-
-         double alpha = 1.0e300;
-         // Find maximum permissible step
-         for (int i = 0; i < n_glob; ++i)
-         {
-            if (soln_nz_glob_up(i) <= zero_tol_)
-            {
-               alpha = std::min(alpha, soln_nz_glob(i)/(soln_nz_glob(i) - soln_nz_glob_up(i)));
-            }
-         }
-         // Update solution
-         smin = 0.0;
-         for (int i = 0; i < n_glob; ++i)
-         {
-            soln_nz_glob(i) += alpha*(soln_nz_glob_up(i) - soln_nz_glob(i));
-            if (i == 0 || soln_nz_glob(i) < smin)
-            {
-               smin = soln_nz_glob(i);
-            }
-         }
-
-         while (smin > zero_tol_)
-         {
-            // This means there was a rounding error, as we should have
-            // a zero element by definition. Recalculate alpha based on
-            // the index that corresponds to the element that should be
-            // zero.
-
-            int index_min = 0;
-            smin = soln_nz_glob(0);
-            for (int i = 1; i < n_glob; ++i)
-            {
-               if (soln_nz_glob(i) < smin)
-               {
-                  smin = soln_nz_glob(i);
-                  index_min = i;
-               }
-            }
-
-            alpha = soln_nz_glob(index_min)/(soln_nz_glob(index_min)
-                                             - soln_nz_glob_up(index_min));
-
-            // Reupdate solution
-            for (int i = 0; i < n_glob; ++i)
-            {
-               soln_nz_glob(i) += alpha*(soln_nz_glob_up(i) - soln_nz_glob(i));
-            }
-         }
-
-         // Clean up zeroed entry
-         i_qr_start = n_glob+1;
-         while (true)
-         {
-            // Check if there is a zero entry
-            int zero_ibool;
-
-            smin = n_glob > 0 ? soln_nz_glob(0) : 0.0;
-            for (int i=1; i<n_glob; ++i)
-            {
-               smin = std::min(smin, soln_nz_glob(i));
-            }
-
-            if (smin < zero_tol_)
-            {
-               zero_ibool = 1;
-            }
-            else
-            {
-               zero_ibool = 0;
-            }
-
-            if (zero_ibool == 0)   // Break if there is no more zero entry
-            {
-               break;
-            }
-
-            int ind_zero = -1; // Index where the first zero is encountered
-            nz_ind_zero = 0;
-
-            // Identify global index of the zeroed element
-            for (int i = 0; i < n_glob; ++i)
-            {
-               if (soln_nz_glob(i) < zero_tol_)
-               {
-                  ind_zero = i;
-                  break;
-               }
-            }
-            MFEM_VERIFY(ind_zero != -1, "");
-            // Identify the local index for nz_ind to which the zeroed entry
-            // belongs
-            for (int i = 0; i < ind_zero; ++i)
-            {
-               ++nz_ind_zero;
-            }
-
-            {
-               // Copy mat_0.cols[ind_zero+1,n_glob) to mat_qr.cols[ind_zero,n_glob-1)
-               for (int i=0; i<m; ++i)
-                  for (int j=ind_zero; j<n_glob-1; ++j)
-                  {
-                     mat_qr_data(i + (j*m)) = mat_0_data(i + ((j+1)*m));
-                  }
-
-               // Copy mat_qr.cols[ind_zero,n_glob-1) to
-               // mat_0.cols[ind_zero,n_glob-1)
-               for (int i=0; i<m; ++i)
-                  for (int j=ind_zero; j<n_glob-1; ++j)
-                  {
-                     mat_0_data(i + (j*m)) = mat_qr_data(i + (j*m));
-                  }
-            }
-
-            // Remove the zeroed entry from the local matrix index
-            for (int i = nz_ind_zero; i < n_nz_ind-1; ++i)
-            {
-               nz_ind[i] = nz_ind[i+1];
-            }
-            --n_nz_ind;
-
-            // Shift soln_nz_glob and proc_index
-            for (int i = ind_zero; i < n_glob-1; ++i)
-            {
-               soln_nz_glob(i) = soln_nz_glob(i+1);
-            }
-
-            i_qr_start = std::min(i_qr_start, ind_zero);
-            --n_glob;
-         } // End of pruning loop
-
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Finished pruning " << iiter << endl;
-         }
-      } // End of inner loop
-
-      // Check if we have stalled
-      if (stalledFlag == 1)
-      {
-         --n_glob;
-         --n_nz_ind;
-         num_stalled = stalled_indices.size();
-         stalled_indices.resize(num_stalled + 1);
-         stalled_indices[num_stalled] = imax;
-         if (verbosity_ > 2)
-         {
-            mfem::out << "Adding index " << imax << " to stalled index list "
-                      << "of size " << num_stalled << endl;
-         }
-      }
-
-      // Compute residual
-      if (!NNLS_qrres_on_)
-      {
-         res_glob = rhs_avg_glob;
-         double fmone = -1.0;
-         dgemv_(&notrans, &m, &n_glob, &fmone,
-                mat_0_data.GetData(), &m,
-                soln_nz_glob.GetData(), &ione, &fone,
-                res_glob.GetData(), &ione);
-      }
-      else
-      {
-         // Compute residual using res = b - Q*Q^T*b, where Q is from an
-         // economical QR decomposition
-         lwork = -1;
-         work.resize(10);
-         qqt_rhs_glob = 0.0;
-         for (int i=0; i<n_glob; ++i)
-         {
-            qqt_rhs_glob(i) = qt_rhs_glob(i);
-         }
-
-         dormqr_(&lside, &notrans, &m, &ione, &n_glob, mat_qr_data.GetData(), &m,
-                 tau.GetData(), qqt_rhs_glob.GetData(), &m,
-                 work.data(), &lwork, &info);
-
-         MFEM_VERIFY(info == 0, ""); // Q Q^T b work calculation failed.
-         lwork = static_cast<int>(work[0]);
-         work.resize(lwork);
-         dormqr_(&lside, &notrans, &m, &ione, &n_glob, mat_qr_data.GetData(), &m,
-                 tau.GetData(), qqt_rhs_glob.GetData(), &m,
-                 work.data(), &lwork, &info);
-         MFEM_VERIFY(info == 0, ""); // Q Q^T b calculation failed.
-         res_glob = rhs_avg_glob;
-         res_glob -= qqt_rhs_glob;
-      }
-
-      if (verbosity_ > 2)
-      {
-         mfem::out << "Computed residual" << endl;
-      }
-
-      ++n_outer_iter;
-   } // End of outer loop
-
-   // Insert the solutions
-   MFEM_VERIFY(n_glob == n_nz_ind, "");
-   soln = 0.0;
-   for (int i = 0; i < n_glob; ++i)
-   {
-      soln(nz_ind[i]) = soln_nz_glob(i);
-   }
-
-   if (verbosity_ > 0)
-   {
-      mfem::out << "NNLS solver: m = " << m << ", n = " << n
-                << ", outer_iter = " << n_outer_iter << ", inner_iter = "
-                << n_total_inner_iter;
-
-      if (exit_flag == 0)
-      {
-         mfem::out << ": converged" << endl;
-      }
-      else
-      {
-         mfem::out << endl << "Warning, NNLS convergence stalled: "
-                   << (exit_flag == 2) << endl;
-         mfem::out << "resErr = " << rmax << " vs tol = " << const_tol_
-                   << "; mumax = " << mumax << " vs tol = " << mu_tol << endl;
-      }
-   }
-}
-#endif // MFEM_USE_LAPACK
-
 }
diff --git a/linalg/solvers.hpp b/linalg/solvers.hpp
index d951476bf..085cea616 100644
--- a/linalg/solvers.hpp
+++ b/linalg/solvers.hpp
@@ -432,7 +432,7 @@ public:
 
    ~OperatorChebyshevSmoother() {}
 
-   void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector&x, Vector &y) const;
 
    void MultTranspose(const Vector &x, Vector &y) const { Mult(x, y); }
 
@@ -1245,126 +1245,6 @@ public:
 };
 #endif // MFEM_USE_MPI
 
-#ifdef MFEM_USE_LAPACK
-/** Non-negative least squares (NNLS) solver class, for computing a vector
-    with non-negative entries approximately satisfying an under-determined
-    linear system. */
-class NNLSSolver : public Solver
-{
-public:
-   NNLSSolver();
-
-   ~NNLSSolver() { }
-
-   /// The operator must be a DenseMatrix.
-   void SetOperator(const Operator &op) override;
-
-   void Mult(const Vector &w, Vector &sol) const override;
-
-   /**
-     * Set verbosity. If set to 0: print nothing; if 1: just print results;
-     * if 2: print short update on every iteration; if 3: print longer update
-     * each iteration.
-     */
-   void SetVerbosity(int v) { verbosity_ = v; }
-
-   void SetTolerance(double tol) { const_tol_ = tol; }
-
-   /// Set the minimum number of nonzeros required for the solution.
-   void SetMinNNZ(int min_nnz) { min_nnz_ = min_nnz; }
-
-   /// Set the maximum number of nonzeros required for the solution, as an early
-   /// termination condition.
-   void SetMaxNNZ(int max_nnz) { max_nnz_ = max_nnz; }
-
-   /// Set threshold on relative change in residual over nStallCheck_ iterations.
-   void SetResidualChangeTolerance(double tol)
-   { res_change_termination_tol_ = tol; }
-
-   void SetZeroTolerance(double tol) { zero_tol_ = tol; }
-
-   /// Set RHS vector constant shift, defining rhs_lb and rhs_ub in Solve().
-   void SetRHSDelta(double d) { rhs_delta_ = d; }
-
-   /// Set the maximum number of outer iterations in Solve().
-   void SetOuterIterations(int n) { n_outer_ = n; }
-
-   /// Set the maximum number of inner iterations in Solve().
-   void SetInnerIterations(int n) { n_inner_ = n; }
-
-   /// Set the number of iterations to use for stall checking.
-   void SetStallCheck(int n) { nStallCheck_ = n; }
-
-   /// Set a flag to determine whether to call NormalizeConstraints().
-   void SetNormalize(bool n) { normalize_ = n; }
-
-   /**
-     * Enumerated types of QRresidual mode. Options are 'off': the residual is
-     * calculated normally, 'on': the residual is calculated using the QR
-     * method, 'hybrid': the residual is calculated normally until we experience
-     * rounding errors, then the QR method is used. The default is 'hybrid',
-     * which should see the best performance. Recommend using 'hybrid' or 'off'
-     * only, since 'on' is computationally expensive.
-     */
-   enum class QRresidualMode {off, on, hybrid};
-
-   /**
-    * Set the residual calculation mode for the NNLS solver. See QRresidualMode
-    * enum above for details.
-    */
-   void SetQRResidualMode(const QRresidualMode qr_residual_mode);
-
-   /**
-    * @brief Solve the NNLS problem. Specifically, we find a vector @a soln,
-    * such that rhs_lb < mat*soln < rhs_ub is satisfied, where mat is the
-    * DenseMatrix input to SetOperator().
-    *
-    * The method by which we find the solution is the active-set method
-    * developed by Lawson and Hanson (1974) using lapack. To decrease rounding
-    * errors in the case of very tight tolerances, we have the option to compute
-    * the residual using the QR factorization of A, by res = b - Q*Q^T*b. This
-    * residual calculation results in less rounding error, but is more
-    * computationally expensive. To select whether to use the QR residual method
-    * or not, see set_qrresidual_mode above.
-    */
-   void Solve(const Vector& rhs_lb, const Vector& rhs_ub, Vector& soln) const;
-
-   /**
-     * Normalize the constraints such that the tolerances for each constraint
-     * (i.e. (UB - LB)/2) are equal. This seems to help the performance in most
-     * cases.
-     */
-   void NormalizeConstraints(Vector& rhs_lb, Vector& rhs_ub) const;
-
-private:
-   const DenseMatrix *mat;
-
-   double const_tol_;
-   int min_nnz_; // minimum number of nonzero entries
-   mutable int max_nnz_; // maximum number of nonzero entries
-   int verbosity_;
-
-   /**
-    * @brief Threshold on relative change in residual over nStallCheck_
-    * iterations, for stall sensing.
-    */
-   double res_change_termination_tol_;
-
-   double zero_tol_;
-   double rhs_delta_;
-   int n_outer_;
-   int n_inner_;
-   int nStallCheck_;
-
-   bool normalize_;
-
-   mutable bool NNLS_qrres_on_;
-   QRresidualMode qr_residual_mode_;
-
-   mutable Vector row_scaling_;
-};
-#endif // MFEM_USE_LAPACK
-
 }
 
 #endif // MFEM_SOLVERS
diff --git a/mesh/nurbs.cpp b/mesh/nurbs.cpp
index aaef06e38..02f40c951 100644
--- a/mesh/nurbs.cpp
+++ b/mesh/nurbs.cpp
@@ -3351,55 +3351,6 @@ void NURBSExtension::Generate3DElementDofTable()
    el_dof = new Table(NumOfActiveElems, el_dof_list);
 }
 
-void NURBSExtension::GetPatchDofs(const int patch, Array<int> &dofs)
-{
-   const KnotVector *kv[3];
-   NURBSPatchMap p2g(this);
-
-   p2g.SetPatchDofMap(patch, kv);
-
-   if (Dimension() == 1)
-   {
-      const int nx = kv[0]->GetNCP();
-      dofs.SetSize(nx);
-
-      for (int i=0; i<nx; ++i)
-      {
-         dofs[i] = DofMap(p2g(i));
-      }
-   }
-   else if (Dimension() == 2)
-   {
-      const int nx = kv[0]->GetNCP();
-      const int ny = kv[1]->GetNCP();
-      dofs.SetSize(nx * ny);
-
-      for (int j=0; j<ny; ++j)
-         for (int i=0; i<nx; ++i)
-         {
-            dofs[i + (nx * j)] = DofMap(p2g(i, j));
-         }
-   }
-   else if (Dimension() == 3)
-   {
-      const int nx = kv[0]->GetNCP();
-      const int ny = kv[1]->GetNCP();
-      const int nz = kv[2]->GetNCP();
-      dofs.SetSize(nx * ny * nz);
-
-      for (int k=0; k<nz; ++k)
-         for (int j=0; j<ny; ++j)
-            for (int i=0; i<nx; ++i)
-            {
-               dofs[i + (nx * (j + (k * ny)))] = DofMap(p2g(i, j, k));
-            }
-   }
-   else
-   {
-      MFEM_ABORT("Only 1D/2D/3D supported currently in NURBSExtension::GetPatchDofs");
-   }
-}
-
 void NURBSExtension::GenerateBdrElementDofTable()
 {
    if (Dimension() == 1)
@@ -4093,12 +4044,6 @@ void NURBSExtension::Set3DSolutionVector(Vector &coords, int vdim)
    }
 }
 
-void NURBSExtension::GetElementIJK(int elem, Array<int> & ijk)
-{
-   MFEM_VERIFY(ijk.Size() == el_to_IJK.NumCols(), "");
-   el_to_IJK.GetRow(elem, ijk);
-}
-
 void NURBSExtension::SetPatchToElements()
 {
    const int np = GetNP();
diff --git a/mesh/nurbs.hpp b/mesh/nurbs.hpp
index ac57d5080..d76a2b90a 100644
--- a/mesh/nurbs.hpp
+++ b/mesh/nurbs.hpp
@@ -21,7 +21,6 @@
 #include "../general/communication.hpp"
 #endif
 #include <iostream>
-#include <set>
 
 namespace mfem
 {
@@ -281,7 +280,9 @@ protected:
    bool ConsistentKVSets();
 
    void GetPatchKnotVectors   (int p, Array<KnotVector *> &kv);
+   void GetPatchKnotVectors   (int p, Array<const KnotVector *> &kv) const;
    void GetBdrPatchKnotVectors(int p, Array<KnotVector *> &kv);
+   void GetBdrPatchKnotVectors(int p, Array<const KnotVector *> &kv) const;
 
    void SetOrderFromOrders();
    void SetOrdersFromKnotVectors();
@@ -424,11 +425,6 @@ public:
    int GetNTotalDof() const { return NumOfDofs; }
    int GetNDof()      const { return NumOfActiveDofs; }
 
-   /// Returns knotvectors in each dimension for patch @a p.
-   void GetPatchKnotVectors(int p, Array<const KnotVector *> &kv) const;
-
-   void GetBdrPatchKnotVectors(int p, Array<const KnotVector *> &kv) const;
-
    // Knotvector read-only access function
    const KnotVector *GetKnotVector(int i) const { return knotVectors[i]; }
 
@@ -488,16 +484,6 @@ public:
    void KnotInsert(Array<KnotVector *> &kv);
    void KnotInsert(Array<Vector *> &kv);
 
-   /// Returns the index of the patch containing element @a elem.
-   int GetElementPatch(int elem) const { return el_to_patch[elem]; }
-
-   /** Returns the Cartesian indices (i,j) in 2D or (i,j,k) in 3D of element
-       @a elem, in the knot-span tensor product ordering for its patch. */
-   void GetElementIJK(int elem, Array<int> & ijk);
-
-   // Returns the degrees of freedom on the patch, in Cartesian order.
-   void GetPatchDofs(const int patch, Array<int> &dofs);
-
    const Array<int>& GetPatchElements(int patch);
    const Array<int>& GetPatchBdrElements(int patch);
 };
diff --git a/miniapps/electromagnetics/joule.cpp b/miniapps/electromagnetics/joule.cpp
index 8f2e68fc3..2ae9e98c7 100644
--- a/miniapps/electromagnetics/joule.cpp
+++ b/miniapps/electromagnetics/joule.cpp
@@ -445,7 +445,7 @@ int main(int argc, char *argv[])
    ParFiniteElementSpace  HDivFESpace(pmesh, &HDivFEC);
    ParFiniteElementSpace  HGradFESpace(pmesh, &HGradFEC);
 
-   // The terminology is TrueVSize is the unique (non-redundant) number of dofs
+   // The terminology is GetTrueVSize is the unique (non-redundant) number of dofs
    HYPRE_BigInt glob_size_l2 = L2FESpace.GlobalTrueVSize();
    HYPRE_BigInt glob_size_nd = HCurlFESpace.GlobalTrueVSize();
    HYPRE_BigInt glob_size_rt = HDivFESpace.GlobalTrueVSize();
diff --git a/miniapps/hdiv-linear-solver/change_basis.cpp b/miniapps/hdiv-linear-solver/change_basis.cpp
index 702c57e4f..e0c34384d 100644
--- a/miniapps/hdiv-linear-solver/change_basis.cpp
+++ b/miniapps/hdiv-linear-solver/change_basis.cpp
@@ -336,7 +336,7 @@ void ChangeOfBasis_RT::Mult(const Vector &x, Vector &y, Mode mode) const
 
    elem_restr->MultLeftInverse(y_e, y_l);
 
-   const Operator *R = fes.GetRestrictionOperator();
+   const Operator *R = fes.GetRestrictionMatrix();
    if (R) { R->Mult(y_l, y); }
    else { MFEM_VERIFY(P == NULL, "Invalid state."); }
 }
diff --git a/miniapps/hdiv-linear-solver/discrete_divergence.cpp b/miniapps/hdiv-linear-solver/discrete_divergence.cpp
index 7ca7eca4c..2c522dad0 100644
--- a/miniapps/hdiv-linear-solver/discrete_divergence.cpp
+++ b/miniapps/hdiv-linear-solver/discrete_divergence.cpp
@@ -201,7 +201,7 @@ HypreParMatrix *FormDiscreteDivergenceMatrix(ParFiniteElementSpace &fes_rt,
    else { MFEM_ABORT("Unsupported dimension.") }
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_rt = dynamic_cast<const ElementRestriction*>(
+   const auto *R_rt = dynamic_cast<const ConformingElementRestriction*>(
                          fes_rt.GetElementRestriction(ordering));
    const auto gather_rt = Reshape(R_rt->GatherMap().Read(), nface_per_el, nel_ho);
    const auto e2f = Reshape(element2face.Read(), 2*dim, nvol_per_el);
diff --git a/miniapps/nurbs/CMakeLists.txt b/miniapps/nurbs/CMakeLists.txt
index d38e89d0b..28a96cdf6 100644
--- a/miniapps/nurbs/CMakeLists.txt
+++ b/miniapps/nurbs/CMakeLists.txt
@@ -17,10 +17,6 @@ add_mfem_miniapp(nurbs_curveint
   MAIN nurbs_curveint.cpp
   LIBRARIES mfem)
 
-add_mfem_miniapp(nurbs_patch_ex1
-  MAIN nurbs_patch_ex1.cpp
-  LIBRARIES mfem)
-
 if (MFEM_ENABLE_TESTING)
   add_test(NAME nurbs_ex1_1d_r1_o2_ser
     COMMAND $<TARGET_FILE:nurbs_ex1> -no-vis
@@ -68,17 +64,6 @@ if (MFEM_ENABLE_TESTING)
     COMMAND $<TARGET_FILE:nurbs_ex1> -no-vis
     -m ${PROJECT_SOURCE_DIR}/data/square-disc-nurbs-patch.mesh -o 2 --weak-bc -r 1)
 
-  if (MFEM_USE_LAPACK)
-    add_test(NAME nurbs_patch_ex1_o4_r2_iro8_patcha_ser
-      COMMAND $<TARGET_FILE:nurbs_patch_ex1> -incdeg 3 -ref 2 -iro 8 -patcha)
-  endif()
-
-  add_test(NAME nurbs_patch_ex1_o4_r2_iro8_patcha_pa_ser
-    COMMAND $<TARGET_FILE:nurbs_patch_ex1> -incdeg 3 -ref 2 -iro 8 -patcha -pa)
-
-  add_test(NAME nurbs_patch_ex1_o4_r2_iro8_patcha_fint_ser
-    COMMAND $<TARGET_FILE:nurbs_patch_ex1> -incdeg 3 -ref 2 -iro 8 -patcha -fint)
-
   add_test(NAME nurbs_curveint_unit_weight_ser
     COMMAND $<TARGET_FILE:nurbs_curveint> -no-vis -no-visit
     -uw -n 9)
diff --git a/miniapps/nurbs/makefile b/miniapps/nurbs/makefile
index 90072023b..20c268763 100644
--- a/miniapps/nurbs/makefile
+++ b/miniapps/nurbs/makefile
@@ -21,7 +21,7 @@ CONFIG_MK = $(MFEM_BUILD_DIR)/config/config.mk
 MFEM_LIB_FILE = mfem_is_not_built
 -include $(CONFIG_MK)
 
-SEQ_MINIAPPS = nurbs_ex1 nurbs_patch_ex1 nurbs_curveint
+SEQ_MINIAPPS = nurbs_ex1 nurbs_curveint
 PAR_MINIAPPS = nurbs_ex1p nurbs_ex11p
 ifeq ($(MFEM_USE_MPI),NO)
    MINIAPPS = $(SEQ_MINIAPPS)
@@ -90,16 +90,6 @@ nurbs_ex1-test-seq: nurbs_ex1
 	@$(call mfem-test,$<,, NURBS miniapp,$(EX1_ARGS_16))
 	@$(call mfem-test,$<,, NURBS miniapp,$(EX1_ARGS_17))
 
-EX1PATCH_ARGS_1 := -incdeg 3 -ref 2 -iro 8 -patcha
-EX1PATCH_ARGS_2 := -incdeg 3 -ref 2 -iro 8 -patcha -pa
-EX1PATCH_ARGS_3 := -incdeg 3 -ref 2 -iro 8 -patcha -fint
-nurbs_patch_ex1-test-seq: nurbs_patch_ex1
-ifeq ($(MFEM_USE_LAPACK),YES)
-	@$(call mfem-test,$<,, NURBS miniapp,$(EX1PATCH_ARGS_1))
-endif
-	@$(call mfem-test,$<,, NURBS miniapp,$(EX1PATCH_ARGS_2))
-	@$(call mfem-test,$<,, NURBS miniapp,$(EX1PATCH_ARGS_3))
-
 CI_ARGS_1 := -uw -n 9 -no-visit
 CI_ARGS_2 := -nw -n 9 -no-visit
 
diff --git a/miniapps/nurbs/nurbs_patch_ex1.cpp b/miniapps/nurbs/nurbs_patch_ex1.cpp
deleted file mode 100644
index ce98a9b21..000000000
--- a/miniapps/nurbs/nurbs_patch_ex1.cpp
+++ /dev/null
@@ -1,333 +0,0 @@
-//               MFEM Example 1 - NURBS with patch-wise assembly
-//
-// Compile with: make nurbs_patch_ex1
-//
-// Sample runs:  nurbs_patch_ex1 -incdeg 3 -ref 2 -iro 8 -patcha
-//               nurbs_patch_ex1 -incdeg 3 -ref 2 -iro 8 -patcha -pa
-//               nurbs_patch_ex1 -incdeg 3 -ref 2 -iro 8 -patcha -fint
-//
-// Description:  This example code demonstrates the use of MFEM to define a
-//               simple finite element discretization of the Laplace problem
-//               -Delta u = 1 with homogeneous Dirichlet boundary conditions.
-//               Specifically, we discretize using a FE space of the specified
-//               order, or if order < 1 using an isoparametric/isogeometric
-//               space (i.e. quadratic for quadratic curvilinear mesh, NURBS for
-//               NURBS mesh, etc.)
-//
-//               This example is a specialization of ex1 which demonstrates
-//               patch-wise matrix assembly and partial assembly on NURBS
-//               meshes. There is the option to compare run times of patch
-//               and element assembly, as well as relative error computation.
-
-#include "mfem.hpp"
-#include <fstream>
-#include <iostream>
-
-using namespace std;
-using namespace mfem;
-
-void AssembleAndSolve(LinearForm & b, BilinearFormIntegrator * bfi,
-                      Array<int> const& ess_tdof_list, const bool pa,
-                      const bool algebraic_ceed, GridFunction & x);
-
-int main(int argc, char *argv[])
-{
-   // 1. Parse command-line options.
-   const char *mesh_file = "../../data/beam-hex-nurbs.mesh";
-   int order = -1;
-   bool pa = false;
-   const char *device_config = "cpu";
-   bool visualization = true;
-   bool algebraic_ceed = false;
-   bool patchAssembly = false;
-   bool reducedIntegration = true;
-   bool compareToElementWise = true;
-   int nurbs_degree_increase = 0;  // Elevate the NURBS mesh degree by this
-   int ref_levels = 0;
-   int ir_order = -1;
-
-   OptionsParser args(argc, argv);
-   args.AddOption(&mesh_file, "-m", "--mesh",
-                  "Mesh file to use.");
-   args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
-                  "--no-partial-assembly", "Enable Partial Assembly.");
-   args.AddOption(&device_config, "-d", "--device",
-                  "Device configuration string, see Device::Configure().");
-#ifdef MFEM_USE_CEED
-   args.AddOption(&algebraic_ceed, "-a", "--algebraic", "-no-a", "--no-algebraic",
-                  "Use algebraic Ceed solver");
-#endif
-   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
-                  "--no-visualization",
-                  "Enable or disable GLVis visualization.");
-   args.AddOption(&patchAssembly, "-patcha", "--patch-assembly", "-no-patcha",
-                  "--no-patch-assembly", "Enable patch-wise assembly.");
-   args.AddOption(&reducedIntegration, "-rint", "--reduced-integration", "-fint",
-                  "--full-integration", "Enable reduced integration rules.");
-   args.AddOption(&ref_levels, "-ref", "--refine",
-                  "Number of uniform mesh refinements.");
-   args.AddOption(&ir_order, "-iro", "--integration-order",
-                  "Order of integration rule.");
-   args.AddOption(&nurbs_degree_increase, "-incdeg", "--nurbs-degree-increase",
-                  "Elevate NURBS mesh degree by this amount.");
-   args.AddOption(&compareToElementWise, "-cew", "--compare-element",
-                  "-no-compare", "-no-compare-element",
-                  "Compute element-wise solution for comparison");
-   args.Parse();
-   if (!args.Good())
-   {
-      args.PrintUsage(cout);
-      return 1;
-   }
-   args.PrintOptions(cout);
-
-   MFEM_VERIFY(!(pa && !patchAssembly), "Patch assembly must be used with -pa");
-
-   // 2. Enable hardware devices such as GPUs, and programming models such as
-   //    CUDA, OCCA, RAJA and OpenMP based on command line options.
-   Device device(device_config);
-   device.Print();
-
-   // 3. Read the mesh from the given mesh file. For this NURBS patch example,
-   //    only 3D hexahedral meshes are currently supported. The NURBS degree is
-   //    optionally increased.
-   Mesh mesh(mesh_file, 1, 1);
-   int dim = mesh.Dimension();
-
-   if (nurbs_degree_increase > 0) { mesh.DegreeElevate(nurbs_degree_increase); }
-
-   // 4. Refine the mesh to increase the resolution.
-   for (int l = 0; l < ref_levels; l++)
-   {
-      mesh.UniformRefinement();
-   }
-
-   // 5. Define an isoparametric/isogeometric finite element space on the mesh.
-   FiniteElementCollection *fec = nullptr;
-   bool delete_fec;
-   if (mesh.GetNodes())
-   {
-      fec = mesh.GetNodes()->OwnFEC();
-      delete_fec = false;
-      cout << "Using isoparametric FEs: " << fec->Name() << endl;
-   }
-   else
-   {
-      MFEM_ABORT("Mesh must have nodes");
-   }
-   FiniteElementSpace fespace(&mesh, fec);
-   cout << "Number of finite element unknowns: "
-        << fespace.GetTrueVSize() << endl;
-
-   // 6. Determine the list of true (i.e. conforming) essential boundary dofs.
-   //    In this example, the boundary conditions are defined by marking all
-   //    the boundary attributes from the mesh as essential (Dirichlet) and
-   //    converting them to a list of true dofs.
-   Array<int> ess_tdof_list;
-   if (mesh.bdr_attributes.Size())
-   {
-      Array<int> ess_bdr(mesh.bdr_attributes.Max());
-      ess_bdr = 1;
-      fespace.GetEssentialTrueDofs(ess_bdr, ess_tdof_list);
-   }
-
-   // 7. Set up the linear form b(.) which corresponds to the right-hand side of
-   //    the FEM linear system, which in this case is (1,phi_i) where phi_i are
-   //    the basis functions in the finite element fespace.
-   LinearForm b(&fespace);
-   ConstantCoefficient one(1.0);
-   b.AddDomainIntegrator(new DomainLFIntegrator(one));
-   b.Assemble();
-
-   // 8. Define the solution vector x as a finite element grid function
-   //    corresponding to fespace. Initialize x with initial guess of zero,
-   //    which satisfies the boundary conditions.
-   GridFunction x(&fespace);
-   x = 0.0;
-
-   // 9. Set up the bilinear form a(.,.) on the finite element space
-   //    corresponding to the Laplacian operator -Delta, by adding the Diffusion
-   //    domain integrator.
-   DiffusionIntegrator *di = new DiffusionIntegrator(one);
-
-   if (patchAssembly && reducedIntegration && !pa)
-   {
-      di->SetIntegrationMode(NonlinearFormIntegrator::Mode::PATCHWISE_REDUCED);
-   }
-   else if (patchAssembly)
-   {
-      di->SetIntegrationMode(NonlinearFormIntegrator::Mode::PATCHWISE);
-   }
-
-   NURBSMeshRules *patchRule = nullptr;
-   if (order < 0)
-   {
-      if (ir_order == -1) { ir_order = 2*fec->GetOrder(); }
-      cout << "Using ir_order " << ir_order << endl;
-
-      patchRule = new NURBSMeshRules(mesh.NURBSext->GetNP(), dim);
-      // Loop over patches and set a different rule for each patch.
-      for (int p=0; p<mesh.NURBSext->GetNP(); ++p)
-      {
-         Array<const KnotVector*> kv(dim);
-         mesh.NURBSext->GetPatchKnotVectors(p, kv);
-
-         std::vector<const IntegrationRule*> ir1D(dim);
-         const IntegrationRule *ir = &IntRules.Get(Geometry::SEGMENT, ir_order);
-
-         // Construct 1D integration rules by applying the rule ir to each
-         // knot span.
-         for (int i=0; i<dim; ++i)
-         {
-            ir1D[i] = ir->ApplyToKnotIntervals(*kv[i]);
-         }
-
-         patchRule->SetPatchRules1D(p, ir1D);
-      }  // loop (p) over patches
-
-      patchRule->Finalize(mesh);
-      di->SetNURBSPatchIntRule(patchRule);
-   }
-
-   // 10. Assemble and solve the linear system
-   cout << "Assembling system patch-wise and solving" << endl;
-   AssembleAndSolve(b, di, ess_tdof_list, pa, algebraic_ceed, x);
-
-   delete patchRule;
-
-   // 11. Save the refined mesh and the solution. This output can be viewed
-   //     later using GLVis: "glvis -m refined.mesh -g sol.gf".
-   ofstream mesh_ofs("refined.mesh");
-   mesh_ofs.precision(8);
-   mesh.Print(mesh_ofs);
-   ofstream sol_ofs("sol.gf");
-   sol_ofs.precision(8);
-   x.Save(sol_ofs);
-
-   // 12. Send the solution by socket to a GLVis server.
-   if (visualization)
-   {
-      char vishost[] = "localhost";
-      int  visport   = 19916;
-      socketstream sol_sock(vishost, visport);
-      sol_sock.precision(8);
-      sol_sock << "solution\n" << mesh << x << flush;
-   }
-
-   // 13. Optionally assemble element-wise and solve the linear system, to
-   //     compare timings and compute relative error.
-   if (compareToElementWise)
-   {
-      Vector x_pw, x_ew;
-      x.GetTrueDofs(x_pw);
-
-      cout << "Assembling system element-wise and solving" << endl;
-      DiffusionIntegrator *d = new DiffusionIntegrator(one);
-      // Element-wise partial assembly is not supported on NURBS meshes, so we
-      // pass pa = false here.
-      AssembleAndSolve(b, d, ess_tdof_list, false, algebraic_ceed, x);
-
-      x.GetTrueDofs(x_ew);
-
-      const double solNorm = x_ew.Norml2();
-      x_ew -= x_pw;
-
-      cout << "Element-wise solution norm " << solNorm << endl;
-      cout << "Relative error of patch-wise solution "
-           << x_ew.Norml2() / solNorm << endl;
-   }
-
-   // 14. Free the used memory.
-   if (delete_fec)
-   {
-      delete fec;
-   }
-
-   return 0;
-}
-
-// This function deletes bfi when the BilinearForm goes out of scope.
-void AssembleAndSolve(LinearForm & b, BilinearFormIntegrator * bfi,
-                      Array<int> const& ess_tdof_list, const bool pa,
-                      const bool algebraic_ceed, GridFunction & x)
-{
-   FiniteElementSpace *fespace = b.FESpace();
-   BilinearForm a(fespace);
-   if (pa) { a.SetAssemblyLevel(AssemblyLevel::PARTIAL); }
-
-   a.AddDomainIntegrator(bfi);  // Takes ownership of bfi
-
-   StopWatch sw;
-   sw.Start();
-
-   // Assemble the bilinear form and the corresponding linear system, applying
-   // any necessary transformations such as: eliminating boundary conditions,
-   // applying conforming constraints for non-conforming AMR, etc.
-   a.Assemble();
-
-   sw.Stop();
-
-   const double timeAssemble = sw.RealTime();
-
-   sw.Clear();
-   sw.Start();
-
-   OperatorPtr A;
-   Vector B, X;
-   a.FormLinearSystem(ess_tdof_list, x, b, A, X, B);
-
-   sw.Stop();
-
-   const double timeFormLinearSystem = sw.RealTime();
-
-   cout << "Timing for Assemble: " << timeAssemble << " seconds" << endl;
-   cout << "Timing for FormLinearSystem: " << timeFormLinearSystem << " seconds"
-        << endl;
-   cout << "Timing for entire setup: " << timeAssemble + timeFormLinearSystem
-        << " seconds" << endl;
-
-   sw.Clear();
-   sw.Start();
-
-   // Solve the linear system A X = B.
-   if (!pa)
-   {
-#ifndef MFEM_USE_SUITESPARSE
-      // Use a simple symmetric Gauss-Seidel preconditioner with PCG.
-      GSSmoother M((SparseMatrix&)(*A));
-      PCG(*A, M, B, X, 1, 200, 1e-20, 0.0);
-#else
-      // If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
-      UMFPackSolver umf_solver;
-      umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
-      umf_solver.SetOperator(*A);
-      umf_solver.Mult(B, X);
-#endif
-   }
-   else
-   {
-      if (UsesTensorBasis(*fespace))
-      {
-         if (algebraic_ceed)
-         {
-            ceed::AlgebraicSolver M(a, ess_tdof_list);
-            PCG(*A, M, B, X, 1, 400, 1e-12, 0.0);
-         }
-         else
-         {
-            OperatorJacobiSmoother M(a, ess_tdof_list);
-            PCG(*A, M, B, X, 1, 400, 1e-12, 0.0);
-         }
-      }
-      else
-      {
-         CG(*A, B, X, 1, 400, 1e-20, 0.0);
-      }
-   }
-
-   sw.Stop();
-   cout << "Timing for solve " << sw.RealTime() << endl;
-
-   // Recover the solution as a finite element grid function.
-   a.RecoverFEMSolution(X, b, x);
-}
diff --git a/miniapps/tools/plor-transfer.cpp b/miniapps/tools/plor-transfer.cpp
index d8d87b8e8..17f865c63 100644
--- a/miniapps/tools/plor-transfer.cpp
+++ b/miniapps/tools/plor-transfer.cpp
@@ -225,7 +225,7 @@ int main(int argc, char *argv[])
    {
       Vector M_rho_true(fespace.GetTrueVSize());
       M_ho_tdof->Mult(rho.GetTrueVector(), M_rho_true);
-      fespace.GetRestrictionOperator()->MultTranspose(M_rho_true, M_rho);
+      fespace.GetRestrictionMatrix()->MultTranspose(M_rho_true, M_rho);
       const Operator &P = gt->BackwardOperator();
       P.MultTranspose(M_rho, M_rho_lor);
       double ho_dual_mass = global_sum(M_rho);
@@ -275,8 +275,8 @@ int main(int argc, char *argv[])
    {
       Vector M_rho_lor_true(fespace_lor.GetTrueVSize());
       M_lor_tdof->Mult(rho_lor.GetTrueVector(), M_rho_lor_true);
-      fespace_lor.GetRestrictionOperator()->MultTranspose(M_rho_lor_true,
-                                                          M_rho_lor);
+      fespace_lor.GetRestrictionMatrix()->MultTranspose(M_rho_lor_true,
+                                                        M_rho_lor);
       R.MultTranspose(M_rho_lor, M_rho);
       double ho_dual_mass = global_sum(M_rho);
       double lor_dual_mass = global_sum(M_rho_lor);
diff --git a/tests/scripts/branch-history b/tests/scripts/branch-history
index 5b9539839..f0c038df7 100755
--- a/tests/scripts/branch-history
+++ b/tests/scripts/branch-history
@@ -155,10 +155,10 @@ foreach my $sha (@commits) {
         my $sz1 = int(`git diff -U0 --binary $src1 $dst | gzip -c | wc -c`);
         my $sz2 = int(`git diff -U0 --binary $src2 $dst | gzip -c | wc -c`);
         $blob_size += $sz1 < $sz2 ? $sz1 : $sz2; }
-      elsif ($mode =~ m/A[MR]/) {
+      elsif ($mode eq "AM") {
         my $sz2 = int(`git diff -U0 --binary $src2 $dst | gzip -c | wc -c`);
         $blob_size += $sz2; }
-      elsif ($mode =~ m/[MR]A/) {
+      elsif ($mode eq "MA") {
         my $sz1 = int(`git diff -U0 --binary $src1 $dst | gzip -c | wc -c`);
         $blob_size += $sz1; }
       else { die "Unknown git status letter: $mode, commit: $sha, file: $fname.\n\t" }
diff --git a/tests/unit/fem/test_blocknonlinearform.cpp b/tests/unit/fem/test_blocknonlinearform.cpp
index 51d6b12ab..91fde3467 100644
--- a/tests/unit/fem/test_blocknonlinearform.cpp
+++ b/tests/unit/fem/test_blocknonlinearform.cpp
@@ -126,8 +126,8 @@ TEST_CASE("ParBlockNonlinearForm",
 
       Array<int> block_trueOffsets(3);
       block_trueOffsets[0] = 0;
-      block_trueOffsets[1] = ufes.TrueVSize();
-      block_trueOffsets[2] = rfes.TrueVSize();
+      block_trueOffsets[1] = ufes.GetTrueVSize();
+      block_trueOffsets[2] = rfes.GetTrueVSize();
       block_trueOffsets.PartialSum();
 
       ParGridFunction u_gf(&ufes);
diff --git a/tests/unit/fem/test_pa_grad.cpp b/tests/unit/fem/test_pa_grad.cpp
index a42d7c83c..af0038cee 100644
--- a/tests/unit/fem/test_pa_grad.cpp
+++ b/tests/unit/fem/test_pa_grad.cpp
@@ -154,7 +154,7 @@ double par_compare_pa_assembly(int dim, int num_elements, int order,
    pa_grad.AddDomainInterpolator(new GradientInterpolator);
    pa_grad.Assemble();
    OperatorPtr pa_grad_oper;
-   pa_grad.FormRectangularSystemMatrix(pa_grad_oper);
+   pa_grad.FormDiscreteOperatorMatrix(pa_grad_oper);
 
    int insize, outsize;
    if (transpose)
diff --git a/tests/unit/linalg/test_matrix_dense.cpp b/tests/unit/linalg/test_matrix_dense.cpp
index 4153e58c1..25dd9a6ba 100644
--- a/tests/unit/linalg/test_matrix_dense.cpp
+++ b/tests/unit/linalg/test_matrix_dense.cpp
@@ -691,32 +691,4 @@ TEST_CASE("Eigensystem Problems",
    }
 }
 
-TEST_CASE("NNLS", "[DenseMatrix]")
-{
-   const int m = 3;
-   const int n = 5;
-   DenseMatrix G(m,n);
-   G = 0.0;
-
-   for (int i=0; i<m; ++i)
-      for (int j=0; j<n; ++j)
-      {
-         G(i,j) = j;
-      }
-
-   Vector w(n);
-   w = 1.0;
-
-   Vector sol(n);
-
-   NNLSSolver nnls;
-   nnls.SetVerbosity(2);
-   nnls.SetOperator(G);
-
-   nnls.Mult(w, sol);
-
-   REQUIRE(sol.Norml2() == MFEM_Approx(2.5));
-   REQUIRE(sol[4] == MFEM_Approx(2.5));
-}
-
 #endif // if MFEM_USE_LAPACK
diff --git a/tests/unit/linalg/test_matrix_rectangular.cpp b/tests/unit/linalg/test_matrix_rectangular.cpp
index 5347ba129..9579f0f9d 100644
--- a/tests/unit/linalg/test_matrix_rectangular.cpp
+++ b/tests/unit/linalg/test_matrix_rectangular.cpp
@@ -213,15 +213,15 @@ TEST_CASE("HypreParMatrixBlocksRectangular",
 
       Array<int> blockRow_trueOffsets(3); // number of variables + 1
       blockRow_trueOffsets[0] = 0;
-      blockRow_trueOffsets[1] = R_space.TrueVSize();
-      blockRow_trueOffsets[2] = W_space.TrueVSize();
+      blockRow_trueOffsets[1] = R_space.GetTrueVSize();
+      blockRow_trueOffsets[2] = W_space.GetTrueVSize();
       blockRow_trueOffsets.PartialSum();
 
       Array<int> blockCol_trueOffsets(4); // number of variables + 1
       blockCol_trueOffsets[0] = 0;
-      blockCol_trueOffsets[1] = R_space.TrueVSize();
-      blockCol_trueOffsets[2] = W_space.TrueVSize();
-      blockCol_trueOffsets[3] = W_space.TrueVSize();
+      blockCol_trueOffsets[1] = R_space.GetTrueVSize();
+      blockCol_trueOffsets[2] = W_space.GetTrueVSize();
+      blockCol_trueOffsets[3] = W_space.GetTrueVSize();
       blockCol_trueOffsets.PartialSum();
 
       BlockOperator blockOper(blockRow_trueOffsets, blockCol_trueOffsets);
diff --git a/tests/unit/linalg/test_matrix_square.cpp b/tests/unit/linalg/test_matrix_square.cpp
index 8009f5033..f8b0f4b2e 100644
--- a/tests/unit/linalg/test_matrix_square.cpp
+++ b/tests/unit/linalg/test_matrix_square.cpp
@@ -223,8 +223,8 @@ TEST_CASE("HypreParMatrixBlocksSquare",
 
       Array<int> blockRow_trueOffsets(3); // number of variables + 1
       blockRow_trueOffsets[0] = 0;
-      blockRow_trueOffsets[1] = R_space.TrueVSize();
-      blockRow_trueOffsets[2] = W_space.TrueVSize();
+      blockRow_trueOffsets[1] = R_space.GetTrueVSize();
+      blockRow_trueOffsets[2] = W_space.GetTrueVSize();
       blockRow_trueOffsets.PartialSum();
 
       BlockOperator blockOper(blockRow_trueOffsets, blockRow_trueOffsets);
@@ -247,8 +247,8 @@ TEST_CASE("HypreParMatrixBlocksSquare",
 
       Vector yB(blockRow_trueOffsets[2]);
       Vector yH(blockRow_trueOffsets[2]);
-      Vector yBR(yB, 0, R_space.TrueVSize());
-      Vector yBW(yB, R_space.TrueVSize(), W_space.TrueVSize());
+      Vector yBR(yB, 0, R_space.GetTrueVSize());
+      Vector yBW(yB, R_space.GetTrueVSize(), W_space.GetTrueVSize());
 
       yB = 0.0;
       yH = 0.0;
