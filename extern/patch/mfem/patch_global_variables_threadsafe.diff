diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index b812e22eb..96aa854a5 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -355,15 +355,11 @@ int InverseElementTransformation::Transform(const Vector &pt,
          }
          else
          {
-            const int old_type = GlobGeometryRefiner.GetType();
-            GlobGeometryRefiner.SetType(qpts_type);
-            RefinedGeometry &RefG =
-               *GlobGeometryRefiner.Refine(T->GetGeometryType(), order);
+            RefinedGeometry &RefG = *refiner.Refine(T->GetGeometryType(), order);
             int closest_idx = (init_guess_type == ClosestPhysNode) ?
                               FindClosestPhysPoint(pt, RefG.RefPts) :
                               FindClosestRefPoint(pt, RefG.RefPts);
             ip0 = &RefG.RefPts.IntPoint(closest_idx);
-            GlobGeometryRefiner.SetType(old_type);
          }
          break;
       }
diff --git a/fem/eltrans.hpp b/fem/eltrans.hpp
index 198e20df3..43eccd499 100644
--- a/fem/eltrans.hpp
+++ b/fem/eltrans.hpp
@@ -234,6 +234,7 @@ protected:
    const IntegrationPoint *ip0;
    int init_guess_type; // algorithm to use
    int qpts_type; // Quadrature1D type for the initial guess type
+   GeometryRefiner refiner; // geometry refiner for initial guess
    int rel_qpts_order; // num_1D_qpts = max(trans_order+rel_qpts_order,0)+1
    int solver_type; // solution strategy to use
    int max_iter; // max. number of Newton iterations
@@ -277,6 +278,7 @@ public:
         ip0(NULL),
         init_guess_type(Center),
         qpts_type(Quadrature1D::OpenHalfUniform),
+        refiner(qpts_type),
         rel_qpts_order(-1),
         solver_type(NewtonElementProject),
         max_iter(16),
@@ -301,7 +303,8 @@ public:
    { ip0 = &init_ip; SetInitialGuessType(GivenPoint); }
 
    /// Set the Quadrature1D type used for the `Closest*` initial guess types.
-   void SetInitGuessPointsType(int q_type) { qpts_type = q_type; }
+   void SetInitGuessPointsType(int q_type)
+   { qpts_type = q_type; refiner.SetType(q_type); }
 
    /// Set the relative order used for the `Closest*` initial guess types.
    /** The number of points in each spatial direction is given by the formula
@@ -361,7 +364,7 @@ public:
 class IsoparametricTransformation : public ElementTransformation
 {
 private:
-   DenseMatrix dshape,d2shape;
+   DenseMatrix dshape, d2shape;
    Vector shape;
 
    const FiniteElement *FElem;
diff --git a/fem/fe/fe_base.cpp b/fem/fe/fe_base.cpp
index b2f49a4bc..4387ae775 100644
--- a/fem/fe/fe_base.cpp
+++ b/fem/fe/fe_base.cpp
@@ -359,135 +359,148 @@ void  FiniteElement::CalcPhysHessian(ElementTransformation &Trans,
 
    // Hessian in physical coords
    lhm.Invert();
-   Mult( hess, lhm, Hessian);
+   Mult(hess, lhm, Hessian);
 }
 
 const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
                                              DofToQuad::Mode mode) const
 {
+   DofToQuad *d2q = nullptr;
    MFEM_VERIFY(mode == DofToQuad::FULL, "invalid mode requested");
 
-   for (int i = 0; i < dof2quad_array.Size(); i++)
-   {
-      const DofToQuad &d2q = *dof2quad_array[i];
-      if (d2q.IntRule == &ir && d2q.mode == mode) { return d2q; }
-   }
-
-#ifdef MFEM_THREAD_SAFE
-   DenseMatrix vshape(dof, dim);
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   #pragma omp critical (DofToQuad)
 #endif
-
-   DofToQuad *d2q = new DofToQuad;
-   const int nqpt = ir.GetNPoints();
-   d2q->FE = this;
-   d2q->IntRule = &ir;
-   d2q->mode = mode;
-   d2q->ndof = dof;
-   d2q->nqpt = nqpt;
-   if (range_type == SCALAR)
-   {
-      d2q->B.SetSize(nqpt*dof);
-      d2q->Bt.SetSize(dof*nqpt);
-
-      Vector shape;
-      vshape.GetColumnReference(0, shape);
-      for (int i = 0; i < nqpt; i++)
-      {
-         const IntegrationPoint &ip = ir.IntPoint(i);
-         CalcShape(ip, shape);
-         for (int j = 0; j < dof; j++)
-         {
-            d2q->B[i+nqpt*j] = d2q->Bt[j+dof*i] = shape(j);
-         }
-      }
-   }
-   else if (range_type == VECTOR)
    {
-      d2q->B.SetSize(nqpt*dim*dof);
-      d2q->Bt.SetSize(dof*nqpt*dim);
-
-      for (int i = 0; i < nqpt; i++)
+      for (int i = 0; i < dof2quad_array.Size(); i++)
       {
-         const IntegrationPoint &ip = ir.IntPoint(i);
-         CalcVShape(ip, vshape);
-         for (int d = 0; d < dim; d++)
-         {
-            for (int j = 0; j < dof; j++)
-            {
-               d2q->B[i+nqpt*(d+dim*j)] = d2q->Bt[j+dof*(i+nqpt*d)] = vshape(j, d);
-            }
-         }
+         d2q = dof2quad_array[i];
+         if (d2q->IntRule != &ir || d2q->mode != mode) { d2q = nullptr; }
       }
-   }
-   else
-   {
-      // Skip B and Bt for unknown range type
-   }
-   switch (deriv_type)
-   {
-      case GRAD:
+      if (!d2q)
       {
-         d2q->G.SetSize(nqpt*dim*dof);
-         d2q->Gt.SetSize(dof*nqpt*dim);
-
-         for (int i = 0; i < nqpt; i++)
+#ifdef MFEM_THREAD_SAFE
+         DenseMatrix vshape(dof, dim);
+#endif
+         d2q = new DofToQuad;
+         const int nqpt = ir.GetNPoints();
+         d2q->FE = this;
+         d2q->IntRule = &ir;
+         d2q->mode = mode;
+         d2q->ndof = dof;
+         d2q->nqpt = nqpt;
+         switch (range_type)
          {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcDShape(ip, vshape);
-            for (int d = 0; d < dim; d++)
+            case SCALAR:
             {
-               for (int j = 0; j < dof; j++)
+               d2q->B.SetSize(nqpt*dof);
+               d2q->Bt.SetSize(dof*nqpt);
+
+               Vector shape;
+               vshape.GetColumnReference(0, shape);
+               for (int i = 0; i < nqpt; i++)
                {
-                  d2q->G[i+nqpt*(d+dim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcShape(ip, shape);
+                  for (int j = 0; j < dof; j++)
+                  {
+                     d2q->B[i+nqpt*j] = d2q->Bt[j+dof*i] = shape(j);
+                  }
                }
+               break;
             }
-         }
-         break;
-      }
-      case DIV:
-      {
-         d2q->G.SetSize(nqpt*dof);
-         d2q->Gt.SetSize(dof*nqpt);
+            case VECTOR:
+            {
+               d2q->B.SetSize(nqpt*dim*dof);
+               d2q->Bt.SetSize(dof*nqpt*dim);
 
-         Vector divshape;
-         vshape.GetColumnReference(0, divshape);
-         for (int i = 0; i < nqpt; i++)
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcVShape(ip, vshape);
+                  for (int d = 0; d < dim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->B[i+nqpt*(d+dim*j)] =
+                           d2q->Bt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                     }
+                  }
+               }
+               break;
+            }
+            case UNKNOWN_RANGE_TYPE:
+               // Skip B and Bt for unknown range type
+               break;
+         }
+         switch (deriv_type)
          {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcDivShape(ip, divshape);
-            for (int j = 0; j < dof; j++)
+            case GRAD:
             {
-               d2q->G[i+nqpt*j] = d2q->Gt[j+dof*i] = divshape(j);
+               d2q->G.SetSize(nqpt*dim*dof);
+               d2q->Gt.SetSize(dof*nqpt*dim);
+
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcDShape(ip, vshape);
+                  for (int d = 0; d < dim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->G[i+nqpt*(d+dim*j)] =
+                           d2q->Gt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                     }
+                  }
+               }
+               break;
             }
-         }
-         break;
-      }
-      case CURL:
-      {
-         d2q->G.SetSize(nqpt*cdim*dof);
-         d2q->Gt.SetSize(dof*nqpt*cdim);
+            case DIV:
+            {
+               d2q->G.SetSize(nqpt*dof);
+               d2q->Gt.SetSize(dof*nqpt);
 
-         DenseMatrix curlshape(vshape.GetData(), dof, cdim);  // cdim <= dim
-         for (int i = 0; i < nqpt; i++)
-         {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcCurlShape(ip, curlshape);
-            for (int d = 0; d < cdim; d++)
+               Vector divshape;
+               vshape.GetColumnReference(0, divshape);
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcDivShape(ip, divshape);
+                  for (int j = 0; j < dof; j++)
+                  {
+                     d2q->G[i+nqpt*j] = d2q->Gt[j+dof*i] = divshape(j);
+                  }
+               }
+               break;
+            }
+            case CURL:
             {
-               for (int j = 0; j < dof; j++)
+               d2q->G.SetSize(nqpt*cdim*dof);
+               d2q->Gt.SetSize(dof*nqpt*cdim);
+
+               DenseMatrix curlshape(vshape.GetData(), dof, cdim);  // cdim <= dim
+               for (int i = 0; i < nqpt; i++)
                {
-                  d2q->G[i+nqpt*(d+cdim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcCurlShape(ip, curlshape);
+                  for (int d = 0; d < cdim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->G[i+nqpt*(d+cdim*j)] =
+                           d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                     }
+                  }
                }
+               break;
             }
+            case NONE:
+               // Skip G and Gt for unknown derivative type
+               break;
          }
-         break;
+         dof2quad_array.Append(d2q);
       }
-      case NONE:
-      default:
-         // Skip G and Gt for unknown derivative type
-         break;
    }
-   dof2quad_array.Append(d2q);
    return *d2q;
 }
 
@@ -904,14 +917,14 @@ VectorFiniteElement::VectorFiniteElement(int D, Geometry::Type G,
 }
 
 void VectorFiniteElement::CalcShape(
-   const IntegrationPoint &ip, Vector &shape ) const
+   const IntegrationPoint &ip, Vector &shape) const
 {
    mfem_error("Error: Cannot use scalar CalcShape(...) function with\n"
               "   VectorFiniteElements!");
 }
 
 void VectorFiniteElement::CalcDShape(
-   const IntegrationPoint &ip, DenseMatrix &dshape ) const
+   const IntegrationPoint &ip, DenseMatrix &dshape) const
 {
    mfem_error("Error: Cannot use scalar CalcDShape(...) function with\n"
               "   VectorFiniteElements!");
@@ -2183,51 +2196,72 @@ void Poly_1D::CalcChebyshev(const int p, const double x, double *u, double *d,
 
 const double *Poly_1D::GetPoints(const int p, const int btype)
 {
+   Array<double*> *pts;
    BasisType::Check(btype);
    const int qtype = BasisType::GetQuadrature1D(btype);
-
    if (qtype == Quadrature1D::Invalid) { return NULL; }
 
-   if (points_container.find(btype) == points_container.end())
-   {
-      points_container[btype] = new Array<double*>(h_mt);
-   }
-   Array<double*> &pts = *points_container[btype];
-   if (pts.Size() <= p)
-   {
-      pts.SetSize(p + 1, NULL);
-   }
-   if (pts[p] == NULL)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   #pragma omp critical (Poly1DGetPoints)
+#endif
    {
-      pts[p] = new double[p + 1];
-      quad_func.GivePolyPoints(p+1, pts[p], qtype);
+      auto it = points_container.find(btype);
+      if (it != points_container.end())
+      {
+         pts = it->second;
+      }
+      else
+      {
+         pts = new Array<double*>(h_mt);
+         points_container[btype] = pts;
+      }
+      if (pts->Size() <= p)
+      {
+         pts->SetSize(p + 1, NULL);
+      }
+      if ((*pts)[p] == NULL)
+      {
+         (*pts)[p] = new double[p + 1];
+         quad_func.GivePolyPoints(p + 1, (*pts)[p], qtype);
+      }
    }
-   return pts[p];
+   return (*pts)[p];
 }
 
 Poly_1D::Basis &Poly_1D::GetBasis(const int p, const int btype)
 {
+   Array<Basis*> *bases;
    BasisType::Check(btype);
 
-   if ( bases_container.find(btype) == bases_container.end() )
-   {
-      // we haven't been asked for basis or points of this type yet
-      bases_container[btype] = new Array<Basis*>(h_mt);
-   }
-   Array<Basis*> &bases = *bases_container[btype];
-   if (bases.Size() <= p)
-   {
-      bases.SetSize(p + 1, NULL);
-   }
-   if (bases[p] == NULL)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   #pragma omp critical (Poly1DGetBasis)
+#endif
    {
-      EvalType etype;
-      if (btype == BasisType::Positive) { etype = Positive; }
-      else if (btype == BasisType::IntegratedGLL) { etype = Integrated; }
-      else { etype = Barycentric; }
-      bases[p] = new Basis(p, GetPoints(p, btype), etype);
+      auto it = bases_container.find(btype);
+      if (it != bases_container.end())
+      {
+         bases = it->second;
+      }
+      else
+      {
+         // we haven't been asked for basis or points of this type yet
+         bases = new Array<Basis*>(h_mt);
+         bases_container[btype] = bases;
+      }
+      if (bases->Size() <= p)
+      {
+         bases->SetSize(p + 1, NULL);
+      }
+      if ((*bases)[p] == NULL)
+      {
+         EvalType etype;
+         if (btype == BasisType::Positive) { etype = Positive; }
+         else if (btype == BasisType::IntegratedGLL) { etype = Integrated; }
+         else { etype = Barycentric; }
+         (*bases)[p] = new Basis(p, GetPoints(p, btype), etype);
+      }
    }
-   return *bases[p];
+   return *(*bases)[p];
 }
 
 Poly_1D::~Poly_1D()
@@ -2236,7 +2270,7 @@ Poly_1D::~Poly_1D()
         it != points_container.end() ; ++it)
    {
       Array<double*>& pts = *it->second;
-      for ( int i = 0 ; i < pts.Size() ; ++i )
+      for (int i = 0; i < pts.Size(); ++i)
       {
          delete [] pts[i];
       }
@@ -2247,7 +2281,7 @@ Poly_1D::~Poly_1D()
         it != bases_container.end() ; ++it)
    {
       Array<Basis*>& bases = *it->second;
-      for ( int i = 0 ; i < bases.Size() ; ++i )
+      for (int i = 0; i < bases.Size(); ++i)
       {
          delete bases[i];
       }
@@ -2461,39 +2495,47 @@ const DofToQuad &TensorBasisElement::GetTensorDofToQuad(
    DofToQuad::Mode mode, const Poly_1D::Basis &basis, bool closed,
    Array<DofToQuad*> &dof2quad_array)
 {
+   DofToQuad *d2q = nullptr;
    MFEM_VERIFY(mode == DofToQuad::TENSOR, "invalid mode requested");
 
-   for (int i = 0; i < dof2quad_array.Size(); i++)
-   {
-      const DofToQuad &d2q = *dof2quad_array[i];
-      if (d2q.IntRule == &ir && d2q.mode == mode) { return d2q; }
-   }
-
-   DofToQuad *d2q = new DofToQuad;
-   const int ndof = closed ? fe.GetOrder() + 1 : fe.GetOrder();
-   const int nqpt = (int)floor(pow(ir.GetNPoints(), 1.0/fe.GetDim()) + 0.5);
-   d2q->FE = &fe;
-   d2q->IntRule = &ir;
-   d2q->mode = mode;
-   d2q->ndof = ndof;
-   d2q->nqpt = nqpt;
-   d2q->B.SetSize(nqpt*ndof);
-   d2q->Bt.SetSize(ndof*nqpt);
-   d2q->G.SetSize(nqpt*ndof);
-   d2q->Gt.SetSize(ndof*nqpt);
-   Vector val(ndof), grad(ndof);
-   for (int i = 0; i < nqpt; i++)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   #pragma omp critical (DofToQuad)
+#endif
    {
-      // The first 'nqpt' points in 'ir' have the same x-coordinates as those
-      // of the 1D rule.
-      basis.Eval(ir.IntPoint(i).x, val, grad);
-      for (int j = 0; j < ndof; j++)
-      {
-         d2q->B[i+nqpt*j] = d2q->Bt[j+ndof*i] = val(j);
-         d2q->G[i+nqpt*j] = d2q->Gt[j+ndof*i] = grad(j);
+      for (int i = 0; i < dof2quad_array.Size(); i++)
+      {
+         d2q = dof2quad_array[i];
+         if (d2q->IntRule != &ir || d2q->mode != mode) { d2q = nullptr; }
+      }
+      if (!d2q)
+      {
+         d2q = new DofToQuad;
+         const int ndof = closed ? fe.GetOrder() + 1 : fe.GetOrder();
+         const int nqpt = (int)floor(pow(ir.GetNPoints(), 1.0/fe.GetDim()) + 0.5);
+         d2q->FE = &fe;
+         d2q->IntRule = &ir;
+         d2q->mode = mode;
+         d2q->ndof = ndof;
+         d2q->nqpt = nqpt;
+         d2q->B.SetSize(nqpt*ndof);
+         d2q->Bt.SetSize(ndof*nqpt);
+         d2q->G.SetSize(nqpt*ndof);
+         d2q->Gt.SetSize(ndof*nqpt);
+         Vector val(ndof), grad(ndof);
+         for (int i = 0; i < nqpt; i++)
+         {
+            // The first 'nqpt' points in 'ir' have the same x-coordinates as those
+            // of the 1D rule.
+            basis.Eval(ir.IntPoint(i).x, val, grad);
+            for (int j = 0; j < ndof; j++)
+            {
+               d2q->B[i+nqpt*j] = d2q->Bt[j+ndof*i] = val(j);
+               d2q->G[i+nqpt*j] = d2q->Gt[j+ndof*i] = grad(j);
+            }
+         }
+         dof2quad_array.Append(d2q);
       }
    }
-   dof2quad_array.Append(d2q);
    return *d2q;
 }
 
diff --git a/fem/fe/fe_base.hpp b/fem/fe/fe_base.hpp
index b948b4f8d..f9e31b457 100644
--- a/fem/fe/fe_base.hpp
+++ b/fem/fe/fe_base.hpp
@@ -250,7 +250,7 @@ protected:
    /// Container for all DofToQuad objects created by the FiniteElement.
    /** Multiple DofToQuad objects may be needed when different quadrature rules
        or different DofToQuad::Mode are used. */
-   mutable Array<DofToQuad*> dof2quad_array;
+   mutable Array<DofToQuad *> dof2quad_array;
 
 public:
    /// Enumeration for range_type and deriv_range_type
@@ -1026,8 +1026,8 @@ public:
    };
 
 private:
-   typedef std::map< int, Array<double*>* > PointsMap;
-   typedef std::map< int, Array<Basis*>* > BasisMap;
+   typedef std::map<int, Array<double*>*> PointsMap;
+   typedef std::map<int, Array<Basis*>*> BasisMap;
 
    MemoryType h_mt;
    PointsMap points_container;
diff --git a/fem/geom.cpp b/fem/geom.cpp
index 5438d741f..2d9f4e907 100644
--- a/fem/geom.cpp
+++ b/fem/geom.cpp
@@ -262,7 +262,7 @@ Geometry::~Geometry()
    }
 }
 
-const IntegrationRule * Geometry::GetVertices(int GeomType)
+const IntegrationRule *Geometry::GetVertices(int GeomType) const
 {
    switch (GeomType)
    {
@@ -274,8 +274,9 @@ const IntegrationRule * Geometry::GetVertices(int GeomType)
       case Geometry::CUBE:        return GeomVert[5];
       case Geometry::PRISM:       return GeomVert[6];
       case Geometry::PYRAMID:     return GeomVert[7];
-      default:
-         mfem_error ("Geometry::GetVertices(...)");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         mfem_error("Geometry::GetVertices(...)");
    }
    // make some compilers happy.
    return GeomVert[0];
@@ -370,7 +371,8 @@ void Geometry::GetRandomPoint(int GeomType, IntegrationPoint &ip)
             ip.x = 1.0 - z;
          }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
 }
@@ -435,12 +437,14 @@ bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip)
          if (ip.x < 0.0 || ip.y < 0.0 || ip.x+ip.z > 1.0 || ip.y+ip.z > 1.0 ||
              ip.z < 0.0 || ip.z > 1.0) { return false; }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
 }
 
+// static method
 bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip, double eps)
 {
    switch (GeomType)
@@ -516,7 +520,8 @@ bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip, double eps)
             return false;
          }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
@@ -640,7 +645,8 @@ bool Geometry::ProjectPoint(int GeomType, const IntegrationPoint &beg,
                           };
          return internal::IntersectSegment<6,3>(lbeg, lend, end);
       }
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
@@ -774,13 +780,16 @@ bool Geometry::ProjectPoint(int GeomType, IntegrationPoint &ip)
          }
       }
 
-      default:
+      case Geometry::POINT:
          MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
 }
 
-void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm)
+void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm) const
 {
    switch (GeomType)
    {
@@ -859,8 +868,11 @@ void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm)
       }
       break;
 
-      default:
-         mfem_error ("Geometry::GetPerfPointMat (...)");
+      case Geometry::POINT:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 }
 
@@ -1055,11 +1067,6 @@ Constants<Geometry::PYRAMID>::VertToVert::J[8][2] =
 };
 
 
-GeometryRefiner::GeometryRefiner()
-{
-   type = Quadrature1D::ClosedUniform;
-}
-
 GeometryRefiner::~GeometryRefiner()
 {
    for (int i = 0; i < Geometry::NumGeom; i++)
@@ -1070,10 +1077,9 @@ GeometryRefiner::~GeometryRefiner()
 }
 
 RefinedGeometry *GeometryRefiner::FindInRGeom(Geometry::Type Geom,
-                                              int Times, int ETimes,
-                                              int Type)
+                                              int Times, int ETimes) const
 {
-   Array<RefinedGeometry *> &RGA = RGeom[Geom];
+   const Array<RefinedGeometry *> &RGA = RGeom[Geom];
    for (int i = 0; i < RGA.Size(); i++)
    {
       RefinedGeometry &RG = *RGA[i];
@@ -1085,9 +1091,10 @@ RefinedGeometry *GeometryRefiner::FindInRGeom(Geometry::Type Geom,
    return NULL;
 }
 
-IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom, int NPts)
+IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom,
+                                               int NPts) const
 {
-   Array<IntegrationRule *> &IPA = IntPts[Geom];
+   const Array<IntegrationRule *> &IPA = IntPts[Geom];
    for (int i = 0; i < IPA.Size(); i++)
    {
       IntegrationRule &ir = *IPA[i];
@@ -1096,491 +1103,538 @@ IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom, int NPts)
    return NULL;
 }
 
-RefinedGeometry * GeometryRefiner::Refine(Geometry::Type Geom,
-                                          int Times, int ETimes)
+RefinedGeometry *GeometryRefiner::Refine(Geometry::Type Geom, int Times,
+                                         int ETimes)
 {
+   RefinedGeometry *RG = NULL;
    int i, j, k, l, m;
-
    Times = std::max(Times, 1);
    ETimes = Geometry::Dimension[Geom] <= 1 ? 0 : std::max(ETimes, 1);
-   const double *cp = poly1d.GetPoints(Times, BasisType::GetNodalBasis(type));
+   const double *cp = poly1d.GetPoints(Times, BasisType::GetNodalBasis(Type));
 
-   RefinedGeometry *RG = FindInRGeom(Geom, Times, ETimes, type);
-   if (RG) { return RG; }
-
-   switch (Geom)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   #pragma omp critical (Refine)
+#endif
    {
-      case Geometry::POINT:
+      RG = FindInRGeom(Geom, Times, ETimes);
+      if (!RG)
       {
-         RG = new RefinedGeometry(1, 1, 0);
-         RG->Times = 1;
-         RG->ETimes = 0;
-         RG->Type = type;
-         RG->RefPts.IntPoint(0).x = cp[0];
-         RG->RefGeoms[0] = 0;
-
-         RGeom[Geometry::POINT].Append(RG);
-         return RG;
-      }
-
-      case Geometry::SEGMENT:
-      {
-         RG = new RefinedGeometry(Times+1, 2*Times, 0);
-         RG->Times = Times;
-         RG->ETimes = 0;
-         RG->Type = type;
-         for (i = 0; i <= Times; i++)
-         {
-            IntegrationPoint &ip = RG->RefPts.IntPoint(i);
-            ip.x = cp[i];
-         }
-         Array<int> &G = RG->RefGeoms;
-         for (i = 0; i < Times; i++)
+         switch (Geom)
          {
-            G[2*i+0] = i;
-            G[2*i+1] = i+1;
-         }
-
-         RGeom[Geometry::SEGMENT].Append(RG);
-         return RG;
-      }
-
-      case Geometry::TRIANGLE:
-      {
-         RG = new RefinedGeometry((Times+1)*(Times+2)/2, 3*Times*Times,
-                                  3*Times*(ETimes+1), 3*Times);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (k = j = 0; j <= Times; j++)
-            for (i = 0; i <= Times-j; i++, k++)
+            case Geometry::POINT:
             {
-               IntegrationPoint &ip = RG->RefPts.IntPoint(k);
-               ip.x = cp[i]/(cp[i] + cp[j] + cp[Times-i-j]);
-               ip.y = cp[j]/(cp[i] + cp[j] + cp[Times-i-j]);
+               RG = new RefinedGeometry(1, 1, 0);
+               RG->Times = 1;
+               RG->ETimes = 0;
+               RG->Type = Type;
+               RG->RefPts.IntPoint(0).x = cp[0];
+               RG->RefGeoms[0] = 0;
+
+               RGeom[Geometry::POINT].Append(RG);
             }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = j = 0; j < Times; j++, k++)
-            for (i = 0; i < Times-j; i++, k++)
+            break;
+
+            case Geometry::SEGMENT:
             {
-               G[l++] = k;
-               G[l++] = k+1;
-               G[l++] = k+Times-j+1;
-               if (i+j+1 < Times)
+               RG = new RefinedGeometry(Times+1, 2*Times, 0);
+               RG->Times = Times;
+               RG->ETimes = 0;
+               RG->Type = Type;
+               for (i = 0; i <= Times; i++)
                {
-                  G[l++] = k+1;
-                  G[l++] = k+Times-j+2;
-                  G[l++] = k+Times-j+1;
+                  IntegrationPoint &ip = RG->RefPts.IntPoint(i);
+                  ip.x = cp[i];
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (i = 0; i < Times; i++)
+               {
+                  G[2*i+0] = i;
+                  G[2*i+1] = i+1;
                }
-            }
-         Array<int> &E = RG->RefEdges;
-         int lb = 0, li = 2*RG->NumBdrEdges;
-         // horizontal edges
-         for (k = 0; k < Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0) ? lb : li;
-            j = k*(Times+1)-((k-1)*k)/2;
-            for (i = 0; i < Times-k; i++)
-            {
-               E[lt++] = j; j++;
-               E[lt++] = j;
-            }
-         }
-         // diagonal edges
-         for (k = Times; k > 0; k -= Times/ETimes)
-         {
-            int &lt = (k == Times) ? lb : li;
-            j = k;
-            for (i = 0; i < k; i++)
-            {
-               E[lt++] = j; j += Times-i;
-               E[lt++] = j;
-            }
-         }
-         // vertical edges
-         for (k = 0; k < Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0) ? lb : li;
-            j = k;
-            for (i = 0; i < Times-k; i++)
-            {
-               E[lt++] = j; j += Times-i+1;
-               E[lt++] = j;
-            }
-         }
-
-         RGeom[Geometry::TRIANGLE].Append(RG);
-         return RG;
-      }
 
-      case Geometry::SQUARE:
-      {
-         RG = new RefinedGeometry((Times+1)*(Times+1), 4*Times*Times,
-                                  4*(ETimes+1)*Times, 4*Times);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (k = j = 0; j <= Times; j++)
-            for (i = 0; i <= Times; i++, k++)
-            {
-               IntegrationPoint &ip = RG->RefPts.IntPoint(k);
-               ip.x = cp[i];
-               ip.y = cp[j];
-            }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = j = 0; j < Times; j++, k++)
-            for (i = 0; i < Times; i++, k++)
-            {
-               G[l++] = k;
-               G[l++] = k+1;
-               G[l++] = k+Times+2;
-               G[l++] = k+Times+1;
+               RGeom[Geometry::SEGMENT].Append(RG);
             }
-         Array<int> &E = RG->RefEdges;
-         int lb = 0, li = 2*RG->NumBdrEdges;
-         // horizontal edges
-         for (k = 0; k <= Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0 || k == Times) ? lb : li;
-            for (i = 0, j = k*(Times+1); i < Times; i++)
-            {
-               E[lt++] = j; j++;
-               E[lt++] = j;
-            }
-         }
-         // vertical edges (in right-to-left order)
-         for (k = Times; k >= 0; k -= Times/ETimes)
-         {
-            int &lt = (k == Times || k == 0) ? lb : li;
-            for (i = 0, j = k; i < Times; i++)
+            break;
+
+            case Geometry::TRIANGLE:
             {
-               E[lt++] = j; j += Times+1;
-               E[lt++] = j;
-            }
-         }
+               RG = new RefinedGeometry((Times+1)*(Times+2)/2, 3*Times*Times,
+                                        3*Times*(ETimes+1), 3*Times);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (k = j = 0; j <= Times; j++)
+               {
+                  for (i = 0; i <= Times-j; i++, k++)
+                  {
+                     IntegrationPoint &ip = RG->RefPts.IntPoint(k);
+                     ip.x = cp[i]/(cp[i] + cp[j] + cp[Times-i-j]);
+                     ip.y = cp[j]/(cp[i] + cp[j] + cp[Times-i-j]);
+                  }
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = j = 0; j < Times; j++, k++)
+               {
+                  for (i = 0; i < Times-j; i++, k++)
+                  {
+                     G[l++] = k;
+                     G[l++] = k+1;
+                     G[l++] = k+Times-j+1;
+                     if (i+j+1 < Times)
+                     {
+                        G[l++] = k+1;
+                        G[l++] = k+Times-j+2;
+                        G[l++] = k+Times-j+1;
+                     }
+                  }
+               }
+               Array<int> &E = RG->RefEdges;
+               int lb = 0, li = 2*RG->NumBdrEdges;
+               // horizontal edges
+               for (k = 0; k < Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0) ? lb : li;
+                  j = k*(Times+1)-((k-1)*k)/2;
+                  for (i = 0; i < Times-k; i++)
+                  {
+                     E[lt++] = j; j++;
+                     E[lt++] = j;
+                  }
+               }
+               // diagonal edges
+               for (k = Times; k > 0; k -= Times/ETimes)
+               {
+                  int &lt = (k == Times) ? lb : li;
+                  j = k;
+                  for (i = 0; i < k; i++)
+                  {
+                     E[lt++] = j; j += Times-i;
+                     E[lt++] = j;
+                  }
+               }
+               // vertical edges
+               for (k = 0; k < Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0) ? lb : li;
+                  j = k;
+                  for (i = 0; i < Times-k; i++)
+                  {
+                     E[lt++] = j; j += Times-i+1;
+                     E[lt++] = j;
+                  }
+               }
 
-         RGeom[Geometry::SQUARE].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::TRIANGLE].Append(RG);
+            }
+            break;
 
-      case Geometry::CUBE:
-      {
-         RG = new RefinedGeometry ((Times+1)*(Times+1)*(Times+1),
-                                   8*Times*Times*Times, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (l = k = 0; k <= Times; k++)
-            for (j = 0; j <= Times; j++)
-               for (i = 0; i <= Times; i++, l++)
+            case Geometry::SQUARE:
+            {
+               RG = new RefinedGeometry((Times+1)*(Times+1), 4*Times*Times,
+                                        4*(ETimes+1)*Times, 4*Times);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (k = j = 0; j <= Times; j++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(l);
-                  ip.x = cp[i];
-                  ip.y = cp[j];
-                  ip.z = cp[k];
+                  for (i = 0; i <= Times; i++, k++)
+                  {
+                     IntegrationPoint &ip = RG->RefPts.IntPoint(k);
+                     ip.x = cp[i];
+                     ip.y = cp[j];
+                  }
                }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = 0; k < Times; k++)
-            for (j = 0; j < Times; j++)
-               for (i = 0; i < Times; i++)
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = j = 0; j < Times; j++, k++)
                {
-                  G[l++] = i+0 + (j+0 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+0 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+1 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+1 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+0 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+0 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+1 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                  for (i = 0; i < Times; i++, k++)
+                  {
+                     G[l++] = k;
+                     G[l++] = k+1;
+                     G[l++] = k+Times+2;
+                     G[l++] = k+Times+1;
+                  }
+               }
+               Array<int> &E = RG->RefEdges;
+               int lb = 0, li = 2*RG->NumBdrEdges;
+               // horizontal edges
+               for (k = 0; k <= Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0 || k == Times) ? lb : li;
+                  for (i = 0, j = k*(Times+1); i < Times; i++)
+                  {
+                     E[lt++] = j; j++;
+                     E[lt++] = j;
+                  }
+               }
+               // vertical edges (in right-to-left order)
+               for (k = Times; k >= 0; k -= Times/ETimes)
+               {
+                  int &lt = (k == Times || k == 0) ? lb : li;
+                  for (i = 0, j = k; i < Times; i++)
+                  {
+                     E[lt++] = j; j += Times+1;
+                     E[lt++] = j;
+                  }
                }
 
-         RGeom[Geometry::CUBE].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::SQUARE].Append(RG);
+            }
+            break;
 
-      case Geometry::TETRAHEDRON:
-      {
-         // subdivide the tetrahedron with vertices
-         // (0,0,0), (0,0,1), (1,1,1), (0,1,1)
-
-         // vertices: 0 <= i <= j <= k <= Times
-         // (3-combination with repetitions)
-         // number of vertices: (n+3)*(n+2)*(n+1)/6, n = Times
-
-         // elements: the vertices are: v1=(i,j,k), v2=v1+u1, v3=v2+u2, v4=v3+u3
-         // where 0 <= i <= j <= k <= n-1 and
-         // u1,u2,u3 is a permutation of (1,0,0),(0,1,0),(0,0,1)
-         // such that all v2,v3,v4 have non-decreasing components
-         // number of elements: n^3
-
-         const int n = Times;
-         RG = new RefinedGeometry((n+3)*(n+2)*(n+1)/6, 4*n*n*n, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         Array<int> vi((n+1)*(n+1)*(n+1));
-         vi = -1;
-         m = 0;
-
-         // vertices are given in lexicographic ordering on the reference
-         // element
-         for (int kk = 0; kk <= n; kk++)
-            for (int jj = 0; jj <= n-kk; jj++)
-               for (int ii = 0; ii <= n-jj-kk; ii++)
+            case Geometry::CUBE:
+            {
+               RG = new RefinedGeometry ((Times+1)*(Times+1)*(Times+1),
+                                         8*Times*Times*Times, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (l = k = 0; k <= Times; k++)
+               {
+                  for (j = 0; j <= Times; j++)
+                  {
+                     for (i = 0; i <= Times; i++, l++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(l);
+                        ip.x = cp[i];
+                        ip.y = cp[j];
+                        ip.z = cp[k];
+                     }
+                  }
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = 0; k < Times; k++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(m);
-                  double w = cp[ii] + cp[jj] + cp[kk] + cp[Times-ii-jj-kk];
-                  ip.x = cp[ii]/w;
-                  ip.y = cp[jj]/w;
-                  ip.z = cp[kk]/w;
-                  // (ii,jj,kk) are coordinates in the reference tetrahedron,
-                  // transform to coordinates (i,j,k) in the auxiliary
-                  // tetrahedron defined by (0,0,0), (0,0,1), (1,1,1), (0,1,1)
-                  i = jj;
-                  j = jj+kk;
-                  k = ii+jj+kk;
-                  l = i + (j + k * (n+1)) * (n+1);
-                  // map from linear Cartesian hex index in the auxiliary tet
-                  // to lexicographic in the reference tet
-                  vi[l] = m;
-                  m++;
+                  for (j = 0; j < Times; j++)
+                  {
+                     for (i = 0; i < Times; i++)
+                     {
+                        G[l++] = i+0 + (j+0 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+0 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+1 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+1 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+0 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+0 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                     }
+                  }
                }
 
-         if (m != (n+3)*(n+2)*(n+1)/6)
-         {
-            mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (k = 0; k < n; k++)
-            for (j = 0; j <= k; j++)
-               for (i = 0; i <= j; i++)
+               RGeom[Geometry::CUBE].Append(RG);
+            }
+            break;
+
+            case Geometry::TETRAHEDRON:
+            {
+               // subdivide the tetrahedron with vertices
+               // (0,0,0), (0,0,1), (1,1,1), (0,1,1)
+
+               // vertices: 0 <= i <= j <= k <= Times
+               // (3-combination with repetitions)
+               // number of vertices: (n+3)*(n+2)*(n+1)/6, n = Times
+
+               // elements: the vertices are: v1=(i,j,k), v2=v1+u1, v3=v2+u2, v4=v3+u3
+               // where 0 <= i <= j <= k <= n-1 and
+               // u1,u2,u3 is a permutation of (1,0,0),(0,1,0),(0,0,1)
+               // such that all v2,v3,v4 have non-decreasing components
+               // number of elements: n^3
+
+               const int n = Times;
+               RG = new RefinedGeometry((n+3)*(n+2)*(n+1)/6, 4*n*n*n, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               Array<int> vi((n+1)*(n+1)*(n+1));
+               vi = -1;
+               m = 0;
+
+               // vertices are given in lexicographic ordering on the reference
+               // element
+               for (int kk = 0; kk <= n; kk++)
                {
-                  // the ordering of the vertices is chosen to ensure:
-                  // 1) correct orientation
-                  // 2) the x,y,z edges are in the set of edges
-                  //    {(0,1),(2,3), (0,2),(1,3)}
-                  //    (goal is to ensure that subsequent refinement using
-                  //    this procedure preserves the six tetrahedral shapes)
-
-                  // zyx: (i,j,k)-(i,j,k+1)-(i+1,j+1,k+1)-(i,j+1,k+1)
-                  G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                  if (j < k)
+                  for (int jj = 0; jj <= n-kk; jj++)
                   {
-                     // yzx: (i,j,k)-(i+1,j+1,k+1)-(i,j+1,k)-(i,j+1,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     // yxz: (i,j,k)-(i,j+1,k)-(i+1,j+1,k+1)-(i+1,j+1,k)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                     for (int ii = 0; ii <= n-jj-kk; ii++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(m);
+                        double w = cp[ii] + cp[jj] + cp[kk] + cp[Times-ii-jj-kk];
+                        ip.x = cp[ii]/w;
+                        ip.y = cp[jj]/w;
+                        ip.z = cp[kk]/w;
+                        // (ii,jj,kk) are coordinates in the reference tetrahedron,
+                        // transform to coordinates (i,j,k) in the auxiliary
+                        // tetrahedron defined by (0,0,0), (0,0,1), (1,1,1), (0,1,1)
+                        i = jj;
+                        j = jj+kk;
+                        k = ii+jj+kk;
+                        l = i + (j + k * (n+1)) * (n+1);
+                        // map from linear Cartesian hex index in the auxiliary tet
+                        // to lexicographic in the reference tet
+                        vi[l] = m;
+                        m++;
+                     }
                   }
-                  if (i < j)
+               }
+
+               if (m != (n+3)*(n+2)*(n+1)/6)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #1");
+               }
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (k = 0; k < n; k++)
+               {
+                  for (j = 0; j <= k; j++)
                   {
-                     // xzy: (i,j,k)-(i+1,j,k)-(i+1,j+1,k+1)-(i+1,j,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                     if (j < k)
+                     for (i = 0; i <= j; i++)
                      {
-                        // xyz: (i,j,k)-(i+1,j+1,k+1)-(i+1,j,k)-(i+1,j+1,k)
+                        // the ordering of the vertices is chosen to ensure:
+                        // 1) correct orientation
+                        // 2) the x,y,z edges are in the set of edges
+                        //    {(0,1),(2,3), (0,2),(1,3)}
+                        //    (goal is to ensure that subsequent refinement using
+                        //    this procedure preserves the six tetrahedral shapes)
+
+                        // zyx: (i,j,k)-(i,j,k+1)-(i+1,j+1,k+1)-(i,j+1,k+1)
                         G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                        G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
                         G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                        G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                        G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                        G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                        if (j < k)
+                        {
+                           // yzx: (i,j,k)-(i+1,j+1,k+1)-(i,j+1,k)-(i,j+1,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           // yxz: (i,j,k)-(i,j+1,k)-(i+1,j+1,k+1)-(i+1,j+1,k)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                        }
+                        if (i < j)
+                        {
+                           // xzy: (i,j,k)-(i+1,j,k)-(i+1,j+1,k+1)-(i+1,j,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                           if (j < k)
+                           {
+                              // xyz: (i,j,k)-(i+1,j+1,k+1)-(i+1,j,k)-(i+1,j+1,k)
+                              G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           }
+                           // zxy: (i,j,k)-(i+1,j+1,k+1)-(i,j,k+1)-(i+1,j,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                        }
                      }
-                     // zxy: (i,j,k)-(i+1,j+1,k+1)-(i,j,k+1)-(i+1,j,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
                   }
                }
-         if (m != 4*n*n*n)
-         {
-            mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #2");
-         }
-         for (i = 0; i < m; i++)
-            if (G[i] < 0)
-            {
-               mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #3");
-            }
+               if (m != 4*n*n*n)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #2");
+               }
+               for (i = 0; i < m; i++)
+               {
+                  if (G[i] < 0)
+                  {
+                     MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #3");
+                  }
+               }
 
-         RGeom[Geometry::TETRAHEDRON].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::TETRAHEDRON].Append(RG);
+            }
+            break;
 
-      case Geometry::PYRAMID:
-      {
-         const int n = Times;
-         RG = new RefinedGeometry ((n+1)*(n+2)*(2*n+3)/6,
-                                   5*n*(2*n-1)*(2*n+1)/3, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         m = 0;
-         for (k = 0; k <= n; k++)
-         {
-            const double *cpij =
-               poly1d.GetPoints(Times - k, BasisType::GetNodalBasis(type));
-            for (j = 0; j <= n - k; j++)
-               for (i = 0; i <= n - k; i++)
+            case Geometry::PYRAMID:
+            {
+               const int n = Times;
+               RG = new RefinedGeometry ((n+1)*(n+2)*(2*n+3)/6,
+                                         5*n*(2*n-1)*(2*n+1)/3, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               m = 0;
+               for (k = 0; k <= n; k++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(m);
-                  if (type == 0)
+                  const double *cpij =
+                     poly1d.GetPoints(Times - k, BasisType::GetNodalBasis(Type));
+                  for (j = 0; j <= n - k; j++)
                   {
-                     ip.x = (n > k) ? (double(i) / (n - k)) : 0.0;
-                     ip.y = (n > k) ? (double(j) / (n - k)) : 0.0;
-                     ip.z = double(k) / n;
+                     for (i = 0; i <= n - k; i++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(m);
+                        if (Type == 0)
+                        {
+                           ip.x = (n > k) ? (double(i) / (n - k)) : 0.0;
+                           ip.y = (n > k) ? (double(j) / (n - k)) : 0.0;
+                           ip.z = double(k) / n;
+                        }
+                        else
+                        {
+                           ip.x = cpij[i] * (1.0 - cp[k]);
+                           ip.y = cpij[j] * (1.0 - cp[k]);
+                           ip.z = cp[k];
+                        }
+                        m++;
+                     }
                   }
-                  else
+               }
+               if (m != (n+1)*(n+2)*(2*n+3)/6)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for PYRAMID #1");
+               }
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (k = 0; k < n; k++)
+               {
+                  int lk = k * (k * (2 * k - 6 * n - 9) + 6 * n * (n + 3) + 13) / 6;
+                  int lkp1 = (k + 1) *
+                             (k * (2 * k - 6 * n -5) + 6 * n * (n + 2) + 6) / 6;
+                  for (j = 0; j < n - k; j++)
                   {
-                     ip.x = cpij[i] * (1.0 - cp[k]);
-                     ip.y = cpij[j] * (1.0 - cp[k]);
-                     ip.z = cp[k];
+                     for (i = 0; i < n - k; i++)
+                     {
+                        G[m++] = lk + j * (n - k + 1) + i;
+                        G[m++] = lk + j * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                     }
+                  }
+                  for (j = 0; j < n - k - 1; j++)
+                  {
+                     for (i = 0; i < n - k - 1; i++)
+                     {
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i + 1;
+                        G[m++] = lkp1 + j * (n - k) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                     }
+                  }
+                  for (j = 0; j < n - k; j++)
+                  {
+                     for (i = 0; i < n - k - 1; i++)
+                     {
+                        G[m++] = lk + j * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = lkp1 + j * (n - k) + i + 1;
+                        G[m++] = -1;
+                     }
+                  }
+                  for (j = 0; j < n - k - 1; j++)
+                  {
+                     for (i = 0; i < n - k; i++)
+                     {
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = -1;
+                     }
                   }
-                  m++;
                }
-         }
-         if (m != (n+1)*(n+2)*(2*n+3)/6)
-         {
-            mfem_error("GeometryRefiner::Refine() for PYRAMID #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (k = 0; k < n; k++)
-         {
-            int lk = k * (k * (2 * k - 6 * n - 9) + 6 * n * (n + 3) + 13) / 6;
-            int lkp1 = (k + 1) *
-                       (k * (2 * k - 6 * n -5) + 6 * n * (n + 2) + 6) / 6;
-            for (j = 0; j < n - k; j++)
-            {
-               for (i = 0; i < n - k; i++)
+               if (m != 5*n*(2*n-1)*(2*n+1)/3)
                {
-                  G[m++] = lk + j * (n - k + 1) + i;
-                  G[m++] = lk + j * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i;
-                  G[m++] = lkp1 + j * (n - k) + i;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PYRAMID #2");
                }
+
+               RGeom[Geometry::PYRAMID].Append(RG);
             }
-            for (j = 0; j < n - k - 1; j++)
+            break;
+
+            case Geometry::PRISM:
             {
-               for (i = 0; i < n - k - 1; i++)
+               const int n = Times;
+               RG = new RefinedGeometry ((n+1)*(n+1)*(n+2)/2, 6*n*n*n, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               m = 0;
+               for (l = k = 0; k <= n; k++)
                {
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i + 1;
-                  G[m++] = lkp1 + j * (n - k) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                  for (j = 0; j <= n; j++)
+                  {
+                     for (i = 0; i <= n-j; i++, l++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(l);
+                        ip.x = cp[i]/(cp[i] + cp[j] + cp[n-i-j]);
+                        ip.y = cp[j]/(cp[i] + cp[j] + cp[n-i-j]);
+                        ip.z = cp[k];
+                        m++;
+                     }
+                  }
                }
-            }
-            for (j = 0; j < n - k; j++)
-            {
-               for (i = 0; i < n - k - 1; i++)
+               if (m != (n+1)*(n+1)*(n+2)/2)
                {
-                  G[m++] = lk + j * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = lkp1 + j * (n - k) + i + 1;
-                  G[m++] = -1;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PRISM #1");
                }
-            }
-            for (j = 0; j < n - k - 1; j++)
-            {
-               for (i = 0; i < n - k; i++)
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (m = k = 0; k < n; k++)
                {
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i;
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = -1;
+                  for (l = j = 0; j < n; j++, l++)
+                  {
+                     for (i = 0; i < n-j; i++, l++)
+                     {
+                        G[m++] = l + (k+0) * (n+1) * (n+2) / 2;
+                        G[m++] = l + 1 + (k+0) * (n+1) * (n+2) / 2;
+                        G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
+                        G[m++] = l + (k+1) * (n+1) * (n+2) / 2;
+                        G[m++] = l + 1 + (k+1) * (n+1) * (Times+2) / 2;
+                        G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                        if (i+j+1 < n)
+                        {
+                           G[m++] = l + 1 + (k+0) * (n+1) * (n+2)/2;
+                           G[m++] = l - j + (2 + (k+0) * (n+1)) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
+                           G[m++] = l + 1 + (k+1) * (n+1) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+1) * (n+1)) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                        }
+                     }
+                  }
                }
-            }
-         }
-         if (m != 5*n*(2*n-1)*(2*n+1)/3)
-         {
-            mfem_error("GeometryRefiner::Refine() for PYRAMID #2");
-         }
-         RGeom[Geometry::PYRAMID].Append(RG);
-         return RG;
-      }
-
-      case Geometry::PRISM:
-      {
-         const int n = Times;
-         RG = new RefinedGeometry ((n+1)*(n+1)*(n+2)/2, 6*n*n*n, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         m = 0;
-         for (l = k = 0; k <= n; k++)
-            for (j = 0; j <= n; j++)
-               for (i = 0; i <= n-j; i++, l++)
+               if (m != 6*n*n*n)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(l);
-                  ip.x = cp[i]/(cp[i] + cp[j] + cp[n-i-j]);
-                  ip.y = cp[j]/(cp[i] + cp[j] + cp[n-i-j]);
-                  ip.z = cp[k];
-                  m++;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PRISM #2");
                }
-         if (m != (n+1)*(n+1)*(n+2)/2)
-         {
-            mfem_error("GeometryRefiner::Refine() for PRISM #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (m = k = 0; k < n; k++)
-            for (l = j = 0; j < n; j++, l++)
-               for (i = 0; i < n-j; i++, l++)
+               for (i = 0; i < m; i++)
                {
-                  G[m++] = l + (k+0) * (n+1) * (n+2) / 2;
-                  G[m++] = l + 1 + (k+0) * (n+1) * (n+2) / 2;
-                  G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
-                  G[m++] = l + (k+1) * (n+1) * (n+2) / 2;
-                  G[m++] = l + 1 + (k+1) * (n+1) * (Times+2) / 2;
-                  G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
-                  if (i+j+1 < n)
+                  if (G[i] < 0)
                   {
-                     G[m++] = l + 1 + (k+0) * (n+1) * (n+2)/2;
-                     G[m++] = l - j + (2 + (k+0) * (n+1)) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
-                     G[m++] = l + 1 + (k+1) * (n+1) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+1) * (n+1)) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                     MFEM_ABORT("GeometryRefiner::Refine() for PRISM #3");
                   }
                }
-         if (m != 6*n*n*n)
-         {
-            mfem_error("GeometryRefiner::Refine() for PRISM #2");
-         }
-         for (i = 0; i < m; i++)
-            if (G[i] < 0)
-            {
-               mfem_error("GeometryRefiner::Refine() for PRISM #3");
+
+               RGeom[Geometry::PRISM].Append(RG);
             }
+            break;
 
-         RGeom[Geometry::PRISM].Append(RG);
-         return RG;
+            case Geometry::INVALID:
+            case Geometry::NUM_GEOMETRIES:
+               MFEM_ABORT("Unknown type of reference element!");
+         }
       }
-
-      default:
-
-         return NULL;
    }
+
+   return RG;
 }
 
 const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
@@ -1596,15 +1650,23 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, Times-1);
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule(Times-1);
-         for (int i = 1; i < Times; i++)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+         #pragma omp critical (RefineInterior)
+#endif
          {
-            IntegrationPoint &ip = ir->IntPoint(i-1);
-            ip.x = double(i) / Times;
-            ip.y = ip.z = 0.0;
+            ir = FindInIntPts(Geometry::SEGMENT, Times-1);
+            if (!ir)
+            {
+               ir = new IntegrationRule(Times-1);
+               for (int i = 1; i < Times; i++)
+               {
+                  IntegrationPoint &ip = ir->IntPoint(i-1);
+                  ip.x = double(i) / Times;
+                  ip.y = ip.z = 0.0;
+               }
+
+               IntPts[Geometry::SEGMENT].Append(ir);
+            }
          }
       }
       break;
@@ -1615,18 +1677,28 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, ((Times-1)*(Times-2))/2);
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule(((Times-1)*(Times-2))/2);
-         for (int k = 0, j = 1; j < Times-1; j++)
-            for (int i = 1; i < Times-j; i++, k++)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+         #pragma omp critical (RefineInterior)
+#endif
+         {
+            ir = FindInIntPts(Geometry::TRIANGLE, ((Times-1)*(Times-2))/2);
+            if (!ir)
             {
-               IntegrationPoint &ip = ir->IntPoint(k);
-               ip.x = double(i) / Times;
-               ip.y = double(j) / Times;
-               ip.z = 0.0;
+               ir = new IntegrationRule(((Times-1)*(Times-2))/2);
+               for (int k = 0, j = 1; j < Times-1; j++)
+               {
+                  for (int i = 1; i < Times-j; i++, k++)
+                  {
+                     IntegrationPoint &ip = ir->IntPoint(k);
+                     ip.x = double(i) / Times;
+                     ip.y = double(j) / Times;
+                     ip.z = 0.0;
+                  }
+               }
+
+               IntPts[Geometry::TRIANGLE].Append(ir);
             }
+         }
       }
       break;
 
@@ -1636,32 +1708,46 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, (Times-1)*(Times-1));
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule((Times-1)*(Times-1));
-         for (int k = 0, j = 1; j < Times; j++)
-            for (int i = 1; i < Times; i++, k++)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+         #pragma omp critical (RefineInterior)
+#endif
+         {
+            ir = FindInIntPts(Geometry::SQUARE, (Times-1)*(Times-1));
+            if (!ir)
             {
-               IntegrationPoint &ip = ir->IntPoint(k);
-               ip.x = double(i) / Times;
-               ip.y = double(j) / Times;
-               ip.z = 0.0;
+               ir = new IntegrationRule((Times-1)*(Times-1));
+               for (int k = 0, j = 1; j < Times; j++)
+               {
+                  for (int i = 1; i < Times; i++, k++)
+                  {
+                     IntegrationPoint &ip = ir->IntPoint(k);
+                     ip.x = double(i) / Times;
+                     ip.y = double(j) / Times;
+                     ip.z = 0.0;
+                  }
+               }
+
+               IntPts[Geometry::SQUARE].Append(ir);
             }
+         }
       }
       break;
 
-      default:
-         mfem_error("GeometryRefiner::RefineInterior(...)");
+      case Geometry::POINT:
+      case Geometry::TETRAHEDRON:
+      case Geometry::CUBE:
+      case Geometry::PYRAMID:
+      case Geometry::PRISM:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
-   MFEM_ASSERT(ir != NULL, "Failed to construct the refined IntegrationRule.");
-   IntPts[Geom].Append(ir);
-
    return ir;
 }
 
-
+// static method
 int GeometryRefiner::GetRefinementLevelFromPoints(Geometry::Type geom, int Npts)
 {
    switch (geom)
@@ -1719,16 +1805,17 @@ int GeometryRefiner::GetRefinementLevelFromPoints(Geometry::Type geom, int Npts)
          }
          return -1;
       }
-      default:
-      {
-         mfem_error("Non existing Geometry.");
-      }
+      case Geometry::PYRAMID:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    return -1;
 }
 
-
+// static method
 int GeometryRefiner::GetRefinementLevelFromElems(Geometry::Type geom, int Nels)
 {
    switch (geom)
@@ -1760,10 +1847,11 @@ int GeometryRefiner::GetRefinementLevelFromElems(Geometry::Type geom, int Nels)
          }
          return -1;
       }
-      default:
-      {
-         mfem_error("Non existing Geometry.");
-      }
+      case Geometry::PYRAMID:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    return -1;
diff --git a/fem/geom.hpp b/fem/geom.hpp
index 698912d97..1290f4e2a 100644
--- a/fem/geom.hpp
+++ b/fem/geom.hpp
@@ -65,10 +65,10 @@ public:
 
    /** @brief Return an IntegrationRule consisting of all vertices of the given
        Geometry::Type, @a GeomType. */
-   const IntegrationRule *GetVertices(int GeomType);
+   const IntegrationRule *GetVertices(int GeomType) const;
 
    /// Return the center of the given Geometry::Type, @a GeomType.
-   const IntegrationPoint &GetCenter(int GeomType)
+   const IntegrationPoint &GetCenter(int GeomType) const
    { return GeomCenter[GeomType]; }
 
    /// Get a random point in the reference element specified by @a GeomType.
@@ -97,9 +97,9 @@ public:
 
    const DenseMatrix &GetGeomToPerfGeomJac(int GeomType) const
    { return *GeomToPerfGeomJac[GeomType]; }
-   DenseMatrix *GetPerfGeomToGeomJac(int GeomType)
-   { return PerfGeomToGeomJac[GeomType]; }
-   void GetPerfPointMat(int GeomType, DenseMatrix &pm);
+   const DenseMatrix &GetPerfGeomToGeomJac(int GeomType) const
+   { return *PerfGeomToGeomJac[GeomType]; }
+   void GetPerfPointMat(int GeomType, DenseMatrix &pm) const;
    void JacToPerfJac(int GeomType, const DenseMatrix &J,
                      DenseMatrix &PJ) const;
 
@@ -123,7 +123,7 @@ public:
    }
 
    /// Return the number of boundary "faces" of a given Geometry::Type.
-   int NumBdr(int GeomType) { return NumBdrArray[GeomType]; }
+   int NumBdr(int GeomType) const { return NumBdrArray[GeomType]; }
 };
 
 template <> struct
@@ -317,27 +317,27 @@ public:
    int Type;
 
    RefinedGeometry(int NPts, int NRefG, int NRefE, int NBdrE = 0) :
-      RefPts(NPts), RefGeoms(NRefG), RefEdges(NRefE), NumBdrEdges(NBdrE) { }
+      RefPts(NPts), RefGeoms(NRefG), RefEdges(NRefE), NumBdrEdges(NBdrE) {}
 };
 
 class GeometryRefiner
 {
 private:
-   int type; // Quadrature1D type (ClosedUniform is default)
+   int Type; // Quadrature1D type (ClosedUniform is default)
    Array<RefinedGeometry *> RGeom[Geometry::NumGeom];
    Array<IntegrationRule *> IntPts[Geometry::NumGeom];
 
-   RefinedGeometry *FindInRGeom(Geometry::Type Geom, int Times, int ETimes,
-                                int Type);
-   IntegrationRule *FindInIntPts(Geometry::Type Geom, int NPts);
+   RefinedGeometry *FindInRGeom(Geometry::Type Geom, int Times,
+                                int ETimes) const;
+   IntegrationRule *FindInIntPts(Geometry::Type Geom, int NPts) const;
 
 public:
-   GeometryRefiner();
+   GeometryRefiner(int t = Quadrature1D::ClosedUniform) : Type(t) {}
 
    /// Set the Quadrature1D type of points to use for subdivision.
-   void SetType(const int t) { type = t; }
+   void SetType(int t) { Type = t; }
    /// Get the Quadrature1D type of points used for subdivision.
-   int GetType() const { return type; }
+   int GetType() const { return Type; }
 
    RefinedGeometry *Refine(Geometry::Type Geom, int Times, int ETimes = 1);
 
@@ -345,10 +345,10 @@ public:
    const IntegrationRule *RefineInterior(Geometry::Type Geom, int Times);
 
    /// Get the Refinement level based on number of points
-   virtual int GetRefinementLevelFromPoints(Geometry::Type Geom, int Npts);
+   static int GetRefinementLevelFromPoints(Geometry::Type Geom, int Npts);
 
    /// Get the Refinement level based on number of elements
-   virtual int GetRefinementLevelFromElems(Geometry::Type geom, int Npts);
+   static int GetRefinementLevelFromElems(Geometry::Type geom, int Npts);
 
    ~GeometryRefiner();
 };
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index 8c5c354e3..cb9544852 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -737,7 +737,7 @@ void QuadratureFunctions1D::GivePolyPoints(const int np, double *pts,
          ClosedGL(np, &ir);
          break;
       }
-      default:
+      case Quadrature1D::Invalid:
       {
          MFEM_ABORT("Asking for an unknown type of 1D Quadrature points, "
                     "type = " << type);
@@ -831,7 +831,10 @@ void QuadratureFunctions1D::CalculateUniformWeights(IntegrationRule *ir,
          hinv = p+1;
          ihoffset = 1;
          break;
-      default:
+      case Quadrature1D::GaussLegendre:
+      case Quadrature1D::GaussLobatto:
+      case Quadrature1D::ClosedGL:
+      case Quadrature1D::Invalid:
          MFEM_ABORT("invalid Quadrature1D type: " << type);
    }
    // set w0 = (-1)^p*(p!)/(hinv^p)
@@ -940,10 +943,10 @@ IntegrationRules IntRules(0, Quadrature1D::GaussLegendre);
 
 IntegrationRules RefinedIntRules(1, Quadrature1D::GaussLegendre);
 
-IntegrationRules::IntegrationRules(int Ref, int type_):
-   quad_type(type_)
+IntegrationRules::IntegrationRules(int ref, int type)
+   : quad_type(type)
 {
-   refined = Ref;
+   refined = ref;
 
    if (refined < 0) { own_rules = 0; return; }
 
@@ -975,11 +978,19 @@ IntegrationRules::IntegrationRules(int Ref, int type_):
 
    CubeIntRules.SetSize(32, h_mt);
    CubeIntRules = NULL;
+
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   IntRuleLocks.SetSize(Geometry::NUM_GEOMETRIES, h_mt);
+   for (int i = 0; i < Geometry::NUM_GEOMETRIES; i++)
+   {
+      omp_init_lock(&IntRuleLocks[i]);
+   }
+#endif
 }
 
 const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
 {
-   Array<IntegrationRule *> *ir_array;
+   Array<IntegrationRule *> *ir_array = NULL;
 
    switch (GeomType)
    {
@@ -991,9 +1002,9 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
       case Geometry::CUBE:        ir_array = &CubeIntRules; break;
       case Geometry::PRISM:       ir_array = &PrismIntRules; break;
       case Geometry::PYRAMID:     ir_array = &PyramidIntRules; break;
-      default:
-         mfem_error("IntegrationRules::Get(...) : Unknown geometry type!");
-         ir_array = NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    if (Order < 0)
@@ -1001,36 +1012,35 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
       Order = 0;
    }
 
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   omp_set_lock(&IntRuleLocks[GeomType]);
+#endif
+
    if (!HaveIntRule(*ir_array, Order))
    {
-#ifdef MFEM_USE_LEGACY_OPENMP
-      #pragma omp critical
-#endif
-      {
-         if (!HaveIntRule(*ir_array, Order))
-         {
-            IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
+      IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
 #ifdef MFEM_DEBUG
-            int RealOrder = Order;
-            while (RealOrder+1 < ir_array->Size() &&
-                   (*ir_array)[RealOrder+1] == ir)
-            {
-               RealOrder++;
-            }
-            MFEM_VERIFY(RealOrder == ir->GetOrder(), "internal error");
+      int RealOrder = Order;
+      while (RealOrder+1 < ir_array->Size() && (*ir_array)[RealOrder+1] == ir)
+      {
+         RealOrder++;
+      }
+      MFEM_VERIFY(RealOrder == ir->GetOrder(), "internal error");
 #else
-            MFEM_CONTRACT_VAR(ir);
+      MFEM_CONTRACT_VAR(ir);
 #endif
-         }
-      }
    }
 
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   omp_unset_lock(&IntRuleLocks[GeomType]);
+#endif
+
    return *(*ir_array)[Order];
 }
 
 void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
 {
-   Array<IntegrationRule *> *ir_array;
+   Array<IntegrationRule *> *ir_array = NULL;
 
    switch (GeomType)
    {
@@ -1042,11 +1052,15 @@ void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
       case Geometry::CUBE:        ir_array = &CubeIntRules; break;
       case Geometry::PRISM:       ir_array = &PrismIntRules; break;
       case Geometry::PYRAMID:     ir_array = &PyramidIntRules; break;
-      default:
-         mfem_error("IntegrationRules::Set(...) : Unknown geometry type!");
-         ir_array = NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   omp_set_lock(&IntRuleLocks[GeomType]);
+#endif
+
    if (HaveIntRule(*ir_array, Order))
    {
       MFEM_ABORT("Overwriting set rules is not supported!");
@@ -1055,16 +1069,19 @@ void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
    AllocIntRule(*ir_array, Order);
 
    (*ir_array)[Order] = &IntRule;
+
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   omp_unset_lock(&IntRuleLocks[GeomType]);
+#endif
 }
 
-void IntegrationRules::DeleteIntRuleArray(Array<IntegrationRule *> &ir_array)
+void IntegrationRules::DeleteIntRuleArray(
+   Array<IntegrationRule *> &ir_array) const
 {
-   int i;
-   IntegrationRule *ir = NULL;
-
    // Many of the intrules have multiple contiguous copies in the ir_array
    // so we have to be careful to not delete them twice.
-   for (i = 0; i < ir_array.Size(); i++)
+   IntegrationRule *ir = NULL;
+   for (int i = 0; i < ir_array.Size(); i++)
    {
       if (ir_array[i] != NULL && ir_array[i] != ir)
       {
@@ -1076,6 +1093,13 @@ void IntegrationRules::DeleteIntRuleArray(Array<IntegrationRule *> &ir_array)
 
 IntegrationRules::~IntegrationRules()
 {
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   for (int i = 0; i < Geometry::NUM_GEOMETRIES; i++)
+   {
+      omp_destroy_lock(&IntRuleLocks[i]);
+   }
+#endif
+
    if (!own_rules) { return; }
 
    DeleteIntRuleArray(PointIntRules);
@@ -1110,10 +1134,11 @@ IntegrationRule *IntegrationRules::GenerateIntegrationRule(int GeomType,
          return PrismIntegrationRule(Order);
       case Geometry::PYRAMID:
          return PyramidIntegrationRule(Order);
-      default:
-         mfem_error("IntegrationRules::Set(...) : Unknown geometry type!");
-         return NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
+   return NULL;
 }
 
 
@@ -1122,7 +1147,7 @@ IntegrationRule *IntegrationRules::PointIntegrationRule(int Order)
 {
    if (Order > 1)
    {
-      mfem_error("Point Integration Rule of Order > 1 not defined");
+      MFEM_ABORT("Point Integration Rule of Order > 1 not defined");
       return NULL;
    }
 
@@ -1185,7 +1210,7 @@ IntegrationRule *IntegrationRules::SegmentIntegrationRule(int Order)
          QuadratureFunctions1D::OpenHalfUniform(n, ir);
          break;
       }
-      default:
+      case Quadrature1D::Invalid:
       {
          MFEM_ABORT("unknown Quadrature1D type: " << quad_type);
       }
@@ -1762,8 +1787,8 @@ IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
 
    for (int k=0; k<npts; k++)
    {
-      const IntegrationPoint & ipc = irc.IntPoint(k);
-      IntegrationPoint & ipp = PyramidIntRules[Order]->IntPoint(k);
+      const IntegrationPoint &ipc = irc.IntPoint(k);
+      IntegrationPoint &ipp = PyramidIntRules[Order]->IntPoint(k);
       ipp.x = ipc.x * (1.0 - ipc.z);
       ipp.y = ipc.y * (1.0 - ipc.z);
       ipp.z = ipc.z;
@@ -1775,8 +1800,8 @@ IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
 // Integration rules for reference prism
 IntegrationRule *IntegrationRules::PrismIntegrationRule(int Order)
 {
-   const IntegrationRule & irt = Get(Geometry::TRIANGLE, Order);
-   const IntegrationRule & irs = Get(Geometry::SEGMENT, Order);
+   const IntegrationRule &irt = Get(Geometry::TRIANGLE, Order);
+   const IntegrationRule &irs = Get(Geometry::SEGMENT, Order);
    int nt = irt.GetNPoints();
    int ns = irs.GetNPoints();
    AllocIntRule(PrismIntRules, Order);
@@ -1790,12 +1815,12 @@ IntegrationRule *IntegrationRules::PrismIntegrationRule(int Order)
 
    for (int ks=0; ks<ns; ks++)
    {
-      const IntegrationPoint & ips = irs.IntPoint(ks);
+      const IntegrationPoint &ips = irs.IntPoint(ks);
       for (int kt=0; kt<nt; kt++)
       {
          int kp = ks * nt + kt;
-         const IntegrationPoint & ipt = irt.IntPoint(kt);
-         IntegrationPoint & ipp = PrismIntRules[Order]->IntPoint(kp);
+         const IntegrationPoint &ipt = irt.IntPoint(kt);
+         IntegrationPoint &ipp = PrismIntRules[Order]->IntPoint(kp);
          ipp.x = ipt.x;
          ipp.y = ipt.y;
          ipp.z = ips.x;
diff --git a/fem/intrules.hpp b/fem/intrules.hpp
index bf38766d7..1d5757994 100644
--- a/fem/intrules.hpp
+++ b/fem/intrules.hpp
@@ -14,6 +14,9 @@
 
 #include "../config/config.hpp"
 #include "../general/array.hpp"
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+#include <omp.h>
+#endif
 
 #include <vector>
 #include <map>
@@ -428,14 +431,18 @@ private:
    Array<IntegrationRule *> PrismIntRules;
    Array<IntegrationRule *> CubeIntRules;
 
-   void AllocIntRule(Array<IntegrationRule *> &ir_array, int Order)
+#if defined(MFEM_THREAD_SAFE) && defined(MFEM_USE_OPENMP)
+   Array<omp_lock_t> IntRuleLocks;
+#endif
+
+   void AllocIntRule(Array<IntegrationRule *> &ir_array, int Order) const
    {
       if (ir_array.Size() <= Order)
       {
          ir_array.SetSize(Order + 1, NULL);
       }
    }
-   bool HaveIntRule(Array<IntegrationRule *> &ir_array, int Order)
+   bool HaveIntRule(Array<IntegrationRule *> &ir_array, int Order) const
    {
       return (ir_array.Size() > Order && ir_array[Order] != NULL);
    }
@@ -443,6 +450,7 @@ private:
    {
       return Order | 1; // valid for all quad_type's
    }
+   void DeleteIntRuleArray(Array<IntegrationRule *> &ir_array) const;
 
    /// The following methods allocate new IntegrationRule objects without
    /// checking if they already exist.  To avoid memory leaks use
@@ -457,12 +465,10 @@ private:
    IntegrationRule *PrismIntegrationRule(int Order);
    IntegrationRule *CubeIntegrationRule(int Order);
 
-   void DeleteIntRuleArray(Array<IntegrationRule *> &ir_array);
-
 public:
    /// Sets initial sizes for the integration rule arrays, but rules
    /// are defined the first time they are requested with the Get method.
-   explicit IntegrationRules(int Ref = 0,
+   explicit IntegrationRules(int ref = 0,
                              int type = Quadrature1D::GaussLegendre);
 
    /// Returns an integration rule for given GeomType and Order.
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 5e96c3f39..600f2fc2a 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -4446,9 +4446,7 @@ void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
 
    Array<int> rdofs;
    DenseMatrix phys_pts;
-
-   GeometryRefiner refiner;
-   refiner.SetType(q_type);
+   GeometryRefiner refiner(q_type);
 
    // Add refined elements and set vertex coordinates
    for (int el = 0; el < orig_ne; el++)
diff --git a/tests/unit/fem/test_lexicographic_ordering.cpp b/tests/unit/fem/test_lexicographic_ordering.cpp
index f68395bfc..6c73cb4e3 100644
--- a/tests/unit/fem/test_lexicographic_ordering.cpp
+++ b/tests/unit/fem/test_lexicographic_ordering.cpp
@@ -20,8 +20,7 @@ void VerifyOrdering(NodalFiniteElement &el)
    Geometry::Type geom = el.GetGeomType();
    const Array<int> &p = el.GetLexicographicOrdering();
 
-   GeometryRefiner refiner;
-   refiner.SetType(BasisType::GaussLobatto);
+   GeometryRefiner refiner(BasisType::GaussLobatto);
    RefinedGeometry *ref_geom = refiner.Refine(geom, order);
 
    double error = 0.0;
