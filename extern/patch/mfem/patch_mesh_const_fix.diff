diff --git a/fem/coefficient.cpp b/fem/coefficient.cpp
index 5f1b799eb..90eef2c9c 100644
--- a/fem/coefficient.cpp
+++ b/fem/coefficient.cpp
@@ -28,7 +28,7 @@ ElementTransformation *RefinedToCoarse(
    Mesh &coarse_mesh, const ElementTransformation &T,
    const IntegrationPoint &ip, IntegrationPoint &coarse_ip)
 {
-   Mesh &fine_mesh = *T.mesh;
+   const Mesh &fine_mesh = *T.mesh;
    // Get the element transformation of the coarse element containing the
    // fine element.
    int fine_element = T.ElementNo;
diff --git a/fem/eltrans.hpp b/fem/eltrans.hpp
index 8d3955ab4..3d0ccb97f 100644
--- a/fem/eltrans.hpp
+++ b/fem/eltrans.hpp
@@ -81,7 +81,7 @@ public:
    /** If the element transformation belongs to a mesh, this will point to the
        containing Mesh object. ElementNo will be the number of the element in
        this Mesh. This will be NULL if the element does not belong to a mesh. */
-   class Mesh *mesh;
+   const Mesh *mesh;
 
    ElementTransformation();
 
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index a8ff93b24..848992dbe 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -83,7 +83,7 @@ void Mesh::GetElementCenter(int i, Vector &center)
    eltransf->Transform(Geometries.GetCenter(geom), center);
 }
 
-double Mesh::GetElementSize(ElementTransformation *T, int type)
+double Mesh::GetElementSize(ElementTransformation *T, int type) const
 {
    DenseMatrix J(spaceDim, Dim);
 
@@ -355,7 +355,8 @@ FiniteElement *Mesh::GetTransformationFEforElementType(Element::Type ElemType)
 }
 
 
-void Mesh::GetElementTransformation(int i, IsoparametricTransformation *ElTr)
+void Mesh::GetElementTransformation(int i,
+                                    IsoparametricTransformation *ElTr) const
 {
    ElTr->Attribute = GetAttribute(i);
    ElTr->ElementNo = i;
@@ -394,7 +395,7 @@ ElementTransformation *Mesh::GetElementTransformation(int i)
 }
 
 void Mesh::GetElementTransformation(int i, const Vector &nodes,
-                                    IsoparametricTransformation *ElTr)
+                                    IsoparametricTransformation *ElTr) const
 {
    ElTr->Attribute = GetAttribute(i);
    ElTr->ElementNo = i;
@@ -437,7 +438,8 @@ void Mesh::GetElementTransformation(int i, const Vector &nodes,
    }
 }
 
-void Mesh::GetBdrElementTransformation(int i, IsoparametricTransformation* ElTr)
+void Mesh::GetBdrElementTransformation(int i,
+                                       IsoparametricTransformation* ElTr) const
 {
    ElTr->Attribute = GetBdrAttribute(i);
    ElTr->ElementNo = i; // boundary element number
@@ -475,10 +477,10 @@ void Mesh::GetBdrElementTransformation(int i, IsoparametricTransformation* ElTr)
          int elem_id, face_info;
          GetBdrElementAdjacentElement2(i, elem_id, face_info);
 
+         IntegrationPointTransformation Loc1;
          GetLocalFaceTransformation(GetBdrElementType(i),
                                     GetElementType(elem_id),
-                                    FaceElemTr.Loc1.Transf, face_info);
-         // NOTE: FaceElemTr.Loc1 is overwritten here -- used as a temporary
+                                    Loc1.Transf, face_info);
 
          Geometry::Type face_geom = GetBdrElementBaseGeometry(i);
          const FiniteElement *face_el =
@@ -487,11 +489,11 @@ void Mesh::GetBdrElementTransformation(int i, IsoparametricTransformation* ElTr)
                      "Mesh requires nodal Finite Element.");
 
          IntegrationRule eir(face_el->GetDof());
-         FaceElemTr.Loc1.Transf.ElementNo = elem_id;
-         FaceElemTr.Loc1.Transf.mesh = this;
-         FaceElemTr.Loc1.Transf.ElementType = ElementTransformation::ELEMENT;
-         FaceElemTr.Loc1.Transform(face_el->GetNodes(), eir);
-         Nodes->GetVectorValues(FaceElemTr.Loc1.Transf, eir, pm);
+         Loc1.Transf.ElementNo = elem_id;
+         Loc1.Transf.mesh = this;
+         Loc1.Transf.ElementType = ElementTransformation::ELEMENT;
+         Loc1.Transform(face_el->GetNodes(), eir);
+         Nodes->GetVectorValues(Loc1.Transf, eir, pm);
 
          ElTr->SetFE(face_el);
       }
@@ -504,7 +506,8 @@ ElementTransformation *Mesh::GetBdrElementTransformation(int i)
    return &BdrTransformation;
 }
 
-void Mesh::GetFaceTransformation(int FaceNo, IsoparametricTransformation *FTr)
+void Mesh::GetFaceTransformation(int FaceNo,
+                                 IsoparametricTransformation *FTr) const
 {
    FTr->Attribute = (Dim == 1) ? 1 : faces[FaceNo]->GetAttribute();
    FTr->ElementNo = FaceNo;
@@ -548,15 +551,14 @@ void Mesh::GetFaceTransformation(int FaceNo, IsoparametricTransformation *FTr)
       }
       else // L2 Nodes (e.g., periodic mesh), go through the volume of Elem1
       {
-         FaceInfo &face_info = faces_info[FaceNo];
-
+         const FaceInfo &face_info = faces_info[FaceNo];
          Geometry::Type face_geom = GetFaceGeometry(FaceNo);
          Element::Type  face_type = GetFaceElementType(FaceNo);
 
+         IntegrationPointTransformation Loc1;
          GetLocalFaceTransformation(face_type,
                                     GetElementType(face_info.Elem1No),
-                                    FaceElemTr.Loc1.Transf, face_info.Elem1Inf);
-         // NOTE: FaceElemTr.Loc1 is overwritten here -- used as a temporary
+                                    Loc1.Transf, face_info.Elem1Inf);
 
          face_el = Nodes->FESpace()->GetTraceElement(face_info.Elem1No,
                                                      face_geom);
@@ -564,11 +566,11 @@ void Mesh::GetFaceTransformation(int FaceNo, IsoparametricTransformation *FTr)
                      "Mesh requires nodal Finite Element.");
 
          IntegrationRule eir(face_el->GetDof());
-         FaceElemTr.Loc1.Transf.ElementNo = face_info.Elem1No;
-         FaceElemTr.Loc1.Transf.ElementType = ElementTransformation::ELEMENT;
-         FaceElemTr.Loc1.Transf.mesh = this;
-         FaceElemTr.Loc1.Transform(face_el->GetNodes(), eir);
-         Nodes->GetVectorValues(FaceElemTr.Loc1.Transf, eir, pm);
+         Loc1.Transf.ElementNo = face_info.Elem1No;
+         Loc1.Transf.ElementType = ElementTransformation::ELEMENT;
+         Loc1.Transf.mesh = this;
+         Loc1.Transform(face_el->GetNodes(), eir);
+         Nodes->GetVectorValues(Loc1.Transf, eir, pm);
 
          FTr->SetFE(face_el);
       }
@@ -581,7 +583,8 @@ ElementTransformation *Mesh::GetFaceTransformation(int FaceNo)
    return &FaceTransformation;
 }
 
-void Mesh::GetEdgeTransformation(int EdgeNo, IsoparametricTransformation *EdTr)
+void Mesh::GetEdgeTransformation(int EdgeNo,
+                                 IsoparametricTransformation *EdTr) const
 {
    if (Dim == 2)
    {
@@ -649,7 +652,7 @@ ElementTransformation *Mesh::GetEdgeTransformation(int EdgeNo)
 
 
 void Mesh::GetLocalPtToSegTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    const IntegrationRule *SegVert;
    DenseMatrix &locpm = Transf.GetPointMat();
@@ -664,7 +667,7 @@ void Mesh::GetLocalPtToSegTransformation(
 }
 
 void Mesh::GetLocalSegToTriTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    const int *tv, *so;
    const IntegrationRule *TriVert;
@@ -684,7 +687,7 @@ void Mesh::GetLocalSegToTriTransformation(
 }
 
 void Mesh::GetLocalSegToQuadTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    const int *qv, *so;
    const IntegrationRule *QuadVert;
@@ -704,7 +707,7 @@ void Mesh::GetLocalSegToQuadTransformation(
 }
 
 void Mesh::GetLocalTriToTetTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
    Transf.Reset();
@@ -728,7 +731,7 @@ void Mesh::GetLocalTriToTetTransformation(
 }
 
 void Mesh::GetLocalTriToWdgTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
    Transf.Reset();
@@ -754,7 +757,7 @@ void Mesh::GetLocalTriToWdgTransformation(
 }
 
 void Mesh::GetLocalTriToPyrTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
 
@@ -779,7 +782,7 @@ void Mesh::GetLocalTriToPyrTransformation(
 }
 
 void Mesh::GetLocalQuadToHexTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
    Transf.Reset();
@@ -801,7 +804,7 @@ void Mesh::GetLocalQuadToHexTransformation(
 }
 
 void Mesh::GetLocalQuadToWdgTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
    Transf.Reset();
@@ -825,7 +828,7 @@ void Mesh::GetLocalQuadToWdgTransformation(
 }
 
 void Mesh::GetLocalQuadToPyrTransformation(
-   IsoparametricTransformation &Transf, int i)
+   IsoparametricTransformation &Transf, int i) const
 {
    DenseMatrix &locpm = Transf.GetPointMat();
 
@@ -903,8 +906,9 @@ void Mesh::DeleteGeometricFactors()
    face_geom_factors.SetSize(0);
 }
 
-void Mesh::GetLocalFaceTransformation(
-   int face_type, int elem_type, IsoparametricTransformation &Transf, int info)
+void Mesh::GetLocalFaceTransformation(int face_type, int elem_type,
+                                      IsoparametricTransformation &Transf,
+                                      int info) const
 {
    switch (face_type)
    {
@@ -971,47 +975,58 @@ void Mesh::GetLocalFaceTransformation(
 FaceElementTransformations *Mesh::GetFaceElementTransformations(int FaceNo,
                                                                 int mask)
 {
-   FaceInfo &face_info = faces_info[FaceNo];
+   GetFaceElementTransformations(FaceNo, &FaceElemTr, &Transformation,
+                                 &Transformation2, mask);
+   return &FaceElemTr;
+}
+
+void Mesh::GetFaceElementTransformations(int FaceNo,
+                                         FaceElementTransformations *FElTr,
+                                         IsoparametricTransformation *ElTr1,
+                                         IsoparametricTransformation *ElTr2,
+                                         int mask) const
+{
+   const FaceInfo &face_info = faces_info[FaceNo];
 
    int cmask = 0;
-   FaceElemTr.SetConfigurationMask(cmask);
-   FaceElemTr.Elem1 = NULL;
-   FaceElemTr.Elem2 = NULL;
+   FElTr->SetConfigurationMask(cmask);
+   FElTr->Elem1 = NULL;
+   FElTr->Elem2 = NULL;
 
    // setup the transformation for the first element
-   FaceElemTr.Elem1No = face_info.Elem1No;
+   FElTr->Elem1No = face_info.Elem1No;
    if (mask & FaceElementTransformations::HAVE_ELEM1)
    {
-      GetElementTransformation(FaceElemTr.Elem1No, &Transformation);
-      FaceElemTr.Elem1 = &Transformation;
+      GetElementTransformation(FElTr->Elem1No, ElTr1);
+      FElTr->Elem1 = ElTr1;
       cmask |= 1;
    }
 
    //  setup the transformation for the second element
    //     return NULL in the Elem2 field if there's no second element, i.e.
    //     the face is on the "boundary"
-   FaceElemTr.Elem2No = face_info.Elem2No;
+   FElTr->Elem2No = face_info.Elem2No;
    if ((mask & FaceElementTransformations::HAVE_ELEM2) &&
-       FaceElemTr.Elem2No >= 0)
+       FElTr->Elem2No >= 0)
    {
 #ifdef MFEM_DEBUG
       if (NURBSext && (mask & FaceElementTransformations::HAVE_ELEM1))
       { MFEM_ABORT("NURBS mesh not supported!"); }
 #endif
-      GetElementTransformation(FaceElemTr.Elem2No, &Transformation2);
-      FaceElemTr.Elem2 = &Transformation2;
+      GetElementTransformation(FElTr->Elem2No, ElTr2);
+      FElTr->Elem2 = ElTr2;
       cmask |= 2;
    }
 
    // setup the face transformation
    if (mask & FaceElementTransformations::HAVE_FACE)
    {
-      GetFaceTransformation(FaceNo, &FaceElemTr);
+      GetFaceTransformation(FaceNo, FElTr);
       cmask |= 16;
    }
    else
    {
-      FaceElemTr.SetGeometryType(GetFaceGeometry(FaceNo));
+      FElTr->SetGeometryType(GetFaceGeometry(FaceNo));
    }
 
    // setup Loc1 & Loc2
@@ -1020,42 +1035,86 @@ FaceElementTransformations *Mesh::GetFaceElementTransformations(int FaceNo,
    {
       int elem_type = GetElementType(face_info.Elem1No);
       GetLocalFaceTransformation(face_type, elem_type,
-                                 FaceElemTr.Loc1.Transf, face_info.Elem1Inf);
+                                 FElTr->Loc1.Transf, face_info.Elem1Inf);
       cmask |= 4;
    }
    if ((mask & FaceElementTransformations::HAVE_LOC2) &&
-       FaceElemTr.Elem2No >= 0)
+       FElTr->Elem2No >= 0)
    {
       int elem_type = GetElementType(face_info.Elem2No);
       GetLocalFaceTransformation(face_type, elem_type,
-                                 FaceElemTr.Loc2.Transf, face_info.Elem2Inf);
+                                 FElTr->Loc2.Transf, face_info.Elem2Inf);
 
       // NC meshes: prepend slave edge/face transformation to Loc2
       if (Nonconforming() && IsSlaveFace(face_info))
       {
-         ApplyLocalSlaveTransformation(FaceElemTr, face_info, false);
+         ApplyLocalSlaveTransformation(*FElTr, face_info, false);
       }
       cmask |= 8;
    }
 
-   FaceElemTr.SetConfigurationMask(cmask);
+   FElTr->SetConfigurationMask(cmask);
 
    // This check can be useful for internal debugging, however it will fail on
    // periodic boundary faces, so we keep it disabled in general.
 #if 0
 #ifdef MFEM_DEBUG
-   double dist = FaceElemTr.CheckConsistency();
+   double dist = FElTr->CheckConsistency();
    if (dist >= 1e-12)
    {
       mfem::out << "\nInternal error: face id = " << FaceNo
                 << ", dist = " << dist << '\n';
-      FaceElemTr.CheckConsistency(1); // print coordinates
+      FElTr->CheckConsistency(1); // print coordinates
       MFEM_ABORT("internal error");
    }
 #endif
 #endif
+}
 
-   return &FaceElemTr;
+FaceElementTransformations *Mesh::GetInteriorFaceTransformations(int FaceNo)
+{
+   GetInteriorFaceTransformations(FaceNo, &FaceElemTr, &Transformation,
+                                  &Transformation2);
+   return (FaceElemTr.geom == Geometry::INVALID) ? nullptr : &FaceElemTr;
+}
+
+void Mesh::GetInteriorFaceTransformations(int FaceNo,
+                                          FaceElementTransformations *FElTr,
+                                          IsoparametricTransformation *ElTr1,
+                                          IsoparametricTransformation *ElTr2) const
+{
+   if (faces_info[FaceNo].Elem2No < 0)
+   {
+      FElTr->SetGeometryType(Geometry::INVALID);
+      return;
+   }
+   GetFaceElementTransformations(FaceNo, FElTr, ElTr1, ElTr2);
+}
+
+FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
+{
+   GetBdrFaceTransformations(BdrElemNo, &FaceElemTr, &Transformation,
+                             &Transformation2);
+   return (FaceElemTr.geom == Geometry::INVALID) ? nullptr : &FaceElemTr;
+}
+
+void Mesh::GetBdrFaceTransformations(int BdrElemNo,
+                                     FaceElementTransformations *FElTr,
+                                     IsoparametricTransformation *ElTr1,
+                                     IsoparametricTransformation *ElTr2) const
+{
+   // Check if the face is interior, shared, or nonconforming.
+   int fn = GetBdrElementFaceIndex(BdrElemNo);
+   if (FaceIsTrueInterior(fn) || faces_info[fn].NCFace >= 0)
+   {
+      FElTr->SetGeometryType(Geometry::INVALID);
+      return;
+   }
+   GetFaceElementTransformations(fn, FElTr, ElTr1, ElTr2, 21);
+   FElTr->Attribute = boundary[BdrElemNo]->GetAttribute();
+   FElTr->ElementNo = BdrElemNo;
+   FElTr->ElementType = ElementTransformation::BDR_FACE;
+   FElTr->mesh = this;
 }
 
 bool Mesh::IsSlaveFace(const FaceInfo &fi) const
@@ -1064,7 +1123,7 @@ bool Mesh::IsSlaveFace(const FaceInfo &fi) const
 }
 
 void Mesh::ApplyLocalSlaveTransformation(FaceElementTransformations &FT,
-                                         const FaceInfo &fi, bool is_ghost)
+                                         const FaceInfo &fi, bool is_ghost) const
 {
 #ifdef MFEM_THREAD_SAFE
    DenseMatrix composition;
@@ -1102,24 +1161,6 @@ void Mesh::ApplyLocalSlaveTransformation(FaceElementTransformations &FT,
    }
 }
 
-FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
-{
-   FaceElementTransformations *tr;
-   int fn = GetBdrElementFaceIndex(BdrElemNo);
-
-   // Check if the face is interior, shared, or nonconforming.
-   if (FaceIsTrueInterior(fn) || faces_info[fn].NCFace >= 0)
-   {
-      return NULL;
-   }
-   tr = GetFaceElementTransformations(fn, 21);
-   tr->Attribute = boundary[BdrElemNo]->GetAttribute();
-   tr->ElementNo = BdrElemNo;
-   tr->ElementType = ElementTransformation::BDR_FACE;
-   tr->mesh = this;
-   return tr;
-}
-
 Mesh::FaceInformation Mesh::GetFaceInformation(int f) const
 {
    FaceInformation face;
@@ -10829,7 +10870,7 @@ int Mesh::FindCoarseElement(int i)
    return coarse;
 }
 
-const CoarseFineTransformations& Mesh::GetRefinementTransforms()
+const CoarseFineTransformations &Mesh::GetRefinementTransforms() const
 {
    MFEM_VERIFY(GetLastOperation() == Mesh::REFINE, "");
 
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index 3eee6c415..3c43cbb97 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -239,7 +239,7 @@ protected:
    FaceElementTransformations FaceElemTr;
 
    // refinement embeddings for forward compatibility with NCMesh
-   CoarseFineTransformations CoarseFineTr;
+   mutable CoarseFineTransformations CoarseFineTr;
 
    // Nodes are only active for higher order meshes, and share locations with
    // the vertices, plus all the higher- order control points within the
@@ -437,39 +437,34 @@ protected:
                   const std::string &comments = "") const;
 
    /// Used in GetFaceElementTransformations (...)
-   void GetLocalPtToSegTransformation(IsoparametricTransformation &, int);
-   void GetLocalSegToTriTransformation (IsoparametricTransformation &loc,
-                                        int i);
-   void GetLocalSegToQuadTransformation (IsoparametricTransformation &loc,
-                                         int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalTriToTetTransformation (IsoparametricTransformation &loc,
-                                        int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalTriToWdgTransformation (IsoparametricTransformation &loc,
-                                        int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalTriToPyrTransformation (IsoparametricTransformation &loc,
-                                        int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalQuadToHexTransformation (IsoparametricTransformation &loc,
-                                         int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalQuadToWdgTransformation (IsoparametricTransformation &loc,
-                                         int i);
-   /// Used in GetFaceElementTransformations (...)
-   void GetLocalQuadToPyrTransformation (IsoparametricTransformation &loc,
-                                         int i);
+   void GetLocalPtToSegTransformation(IsoparametricTransformation &,
+                                      int i) const;
+   void GetLocalSegToTriTransformation(IsoparametricTransformation &loc,
+                                       int i) const;
+   void GetLocalSegToQuadTransformation(IsoparametricTransformation &loc,
+                                        int i) const;
+   void GetLocalTriToTetTransformation(IsoparametricTransformation &loc,
+                                       int i) const;
+   void GetLocalTriToWdgTransformation(IsoparametricTransformation &loc,
+                                       int i) const;
+   void GetLocalTriToPyrTransformation(IsoparametricTransformation &loc,
+                                       int i) const;
+   void GetLocalQuadToHexTransformation(IsoparametricTransformation &loc,
+                                        int i) const;
+   void GetLocalQuadToWdgTransformation(IsoparametricTransformation &loc,
+                                        int i) const;
+   void GetLocalQuadToPyrTransformation(IsoparametricTransformation &loc,
+                                        int i) const;
 
    /** Used in GetFaceElementTransformations to account for the fact that a
        slave face occupies only a portion of its master face. */
    void ApplyLocalSlaveTransformation(FaceElementTransformations &FT,
-                                      const FaceInfo &fi, bool is_ghost);
+                                      const FaceInfo &fi, bool is_ghost) const;
 
    bool IsSlaveFace(const FaceInfo &fi) const;
 
    /// Returns the orientation of "test" relative to "base"
-   static int GetTriOrientation (const int * base, const int * test);
+   static int GetTriOrientation(const int *base, const int *test);
 
    /// Returns the orientation of "base" relative to "test"
    /// In other words: GetTriOrientation(test, base) should equal
@@ -482,7 +477,7 @@ protected:
    static int ComposeTriOrientations(int ori_a_b, int ori_b_c);
 
    /// Returns the orientation of "test" relative to "base"
-   static int GetQuadOrientation (const int * base, const int * test);
+   static int GetQuadOrientation(const int *base, const int *test);
 
    /// Returns the orientation of "base" relative to "test"
    /// In other words: GetQuadOrientation(test, base) should equal
@@ -495,7 +490,7 @@ protected:
    static int ComposeQuadOrientations(int ori_a_b, int ori_b_c);
 
    /// Returns the orientation of "test" relative to "base"
-   static int GetTetOrientation (const int * base, const int * test);
+   static int GetTetOrientation(const int *base, const int *test);
 
    static void GetElementArrayEdgeTable(const Array<Element*> &elem_array,
                                         const DSTable &v_to_v,
@@ -614,8 +609,6 @@ protected:
    void GetElementData(const Array<Element*> &elem_array, int geom,
                        Array<int> &elem_vtx, Array<int> &attr) const;
 
-   double GetElementSize(ElementTransformation *T, int type = 0);
-
    // Internal helper used in MakeSimplicial (and ParMesh::MakeSimplicial).
    void MakeSimplicial_(const Mesh &orig_mesh, int *vglobal);
 
@@ -1165,7 +1158,7 @@ public:
 
        In parallel, the result takes into account elements on all processors.
    */
-   inline int MeshGenerator() { return meshgen; }
+   inline int MeshGenerator() const { return meshgen; }
 
    /// Checks if the mesh has boundary elements
    virtual bool HasBoundaryElements() const { return (NumOfBdrElements > 0); }
@@ -1257,7 +1250,7 @@ public:
 
    /// @brief Return pointer to the i'th element object
    ///
-   /// The index @a i should be in the range [0, this->Mesh::GetNE())
+   /// The index @a i should be in the range [0, Mesh::GetNE())
    ///
    /// In parallel, @a i is the local element index which is in the
    /// same range mentioned above.
@@ -1272,7 +1265,7 @@ public:
 
    /// @brief Return pointer to the i'th boundary element object
    ///
-   /// The index @a i should be in the range [0, this->Mesh::GetNBE())
+   /// The index @a i should be in the range [0, Mesh::GetNBE())
    ///
    /// In parallel, @a i is the local boundary element index which is
    /// in the same range mentioned above.
@@ -1285,6 +1278,9 @@ public:
    /// the Element object itself should not be deleted by the caller.
    Element *GetBdrElement(int i) { return boundary[i]; }
 
+   /// @brief Return pointer to the i'th face element object
+   ///
+   /// The index @a i should be in the range [0, Mesh::GetNFaces())
    const Element *GetFace(int i) const { return faces[i]; }
 
    /// @}
@@ -1378,6 +1374,8 @@ public:
 
    double GetElementSize(int i, const Vector &dir);
 
+   double GetElementSize(ElementTransformation *T, int type = 0) const;
+
    double GetElementVolume(int i);
 
    void GetElementCenter(int i, Vector &center);
@@ -1397,12 +1395,12 @@ public:
       Geometry::Type geom_buf[Geometry::NumGeom];
    public:
       /// Construct a GeometryList of all element geometries in @a mesh.
-      GeometryList(Mesh &mesh)
+      GeometryList(const Mesh &mesh)
          : Array<Geometry::Type>(geom_buf, Geometry::NumGeom)
       { mesh.GetGeometries(mesh.Dimension(), *this); }
       /** @brief Construct a GeometryList of all geometries of dimension @a dim
           in @a mesh. */
-      GeometryList(Mesh &mesh, int dim)
+      GeometryList(const Mesh &mesh, int dim)
          : Array<Geometry::Type>(geom_buf, Geometry::NumGeom)
       { mesh.GetGeometries(dim, *this); }
    };
@@ -1559,7 +1557,8 @@ public:
 
    /// Builds the transformation defining the i-th element in @a ElTr.
    /// @a ElTr must be allocated in advance and will be owned by the caller.
-   void GetElementTransformation(int i, IsoparametricTransformation *ElTr);
+   void GetElementTransformation(int i,
+                                 IsoparametricTransformation *ElTr) const;
 
    /// Returns a pointer to the transformation defining the i-th element.
    ///
@@ -1572,7 +1571,7 @@ public:
    /// assuming position of the vertices/nodes are given by @a nodes.
    /// @a ElTr must be allocated in advance and will be owned by the caller.
    void GetElementTransformation(int i, const Vector &nodes,
-                                 IsoparametricTransformation *ElTr);
+                                 IsoparametricTransformation *ElTr) const;
 
    /// Returns a pointer to the transformation defining the i-th boundary
    /// element.
@@ -1583,11 +1582,18 @@ public:
 
    /// Builds the transformation defining the i-th boundary element in @a ElTr.
    /// @a ElTr must be allocated in advance and will be owned by the caller.
-   void GetBdrElementTransformation(int i, IsoparametricTransformation *ElTr);
+   void GetBdrElementTransformation(int i,
+                                    IsoparametricTransformation *ElTr) const;
+
+   /// Returns a pointer to the transformation defining the given face element.
+   /// @note The returned object is owned by the class and is shared, i.e.,
+   /// calling this function resets pointers obtained from previous calls.
+   /// Also, the returned object should NOT be deleted by the caller.
+   ElementTransformation *GetFaceTransformation(int FaceNo);
 
    /// Builds the transformation defining the i-th face element in @a FTr.
    /// @a FTr must be allocated in advance and will be owned by the caller.
-   void GetFaceTransformation(int i, IsoparametricTransformation *FTr);
+   void GetFaceTransformation(int i, IsoparametricTransformation *FTr) const;
 
    /** @brief A helper method that constructs a transformation from the
        reference space of a face to the reference space of an element. */
@@ -1596,17 +1602,11 @@ public:
        loc_face_orientation. */
    void GetLocalFaceTransformation(int face_type, int elem_type,
                                    IsoparametricTransformation &Transf,
-                                   int info);
-
-   /// Returns a pointer to the transformation defining the given face element.
-   /// @note The returned object is owned by the class and is shared, i.e.,
-   /// calling this function resets pointers obtained from previous calls.
-   /// Also, the returned object should NOT be deleted by the caller.
-   ElementTransformation *GetFaceTransformation(int FaceNo);
+                                   int info) const;
 
    /// Builds the transformation defining the i-th edge element in @a EdTr.
    /// @a EdTr must be allocated in advance and will be owned by the caller.
-   void GetEdgeTransformation(int i, IsoparametricTransformation *EdTr);
+   void GetEdgeTransformation(int i, IsoparametricTransformation *EdTr) const;
 
    /// Returns a pointer to the transformation defining the given edge element.
    /// @note The returned object is owned by the class and is shared, i.e.,
@@ -1648,21 +1648,44 @@ public:
    /// @note The returned object is owned by the class and is shared, i.e.,
    /// calling this function resets pointers obtained from previous calls.
    /// Also, this pointer should NOT be deleted by the caller.
-   virtual FaceElementTransformations *GetFaceElementTransformations(
-      int FaceNo,
-      int mask = 31);
+   virtual FaceElementTransformations *
+   GetFaceElementTransformations(int FaceNo, int mask = 31);
+
+   /// Variant of GetFaceElementTransformations using a user allocated
+   /// FaceElementTransformations object.
+   virtual void GetFaceElementTransformations(int FaceNo,
+                                              FaceElementTransformations *FElTr,
+                                              IsoparametricTransformation *ElTr1,
+                                              IsoparametricTransformation *ElTr2,
+                                              int mask = 31) const;
 
    /// See GetFaceElementTransformations().
-   /// @note The returned object should NOT be deleted by the caller.
-   FaceElementTransformations *GetInteriorFaceTransformations (int FaceNo)
-   {
-      if (faces_info[FaceNo].Elem2No < 0) { return NULL; }
-      return GetFaceElementTransformations (FaceNo);
-   }
+   ///
+   /// @note The returned object is owned by the class and is shared, i.e.,
+   /// calling this function resets pointers obtained from previous calls.
+   /// Also, this pointer should NOT be deleted by the caller.
+   FaceElementTransformations *GetInteriorFaceTransformations(int FaceNo);
+
+   /// Variant of GetInteriorFaceTransformations using a user allocated
+   /// FaceElementTransformations object.
+   void GetInteriorFaceTransformations(int FaceNo,
+                                       FaceElementTransformations *FElTr,
+                                       IsoparametricTransformation *ElTr1,
+                                       IsoparametricTransformation *ElTr2) const;
 
    /// Builds the transformation defining the given boundary face.
-   /// @note The returned object should NOT be deleted by the caller.
-   FaceElementTransformations *GetBdrFaceTransformations (int BdrElemNo);
+   ///
+   /// @note The returned object is owned by the class and is shared, i.e.,
+   /// calling this function resets pointers obtained from previous calls.
+   /// Also, this pointer should NOT be deleted by the caller.
+   FaceElementTransformations *GetBdrFaceTransformations(int BdrElemNo);
+
+   /// Variant of GetBdrFaceTransformations using a user allocated
+   /// FaceElementTransformations object.
+   void GetBdrFaceTransformations(int BdrElemNo,
+                                  FaceElementTransformations *FElTr,
+                                  IsoparametricTransformation *ElTr1,
+                                  IsoparametricTransformation *ElTr2) const;
 
    /// @}
 
@@ -2110,7 +2133,7 @@ public:
 
    /** Return fine element transformations following a mesh refinement.
        Space uses this to construct a global interpolation matrix. */
-   const CoarseFineTransformations &GetRefinementTransforms();
+   const CoarseFineTransformations &GetRefinementTransforms() const;
 
    /// Return type of last modification of the mesh.
    Operation GetLastOperation() const { return last_operation; }
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index 2074d3048..19af5028b 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -4112,7 +4112,7 @@ const NCMesh::PointMatrix& NCMesh::GetGeomIdentity(Geometry::Type geom)
 }
 
 void NCMesh::GetPointMatrix(Geometry::Type geom, const char* ref_path,
-                            DenseMatrix& matrix)
+                            DenseMatrix& matrix) const
 {
    PointMatrix pm = GetGeomIdentity(geom);
 
@@ -4608,9 +4608,9 @@ void NCMesh::MarkCoarseLevel()
 }
 
 void NCMesh::TraverseRefinements(int elem, int coarse_index,
-                                 std::string &ref_path, RefPathMap &map)
+                                 std::string &ref_path, RefPathMap &map) const
 {
-   Element &el = elements[elem];
+   const Element &el = elements[elem];
    if (!el.ref_type)
    {
       int &matrix = map[ref_path];
@@ -4641,7 +4641,7 @@ void NCMesh::TraverseRefinements(int elem, int coarse_index,
    }
 }
 
-const CoarseFineTransformations& NCMesh::GetRefinementTransforms()
+const CoarseFineTransformations& NCMesh::GetRefinementTransforms() const
 {
    MFEM_VERIFY(coarse_elements.Size() || !leaf_elements.Size(),
                "GetRefinementTransforms() must be preceded by MarkCoarseLevel()"
@@ -4692,7 +4692,7 @@ const CoarseFineTransformations& NCMesh::GetRefinementTransforms()
    return transforms;
 }
 
-const CoarseFineTransformations& NCMesh::GetDerefinementTransforms()
+const CoarseFineTransformations& NCMesh::GetDerefinementTransforms() const
 {
    MFEM_VERIFY(transforms.embeddings.Size() || !leaf_elements.Size(),
                "GetDerefinementTransforms() must be preceded by Derefine().");
@@ -5233,18 +5233,16 @@ void NCMesh::GetElementFacesAttributes(int leaf_elem,
    }
 }
 
-void NCMesh::FindFaceNodes(int face, int node[4])
+void NCMesh::FindFaceNodes(int face, int node[4]) const
 {
    // Obtain face nodes from one of its elements (note that face->p1, p2, p3
    // cannot be used directly since they are not in order and p4 is missing).
-
-   Face &fa = faces[face];
-
+   const Face &fa = faces[face];
    int elem = fa.elem[0];
    if (elem < 0) { elem = fa.elem[1]; }
    MFEM_ASSERT(elem >= 0, "Face has no elements?");
 
-   Element &el = elements[elem];
+   const Element &el = elements[elem];
    int f = find_local_face(el.Geom(),
                            find_node(el, fa.p1),
                            find_node(el, fa.p2),
diff --git a/mesh/ncmesh.hpp b/mesh/ncmesh.hpp
index 1e04d16bb..64a56beee 100644
--- a/mesh/ncmesh.hpp
+++ b/mesh/ncmesh.hpp
@@ -337,13 +337,13 @@ public:
    /** After refinement, calculate the relation of each fine element to its
        parent coarse element. Note that Refine() or LimitNCLevel() can be called
        multiple times between MarkCoarseLevel() and this function. */
-   const CoarseFineTransformations& GetRefinementTransforms();
+   const CoarseFineTransformations& GetRefinementTransforms() const;
 
    /** After derefinement, calculate the relations of previous fine elements
        (some of which may no longer exist) to the current leaf elements.
        Unlike for refinement, Derefine() may only be called once before this
        function so there is no MarkFineLevel(). */
-   const CoarseFineTransformations& GetDerefinementTransforms();
+   const CoarseFineTransformations& GetDerefinementTransforms() const;
 
    /// Free all internal data created by the above three functions.
    void ClearTransforms();
@@ -1036,15 +1036,15 @@ protected: // implementation
    static const PointMatrix& GetGeomIdentity(Geometry::Type geom);
 
    void GetPointMatrix(Geometry::Type geom, const char* ref_path,
-                       DenseMatrix& matrix);
+                       DenseMatrix& matrix) const;
 
    typedef std::map<std::string, int> RefPathMap;
 
    void TraverseRefinements(int elem, int coarse_index,
-                            std::string &ref_path, RefPathMap &map);
+                            std::string &ref_path, RefPathMap &map) const;
 
    /// storage for data returned by Get[De]RefinementTransforms()
-   CoarseFineTransformations transforms;
+   mutable CoarseFineTransformations transforms;
 
    /// state of leaf_elements before Refine(), set by MarkCoarseLevel()
    Array<int> coarse_elements;
@@ -1069,7 +1069,7 @@ protected: // implementation
 
    int GetEdgeMaster(int node) const;
 
-   void FindFaceNodes(int face, int node[4]);
+   void FindFaceNodes(int face, int node[4]) const;
 
    /**
     * @brief Return the number of splits of this edge that have occurred in the
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index 5225cfc14..b6424d4e8 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -1947,65 +1947,6 @@ void ParMesh::GenerateOffsets(int N, HYPRE_BigInt loc_sizes[],
    }
 }
 
-void ParMesh::GetFaceNbrElementTransformation(
-   int i, IsoparametricTransformation *ElTr)
-{
-   DenseMatrix &pointmat = ElTr->GetPointMat();
-   Element *elem = face_nbr_elements[i];
-
-   ElTr->Attribute = elem->GetAttribute();
-   ElTr->ElementNo = NumOfElements + i;
-   ElTr->ElementType = ElementTransformation::ELEMENT;
-   ElTr->mesh = this;
-   ElTr->Reset();
-
-   if (Nodes == NULL)
-   {
-      const int nv = elem->GetNVertices();
-      const int *v = elem->GetVertices();
-
-      pointmat.SetSize(spaceDim, nv);
-      for (int k = 0; k < spaceDim; k++)
-      {
-         for (int j = 0; j < nv; j++)
-         {
-            pointmat(k, j) = face_nbr_vertices[v[j]](k);
-         }
-      }
-
-      ElTr->SetFE(GetTransformationFEforElementType(elem->GetType()));
-   }
-   else
-   {
-      Array<int> vdofs;
-      ParGridFunction *pNodes = dynamic_cast<ParGridFunction *>(Nodes);
-      if (pNodes)
-      {
-         pNodes->ParFESpace()->GetFaceNbrElementVDofs(i, vdofs);
-         int n = vdofs.Size()/spaceDim;
-         pointmat.SetSize(spaceDim, n);
-         for (int k = 0; k < spaceDim; k++)
-         {
-            for (int j = 0; j < n; j++)
-            {
-               pointmat(k,j) = (pNodes->FaceNbrData())(vdofs[n*k+j]);
-            }
-         }
-
-         ElTr->SetFE(pNodes->ParFESpace()->GetFaceNbrFE(i));
-      }
-      else
-      {
-         MFEM_ABORT("Nodes are not ParGridFunction!");
-      }
-   }
-}
-
-double ParMesh::GetFaceNbrElementSize(int i, int type)
-{
-   return GetElementSize(GetFaceNbrElementTransformation(i), type);
-}
-
 void ParMesh::DeleteFaceNbrData()
 {
    if (!have_face_nbr_data)
@@ -2917,86 +2858,83 @@ Table *ParMesh::GetFaceToAllElementTable() const
    return face_elem;
 }
 
-void ParMesh::GetGhostFaceTransformation(
-   FaceElementTransformations* FETr, Element::Type face_type,
-   Geometry::Type face_geom)
+FaceElementTransformations *ParMesh::GetFaceElementTransformations(int FaceNo,
+                                                                   int mask)
 {
-   // calculate composition of FETr->Loc1 and FETr->Elem1
-   DenseMatrix &face_pm = FETr->GetPointMat();
-   FETr->Reset();
-   if (Nodes == NULL)
-   {
-      FETr->Elem1->Transform(FETr->Loc1.Transf.GetPointMat(), face_pm);
-      FETr->SetFE(GetTransformationFEforElementType(face_type));
-   }
-   else
-   {
-      const FiniteElement* face_el =
-         Nodes->FESpace()->GetTraceElement(FETr->Elem1No, face_geom);
-      MFEM_VERIFY(dynamic_cast<const NodalFiniteElement*>(face_el),
-                  "Mesh requires nodal Finite Element.");
-
-#if 0 // TODO: handle the case of non-interpolatory Nodes
-      DenseMatrix I;
-      face_el->Project(Transformation.GetFE(), FETr->Loc1.Transf, I);
-      MultABt(Transformation.GetPointMat(), I, pm_face);
-#else
-      IntegrationRule eir(face_el->GetDof());
-      FETr->Loc1.Transform(face_el->GetNodes(), eir);
-      Nodes->GetVectorValues(*FETr->Elem1, eir, face_pm);
-#endif
-      FETr->SetFE(face_el);
-   }
+   GetFaceElementTransformations(FaceNo, &FaceElemTr, &Transformation,
+                                 &Transformation2, mask);
+   return &FaceElemTr;
 }
 
-FaceElementTransformations *ParMesh::GetFaceElementTransformations(
-   int FaceNo,
-   int mask)
+void ParMesh::GetFaceElementTransformations(int FaceNo,
+                                            FaceElementTransformations *FElTr,
+                                            IsoparametricTransformation *ElTr1,
+                                            IsoparametricTransformation *ElTr2,
+                                            int mask) const
 {
    if (FaceNo < GetNumFaces())
    {
-      return Mesh::GetFaceElementTransformations(FaceNo, mask);
+      Mesh::GetFaceElementTransformations(FaceNo, FElTr, ElTr1, ElTr2, mask);
    }
    else
    {
       const bool fill2 = mask & 10; // Elem2 and/or Loc2
-      return GetSharedFaceTransformationsByLocalIndex(FaceNo, fill2);
+      GetSharedFaceTransformationsByLocalIndex(FaceNo, FElTr, ElTr1, ElTr2,
+                                               fill2);
    }
 }
 
-FaceElementTransformations *ParMesh::
-GetSharedFaceTransformations(int sf, bool fill2)
+FaceElementTransformations *ParMesh::GetSharedFaceTransformations(int sf,
+                                                                  bool fill2)
+{
+   GetSharedFaceTransformations(sf, &FaceElemTr, &Transformation,
+                                &Transformation2, fill2);
+   return &FaceElemTr;
+}
+
+void ParMesh::GetSharedFaceTransformations(int sf,
+                                           FaceElementTransformations *FElTr,
+                                           IsoparametricTransformation *ElTr1,
+                                           IsoparametricTransformation *ElTr2,
+                                           bool fill2) const
 {
    int FaceNo = GetSharedFace(sf);
+   GetSharedFaceTransformationsByLocalIndex(FaceNo, FElTr, ElTr1, ElTr2, fill2);
+}
 
-   return GetSharedFaceTransformationsByLocalIndex(FaceNo, fill2);
+FaceElementTransformations *
+ParMesh::GetSharedFaceTransformationsByLocalIndex(int FaceNo, bool fill2)
+{
+   GetSharedFaceTransformationsByLocalIndex(FaceNo, &FaceElemTr, &Transformation,
+                                            &Transformation2, fill2);
+   return &FaceElemTr;
 }
 
-FaceElementTransformations *ParMesh::
-GetSharedFaceTransformationsByLocalIndex(int FaceNo, bool fill2)
+void ParMesh::GetSharedFaceTransformationsByLocalIndex(
+   int FaceNo, FaceElementTransformations *FElTr,
+   IsoparametricTransformation *ElTr1, IsoparametricTransformation *ElTr2,
+   bool fill2) const
 {
-   FaceInfo &face_info = faces_info[FaceNo];
+   const FaceInfo &face_info = faces_info[FaceNo];
    MFEM_VERIFY(face_info.Elem2Inf >= 0, "The face must be shared.");
 
    bool is_slave = Nonconforming() && IsSlaveFace(face_info);
    bool is_ghost = Nonconforming() && FaceNo >= GetNumFaces();
 
    int mask = 0;
-   FaceElemTr.SetConfigurationMask(0);
-   FaceElemTr.Elem1 = NULL;
-   FaceElemTr.Elem2 = NULL;
+   FElTr->SetConfigurationMask(0);
+   FElTr->Elem1 = NULL;
+   FElTr->Elem2 = NULL;
 
-   NCFaceInfo* nc_info = NULL;
-   if (is_slave) { nc_info = &nc_faces_info[face_info.NCFace]; }
-
-   int local_face = is_ghost ? nc_info->MasterFace : FaceNo;
+   int local_face =
+      is_ghost ? nc_faces_info[face_info.NCFace].MasterFace : FaceNo;
    Element::Type  face_type = GetFaceElementType(local_face);
    Geometry::Type face_geom = GetFaceGeometry(local_face);
 
    // setup the transformation for the first element
-   FaceElemTr.Elem1No = face_info.Elem1No;
-   GetElementTransformation(FaceElemTr.Elem1No, &Transformation);
-   FaceElemTr.Elem1 = &Transformation;
+   FElTr->Elem1No = face_info.Elem1No;
+   GetElementTransformation(FElTr->Elem1No, ElTr1);
+   FElTr->Elem1 = ElTr1;
    mask |= FaceElementTransformations::HAVE_ELEM1;
 
    // setup the transformation for the second (neighbor) element
@@ -3004,42 +2942,42 @@ GetSharedFaceTransformationsByLocalIndex(int FaceNo, bool fill2)
    if (fill2)
    {
       Elem2NbrNo = -1 - face_info.Elem2No;
-      // Store the "shifted index" for element 2 in FaceElemTr.Elem2No.
+      // Store the "shifted index" for element 2 in FElTr->Elem2No.
       // `Elem2NbrNo` is the index of the face neighbor (starting from 0),
-      // and `FaceElemTr.Elem2No` will be offset by the number of (local)
+      // and `FElTr->Elem2No` will be offset by the number of (local)
       // elements in the mesh.
-      FaceElemTr.Elem2No = NumOfElements + Elem2NbrNo;
-      GetFaceNbrElementTransformation(Elem2NbrNo, &Transformation2);
-      FaceElemTr.Elem2 = &Transformation2;
+      FElTr->Elem2No = NumOfElements + Elem2NbrNo;
+      GetFaceNbrElementTransformation(Elem2NbrNo, ElTr2);
+      FElTr->Elem2 = ElTr2;
       mask |= FaceElementTransformations::HAVE_ELEM2;
    }
    else
    {
-      FaceElemTr.Elem2No = -1;
+      FElTr->Elem2No = -1;
    }
 
    // setup the face transformation if the face is not a ghost
    if (!is_ghost)
    {
-      GetFaceTransformation(FaceNo, &FaceElemTr);
-      // NOTE: The above call overwrites FaceElemTr.Loc1
+      GetFaceTransformation(FaceNo, FElTr);
+      // NOTE: The above call overwrites FElTr->Loc1
       mask |= FaceElementTransformations::HAVE_FACE;
    }
    else
    {
-      FaceElemTr.SetGeometryType(face_geom);
+      FElTr->SetGeometryType(face_geom);
    }
 
    // setup Loc1 & Loc2
    int elem_type = GetElementType(face_info.Elem1No);
-   GetLocalFaceTransformation(face_type, elem_type, FaceElemTr.Loc1.Transf,
+   GetLocalFaceTransformation(face_type, elem_type, FElTr->Loc1.Transf,
                               face_info.Elem1Inf);
    mask |= FaceElementTransformations::HAVE_LOC1;
 
    if (fill2)
    {
       elem_type = face_nbr_elements[Elem2NbrNo]->GetType();
-      GetLocalFaceTransformation(face_type, elem_type, FaceElemTr.Loc2.Transf,
+      GetLocalFaceTransformation(face_type, elem_type, FElTr->Loc2.Transf,
                                  face_info.Elem2Inf);
       mask |= FaceElementTransformations::HAVE_LOC2;
    }
@@ -3050,35 +2988,130 @@ GetSharedFaceTransformationsByLocalIndex(int FaceNo, bool fill2)
       if (is_ghost || fill2)
       {
          // is_ghost -> modify side 1, otherwise -> modify side 2:
-         ApplyLocalSlaveTransformation(FaceElemTr, face_info, is_ghost);
+         ApplyLocalSlaveTransformation(*FElTr, face_info, is_ghost);
       }
    }
 
    // for ghost faces we need a special version of GetFaceTransformation
    if (is_ghost)
    {
-      GetGhostFaceTransformation(&FaceElemTr, face_type, face_geom);
+      GetGhostFaceTransformation(FElTr, face_type, face_geom);
       mask |= FaceElementTransformations::HAVE_FACE;
    }
 
-   FaceElemTr.SetConfigurationMask(mask);
+   FElTr->SetConfigurationMask(mask);
 
    // This check can be useful for internal debugging, however it will fail on
    // periodic boundary faces, so we keep it disabled in general.
 #if 0
 #ifdef MFEM_DEBUG
-   double dist = FaceElemTr.CheckConsistency();
+   double dist = FElTr->CheckConsistency();
    if (dist >= 1e-12)
    {
       mfem::out << "\nInternal error: face id = " << FaceNo
                 << ", dist = " << dist << ", rank = " << MyRank << '\n';
-      FaceElemTr.CheckConsistency(1); // print coordinates
+      FElTr->CheckConsistency(1); // print coordinates
       MFEM_ABORT("internal error");
    }
 #endif
 #endif
+}
 
-   return &FaceElemTr;
+void ParMesh::GetGhostFaceTransformation(
+   FaceElementTransformations *FElTr, Element::Type face_type,
+   Geometry::Type face_geom) const
+{
+   // calculate composition of FElTr->Loc1 and FElTr->Elem1
+   DenseMatrix &face_pm = FElTr->GetPointMat();
+   FElTr->Reset();
+   if (Nodes == NULL)
+   {
+      FElTr->Elem1->Transform(FElTr->Loc1.Transf.GetPointMat(), face_pm);
+      FElTr->SetFE(GetTransformationFEforElementType(face_type));
+   }
+   else
+   {
+      const FiniteElement* face_el =
+         Nodes->FESpace()->GetTraceElement(FElTr->Elem1No, face_geom);
+      MFEM_VERIFY(dynamic_cast<const NodalFiniteElement*>(face_el),
+                  "Mesh requires nodal Finite Element.");
+
+#if 0 // TODO: handle the case of non-interpolatory Nodes
+      DenseMatrix I;
+      face_el->Project(Transformation.GetFE(), FElTr->Loc1.Transf, I);
+      MultABt(Transformation.GetPointMat(), I, pm_face);
+#else
+      IntegrationRule eir(face_el->GetDof());
+      FElTr->Loc1.Transform(face_el->GetNodes(), eir);
+      Nodes->GetVectorValues(*FElTr->Elem1, eir, face_pm);
+#endif
+      FElTr->SetFE(face_el);
+   }
+}
+
+ElementTransformation *ParMesh::GetFaceNbrElementTransformation(int FaceNo)
+{
+   GetFaceNbrElementTransformation(FaceNo, &Transformation);
+   return &Transformation;
+}
+
+void ParMesh::GetFaceNbrElementTransformation(
+   int FaceNo, IsoparametricTransformation *ElTr) const
+{
+   DenseMatrix &pointmat = ElTr->GetPointMat();
+   Element *elem = face_nbr_elements[FaceNo];
+
+   ElTr->Attribute = elem->GetAttribute();
+   ElTr->ElementNo = NumOfElements + FaceNo;
+   ElTr->ElementType = ElementTransformation::ELEMENT;
+   ElTr->mesh = this;
+   ElTr->Reset();
+
+   if (Nodes == NULL)
+   {
+      const int nv = elem->GetNVertices();
+      const int *v = elem->GetVertices();
+
+      pointmat.SetSize(spaceDim, nv);
+      for (int k = 0; k < spaceDim; k++)
+      {
+         for (int j = 0; j < nv; j++)
+         {
+            pointmat(k, j) = face_nbr_vertices[v[j]](k);
+         }
+      }
+
+      ElTr->SetFE(GetTransformationFEforElementType(elem->GetType()));
+   }
+   else
+   {
+      Array<int> vdofs;
+      ParGridFunction *pNodes = dynamic_cast<ParGridFunction *>(Nodes);
+      if (pNodes)
+      {
+         pNodes->ParFESpace()->GetFaceNbrElementVDofs(FaceNo, vdofs);
+         int n = vdofs.Size()/spaceDim;
+         pointmat.SetSize(spaceDim, n);
+         for (int k = 0; k < spaceDim; k++)
+         {
+            for (int j = 0; j < n; j++)
+            {
+               pointmat(k,j) = (pNodes->FaceNbrData())(vdofs[n*k+j]);
+            }
+         }
+
+         ElTr->SetFE(pNodes->ParFESpace()->GetFaceNbrFE(FaceNo));
+      }
+      else
+      {
+         MFEM_ABORT("Nodes are not ParGridFunction!");
+      }
+   }
+}
+
+double ParMesh::GetFaceNbrElementSize(int i, int type)
+{
+   return GetElementSize(GetFaceNbrElementTransformation(i), type);
 }
 
 int ParMesh::GetNSharedFaces() const
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index d723204f6..b1235ccbf 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -91,8 +91,6 @@ protected:
    /// orientations for each face (from nbr processor)
    std::unique_ptr<Table> face_nbr_el_ori;
 
-   IsoparametricTransformation FaceNbrTransformation;
-
    // glob_elem_offset + local element number defines a global element numbering
    mutable long long glob_elem_offset;
    mutable long glob_offset_sequence;
@@ -153,12 +151,9 @@ protected:
                     const std::unique_ptr<STable3D> &shared_faces,
                     int elem, int start, int end, const int fverts[][N]);
 
-   void GetFaceNbrElementTransformation(
-      int i, IsoparametricTransformation *ElTr);
-
    void GetGhostFaceTransformation(
-      FaceElementTransformations* FETr, Element::Type face_type,
-      Geometry::Type face_geom);
+      FaceElementTransformations *FElTr, Element::Type face_type,
+      Geometry::Type face_geom) const;
 
    /// Update the groups after triangle refinement
    void RefineGroups(const DSTable &v_to_v, int *middle);
@@ -551,9 +546,16 @@ public:
    /// @note The returned object is owned by the class and is shared, i.e.,
    /// calling this function resets pointers obtained from previous calls.
    /// Also, the returned object should NOT be deleted by the caller.
-   FaceElementTransformations *GetFaceElementTransformations(
-      int FaceNo,
-      int mask = 31) override;
+   FaceElementTransformations *
+   GetFaceElementTransformations(int FaceNo, int mask = 31) override;
+
+   /// Variant of GetFaceElementTransformations using a user allocated
+   /// FaceElementTransformations object.
+   void GetFaceElementTransformations(int FaceNo,
+                                      FaceElementTransformations *FElTr,
+                                      IsoparametricTransformation *ElTr1,
+                                      IsoparametricTransformation *ElTr2,
+                                      int mask = 31) const override;
 
    /// Get the FaceElementTransformations for the given shared face (edge 2D)
    /// using the shared face index @a sf. @a fill2 specify if the information
@@ -567,6 +569,14 @@ public:
    FaceElementTransformations *
    GetSharedFaceTransformations(int sf, bool fill2 = true);
 
+   /// Variant of GetSharedFaceTransformations using a user allocated
+   /// FaceElementTransformations object.
+   void GetSharedFaceTransformations(int sf,
+                                     FaceElementTransformations *FElTr,
+                                     IsoparametricTransformation *ElTr1,
+                                     IsoparametricTransformation *ElTr2,
+                                     bool fill2 = true) const;
+
    /// Get the FaceElementTransformations for the given shared face (edge 2D)
    /// using the face index @a FaceNo. @a fill2 specify if the information
    /// for elem2 of the face should be computed or not.
@@ -579,20 +589,29 @@ public:
    FaceElementTransformations *
    GetSharedFaceTransformationsByLocalIndex(int FaceNo, bool fill2 = true);
 
+   /// Variant of GetSharedFaceTransformationsByLocalIndex using a user
+   /// allocated FaceElementTransformations object.
+   void GetSharedFaceTransformationsByLocalIndex(int FaceNo,
+                                                 FaceElementTransformations *FElTr,
+                                                 IsoparametricTransformation *ElTr1,
+                                                 IsoparametricTransformation *ElTr2,
+                                                 bool fill2 = true) const;
+
    /// Returns a pointer to the transformation defining the i-th face neighbor.
+   ///
    /// @note The returned object is owned by the class and is shared, i.e.,
    /// calling this function resets pointers obtained from previous calls.
    /// Also, the returned object should NOT be deleted by the caller.
-   ElementTransformation *GetFaceNbrElementTransformation(int i)
-   {
-      GetFaceNbrElementTransformation(i, &FaceNbrTransformation);
+   ElementTransformation *GetFaceNbrElementTransformation(int FaceNo);
 
-      return &FaceNbrTransformation;
-   }
+   /// Variant of GetFaceNbrElementTransformation using a user allocated
+   /// IsoparametricTransformation object.
+   void GetFaceNbrElementTransformation(int FaceNo,
+                                        IsoparametricTransformation *ElTr) const;
 
    /// Get the size of the i-th face neighbor element relative to the reference
    /// element.
-   double GetFaceNbrElementSize(int i, int type=0);
+   double GetFaceNbrElementSize(int i, int type = 0);
 
    /// Return the number of shared faces (3D), edges (2D), vertices (1D)
    int GetNSharedFaces() const;
