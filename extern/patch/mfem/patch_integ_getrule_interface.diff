diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index 210acf882..db71bc7d4 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -1298,8 +1298,8 @@ void MixedBilinearForm::Assemble(int skip_zeros)
             }
             for (int k = 0; k < trace_face_integs.Size(); k++)
             {
-               trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe, *test_fe1,
-                                                        *test_fe2, *ftr, elemmat);
+               trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe, *test_fe1,
+                                                         *test_fe2, *ftr, elemmat);
                mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
             }
          }
@@ -1327,10 +1327,10 @@ void MixedBilinearForm::Assemble(int skip_zeros)
                if (boundary_trace_face_integs_marker[k] == NULL ||
                    (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 1)
                {
-                  boundary_trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe,
-                                                                    *test_fe1,
-                                                                    *test_fe2,
-                                                                    *ftr, elemmat);
+                  boundary_trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe,
+                                                                     *test_fe1,
+                                                                     *test_fe2,
+                                                                     *ftr, elemmat);
                   mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
                }
             }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index e6fc2a6ee..b07f4a9d9 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -141,7 +141,7 @@ void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace&,
                                                      Vector&,
                                                      Vector&)
 {
@@ -156,47 +156,50 @@ void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix(const FiniteElement&,
+                                                   ElementTransformation&,
+                                                   DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2(
-   const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix2(const FiniteElement&,
+                                                    const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix(const FiniteElement&,
+                                                const FiniteElement&,
+                                                FaceElementTransformations&Trans,
+                                                DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
-   const FiniteElement &test_fe2, FaceElementTransformations &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix2(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 DenseMatrix&)
 {
-   MFEM_ABORT("AssembleFaceMatrix (mixed form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleTraceFaceMatrix (int elem,
-                                                      const FiniteElement &trial_face_fe,
-                                                      const FiniteElement &test_fe1,
-                                                      FaceElementTransformations &Trans,
-                                                      DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleTraceFaceMatrix(int,
+                                                     const FiniteElement&,
+                                                     const FiniteElement&,
+                                                     FaceElementTransformations&,
+                                                     DenseMatrix&)
 {
-   MFEM_ABORT("AssembleTraceFaceMatrix (DPG form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleTraceFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleElementVector(
@@ -221,17 +224,10 @@ void BilinearFormIntegrator::AssembleFaceVector(
    elmat.Mult(elfun, elvect);
 }
 
-void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -240,7 +236,6 @@ void TransposeIntegrator::AssembleElementMatrix2(
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -249,16 +244,9 @@ void TransposeIntegrator::AssembleFaceMatrix(
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
-void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -266,38 +254,41 @@ void LumpedIntegrator::AssembleElementMatrix(
    elmat.Lump();
 }
 
-void InverseIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   integrator->SetIntRule(ir);
-}
-
 void InverseIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   integrator->AssembleElementMatrix(el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Invert();
 }
 
+bool SumIntegrator::SupportsCeed() const
+{
+   for (int i = 0; i < bfis.Size(); i++)
+   {
+      if (!bfis[i]->SupportsCeed()) { return false; }
+   }
+   return true;
+}
+
 void SumIntegrator::SetIntRule(const IntegrationRule *ir)
 {
    IntRule = ir;
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->SetIntRule(ir);
+      bfis[i]->SetIntRule(ir);
    }
 }
 
 void SumIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix(el, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix(el, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix(el, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix(el, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -305,13 +296,13 @@ void SumIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix2(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix2(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -319,134 +310,134 @@ void SumIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
-void SumIntegrator::AssembleFaceMatrix(
-   const FiniteElement &tr_fe,
-   const FiniteElement &te_fe1, const FiniteElement &te_fe2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void SumIntegrator::AssembleFaceMatrix2(
+   const FiniteElement &tr_fe, const FiniteElement &te_fe1,
+   const FiniteElement &te_fe2, FaceElementTransformations &Trans,
+   DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(fes);
+      bfis[i]->AssemblePA(fes);
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(trial_fes, test_fes);
+      bfis[i]->AssemblePA(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalPA(diag);
+      bfis[i]->AssembleDiagonalPA(diag);
    }
 }
 
 void SumIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePAInteriorFaces(fes);
+      bfis[i]->AssemblePAInteriorFaces(fes);
    }
 }
 
 void SumIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePABoundaryFaces(fes);
+      bfis[i]->AssemblePABoundaryFaces(fes);
    }
 }
 
 void SumIntegrator::AddMultPA(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultPA(x, y);
+      bfis[i]->AddMultPA(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposePA(x, y);
+      bfis[i]->AddMultTransposePA(x, y);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(fes);
+      bfis[i]->AssembleMF(fes);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(trial_fes, test_fes);
+      bfis[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      bfis[i]->AssembleDiagonalMF(diag);
    }
 }
 
 void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      bfis[i]->AddMultTransposeMF(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      bfis[i]->AddMultMF(x, y);
    }
 }
 
 void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat);
+      bfis[i]->AssembleEA(fes, emat);
    }
 }
 
@@ -454,32 +445,41 @@ void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
                                             Vector &ea_data_ext)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
+      bfis[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_bdr)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
+      bfis[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
 SumIntegrator::~SumIntegrator()
 {
-   if (own_integrators)
+   if (own_bfis)
    {
-      for (int i = 0; i < integrators.Size(); i++)
+      for (int i = 0; i < bfis.Size(); i++)
       {
-         delete integrators[i];
+         delete bfis[i];
       }
    }
 }
 
+const IntegrationRule &MixedScalarIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -507,12 +507,8 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -539,6 +535,15 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -598,12 +603,8 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -713,6 +714,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedScalarVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -754,12 +764,8 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -787,6 +793,15 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -843,18 +858,30 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
+const IntegrationRule &DiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans)
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
+   }
+   else
+   {
+      // order = 2 * el.GetOrder() - 2;  // <-- this seems to work fine too
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void DiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void DiffusionIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                ElementTransformation &Trans,
+                                                DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -889,7 +916,7 @@ void DiffusionIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -970,7 +997,8 @@ void DiffusionIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd, tr_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1048,7 +1076,7 @@ void DiffusionIntegrator::AssembleElementVector(
 
    elvect.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1094,13 +1122,9 @@ void DiffusionIntegrator::AssembleElementVector(
 }
 
 void DiffusionIntegrator::ComputeElementFlux(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   Vector &u,
-   const FiniteElement &fluxelem,
-   Vector &flux,
-   bool with_coef,
-   const IntegrationRule *ir)
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1196,11 +1220,9 @@ void DiffusionIntegrator::ComputeElementFlux(
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy(
-   const FiniteElement &fluxelem,
-   ElementTransformation &Trans,
-   Vector &flux,
-   Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
+                                              ElementTransformation &Trans,
+                                              Vector &flux, Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1218,7 +1240,7 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    if (d_energy) { vec.SetSize(spaceDim); }
    if (MQ) { M.SetSize(spaceDim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule *ir = &IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -1274,20 +1296,13 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    return energy;
 }
 
-const IntegrationRule &DiffusionIntegrator::GetRule(
+const IntegrationRule &MassIntegrator::GetRuleStatic(
    const FiniteElement &trial_fe,
-   const FiniteElement &test_fe)
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans,
+   int Q_order)
 {
-   int order;
-   if (trial_fe.Space() == FunctionSpace::Pk)
-   {
-      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
-   }
-   else
-   {
-      // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
-      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
-   }
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() + Q_order;
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1295,22 +1310,20 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void MassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void MassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                           ElementTransformation &Trans,
+                                           DenseMatrix &elmat)
 {
    int nd = el.GetDof();
-   // int dim = el.GetDim();
    double w;
 
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   shape.SetSize(nd);
    elmat.SetSize(nd);
+   shape.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1345,8 +1358,8 @@ void MassIntegrator::AssembleElementMatrix2(
    shape.SetSize(tr_nd);
    te_shape.SetSize(te_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule :
-                               &GetRule(trial_fe, test_fe, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1367,18 +1380,13 @@ void MassIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
-                                               const FiniteElement &test_fe,
-                                               ElementTransformation &Trans)
+const IntegrationRule &BoundaryMassIntegrator::GetRule(
+   const FiniteElement &el1,
+   const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
 {
-   // int order = trial_fe.GetOrder() + test_fe.GetOrder();
-   const int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW();
-
-   if (trial_fe.Space() == FunctionSpace::rQk)
-   {
-      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-   }
-   return IntRules.Get(trial_fe.GetGeomType(), order);
+   int order = el1.GetOrder() + el2.GetOrder();
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void BoundaryMassIntegrator::AssembleFaceMatrix(
@@ -1397,13 +1405,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    elmat.SetSize(nd1);
    shape.SetSize(nd1);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el1.GetOrder();
-
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1427,6 +1429,15 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void ConvectionIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -1446,12 +1457,7 @@ void ConvectionIntegrator::AssembleElementMatrix(
 
    Vector vec1;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + Trans.Order() + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_ir, Trans, *ir);
 
@@ -1474,18 +1480,8 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
-   return IntRules.Get(fe.GetGeomType(), order);
-}
-
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1496,12 +1492,7 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    shape.SetSize(nd);
    grad.SetSize(nd,dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_nodal, Trans, el.GetNodes()); // sets the size of Q_nodal
 
@@ -1536,10 +1527,9 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-void VectorMassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void VectorMassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                 ElementTransformation &Trans,
+                                                 DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1561,20 +1551,7 @@ void VectorMassIntegrator::AssembleElementMatrix(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() + Trans.OrderW() + Q_order;
-
-      if (el.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(el.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(el.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1644,21 +1621,8 @@ void VectorMassIntegrator::AssembleElementMatrix2(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = (trial_fe.GetOrder() + test_fe.GetOrder() +
-                   Trans.OrderW() + Q_order);
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1704,6 +1668,179 @@ void VectorMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+void VectorDiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Trans.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, sdim);
+
+   elmat.SetSize(vdim * dof);
+   pelmat.SetSize(dof);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+
+   elmat = 0.0;
+
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Trans.SetIntPoint(&ip);
+      double w = Trans.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      // AdjugateJacobian = / adj(J),         if J is square
+      //                    \ adj(J^t.J).J^t, otherwise
+      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Trans, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Trans, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
+               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Trans, ip); }
+         Mult_a_AAt(w, dshapedxt, pelmat);
+         for (int k = 0; k < vdim; ++k)
+         {
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+   }
+}
+
+void VectorDiffusionIntegrator::AssembleElementVector(
+   const FiniteElement &el, ElementTransformation &Tr,
+   const Vector &elfun, Vector &elvect)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Tr.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, dim);
+   // pelmat.SetSize(dim);
+
+   elvect.SetSize(dim*dof);
+
+   // NOTE: DenseMatrix is in column-major order. This is consistent with
+   // vectors ordered byNODES. In the resulting DenseMatrix, each column
+   // corresponds to a particular vdim.
+   DenseMatrix mat_in(elfun.GetData(), dof, dim);
+   DenseMatrix mat_out(elvect.GetData(), dof, dim);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
+
+   elvect = 0.0;
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Tr.SetIntPoint(&ip);
+      double w = Tr.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
+      MultAAt(dshapedxt, pelmat);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Tr, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            pelmat *= w*vcoeff(k);
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Tr, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            Vector vec_out(mat_out.GetColumn(ii), dof);
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               pelmat *= w*mcoeff(ii,jj);
+               const Vector vec_in(mat_in.GetColumn(jj), dof);
+               pelmat.Mult(vec_in, vec_out);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Tr, ip); }
+         pelmat *= w;
+         for (int k = 0; k < vdim; ++k)
+         {
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+   }
+}
+
+const IntegrationRule &VectorFEDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1719,12 +1856,8 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1744,6 +1877,46 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEWeakDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // The integrand on the reference element is:
+   //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
+   //
+   // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
+   // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
+   // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
+   // - u_hat is in (P_m)^d
+   // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
+   //   n = 2*(d-1)*(k-1)+(l-1)+m
+   //
+   // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
+   // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
+   // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
+   //   with s = (d-1)*k
+   // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
+   // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
+   // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
+   //   n = 2*(d-1)*k+(l-1)+(m-1)
+   //
+   // In the next formula we use the expressions for n with k=1, which means
+   // that the term Q/det(J) is disregarded:
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + 2 * (trial_fe.GetDim() - 2);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1770,37 +1943,8 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // The integrand on the reference element is:
-      //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
-      //
-      // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
-      // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
-      // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
-      // - u_hat is in (P_m)^d
-      // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
-      //   n = 2*(d-1)*(k-1)+(l-1)+m
-      //
-      // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
-      // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
-      // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
-      //   with s = (d-1)*k
-      // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
-      // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
-      // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
-      //   n = 2*(d-1)*k+(l-1)+(m-1)
-      //
-      // In the next formula we use the expressions for n with k=1, which means
-      // that the term Q/det(J) is disregarded:
-      int ir_order = (trial_fe.Space() == FunctionSpace::Pk) ?
-                     (trial_fe.GetOrder() + test_fe.GetOrder() - 1) :
-                     (trial_fe.GetOrder() + test_fe.GetOrder() + 2*(dim-2));
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1826,6 +1970,15 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFECurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFECurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1863,12 +2016,8 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1923,6 +2072,27 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &DerivativeIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim();
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -1944,28 +2114,8 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    invdfdx.SetSize(dim, spaceDim);
    shape.SetSize(test_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
-      }
-      else
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() + dim;
-      }
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1991,10 +2141,26 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+const IntegrationRule &CurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
+   }
+   else
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
+void CurlCurlIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                               ElementTransformation &Trans,
+                                               DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -2009,25 +2175,10 @@ void CurlCurlIntegrator::AssembleElementMatrix(
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
-
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order = 2*el.GetOrder() - 2;
-      }
-      else
-      {
-         order = 2*el.GetOrder();
-      }
-
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2090,20 +2241,8 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
-      }
-      else
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
-      }
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2174,7 +2313,7 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    pointflux.SetSize(dim);
    if (d_energy) { vec.SetSize(dim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule &ir = IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -2265,10 +2404,18 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &VectorCurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // Use the same integration rule as diffusion
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2284,13 +2431,7 @@ void VectorCurlCurlIntegrator::AssembleElementMatrix(
    Jadj.SetSize(dim);
 #endif
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Trans.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat.SetSize(dof*dim);
    elmat = 0.0;
@@ -2332,13 +2473,7 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
 #endif
    DenseMatrix elfun_mat(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Tr.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    double energy = 0.;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2380,6 +2515,15 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
    return 0.5 * energy;
 }
 
+const IntegrationRule &MixedCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedCurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -2415,13 +2559,9 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
 
    double c;
    Vector d_col;
-   const IntegrationRule *ir = IntRule;
 
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2458,6 +2598,15 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEMassIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder();
+   return IntRules.Get(test_fe.GetGeomType(), order);
+}
+
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2483,13 +2632,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    elmat.SetSize(dof);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int order = 2 * el.GetOrder();
-      int order = Trans.OrderW() + 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2517,7 +2660,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q->Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          AddMult_a_AAt(w, trial_vshape, elmat);
       }
@@ -2552,12 +2695,8 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 
       elmat.SetSize(vdim*test_dof, trial_dof);
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
       elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2687,7 +2826,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q->Eval (Trans, ip);
+               w *= Q->Eval(Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2700,6 +2839,15 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -2741,7 +2889,7 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
       c = ip.weight;
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
@@ -2750,12 +2898,13 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+const IntegrationRule &DivDivIntegrator::GetRule(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
-   ElementTransformation &Trans)
+   ElementTransformation &Trans) const
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order = 2 * max(trial_fe.GetOrder(),
+                       test_fe.GetOrder()) - 2; // <--- OK for RTk
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
@@ -2774,12 +2923,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() - 2; // <--- OK for RTk
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2793,7 +2937,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
@@ -2820,13 +2964,8 @@ void DivDivIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd,tr_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * max(test_fe.GetOrder(),
-                          trial_fe.GetOrder()) - 2; // <--- OK for RTk
-      ir = &IntRules.Get(test_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2841,7 +2980,7 @@ void DivDivIntegrator::AssembleElementMatrix2(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       te_divshape *= c;
@@ -2849,176 +2988,13 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 }
 
-void VectorDiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
-{
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Trans.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, sdim);
-
-   elmat.SetSize(vdim * dof);
-   pelmat.SetSize(dof);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elmat = 0.0;
-
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Trans.SetIntPoint(&ip);
-      double w = Trans.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      // AdjugateJacobian = / adj(J),         if J is square
-      //                    \ adj(J^t.J).J^t, otherwise
-      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Trans, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Trans, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
-               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Trans, ip); }
-         Mult_a_AAt(w, dshapedxt, pelmat);
-         for (int k = 0; k < vdim; ++k)
-         {
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-   }
-}
-
-void VectorDiffusionIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+const IntegrationRule &ElasticityIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Tr.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, dim);
-   // pelmat.SetSize(dim);
-
-   elvect.SetSize(dim*dof);
-
-   // NOTE: DenseMatrix is in column-major order. This is consistent with
-   // vectors ordered byNODES. In the resulting DenseMatrix, each column
-   // corresponds to a particular vdim.
-   DenseMatrix mat_in(elfun.GetData(), dof, dim);
-   DenseMatrix mat_out(elvect.GetData(), dof, dim);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elvect = 0.0;
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Tr.SetIntPoint(&ip);
-      double w = Tr.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
-      MultAAt(dshapedxt, pelmat);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Tr, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            pelmat *= w*vcoeff(k);
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Tr, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            Vector vec_out(mat_out.GetColumn(ii), dof);
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               pelmat *= w*mcoeff(ii,jj);
-               const Vector vec_in(mat_in.GetColumn(jj), dof);
-               pelmat.Mult(vec_in, vec_out);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Tr, ip); }
-         pelmat *= w;
-         for (int k = 0; k < vdim; ++k)
-         {
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-   }
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void ElasticityIntegrator::AssembleElementMatrix(
@@ -3042,12 +3018,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat.SetSize(dof * dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&el); // correct order?
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
 
@@ -3210,12 +3181,7 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    // Use the same integration rule as in AssembleElementMatrix, replacing 'el'
    // with 'fluxelem' when 'IntRule' is not set.
    // Should we be using a different (more accurate) rule here?
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&fluxelem);
-      ir = &IntRules.Get(fluxelem.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fluxelem, Trans);
 
    double energy = 0.0;
 
@@ -3275,6 +3241,28 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &DGTraceIntegrator::GetRule(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
+{
+   // Assuming order(u) == order(mesh)
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
+               2 * max(el1.GetOrder(), el2.GetOrder()));
+   }
+   else
+   {
+      order = Trans.Elem1->OrderW() + 2 * el1.GetOrder();
+   }
+   if (el1.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
+}
+
 void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
                                            const FiniteElement &el2,
                                            FaceElementTransformations &Trans,
@@ -3302,24 +3290,7 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    elmat.SetSize(ndof1 + ndof2);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      // Assuming order(u)==order(mesh)
-      if (Trans.Elem2No >= 0)
-         order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
-                  2*max(el1.GetOrder(), el2.GetOrder()));
-      else
-      {
-         order = Trans.Elem1->OrderW() + 2*el1.GetOrder();
-      }
-      if (el1.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -3408,11 +3379,21 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-const IntegrationRule &DGTraceIntegrator::GetRule(
-   Geometry::Type geom, int order, FaceElementTransformations &T)
+const IntegrationRule &DGDiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans)
 {
-   int int_order = T.Elem1->OrderW() + 2*order;
-   return IntRules.Get(geom, int_order);
+   // A simple choice for the integration order; is this OK?
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = 2 * max(el1.GetOrder(), el2.GetOrder());
+   }
+   else
+   {
+      order = 2 * el1.GetOrder();
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void DGDiffusionIntegrator::AssembleFaceMatrix(
@@ -3459,21 +3440,7 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
       jmat = 0.;
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order;
-      if (ndof2)
-      {
-         order = 2*max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    // assemble: < {(Q \nabla u).n},[v] >      --> elmat
    //           kappa < {h^{-1} Q} [u],[v] >  --> jmat
@@ -3749,13 +3716,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
       dshape2_dnM.SetSize(ndofs2);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      const int order = 2 * max(el1.GetOrder(), ndofs2 ? el2.GetOrder() : 0);
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int pind = 0; pind < ir->GetNPoints(); ++pind)
    {
@@ -3872,7 +3833,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-void TraceJumpIntegrator::AssembleFaceMatrix(
+void TraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -3964,7 +3925,7 @@ void TraceJumpIntegrator::AssembleFaceMatrix(
    }
 }
 
-void NormalTraceJumpIntegrator::AssembleFaceMatrix(
+void NormalTraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -4312,11 +4273,11 @@ struct ShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
-                                                  const FiniteElement &ran_fe,
-                                                  ElementTransformation &Trans,
-                                                  DenseMatrix &elmat)
+void ScalarProductInterpolator::AssembleElementMatrix2(
+   const FiniteElement &dom_fe,
+   const FiniteElement &ran_fe,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    internal::ShapeCoefficient dom_shape_coeff(*Q, dom_fe);
 
@@ -4327,8 +4288,7 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarVectorProductInterpolator::AssembleElementMatrix2(
+void ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4361,8 +4321,7 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorScalarProductInterpolator::AssembleElementMatrix2(
+void VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4398,8 +4357,7 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarCrossProductInterpolator::AssembleElementMatrix2(
+void ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4440,8 +4398,7 @@ ScalarCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorCrossProductInterpolator::AssembleElementMatrix2(
+void VectorCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 209898714..a17058029 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -41,10 +41,6 @@ public:
    // TODO: add support for other assembly levels (in addition to PA) and their
    // actions.
 
-   // TODO: for mixed meshes the quadrature rules to be used by methods like
-   // AssemblePA() can be given as a QuadratureSpace, e.g. using a new method:
-   // SetQuadratureSpace().
-
    // TODO: the methods for the various assembly levels make sense even in the
    // base class NonlinearFormIntegrator, except that not all assembly levels
    // make sense for the action of the nonlinear operator (but they all make
@@ -159,11 +155,11 @@ public:
 
    /** Abstract method used for assembling TraceFaceIntegrators in a
        MixedBilinearForm. */
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    /** Abstract method used for assembling TraceFaceIntegrators for
        DPG weak formulations. */
@@ -173,7 +169,6 @@ public:
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 
-
    /// @brief Perform the local action of the BilinearFormIntegrator.
    /// Note that the default implementation in the base class is general but not
    /// efficient.
@@ -282,7 +277,12 @@ public:
    TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -293,7 +293,6 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -362,7 +361,12 @@ public:
    LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -375,57 +379,64 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrator;
-   BilinearFormIntegrator *integrator;
+   bool own_bfi;
+   BilinearFormIntegrator *bfi;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
-   { integrator = integ; own_integrator = own_integ; }
+   InverseIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
+   { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
 
-   virtual ~InverseIntegrator() { if (own_integrator) { delete integrator; } }
+   virtual ~InverseIntegrator() { if (own_bfi) { delete bfi; } }
 };
 
 /// Integrator defining a sum of multiple Integrators.
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrators;
-   mutable DenseMatrix elem_mat;
-   Array<BilinearFormIntegrator*> integrators;
+   bool own_bfis;
+   Array<BilinearFormIntegrator*> bfis;
+   DenseMatrix bfi_elmat;
 
 public:
-   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
+   SumIntegrator(bool own_bfis_ = true) { own_bfis = own_bfis_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   void AddIntegrator(BilinearFormIntegrator *bfi)
+   { bfis.Append(bfi); }
+
+   virtual bool SupportsCeed() const;
 
-   void AddIntegrator(BilinearFormIntegrator *integ)
-   { integrators.Append(integ); }
+   virtual void SetIntRule(const IntegrationRule *ir);
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    virtual void AssemblePA(const FiniteElementSpace &fes);
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
@@ -469,6 +480,11 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -486,39 +502,40 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   Coefficient *Q;
+
    MixedScalarIntegrator() : same_calc_shape(false), Q(NULL) {}
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
+   virtual bool VerifyFiniteElementTypes(
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector test_shape, trial_shape;
@@ -530,6 +547,11 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -547,6 +569,12 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   int space_dim;
+   Coefficient *Q;
+   VectorCoefficient *VQ;
+   DiagonalMatrixCoefficient *DQ;
+   MatrixCoefficient *MQ;
+
    MixedVectorIntegrator()
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(NULL) {}
    MixedVectorIntegrator(Coefficient &q)
@@ -557,47 +585,41 @@ protected:
    MixedVectorIntegrator(MatrixCoefficient &mq)
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
-   int space_dim;
-   Coefficient *Q;
-   VectorCoefficient *VQ;
-   DiagonalMatrixCoefficient *DQ;
-   MatrixCoefficient *MQ;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector V, D;
@@ -611,6 +633,11 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -627,24 +654,28 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
+   VectorCoefficient *VQ;
+   int space_dim;
+   bool transpose;
+   bool cross_2d;  // In 2D use a cross product rather than a dot product
+
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR ) ||
+               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR) ||
               (!transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR )
-             );
+               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR));
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       if (transpose)
       {
@@ -660,35 +691,28 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape_)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape_)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
-   VectorCoefficient *VQ;
-   int space_dim;
-   bool transpose;
-   bool cross_2d;  // In 2D use a cross product rather than a dot product
-
 private:
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
+   Vector V, shape, vshape_tmp;
    DenseMatrix vshape;
-   Vector      shape;
-   Vector      vshape_tmp;
 #endif
 };
 
@@ -723,25 +747,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -758,16 +782,16 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -775,9 +799,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -796,29 +820,29 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -832,15 +856,15 @@ public:
       : MixedScalarVectorIntegrator(vq) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -849,14 +873,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -871,24 +895,24 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
    virtual void CalcTestShape(const FiniteElement &test_fe,
@@ -911,7 +935,7 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -920,21 +944,21 @@ protected:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -968,25 +992,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1026,15 +1050,15 @@ public:
    MixedDotProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1051,16 +1075,16 @@ public:
    MixedWeakGradDotIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1069,14 +1093,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1088,29 +1112,29 @@ public:
    MixedWeakDivCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1128,26 +1152,26 @@ public:
    MixedGradGradIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    {
       // Same as DiffusionIntegrator
       return test_fe.Space() == FunctionSpace::Pk ?
@@ -1155,20 +1179,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1180,37 +1204,37 @@ public:
    MixedCrossGradGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1228,7 +1252,7 @@ public:
    MixedCurlCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1236,30 +1260,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1271,7 +1295,7 @@ public:
    MixedCrossCurlCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1280,30 +1304,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1315,7 +1339,7 @@ public:
    MixedCrossCurlGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1323,30 +1347,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1358,7 +1382,7 @@ public:
    MixedCrossGradCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1366,30 +1390,30 @@ public:
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType()  == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType() == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType() == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1402,29 +1426,29 @@ public:
    MixedWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1437,26 +1461,26 @@ public:
    MixedScalarWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1472,34 +1496,34 @@ public:
    MixedCrossGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1512,29 +1536,29 @@ public:
    MixedCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1547,26 +1571,26 @@ public:
    MixedScalarCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1581,29 +1605,29 @@ public:
    MixedScalarCrossGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1615,16 +1639,16 @@ public:
    MixedScalarCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1640,25 +1664,25 @@ public:
    MixedScalarWeakCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1670,28 +1694,28 @@ public:
    MixedDirectionalDerivativeIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1703,34 +1727,34 @@ public:
    MixedGradDivIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1742,35 +1766,34 @@ public:
    MixedDivGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD
-             );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1782,28 +1805,28 @@ public:
    MixedScalarWeakDivergenceIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1833,31 +1856,32 @@ public:
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
+private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1891,28 +1915,28 @@ public:
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -1951,28 +1975,28 @@ public:
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -2001,27 +2025,27 @@ public:
       : MixedVectorIntegrator(mq) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2063,6 +2087,11 @@ public:
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
    {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2075,10 +2104,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q grad u, grad v) where Q
@@ -2128,6 +2153,18 @@ public:
       : BilinearFormIntegrator(ir),
         Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2175,11 +2212,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2210,6 +2242,19 @@ public:
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans,
+                                               int Q_order = 0);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2243,12 +2288,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2258,7 +2297,10 @@ class BoundaryMassIntegrator : public MassIntegrator
 public:
    BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
 
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -2289,6 +2331,13 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &fes,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2311,11 +2360,6 @@ public:
 
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
-
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 // Alias for @ConvectionIntegrator.
@@ -2349,6 +2393,121 @@ public:
                                       DenseMatrix &);
 };
 
+/** Integrator for
+
+      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
+
+    for vector FE spaces, where e_i is the unit vector in the i-th direction.
+    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
+    where \c vdim is the vector dimension space and \c dof is the local degrees
+    of freedom. The integrator is not aware of the true vector dimension and
+    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
+    value to determine the vector space. For a scalar coefficient, the caller
+    may manually specify the vector dimension or the vector dimension is assumed
+    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
+*/
+class VectorDiffusionIntegrator : public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Q = NULL;
+   VectorCoefficient *VQ = NULL;
+   MatrixCoefficient *MQ = NULL;
+
+   // PA extension
+   const DofToQuad *maps;         ///< Not owned
+   const GeometricFactors *geom;  ///< Not owned
+   int dim, sdim, ne, dofs1D, quad1D;
+   Vector pa_data;
+
+private:
+   DenseMatrix dshape, dshapedxt, pelmat;
+   int vdim = -1;
+   DenseMatrix mcoeff;
+   Vector vcoeff;
+
+public:
+   VectorDiffusionIntegrator() {}
+
+   /** \brief Integrator with unit coefficient for caller-specified vector
+       dimension.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(int vector_dimension)
+      : vdim(vector_dimension) {}
+
+   VectorDiffusionIntegrator(Coefficient &q)
+      : Q(&q) {}
+
+   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
+      : BilinearFormIntegrator(ir), Q(&q) {}
+
+   /** \brief Integrator with scalar coefficient for caller-specified vector
+       dimension.
+
+       The element matrix is block-diagonal with \c vdim copies of the element
+       matrix integrated with the \c Coefficient.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
+      : Q(&q), vdim(vector_dimension) {}
+
+   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Vector.
+
+       The element matrix is block-diagonal and each block is integrated with
+       coefficient q_i.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(VectorCoefficient &vq)
+      : VQ(&vq), vdim(vq.GetVDim()) {}
+
+   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Matrix.
+
+       The element matrix is populated in each block. Each block is integrated
+       with coefficient q_ij.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(MatrixCoefficient& mq)
+      : MQ(&mq), vdim(mq.GetVDim()) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return DiffusionIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   virtual void AssembleElementMatrix(const FiniteElement &el,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
+
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+};
+
 /** Class for integrating the bilinear form a(u,v) := (Q u, v),
     where u=(u1,...,un) and v=(v1,...,vn); ui and vi are defined
     by scalar FE through standard transformation. */
@@ -2394,6 +2553,14 @@ public:
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans, Q_order); }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2416,8 +2583,6 @@ public:
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 /** Class for integrating (div u, p) where u is a vector field given by
@@ -2430,14 +2595,14 @@ public:
     ElementTransformation Trans. */
 class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
 #endif
 
+protected:
+   Coefficient *Q;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *mapsO;         ///< Not owned. DOF-to-quad map, open.
@@ -2449,9 +2614,10 @@ public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2473,9 +2639,6 @@ public:
     This is equivalent to a weak divergence of the Nedelec basis functions. */
 class VectorFEWeakDivergenceIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix dshape;
@@ -2484,13 +2647,17 @@ private:
    DenseMatrix invdfdx;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2502,9 +2669,6 @@ public:
     test spaces are switched, assembles the form (u, curl v). */
 class VectorFECurlIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix curlshapeTrial;
@@ -2512,13 +2676,17 @@ private:
    DenseMatrix curlshapeTrial_dFT;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2540,6 +2708,11 @@ private:
 public:
    DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
@@ -2587,6 +2760,11 @@ public:
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2632,13 +2810,18 @@ protected:
 
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
-
    VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /// Compute element energy: (1/2) (curl u, curl u)_E
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Tr,
@@ -2663,11 +2846,17 @@ private:
    DenseMatrix dshape;
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
+
 public:
    MixedCurlIntegrator() : Q{NULL} {}
    MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
    MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2681,9 +2870,6 @@ public:
 class VectorFEMassIntegrator: public BilinearFormIntegrator
 {
 private:
-   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
-   { Q = q; DQ = dq; MQ = mq; }
-
 #ifndef MFEM_THREAD_SAFE
    Vector shape;
    Vector D;
@@ -2693,6 +2879,9 @@ private:
    DenseMatrix trial_vshape;
 #endif
 
+   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
+   { Q = q; DQ = dq; MQ = mq; }
+
 protected:
    Coefficient *Q;
    DiagonalMatrixCoefficient *DQ;
@@ -2717,6 +2906,11 @@ public:
    VectorFEMassIntegrator(MatrixCoefficient *mq_) { Init(NULL, NULL, mq_); }
    VectorFEMassIntegrator(MatrixCoefficient &mq) { Init(NULL, NULL, &mq); }
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2762,14 +2956,16 @@ private:
 
 public:
    VectorDivergenceIntegrator() :
-      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {  }
+      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient *q_) :
-      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient &q) :
-      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2783,10 +2979,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /// (Q div u, div v) for RT elements
@@ -2812,6 +3004,11 @@ public:
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(&q) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2831,115 +3028,6 @@ public:
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
-/** Integrator for
-
-      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
-
-    for vector FE spaces, where e_i is the unit vector in the i-th direction.
-    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
-    where \c vdim is the vector dimension space and \c dof is the local degrees
-    of freedom. The integrator is not aware of the true vector dimension and
-    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
-    value to determine the vector space. For a scalar coefficient, the caller
-    may manually specify the vector dimension or the vector dimension is assumed
-    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
-*/
-class VectorDiffusionIntegrator : public BilinearFormIntegrator
-{
-protected:
-   Coefficient *Q = NULL;
-   VectorCoefficient *VQ = NULL;
-   MatrixCoefficient *MQ = NULL;
-
-   // PA extension
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
-   int dim, sdim, ne, dofs1D, quad1D;
-   Vector pa_data;
-
-private:
-   DenseMatrix dshape, dshapedxt, pelmat;
-   int vdim = -1;
-   DenseMatrix mcoeff;
-   Vector vcoeff;
-
-public:
-   VectorDiffusionIntegrator() {}
-
-   /** \brief Integrator with unit coefficient for caller-specified vector
-       dimension.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) {}
-
-   VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) {}
-
-   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) {}
-
-   /** \brief Integrator with scalar coefficient for caller-specified vector
-       dimension.
-
-       The element matrix is block-diagonal with \c vdim copies of the element
-       matrix integrated with the \c Coefficient.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) {}
-
-   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Vector.
-
-       The element matrix is block-diagonal and each block is integrated with
-       coefficient q_i.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) {}
-
-   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Matrix.
-
-       The element matrix is populated in each block. Each block is integrated
-       with coefficient q_ij.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) {}
-
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat);
-
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
-
-   virtual void AssembleDiagonalPA(Vector &diag);
-
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-
-   using BilinearFormIntegrator::AssembleMF;
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
-   virtual void AssembleDiagonalMF(Vector &diag);
-
-   virtual void AddMultMF(const Vector &x, Vector &y) const;
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-};
-
 /** Integrator for the linear elasticity form:
     a(u,v) = (lambda div(u), div(v)) + (2 mu e(u), e(v)),
     where e(v) = (1/2) (grad(v) + grad(v)^T).
@@ -2966,6 +3054,11 @@ public:
    ElasticityIntegrator(Coefficient &m, double q_l, double q_m)
    { lambda = NULL; mu = &m; q_lambda = q_l; q_mu = q_m; }
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -3054,7 +3147,11 @@ public:
                      double a, double b)
    { rho = &rho_; u = &u_; alpha = a; beta = b; }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3075,9 +3172,6 @@ public:
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_bdr);
 
-   static const IntegrationRule &GetRule(Geometry::Type geom, int order,
-                                         FaceElementTransformations &T);
-
 private:
    void SetupPA(const FiniteElementSpace &fes, FaceType type);
 };
@@ -3137,7 +3231,16 @@ public:
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
       : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &el1,
+                                               const FiniteElement &el2,
+                                               FaceElementTransformations &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3197,7 +3300,12 @@ public:
    MFEM_DEPRECATED DGDiffusionBR2Integrator(class FiniteElementSpace *fes,
                                             double e = 1.0);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3274,7 +3382,12 @@ public:
                           double alpha_, double kappa_)
       : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3325,12 +3438,11 @@ private:
 public:
    TraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, [w.n] > over all faces (the interface) where
@@ -3345,12 +3457,11 @@ private:
 public:
    NormalTraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the DPG form: < v, w > over a face (the interface) where
@@ -3361,13 +3472,15 @@ class TraceIntegrator : public BilinearFormIntegrator
 {
 private:
    Vector face_shape, shape;
+
 public:
-   TraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, w.n > over a face (the interface) where
@@ -3380,15 +3493,15 @@ private:
    DenseMatrix shape;
 
 public:
-   NormalTraceIntegrator() { }
-   virtual void AssembleTraceFaceMatrix(int ielem,
+   NormalTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
                                         const FiniteElement &trial_face_fe,
                                         const FiniteElement &test_fe,
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 };
 
-
 /** Integrator for the form: < v, w × n > over a face (the interface)
  *  In 3D the trial variable v is defined on the interface (H^-1/2(curl), trace of H(curl))
  *  In 2D it's defined on the interface (H^1/2, trace of H1)
@@ -3426,12 +3539,13 @@ private:
    }
 
 public:
-   TangentTraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TangentTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Abstract class to serve as a base for local interpolators to be used in the
@@ -3469,7 +3583,6 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    bool B_id; // is the B basis operator (maps_C_C) the identity?
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
@@ -3482,7 +3595,7 @@ private:
 class IdentityInterpolator : public DiscreteInterpolator
 {
 public:
-   IdentityInterpolator(): dofquad_fe(NULL) { }
+   IdentityInterpolator(): dofquad_fe(NULL) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3503,11 +3616,9 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
    int dim, ne, o_dofs1D, c_dofs1D;
-
    Vector pa_data;
 };
 
@@ -3577,8 +3688,7 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient &sc)
-      : Q(&sc) {}
+   ScalarVectorProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3595,8 +3705,7 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorScalarProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3630,8 +3739,7 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorCrossProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
diff --git a/fem/ceed/interface/mixed_integrator.hpp b/fem/ceed/interface/mixed_integrator.hpp
index 8d344f4d9..4e238bde3 100644
--- a/fem/ceed/interface/mixed_integrator.hpp
+++ b/fem/ceed/interface/mixed_integrator.hpp
@@ -96,7 +96,7 @@ public:
          MFEM_ASSERT(!integ.GetIntegrationRule(),
                      "Mixed mesh integrators should not have an"
                      " IntegrationRule.");
-         const IntegrationRule &ir = GetRule(integ, el, el, T);
+         const IntegrationRule &ir = integ.GetRule(el, el, T);
          auto sub_op = new CeedInteg();
          int nelem = *count[value.first];
          sub_op->Assemble(info, fes, ir, nelem, indices, Q);
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index b65fd2197..882ba9399 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -190,66 +190,6 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    return 0;
 }
 
-template <>
-const IntegrationRule & GetRule<MassIntegrator>(
-   const MassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorMassIntegrator>(
-   const VectorMassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<ConvectionIntegrator>(
-   const ConvectionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return ConvectionIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorConvectionNLFIntegrator>(
-   const VectorConvectionNLFIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return VectorConvectionNLFIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<DiffusionIntegrator>(
-   const DiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorDiffusionIntegrator>(
-   const VectorDiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
 std::string ceed_path;
 
 const std::string &GetCeedPath()
diff --git a/fem/ceed/interface/util.hpp b/fem/ceed/interface/util.hpp
index 674186a87..6d1cc3c68 100644
--- a/fem/ceed/interface/util.hpp
+++ b/fem/ceed/interface/util.hpp
@@ -94,14 +94,6 @@ void InitBasisAndRestriction(const FiniteElementSpace &fes,
 
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field);
 
-
-template <typename Integrator>
-const IntegrationRule & GetRule(
-   const Integrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &Trans);
-
 /// Return the path to the libCEED q-function headers.
 const std::string &GetCeedPath();
 
diff --git a/fem/hybridization.cpp b/fem/hybridization.cpp
index 10ba8b907..7e4697604 100644
--- a/fem/hybridization.cpp
+++ b/fem/hybridization.cpp
@@ -120,10 +120,10 @@ void Hybridization::ConstructC()
             vdofs[s1+j] = o2 + j;
          }
          c_fes->GetFaceVDofs(i, c_vdofs);
-         c_bfi->AssembleFaceMatrix(*c_fes->GetFaceElement(i),
-                                   *fes->GetFE(FTr->Elem1No),
-                                   *fes->GetFE(FTr->Elem2No),
-                                   *FTr, elmat);
+         c_bfi->AssembleFaceMatrix2(*c_fes->GetFaceElement(i),
+                                    *fes->GetFE(FTr->Elem1No),
+                                    *fes->GetFE(FTr->Elem2No),
+                                    *FTr, elmat);
          // zero-out small elements in elmat
          elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
          Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
@@ -165,7 +165,7 @@ void Hybridization::ConstructC()
                vdofs[j] = o1 + j;
             }
             fe = fes->GetFE(FTr->Elem1No);
-            c_bfi->AssembleFaceMatrix(*face_fe, *fe, *fe, *FTr, elmat);
+            c_bfi->AssembleFaceMatrix2(*face_fe, *fe, *fe, *FTr, elmat);
             // zero-out small elements in elmat
             elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
             Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
diff --git a/fem/integ/bilininteg_br2.cpp b/fem/integ/bilininteg_br2.cpp
index 159947029..846d72c7c 100644
--- a/fem/integ/bilininteg_br2.cpp
+++ b/fem/integ/bilininteg_br2.cpp
@@ -152,20 +152,7 @@ void DGDiffusionBR2Integrator::AssembleFaceMatrix(
    elmat.SetSize(ndofs);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (ndof2)
-      {
-         order = 2*std::max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.FaceGeom, order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 25928f002..66d2c9466 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -119,8 +119,8 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
    const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+   ElementTransformation &T = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
index 68914fe14..ef61b92d3 100644
--- a/fem/integ/bilininteg_curlcurl_pa.cpp
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -24,11 +24,8 @@ void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
-                                                     *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
 
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index f4b8d837c..284191c13 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -123,9 +123,7 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       *fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0));
    FaceElementTransformations &T0 =
       *fes.GetMesh()->GetFaceElementTransformations(0);
-   const IntegrationRule *ir = IntRule?
-                               IntRule:
-                               &GetRule(el.GetGeomType(), el.GetOrder(), T0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fes.GetFE(0), T0);
    const int symmDims = 4;
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 0896b8bf9..db91bfde3 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -22,7 +22,8 @@ void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index a966c8520..be306f17f 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -26,7 +26,8 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
index aee788e55..300117e60 100644
--- a/fem/integ/bilininteg_divdiv_pa.cpp
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -26,10 +26,8 @@ void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
-                               (*el, *el, *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
 
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 20ef4684d..cb37e981a 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -167,9 +167,8 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index b1e98f682..61f91ab68 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -22,8 +22,8 @@ void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index ea52b6953..d3feea5ca 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -28,8 +28,8 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T0 = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+   ElementTransformation &T =* mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
@@ -122,8 +122,7 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
    if (mesh->GetNBE() == 0) { return; }
    const FiniteElement &el = *fes.GetBE(0);
    ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
-
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, *T0);
    int map_type = el.GetMapType();
    dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
    ne = fes.GetMesh()->GetNBE();
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index a3c113982..62f9fc261 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -35,9 +35,8 @@ void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_ABORT("Unknown kernel.");
    }
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fel, *eltest, T);
 
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2, "");
@@ -123,9 +122,10 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
@@ -282,9 +282,10 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index f9e6d3ee8..59ae9bc5f 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -18,6 +18,68 @@
 namespace mfem
 {
 
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   // Use the same setup functions as VectorFEMassIntegrator.
+   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                      coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
 // Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
 // integrated against H(curl) test functions corresponding to y.
 static void PAHcurlH1Apply2D(const int D1D,
@@ -656,67 +718,6 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(
-   const FiniteElementSpace &trial_fes,
-   const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   // Use the same setup functions as VectorFEMassIntegrator.
-   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
-   {
-      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                   coeff, pa_data);
-   }
-   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
-   {
-      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                      coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
 void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (dim == 3)
diff --git a/fem/integ/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
index 150b662f1..d46a1a27b 100644
--- a/fem/integ/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -22,8 +22,8 @@ void VectorDiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 84e4d5b2a..c21a949b2 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -117,8 +117,8 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
    const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index 63f7a3308..cf58df9ea 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -105,9 +105,8 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
index d71f05808..ad271f1fa 100644
--- a/fem/integ/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -22,9 +22,8 @@ void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index b1c20b4c4..c796afbd5 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -23,9 +23,8 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
diff --git a/fem/integ/bilininteg_vectorfediv_pa.cpp b/fem/integ/bilininteg_vectorfediv_pa.cpp
index 97843a576..0e56e4f2b 100644
--- a/fem/integ/bilininteg_vectorfediv_pa.cpp
+++ b/fem/integ/bilininteg_vectorfediv_pa.cpp
@@ -35,9 +35,9 @@ VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
-                                  *trial_el, *trial_el,
-                                  *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
 
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index c07e9f816..90d0cd8c6 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -35,10 +35,9 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    const VectorTensorFiniteElement *test_el =
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *trial_el,
+                                                            T);
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
 
diff --git a/fem/integ/lininteg_boundary.cpp b/fem/integ/lininteg_boundary.cpp
index 9b785335c..92f1ff8a5 100644
--- a/fem/integ/lininteg_boundary.cpp
+++ b/fem/integ/lininteg_boundary.cpp
@@ -214,30 +214,28 @@ void BoundaryLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, false, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, false, b);
 }
 
 void BoundaryNormalLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, true, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, true, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index b9f047817..a6e422b94 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -166,15 +166,14 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleDevice(
    const Array<int> &markers,
    Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(F, qs, CoefficientStorage::COMPRESSED);
-   BFLFEvalAssemble(fes, ir, markers, coeff, b);
+   BFLFEvalAssemble(fes, *ir, markers, coeff, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_domain.cpp b/fem/integ/lininteg_domain.cpp
index 6ff7b090d..438da4df2 100644
--- a/fem/integ/lininteg_domain.cpp
+++ b/fem/integ/lininteg_domain.cpp
@@ -242,10 +242,10 @@ void DomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                         const Array<int> &markers,
                                         Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -256,10 +256,10 @@ void VectorDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                               const Array<int> &markers,
                                               Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 5cca01a1d..735ea56c4 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -321,11 +321,10 @@ void DomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                             const Array<int> &markers,
                                             Vector &b)
 {
-
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -336,10 +335,10 @@ void VectorDomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                   const Array<int> &markers,
                                                   Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_vectorfe.cpp b/fem/integ/lininteg_domain_vectorfe.cpp
index 16d9e866c..0765d58bc 100644
--- a/fem/integ/lininteg_domain_vectorfe.cpp
+++ b/fem/integ/lininteg_domain_vectorfe.cpp
@@ -325,10 +325,10 @@ void VectorFEDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(QF, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/lininteg.cpp b/fem/lininteg.cpp
index c9b6b4699..25e7c2823 100644
--- a/fem/lininteg.cpp
+++ b/fem/lininteg.cpp
@@ -15,6 +15,22 @@
 namespace mfem
 {
 
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
+}
+
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(Tr.GetGeometryType(), oa * el.GetOrder() + ob);
+}
+
 void LinearFormIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
@@ -41,17 +57,11 @@ void DomainLFIntegrator::AssembleRHSElementVect(const FiniteElement &el,
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // ir = &IntRules.Get(el.GetGeomType(),
-      //                    oa * el.GetOrder() + ob + Tr.OrderW());
-      ir = &IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -86,12 +96,7 @@ void DomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -128,16 +133,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -157,16 +157,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;    // <------ user control
-      ir = &IntRules.Get(Tr.FaceGeom, intorder); // of integration order
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -197,12 +192,7 @@ void BoundaryNormalLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -241,12 +231,7 @@ void BoundaryTangentialLFIntegrator::AssembleRHSElementVect(
       mfem_error("These methods make sense only in 2D problems.");
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -273,17 +258,12 @@ void VectorDomainLFIntegrator::AssembleRHSElementVect(
 
    double val,cf;
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
 
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -337,12 +317,7 @@ void VectorDomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof*(vdim/sdim));
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    Vector pelvect(dof);
    Vector part_x(dim);
@@ -384,12 +359,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -419,12 +389,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -463,13 +428,8 @@ void VectorFEDomainLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int intorder = 2*el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   // Previously: 2 * el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -512,12 +472,7 @@ void VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -554,16 +509,11 @@ void VectorFEDomainLFDivIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   divshape.SetSize(dof);       // vector of size dof
+   divshape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -596,11 +546,7 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    nor.SetSize (dim);
    elvect.SetSize (dim*dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &IntRules.Get(el.GetGeomType(), el.GetOrder() + 1);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, 1, 1);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -618,7 +564,6 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
 void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -628,12 +573,7 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -667,12 +607,7 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -707,6 +642,20 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &BoundaryFlowIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   // Assuming order(u) == order(mesh)
+   int order = 2 * el.GetOrder() + Tr.Elem1->OrderW();
+   if (el.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Tr.GetGeometryType(), order);
+}
+
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -719,24 +668,14 @@ void BoundaryFlowIntegrator::AssembleRHSElementVect(
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, FaceElementTransformations &Tr, Vector &elvect)
 {
-   int dim, ndof, order;
+   int dim, ndof;
    double un, w, vu_data[3], nor_data[3];
 
    dim  = el.GetDim();
    ndof = el.GetDof();
    Vector vu(vu_data, dim), nor(nor_data, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // Assuming order(u)==order(mesh)
-      order = Tr.Elem1->OrderW() + 2*el.GetOrder();
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    shape.SetSize(ndof);
    elvect.SetSize(ndof);
@@ -805,13 +744,7 @@ void DGDirichletLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(ndof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -902,12 +835,7 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    dshape_du.SetSize(ndofs);
    u_dir.SetSize(dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      const int order = 2*el.GetOrder(); // <-----
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int pi = 0; pi < ir->GetNPoints(); ++pi)
    {
@@ -1000,12 +928,10 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
-
-void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
-(const FiniteElement &el,
- ElementTransformation &Tr,
- Vector &elvect)
+void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   Vector &elvect)
 {
    int n = el.GetDof();
    elvect.SetSize(n);
@@ -1040,13 +966,18 @@ void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
    }
 }
 
+const IntegrationRule &VectorQuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &fe, ElementTransformation &Tr, Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int vdim = vqfc.GetVDim();
    const int ndofs = fe.GetDof();
@@ -1071,14 +1002,19 @@ void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &QuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void QuadratureLFIntegrator::AssembleRHSElementVect(const FiniteElement &fe,
                                                     ElementTransformation &Tr,
                                                     Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int ndofs = fe.GetDof();
    Vector shape(ndofs);
diff --git a/fem/lininteg.hpp b/fem/lininteg.hpp
index 02fde00c9..5bcdfdb83 100644
--- a/fem/lininteg.hpp
+++ b/fem/lininteg.hpp
@@ -29,10 +29,20 @@ protected:
    LinearFormIntegrator(const IntegrationRule *ir = NULL) { IntRule = ir; }
 
 public:
-
    /// Method probing for assembly on device
    virtual bool SupportsDevice() const { return false; }
 
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+
+   const IntegrationRule *GetIntRule() { return IntRule; }
+
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    /// Method defining assembly on device
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
@@ -51,13 +61,9 @@ public:
                                        FaceElementTransformations &Tr,
                                        Vector &elvect);
 
-   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-   const IntegrationRule* GetIntRule() { return IntRule; }
-
-   virtual ~LinearFormIntegrator() { }
+   virtual ~LinearFormIntegrator() {}
 };
 
-
 /// Abstract class for integrators that support delta coefficients
 class DeltaLFIntegrator : public LinearFormIntegrator
 {
@@ -70,7 +76,7 @@ protected:
    DeltaLFIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(dynamic_cast<DeltaCoefficient*>(&q)),
-        vec_delta(NULL) { }
+        vec_delta(NULL) {}
 
    /** @brief This constructor should be used by derived classes that use a
        VectorDeltaCoefficient. */
@@ -78,7 +84,7 @@ protected:
                      const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(NULL),
-        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) { }
+        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) {}
 
 public:
    /// Returns true if the derived class instance uses a delta coefficient.
@@ -103,23 +109,23 @@ public:
                                          Vector &elvect) = 0;
 };
 
-
 /// Class for domain integration L(v) := (f, v)
 class DomainLFIntegrator : public DeltaLFIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a domain integrator with a given Coefficient
+   /// the old default was a = 1, b = 1
+   /// for simple elliptic problems a = 2, b = -2 is OK
    DomainLFIntegrator(Coefficient &QF, int a = 2, int b = 0)
-   // the old default was a = 1, b = 1
-   // for simple elliptic problems a = 2, b = -2 is OK
-      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) { }
+      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) {}
 
    /// Constructs a domain integrator with a given Coefficient
    DomainLFIntegrator(Coefficient &QF, const IntegrationRule *ir)
-      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) { }
+      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -152,7 +158,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    DomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -174,18 +180,18 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /// Class for boundary integration L(v) := (g, v)
 class BoundaryLFIntegrator : public LinearFormIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /** @brief Constructs a boundary integrator with a given Coefficient @a QG.
        Integration order will be @a a * basis_order + @a b. */
    BoundaryLFIntegrator(Coefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -212,10 +218,11 @@ class BoundaryNormalLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryNormalLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -237,10 +244,11 @@ class BoundaryTangentialLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryTangentialLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -260,7 +268,7 @@ private:
 public:
    /// Constructs a domain integrator with a given VectorCoefficient
    VectorDomainLFIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -294,7 +302,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    VectorDomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const override { return true; }
 
@@ -326,7 +334,7 @@ private:
 
 public:
    /// Constructs a boundary integrator with a given VectorCoefficient QG
-   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) { }
+   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) {}
 
    /** Given a particular boundary Finite Element and a transformation (Tr)
        computes the element boundary vector, elvect. */
@@ -352,7 +360,9 @@ private:
 
 public:
    VectorFEDomainLFIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(F) { }
+      : DeltaLFIntegrator(F), QF(F) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -362,8 +372,6 @@ public:
                                          ElementTransformation &Trans,
                                          Vector &elvect);
 
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
@@ -382,7 +390,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, curl v)
    VectorFEDomainLFCurlIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(&F) { }
+      : DeltaLFIntegrator(F), QF(&F) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -401,10 +409,11 @@ class VectorFEDomainLFDivIntegrator : public DeltaLFIntegrator
 private:
    Vector divshape;
    Coefficient &Q;
+
 public:
    /// Constructs the domain integrator (Q, div v)
    VectorFEDomainLFDivIntegrator(Coefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    /** Given a particular Finite Element and a transformation (Tr)
        computes the element right hand side element vector, elvect. */
@@ -432,7 +441,7 @@ private:
 public:
    VectorBoundaryFluxLFIntegrator(Coefficient &f, double s = 1.0,
                                   const IntegrationRule *ir = NULL)
-      : LinearFormIntegrator(ir), Sign(s), F(&f) { }
+      : LinearFormIntegrator(ir), Sign(s), F(&f) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -453,21 +462,21 @@ private:
 
 public:
    VectorFEBoundaryFluxLFIntegrator(int a = 1, int b = -1)
-      : F(NULL), oa(a), ob(b) { }
+      : F(NULL), oa(a), ob(b) {}
    VectorFEBoundaryFluxLFIntegrator(Coefficient &f, int a = 2, int b = 0)
-      : F(&f), oa(a), ob(b) { }
+      : F(&f), oa(a), ob(b) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 /// Class for boundary integration \f$ L(v) = (n \times f, v) \f$
@@ -480,7 +489,7 @@ private:
 public:
    VectorFEBoundaryTangentLFIntegrator(VectorCoefficient &QG,
                                        int a = 2, int b = 0)
-      : f(QG), oa(a), ob(b) { }
+      : f(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -489,7 +498,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for boundary integration of the linear form:
     (alpha/2) < (u.n) f, w > - beta < |u.n| f, w >,
     where f and u are given scalar and vector coefficients, respectively,
@@ -512,6 +520,11 @@ public:
                           double a, double b)
    { f = &f_; u = &u_; alpha = a; beta = b; }
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -522,7 +535,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear integrator for imposing non-zero Dirichlet boundary
     conditions, to be used in conjunction with DGDiffusionIntegrator.
     Specifically, given the Dirichlet data u_D, the linear form assembles the
@@ -546,13 +558,13 @@ protected:
 
 public:
    DGDirichletLFIntegrator(Coefficient &u, const double s, const double k)
-      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, Coefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, MatrixCoefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -564,7 +576,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear form integrator for imposing non-zero Dirichlet boundary
     conditions, in a DG elasticity formulation. Specifically, the linear form is
     given by
@@ -597,7 +608,7 @@ public:
    DGElasticityDirichletLFIntegrator(VectorCoefficient &uD_,
                                      Coefficient &lambda_, Coefficient &mu_,
                                      double alpha_, double kappa_)
-      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -609,7 +620,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for spatial white Gaussian noise integration.
 
     The target problem is the linear SPDE a(u,v) = F(v) with F(v) := <Ẇ,v>,
@@ -637,8 +647,8 @@ class WhiteGaussianNoiseDomainLFIntegrator : public LinearFormIntegrator
    std::normal_distribution<double> dist;
 
    bool save_factors = false;
-public:
 
+public:
 #ifdef MFEM_USE_MPI
    /** @brief Sets the @a seed_ of the random number generator. A fixed seed
        allows for a reproducible sequence of white noise vectors. */
@@ -669,13 +679,13 @@ public:
       if (seed_ > 0) { SetSeed(seed_); }
    }
 #endif
+
    /// @brief Sets/resets the @a seed of the random number generator.
    void SetSeed(int seed)
    {
       generator.seed(seed);
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -715,8 +725,9 @@ public:
       }
       L.DeleteAll();
    }
-};
 
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration of L(v) := (f, v), where
     f=(f1,...,fn) and v=(v1,...,vn). that makes use of
@@ -738,18 +749,23 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
-};
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration L(v) := (f, v) that makes use
     of QuadratureFunctionCoefficient. */
@@ -770,19 +786,24 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
+
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 }
 
-
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index 5ee1febea..a704ee207 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,26 +15,44 @@
 namespace mfem
 {
 
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector&,
+                                             const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
               "   is not implemented for this class.");
@@ -46,119 +64,141 @@ void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
               "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+double NonlinearFormIntegrator::GetElementEnergy(const FiniteElement&,
+                                                 ElementTransformation&,
+                                                 const Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy(...)"
+              "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleElementVector(const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    const Vector&,
+                                                    Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceVector(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleFaceVector(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 const Vector&,
+                                                 Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleElementGrad(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleElementGrad(const FiniteElement&,
+                                                  ElementTransformation&,
+                                                  const Vector&,
+                                                  DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceGrad(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleFaceGrad(const FiniteElement&,
+                                               const FiniteElement&,
+                                               FaceElementTransformations&,
+                                               const Vector&,
+                                               DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&test_fe,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
 
-void BlockNonlinearFormIntegrator::AssembleElementVector(
-   const Array<const FiniteElement *> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvec)
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceVector(
-   const Array<const FiniteElement *> &el1,
-   const Array<const FiniteElement *> &el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvect)
+double BlockNonlinearFormIntegrator::GetElementEnergy(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
-void BlockNonlinearFormIntegrator::AssembleElementGrad(
-   const Array<const FiniteElement*> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleElementVector(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceGrad(
-   const Array<const FiniteElement *>&el1,
-   const Array<const FiniteElement *>&el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleFaceVector(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-double BlockNonlinearFormIntegrator::GetElementEnergy(
-   const Array<const FiniteElement *>&el,
-   ElementTransformation &Tr,
-   const Array<const Vector *>&elfun)
+void BlockNonlinearFormIntegrator::AssembleElementGrad(
+   const Array<const FiniteElement*>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+void BlockNonlinearFormIntegrator::AssembleFaceGrad(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
+}
 
 double InverseHarmonicModel::EvalW(const DenseMatrix &J) const
 {
@@ -260,7 +300,6 @@ void InverseHarmonicModel::AssembleH(
       }
 }
 
-
 inline void NeoHookeanModel::EvalCoeffs() const
 {
    mu = c_mu->Eval(*Ttr, Ttr->GetIntPoint());
@@ -376,6 +415,13 @@ void NeoHookeanModel::AssembleH(const DenseMatrix &J, const DenseMatrix &DS,
             }
 }
 
+const IntegrationRule &HyperelasticNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
                                                    ElementTransformation &Ttr,
@@ -390,11 +436,7 @@ double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
    Jpt.SetSize(dim);
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    energy = 0.0;
    model->SetTransformation(Ttr);
@@ -429,11 +471,7 @@ void HyperelasticNLFIntegrator::AssembleElementVector(
    elvect.SetSize(dof*dim);
    PMatO.UseExternalData(elvect.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elvect = 0.0;
    model->SetTransformation(Ttr);
@@ -468,11 +506,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
    elmat.SetSize(dof*dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elmat = 0.0;
    model->SetTransformation(Ttr);
@@ -490,6 +524,13 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+const IntegrationRule &IncompressibleNeoHookeanIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
@@ -511,15 +552,14 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    J.SetSize(dim);
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    double energy = 0.0;
    double mu = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -572,15 +612,14 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
    Sh_p.SetSize(dof_p);
    elvec[1]->SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    *elvec[0] = 0.0;
    *elvec[1] = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -605,7 +644,6 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
       elvec[1]->Add(ip.weight * Tr.Weight() * (dJ - 1.0), Sh_p);
    }
-
 }
 
 void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
@@ -639,12 +677,11 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
    Sh_p.SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -721,16 +758,15 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
          }
       }
    }
-
 }
 
-
-const IntegrationRule&
-VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
-                                       ElementTransformation &T)
+const IntegrationRule &VectorConvectionNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int order = 2 * fe.GetOrder() + T.OrderGrad(&fe);
-   return IntRules.Get(fe.GetGeomType(), order);
+   int order = Trans.OrderGrad(&trial_fe) + trial_fe.GetOrder() +
+               test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void VectorConvectionNLFIntegrator::AssembleElementVector(
@@ -751,7 +787,9 @@ void VectorConvectionNLFIntegrator::AssembleElementVector(
    ELV.UseExternalData(elvect.GetData(), nd, dim);
 
    Vector vec1(dim), vec2(dim);
+
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+
    ELV = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -841,7 +879,6 @@ void VectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
@@ -890,7 +927,6 @@ void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 38b133244..4c2ee2470 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -17,6 +17,7 @@
 #include "coefficient.hpp"
 #include "fespace.hpp"
 #include "ceed/interface/operator.hpp"
+#include "ceed/interface/util.hpp"
 
 namespace mfem
 {
@@ -37,23 +38,43 @@ protected:
       : IntRule(ir), ceedOp(NULL) {}
 
 public:
+   /// Set the memory type used for GeometricFactors and other large allocations
+   /// in PA extensions.
+   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   /// Access the underlying ceed::Operator for libCEED backends, after the
+   /// integrator has been assembled.
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
+
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
        let the integrator choose (when @a ir == NULL). */
    virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-
-   /// Prescribe a fixed IntegrationRule to use.
    void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
 
-   /// Set the memory type used for GeometricFactors and other large allocations
-   /// in PA extensions.
-   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
-
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA(). */
+       used later in the methods AddMultPA() and AddMultTransposePA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
    /** @brief Prepare the integrator for partial assembly (PA) gradient
@@ -132,11 +153,6 @@ public:
                                  FaceElementTransformations &Tr,
                                  const Vector &elfun, DenseMatrix &elmat);
 
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
-
-   ceed::Operator &GetCeedOp() { return *ceedOp; }
-
    virtual ~NonlinearFormIntegrator()
    {
       delete ceedOp;
@@ -149,7 +165,36 @@ public:
     for block state vectors. */
 class BlockNonlinearFormIntegrator
 {
+protected:
+   const IntegrationRule *IntRule;
+
+   BlockNonlinearFormIntegrator(const IntegrationRule *ir = NULL)
+      : IntRule(ir) {}
+
 public:
+   /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
+       let the integrator choose (when @a ir == NULL). */
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+   void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
+
+   /// Get the integration rule of the integrator (possibly NULL).
+   const IntegrationRule *GetIntegrationRule() const { return IntRule; }
+
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Tr) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Tr) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Compute the local energy
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -182,8 +227,7 @@ public:
    virtual ~BlockNonlinearFormIntegrator() {}
 };
 
-
-/// Abstract class for hyperelastic models
+/// Abstract base class for hyperelastic models
 class HyperelasticModel
 {
 protected:
@@ -228,7 +272,6 @@ public:
                           const double weight, DenseMatrix &A) const = 0;
 };
 
-
 /** Inverse-harmonic hyperelastic model with a strain energy density function
     given by the formula: W(J) = (1/2) det(J) Tr((J J^t)^{-1}) where J is the
     deformation gradient. */
@@ -247,7 +290,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Neo-Hookean hyperelastic model with a strain energy density function given
     by the formula: \f$(\mu/2)(\bar{I}_1 - dim) + (K/2)(det(J)/g - 1)^2\f$ where
     J is the deformation gradient and \f$\bar{I}_1 = (det(J))^{-2/dim} Tr(J
@@ -281,7 +323,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Hyperelastic integrator for any given HyperelasticModel.
 
     Represents @f$ \int W(Jpt) dx @f$ over a target zone, where W is the
@@ -310,10 +351,11 @@ public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
    HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
-   /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
-       @param[in] el     Type of FiniteElement.
-       @param[in] Ttr    Represents ref->target coordinates transformation.
-       @param[in] elfun  Physical coordinates of the zone. */
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Ttr,
                                    const Vector &elfun);
@@ -342,24 +384,26 @@ private:
 public:
    IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
+   using BlockNonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
                                    const Array<const Vector *> &elfun);
 
-   /// Perform the local action of the NonlinearFormIntegrator
    virtual void AssembleElementVector(const Array<const FiniteElement *> &el,
                                       ElementTransformation &Tr,
                                       const Array<const Vector *> &elfun,
                                       const Array<Vector *> &elvec);
 
-   /// Assemble the local gradient matrix
    virtual void AssembleElementGrad(const Array<const FiniteElement*> &el,
                                     ElementTransformation &Tr,
                                     const Array<const Vector *> &elfun,
                                     const Array2D<DenseMatrix *> &elmats);
 };
 
-
 class VectorConvectionNLFIntegrator : public NonlinearFormIntegrator
 {
 private:
@@ -378,8 +422,12 @@ public:
 
    VectorConvectionNLFIntegrator() = default;
 
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &T);
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &trans,
@@ -400,7 +448,6 @@ public:
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
-
 /** This class is used to assemble the convective form of the nonlinear term
     arising in the Navier-Stokes equations \f$(u \cdot \nabla v, w )\f$ */
 class ConvectiveVectorConvectionNLFIntegrator :
@@ -422,7 +469,6 @@ public:
                                     DenseMatrix &elmat);
 };
 
-
 /** This class is used to assemble the skew-symmetric form of the nonlinear term
     arising in the Navier-Stokes equations
     \f$.5*(u \cdot \nabla v, w ) - .5*(u \cdot \nabla w, v )\f$ */
diff --git a/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp b/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
index 8951d1023..dad856887 100644
--- a/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
+++ b/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
@@ -59,7 +59,8 @@ const IntegrationRule &GetMassIntRule(FiniteElementSpace &fes_l2)
 {
    Mesh *mesh = fes_l2.GetMesh();
    const FiniteElement *fe = fes_l2.GetFE(0);
-   return MassIntegrator::GetRule(*fe, *fe, *mesh->GetElementTransformation(0));
+   return MassIntegrator::GetRuleStatic(*fe, *fe,
+                                        *mesh->GetElementTransformation(0));
 }
 
 HdivSaddlePointSolver::HdivSaddlePointSolver(
diff --git a/miniapps/shifted/sbm_solver.hpp b/miniapps/shifted/sbm_solver.hpp
index db16738d5..b8830bf31 100644
--- a/miniapps/shifted/sbm_solver.hpp
+++ b/miniapps/shifted/sbm_solver.hpp
@@ -121,7 +121,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -241,7 +240,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index 050561e1d..42cdc76ba 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -447,8 +447,8 @@ TEST_CASE("Hcurl/Hdiv diagonal PA",
                      else
                      {
                         const FiniteElement *fel = fespace.GetFE(0);
-                        const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                  *mesh.GetElementTransformation(0));
+                        ElementTransformation *T = mesh.GetElementTransformation(0);
+                        const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                         if (spaceType == Hcurl)
                         {
diff --git a/tests/unit/fem/test_pa_coeff.cpp b/tests/unit/fem/test_pa_coeff.cpp
index b45738fad..270359f3c 100644
--- a/tests/unit/fem/test_pa_coeff.cpp
+++ b/tests/unit/fem/test_pa_coeff.cpp
@@ -530,8 +530,8 @@ TEST_CASE("Hcurl/Hdiv PA Coefficient",
                         if (spaceType == Hcurl)
                         {
                            const FiniteElement *fel = fespace.GetFE(0);
-                           const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                     *mesh.GetElementTransformation(0));
+                           ElementTransformation *T = mesh.GetElementTransformation(0);
+                           const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                            if (coeffType >= 3 && dimension == 3)
                            {
