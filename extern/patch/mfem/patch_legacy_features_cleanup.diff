diff --git a/CMakeLists.txt b/CMakeLists.txt
index a163c66b6..76010e6ff 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -218,10 +218,7 @@ if (MFEM_USE_HIP)
 endif()
 
 # OpenMP
-if (MFEM_USE_OPENMP OR MFEM_USE_LEGACY_OPENMP)
-  if (NOT MFEM_THREAD_SAFE AND MFEM_USE_LEGACY_OPENMP)
-    message(FATAL_ERROR " *** MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE=ON.")
-  endif()
+if (MFEM_USE_OPENMP)
   find_package(OpenMP REQUIRED)
   set(OPENMP_LIBRARIES ${OpenMP_CXX_LIBRARIES})
   if(APPLE)
diff --git a/INSTALL b/INSTALL
index ee3f7c03c..bf7d2d3c4 100644
--- a/INSTALL
+++ b/INSTALL
@@ -309,10 +309,6 @@ MFEM_THREAD_SAFE = YES/NO
    Use thread-safe implementation for some classes/methods. This comes at the
    cost of extra memory allocation and de-allocation.
 
-MFEM_USE_LEGACY_OPENMP = YES/NO
-   Enable (basic) experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-   This option is deprecated.
-
 MFEM_USE_OPENMP = YES/NO
    Enable the OpenMP backend.
 
@@ -611,8 +607,8 @@ The specific libraries and their options are:
        http://math-atlas.sourceforge.net (ATLAS)
   Options: LAPACK_OPT (currently not used/needed), LAPACK_LIB.
 
-- OpenMP (optional), usually part of compiler, used when either MFEM_USE_OPENMP
-  or MFEM_USE_LEGACY_OPENMP is set to YES.
+- OpenMP (optional), usually part of compiler, used when MFEM_USE_OPENMP is set
+  to YES.
   Options: OPENMP_OPT, OPENMP_LIB.
 
 - High-resolution POSIX clocks: when using MFEM_TIMER_TYPE = 2, it may be
@@ -959,7 +955,6 @@ MFEM_USE_METIS - Set to ${MFEM_USE_MPI}, can be overwritten.
 MFEM_USE_LIBUNWIND
 MFEM_USE_LAPACK
 MFEM_THREAD_SAFE
-MFEM_USE_LEGACY_OPENMP
 MFEM_USE_OPENMP
 MFEM_USE_MEMALLOC
 MFEM_TIMER_TYPE - Set automatically, can be overwritten.
diff --git a/config/cmake/MFEMConfig.cmake.in b/config/cmake/MFEMConfig.cmake.in
index ed271311a..a9570e82f 100644
--- a/config/cmake/MFEMConfig.cmake.in
+++ b/config/cmake/MFEMConfig.cmake.in
@@ -25,7 +25,6 @@ set(MFEM_USE_LIBUNWIND @MFEM_USE_LIBUNWIND@)
 set(MFEM_USE_LAPACK @MFEM_USE_LAPACK@)
 set(MFEM_THREAD_SAFE @MFEM_THREAD_SAFE@)
 set(MFEM_USE_OPENMP @MFEM_USE_OPENMP@)
-set(MFEM_USE_LEGACY_OPENMP @MFEM_USE_LEGACY_OPENMP@)
 set(MFEM_USE_MEMALLOC @MFEM_USE_MEMALLOC@)
 set(MFEM_TIMER_TYPE @MFEM_TIMER_TYPE@)
 set(MFEM_USE_SUNDIALS @MFEM_USE_SUNDIALS@)
diff --git a/config/cmake/config.hpp.in b/config/cmake/config.hpp.in
index 7cb2a958d..ac715ee69 100644
--- a/config/cmake/config.hpp.in
+++ b/config/cmake/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 #cmakedefine MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-#cmakedefine MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 #cmakedefine MFEM_USE_MEMALLOC
 
diff --git a/config/cmake/modules/MfemCmakeUtilities.cmake b/config/cmake/modules/MfemCmakeUtilities.cmake
index 204b7d87f..9a629330b 100644
--- a/config/cmake/modules/MfemCmakeUtilities.cmake
+++ b/config/cmake/modules/MfemCmakeUtilities.cmake
@@ -843,16 +843,16 @@ function(mfem_export_mk_files)
   # Convert Boolean vars to YES/NO without writing the values to cache
   set(CONFIG_MK_BOOL_VARS MFEM_USE_MPI MFEM_USE_METIS MFEM_USE_METIS_5
       MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB MFEM_USE_LIBUNWIND
-      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_LEGACY_OPENMP MFEM_USE_OPENMP
-      MFEM_USE_MEMALLOC MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE
-      MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_MUMPS MFEM_USE_STRUMPACK
-      MFEM_USE_GINKGO MFEM_USE_AMGX MFEM_USE_GNUTLS MFEM_USE_NETCDF
-      MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS
-      MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA
-      MFEM_USE_HIP MFEM_USE_RAJA MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER
-      MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO
-      MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG
-      MFEM_USE_MOONOLITH MFEM_USE_ALGOIM MFEM_USE_ENZYME)
+      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP MFEM_USE_MEMALLOC
+      MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE MFEM_USE_SUPERLU MFEM_USE_SUPERLU5
+      MFEM_USE_MUMPS MFEM_USE_STRUMPACK MFEM_USE_GINKGO MFEM_USE_AMGX
+      MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC
+      MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI
+      MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_RAJA
+      MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER MFEM_USE_UMPIRE
+      MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_ADFORWARD
+      MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_MOONOLITH
+      MFEM_USE_ALGOIM MFEM_USE_ENZYME)
   foreach(var ${CONFIG_MK_BOOL_VARS})
     if (${var})
       set(${var} YES)
diff --git a/config/config.hpp.in b/config/config.hpp.in
index 39d7737c7..e89cb4452 100644
--- a/config/config.hpp.in
+++ b/config/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 // #define MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-// #define MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 // #define MFEM_USE_MEMALLOC
 
diff --git a/config/config.mk.in b/config/config.mk.in
index 303750bf5..fd3bf4b77 100644
--- a/config/config.mk.in
+++ b/config/config.mk.in
@@ -24,7 +24,6 @@ MFEM_USE_ZLIB          = @MFEM_USE_ZLIB@
 MFEM_USE_LIBUNWIND     = @MFEM_USE_LIBUNWIND@
 MFEM_USE_LAPACK        = @MFEM_USE_LAPACK@
 MFEM_THREAD_SAFE       = @MFEM_THREAD_SAFE@
-MFEM_USE_LEGACY_OPENMP = @MFEM_USE_LEGACY_OPENMP@
 MFEM_USE_OPENMP        = @MFEM_USE_OPENMP@
 MFEM_USE_MEMALLOC      = @MFEM_USE_MEMALLOC@
 MFEM_TIMER_TYPE        = @MFEM_TIMER_TYPE@
diff --git a/config/defaults.cmake b/config/defaults.cmake
index 526c87c4f..d4fba9922 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -28,7 +28,6 @@ option(MFEM_USE_LIBUNWIND "Enable backtrace for errors." OFF)
 option(MFEM_USE_LAPACK "Enable LAPACK usage" OFF)
 option(MFEM_THREAD_SAFE "Enable thread safety" OFF)
 option(MFEM_USE_OPENMP "Enable the OpenMP backend" OFF)
-option(MFEM_USE_LEGACY_OPENMP "Enable legacy OpenMP usage" OFF)
 option(MFEM_USE_MEMALLOC "Enable the internal MEMALLOC option." ON)
 option(MFEM_USE_SUNDIALS "Enable SUNDIALS usage" OFF)
 option(MFEM_USE_SUITESPARSE "Enable SuiteSparse usage" OFF)
diff --git a/config/defaults.mk b/config/defaults.mk
index 237e9ed24..6150a393c 100644
--- a/config/defaults.mk
+++ b/config/defaults.mk
@@ -127,7 +127,6 @@ MFEM_USE_LIBUNWIND     = NO
 MFEM_USE_LAPACK        = NO
 MFEM_THREAD_SAFE       = NO
 MFEM_USE_OPENMP        = NO
-MFEM_USE_LEGACY_OPENMP = NO
 MFEM_USE_MEMALLOC      = YES
 MFEM_TIMER_TYPE        = $(if $(NOTMAC),2,4)
 MFEM_USE_SUNDIALS      = NO
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index 206dff53d..210acf882 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -18,51 +18,6 @@
 namespace mfem
 {
 
-void BilinearForm::AllocMat()
-{
-   if (static_cond) { return; }
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      mat = new SparseMatrix(height);
-      return;
-   }
-
-   const Table &elem_dof = fes->GetElementToDofTable();
-   Table dof_dof;
-
-   if (interior_face_integs.Size() > 0)
-   {
-      // the sparsity pattern is defined from the map: face->element->dof
-      Table face_dof, dof_face;
-      {
-         Table *face_elem = fes->GetMesh()->GetFaceToElementTable();
-         mfem::Mult(*face_elem, elem_dof, face_dof);
-         delete face_elem;
-      }
-      Transpose(face_dof, dof_face, height);
-      mfem::Mult(dof_face, face_dof, dof_dof);
-   }
-   else
-   {
-      // the sparsity pattern is defined from the map: element->dof
-      Table dof_elem;
-      Transpose(elem_dof, dof_elem, height);
-      mfem::Mult(dof_elem, elem_dof, dof_dof);
-   }
-
-   dof_dof.SortRows();
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   double *data = Memory<double>(I[height]);
-
-   mat = new SparseMatrix(I, J, data, height, height, true, true, true);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
 BilinearForm::BilinearForm(FiniteElementSpace *f)
    : Matrix(f->GetVSize())
 {
@@ -70,32 +25,24 @@ BilinearForm::BilinearForm(FiniteElementSpace *f)
    sequence = f->GetSequence();
    mat = mat_e = NULL;
    extern_bfs = 0;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = 0;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 }
 
-BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf)
    : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
-   mat_e = NULL;
+   mat = mat_e = NULL;
    extern_bfs = 1;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = ps;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 
    // Copy the pointers to the integrators
@@ -108,8 +55,6 @@ BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
 
    boundary_face_integs = bf->boundary_face_integs;
    boundary_face_integs_marker = bf->boundary_face_integs_marker;
-
-   AllocMat();
 }
 
 void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -181,32 +126,6 @@ void BilinearForm::EnableHybridization(FiniteElementSpace *constr_space,
    hybridization->Init(ess_tdof_list);
 }
 
-void BilinearForm::UseSparsity(int *I, int *J, bool isSorted)
-{
-   if (static_cond) { return; }
-
-   if (mat)
-   {
-      if (mat->Finalized() && mat->GetI() == I && mat->GetJ() == J)
-      {
-         return; // mat is already using the given sparsity
-      }
-      delete mat;
-   }
-   height = width = fes->GetVSize();
-   mat = new SparseMatrix(I, J, NULL, height, width, false, true, isSorted);
-}
-
-void BilinearForm::UseSparsity(SparseMatrix &A)
-{
-   MFEM_ASSERT(A.Height() == fes->GetVSize() && A.Width() == fes->GetVSize(),
-               "invalid matrix A dimensions: "
-               << A.Height() << " x " << A.Width());
-   MFEM_ASSERT(A.Finalized(), "matrix A must be Finalized");
-
-   UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
-}
-
 double &BilinearForm::Elem(int i, int j)
 {
    return mat->Elem(i,j);
@@ -327,65 +246,97 @@ void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_face_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
+void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat,
+                                        Array<int> &vdofs)
 {
-   if (element_matrices)
-   {
-      elmat.SetSize(element_matrices->SizeI(), element_matrices->SizeJ());
-      elmat = element_matrices->GetData(i);
-      return;
-   }
-
+   DofTransformation *doftrans = fes->GetElementVDofs(i, vdofs);
+   elmat.SetSize(vdofs.Size());
+   elmat = 0.0;
    if (domain_integs.Size())
    {
-      const FiniteElement &fe = *fes->GetFE(i);
-      ElementTransformation *eltrans = fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix(fe, *eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
+      Mesh *mesh = fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+      int elem_attr = mesh->GetAttribute(i);
+#ifdef MFEM_DEBUG
+      for (int k = 0; k < domain_integs.Size(); k++)
       {
-         domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-         elmat += elemmat;
+         if (domain_integs_marker[k] != NULL)
+         {
+            MFEM_VERIFY(domain_integs_marker[k]->Size() ==
+                        (mesh->attributes.Size() ? mesh->attributes.Max() : 0),
+                        "invalid element marker for domain integrator #"
+                        << k << ", counting from zero");
+         }
+      }
+#endif
+      for (int k = 0; k < domain_integs.Size(); k++)
+      {
+         if (domain_integs_marker[k] == NULL ||
+             (*(domain_integs_marker[k]))[elem_attr-1] == 1)
+         {
+            domain_integs[k]->AssembleElementMatrix(*fes->GetFE(i),
+                                                    *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (doftrans)
+      {
+         doftrans->TransformDual(elmat);
       }
-   }
-   else
-   {
-      fes->GetElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
    }
 }
 
-void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
+void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat,
+                                           Array<int> &vdofs)
 {
+   DofTransformation *doftrans = fes->GetBdrElementVDofs(i, vdofs);
+   elmat.SetSize(vdofs.Size());
+   elmat = 0.0;
    if (boundary_integs.Size())
    {
-      const FiniteElement &be = *fes->GetBE(i);
-      ElementTransformation *eltrans = fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix(be, *eltrans, elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
+      Mesh *mesh = fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+      int bdr_attr = mesh->GetBdrAttribute(i);
+#ifdef MFEM_DEBUG
+      for (int k = 0; k < boundary_integs.Size(); k++)
       {
-         boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-         elmat += elemmat;
+         if (boundary_integs_marker[k] != NULL)
+         {
+            MFEM_VERIFY(boundary_integs_marker[k]->Size() ==
+                        (mesh->bdr_attributes.Size() ? mesh->bdr_attributes.Max() : 0),
+                        "invalid element marker for bdr integrator #"
+                        << k << ", counting from zero");
+         }
+      }
+#endif
+      for (int k = 0; k < boundary_integs.Size(); k++)
+      {
+         if (boundary_integs_marker[k] == NULL ||
+             (*(boundary_integs_marker[k]))[bdr_attr-1] == 1)
+         {
+            boundary_integs[k]->AssembleElementMatrix(*fes->GetBE(i),
+                                                      *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (doftrans)
+      {
+         doftrans->TransformDual(elmat);
       }
-   }
-   else
-   {
-      fes->GetBdrElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
    }
 }
 
 void BilinearForm::AssembleElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
+   Array<int> vdofs;
+   fes->GetElementVDofs(i, vdofs);
    AssembleElementMatrix(i, elmat, vdofs, skip_zeros);
 }
 
 void BilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &vdofs_, int skip_zeros)
+   int i, const DenseMatrix &elmat, const Array<int> &vdofs, int skip_zeros)
 {
-   fes->GetElementVDofs(i, vdofs_);
    if (static_cond)
    {
       static_cond->AssembleMatrix(i, elmat);
@@ -394,9 +345,9 @@ void BilinearForm::AssembleElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
-      mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
+      mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
       if (hybridization)
       {
          hybridization->AssembleMatrix(i, elmat);
@@ -407,13 +358,14 @@ void BilinearForm::AssembleElementMatrix(
 void BilinearForm::AssembleBdrElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
+   Array<int> vdofs;
+   fes->GetBdrElementVDofs(i, vdofs);
    AssembleBdrElementMatrix(i, elmat, vdofs, skip_zeros);
 }
 
 void BilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &vdofs_, int skip_zeros)
+   int i, const DenseMatrix &elmat, const Array<int> &vdofs, int skip_zeros)
 {
-   fes->GetBdrElementVDofs(i, vdofs_);
    if (static_cond)
    {
       static_cond->AssembleBdrMatrix(i, elmat);
@@ -422,9 +374,9 @@ void BilinearForm::AssembleBdrElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
-      mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
+      mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
       if (hybridization)
       {
          hybridization->AssembleBdrMatrix(i, elmat);
@@ -440,174 +392,39 @@ void BilinearForm::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *doftrans;
    Mesh *mesh = fes->GetMesh();
-   DenseMatrix elmat, *elmat_p;
+   DenseMatrix elmat;
+   Array<int> vdofs;
 
    if (mat == NULL)
    {
-      AllocMat();
-   }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   int free_element_matrices = 0;
-   if (!element_matrices)
-   {
-      ComputeElementMatrices();
-      free_element_matrices = 1;
+      mat = new SparseMatrix(height);
    }
-#endif
 
    if (domain_integs.Size())
    {
-      for (int k = 0; k < domain_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         if (domain_integs_marker[k] != NULL)
-         {
-            MFEM_VERIFY(domain_integs_marker[k]->Size() ==
-                        (mesh->attributes.Size() ? mesh->attributes.Max() : 0),
-                        "invalid element marker for domain integrator #"
-                        << k << ", counting from zero");
-         }
-      }
-
-      for (int i = 0; i < fes->GetNE(); i++)
-      {
-         int elem_attr = fes->GetMesh()->GetAttribute(i);
-         doftrans = fes->GetElementVDofs(i, vdofs);
-         if (element_matrices)
-         {
-            elmat_p = &(*element_matrices)(i);
-         }
-         else
-         {
-            elmat.SetSize(0);
-            for (int k = 0; k < domain_integs.Size(); k++)
-            {
-               if ( domain_integs_marker[k] == NULL ||
-                    (*(domain_integs_marker[k]))[elem_attr-1] == 1)
-               {
-                  const FiniteElement &fe = *fes->GetFE(i);
-                  eltrans = fes->GetElementTransformation(i);
-                  domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-                  if (elmat.Size() == 0)
-                  {
-                     elmat = elemmat;
-                  }
-                  else
-                  {
-                     elmat += elemmat;
-                  }
-               }
-            }
-            if (elmat.Size() == 0)
-            {
-               continue;
-            }
-            else
-            {
-               elmat_p = &elmat;
-            }
-            if (doftrans)
-            {
-               doftrans->TransformDual(elmat);
-            }
-            elmat_p = &elmat;
-         }
-         if (static_cond)
-         {
-            static_cond->AssembleMatrix(i, *elmat_p);
-         }
-         else
-         {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
-            if (hybridization)
-            {
-               hybridization->AssembleMatrix(i, *elmat_p);
-            }
-         }
+         ComputeElementMatrix(i, elmat, vdofs);
+         AssembleElementMatrix(i, elmat, vdofs, skip_zeros);
       }
    }
 
    if (boundary_integs.Size())
    {
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         if (boundary_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < fes->GetNBE(); i++)
-      {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes->GetBdrElementVDofs(i, vdofs);
-         eltrans = fes->GetBdrElementTransformation(i);
-         int k = 0;
-         for (; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elmat);
-            k++;
-            break;
-         }
-         for (; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (doftrans)
-         {
-            doftrans->TransformDual(elmat);
-         }
-         elmat_p = &elmat;
-         if (!static_cond)
-         {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
-            if (hybridization)
-            {
-               hybridization->AssembleBdrMatrix(i, *elmat_p);
-            }
-         }
-         else
-         {
-            static_cond->AssembleBdrMatrix(i, *elmat_p);
-         }
+         ComputeBdrElementMatrix(i, elmat, vdofs);
+         AssembleBdrElementMatrix(i, elmat, vdofs, skip_zeros);
       }
    }
 
    if (interior_face_integs.Size())
    {
-      FaceElementTransformations *tr;
       Array<int> vdofs2;
-
-      int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
-         tr = mesh->GetInteriorFaceTransformations(i);
+         FaceElementTransformations *tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
             fes->GetElementVDofs(tr->Elem1No, vdofs);
@@ -626,64 +443,31 @@ void BilinearForm::Assemble(int skip_zeros)
 
    if (boundary_face_integs.Size())
    {
-      FaceElementTransformations *tr;
-      const FiniteElement *fe1, *fe2;
-
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_face_integs.Size(); k++)
-      {
-         if (boundary_face_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_face_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary face integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < fes->GetNBE(); i++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         tr = mesh->GetBdrFaceTransformations(i);
+         FaceElementTransformations *tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes->GetElementVDofs(tr->Elem1No, vdofs);
-            fe1 = fes->GetFE(tr->Elem1No);
+            int bdr_attr = mesh->GetBdrAttribute(i);
+            const FiniteElement *fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
-            fe2 = fe1;
+            const FiniteElement *fe2 = fe1;
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
             for (int k = 0; k < boundary_face_integs.Size(); k++)
             {
-               if (boundary_face_integs_marker[k] &&
-                   (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
-               { continue; }
-
-               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
-                                                           elemmat);
-               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
+               if (boundary_face_integs_marker[k] == NULL ||
+                   (*boundary_face_integs_marker[k])[bdr_attr-1] == 1)
+               {
+                  boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                              elemmat);
+                  mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
+               }
             }
          }
       }
    }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   if (free_element_matrices)
-   {
-      FreeElementMatrices();
-   }
-#endif
 }
 
 void BilinearForm::ConformingAssemble()
@@ -949,48 +733,6 @@ void BilinearForm::RecoverFEMSolution(const Vector &X,
    }
 }
 
-void BilinearForm::ComputeElementMatrices()
-{
-   if (element_matrices || domain_integs.Size() == 0 || fes->GetNE() == 0)
-   {
-      return;
-   }
-
-   int num_elements = fes->GetNE();
-   int num_dofs_per_el = fes->GetFE(0)->GetDof() * fes->GetVDim();
-
-   element_matrices = new DenseTensor(num_dofs_per_el, num_dofs_per_el,
-                                      num_elements);
-
-   DenseMatrix tmp;
-   IsoparametricTransformation eltrans;
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for private(tmp,eltrans)
-#endif
-   for (int i = 0; i < num_elements; i++)
-   {
-      DenseMatrix elmat(element_matrices->GetData(i),
-                        num_dofs_per_el, num_dofs_per_el);
-      const FiniteElement &fe = *fes->GetFE(i);
-#ifdef MFEM_DEBUG
-      if (num_dofs_per_el != fe.GetDof()*fes->GetVDim())
-         mfem_error("BilinearForm::ComputeElementMatrices:"
-                    " all elements must have same number of dofs");
-#endif
-      fes->GetElementTransformation(i, &eltrans);
-
-      domain_integs[0]->AssembleElementMatrix(fe, eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         // note: some integrators may not be thread-safe
-         domain_integs[k]->AssembleElementMatrix(fe, eltrans, tmp);
-         elmat += tmp;
-      }
-      elmat.ClearExternalData();
-   }
-}
-
 void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
                                         const Vector &sol, Vector &rhs,
                                         DiagonalPolicy dpolicy)
@@ -1043,15 +785,15 @@ void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
+void BilinearForm::EliminateVDofs(const Array<int> &vdofs,
                                   const Vector &sol, Vector &rhs,
                                   DiagonalPolicy dpolicy)
 {
-   vdofs_.HostRead();
-   for (int i = 0; i < vdofs_.Size(); i++)
+   vdofs.HostRead();
+   for (int i = 0; i < vdofs.Size(); i++)
    {
-      int vdof = vdofs_[i];
-      if ( vdof >= 0 )
+      int vdof = vdofs[i];
+      if (vdof >= 0)
       {
          mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
@@ -1062,7 +804,7 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
    }
 }
 
-void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
+void BilinearForm::EliminateVDofs(const Array<int> &vdofs,
                                   DiagonalPolicy dpolicy)
 {
    if (mat_e == NULL)
@@ -1070,11 +812,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       mat_e = new SparseMatrix(height);
    }
 
-   vdofs_.HostRead();
-   for (int i = 0; i < vdofs_.Size(); i++)
+   vdofs.HostRead();
+   for (int i = 0; i < vdofs.Size(); i++)
    {
-      int vdof = vdofs_[i];
-      if ( vdof >= 0 )
+      int vdof = vdofs[i];
+      if (vdof >= 0)
       {
          mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
@@ -1094,10 +836,12 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    MFEM_ASSERT(rhs.Size() == height, "incorrect rhs Vector size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
+   {
       if (ess_dofs[i] < 0)
       {
          mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
+   }
 }
 
 void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
@@ -1106,10 +850,12 @@ void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
+   {
       if (ess_dofs[i] < 0)
       {
          mat->EliminateRowCol(i, dpolicy);
       }
+   }
 }
 
 void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
@@ -1125,10 +871,10 @@ void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
 }
 
 void BilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs_, const Vector &x, Vector &b)
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
    mat_e->AddMult(x, b, -1.);
-   mat->PartMult(vdofs_, x, b);
+   mat->PartMult(vdofs, x, b);
 }
 
 void BilinearForm::Update(FiniteElementSpace *nfes)
@@ -1150,7 +896,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
 
    delete mat_e;
    mat_e = NULL;
-   FreeElementMatrices();
    delete static_cond;
    static_cond = NULL;
 
@@ -1177,7 +922,6 @@ BilinearForm::~BilinearForm()
 {
    delete mat_e;
    delete mat;
-   delete element_matrices;
    delete static_cond;
    delete hybridization;
 
@@ -1195,7 +939,6 @@ BilinearForm::~BilinearForm()
    delete ext;
 }
 
-
 MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
                                      FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
@@ -1220,6 +963,8 @@ MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
    mat_e = NULL;
    extern_bfs = 1;
    ext = NULL;
+   assembly = AssemblyLevel::LEGACY;
+   ext = NULL;
 
    // Copy the pointers to the integrators
    domain_integs = mbf->domain_integs;
@@ -1229,9 +974,6 @@ MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
 
    boundary_integs_marker = mbf->boundary_integs_marker;
    boundary_trace_face_integs_marker = mbf->boundary_trace_face_integs_marker;
-
-   assembly = AssemblyLevel::LEGACY;
-   ext = NULL;
 }
 
 void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -1395,6 +1137,104 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
+void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat,
+                                             Array<int> &trial_vdofs,
+                                             Array<int> &test_vdofs)
+{
+   DofTransformation *dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+   DofTransformation *ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+   elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+   elmat = 0.0;
+   if (domain_integs.Size())
+   {
+      Mesh *mesh = test_fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+      for (int k = 0; k < domain_integs.Size(); k++)
+      {
+         domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                  *test_fes->GetFE(i),
+                                                  *eltrans, elemmat);
+         elmat += elemmat;
+      }
+      if (ran_dof_trans || dom_dof_trans)
+      {
+         TransformDual(ran_dof_trans, dom_dof_trans, elmat);
+      }
+   }
+}
+
+void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat,
+                                                Array<int> &trial_vdofs,
+                                                Array<int> &test_vdofs)
+{
+   DofTransformation *dom_dof_trans = trial_fes->GetBdrElementVDofs(i,
+                                                                    trial_vdofs);
+   DofTransformation *ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+   elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+   elmat = 0.0;
+   if (boundary_integs.Size())
+   {
+      Mesh *mesh = test_fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+      int bdr_attr = mesh->GetBdrAttribute(i);
+      for (int k = 0; k < boundary_integs.Size(); k++)
+      {
+         if (boundary_integs_marker[k] == NULL ||
+             (*boundary_integs_marker[k])[bdr_attr-1] == 1)
+         {
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (ran_dof_trans || dom_dof_trans)
+      {
+         TransformDual(ran_dof_trans, dom_dof_trans, elmat);
+      }
+   }
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   Array<int> trial_vdofs, test_vdofs;
+   trial_fes->GetElementVDofs(i, trial_vdofs);
+   test_fes->GetElementVDofs(i, test_vdofs);
+   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, const Array<int> &trial_vdofs,
+   const Array<int> &test_vdofs, int skip_zeros)
+{
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   Array<int> trial_vdofs, test_vdofs;
+   trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+   test_fes->GetBdrElementVDofs(i, test_vdofs);
+   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, const Array<int> &trial_vdofs,
+   const Array<int> &test_vdofs, int skip_zeros)
+{
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+}
+
 void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
@@ -1403,11 +1243,9 @@ void MixedBilinearForm::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *dom_dof_trans;
-   DofTransformation *ran_dof_trans;
    Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
+   Array<int> trial_vdofs, test_vdofs;
 
    if (mat == NULL)
    {
@@ -1416,171 +1254,85 @@ void MixedBilinearForm::Assemble(int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes->GetNE(); i++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetElementTransformation(i);
-
-         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-         elmat = 0.0;
-         for (int k = 0; k < domain_integs.Size(); k++)
-         {
-            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
-                                                     *test_fes->GetFE(i),
-                                                     *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (ran_dof_trans || dom_dof_trans)
-         {
-            TransformDual(ran_dof_trans, dom_dof_trans, elmat);
-         }
-         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+         ComputeElementMatrix(i, elmat, trial_vdofs, test_vdofs);
+         AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
       }
    }
 
    if (boundary_integs.Size())
    {
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         if (boundary_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < test_fes->GetNBE(); i++)
-      {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetBdrElementTransformation(i);
-
-         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-         elmat = 0.0;
-         for (int k = 0; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
-                                                       *test_fes->GetBE(i),
-                                                       *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (ran_dof_trans || dom_dof_trans)
-         {
-            TransformDual(ran_dof_trans, dom_dof_trans, elmat);
-         }
-         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+         ComputeBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs);
+         AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      FaceElementTransformations *ftr;
       Array<int> test_vdofs2;
-      const FiniteElement *trial_face_fe, *test_fe1, *test_fe2;
-
-      int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
-         ftr = mesh->GetFaceElementTransformations(i);
-         trial_fes->GetFaceVDofs(i, trial_vdofs);
-         test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
-         trial_face_fe = trial_fes->GetFaceElement(i);
-         test_fe1 = test_fes->GetFE(ftr->Elem1No);
-         if (ftr->Elem2No >= 0)
-         {
-            test_fes->GetElementVDofs(ftr->Elem2No, test_vdofs2);
-            test_vdofs.Append(test_vdofs2);
-            test_fe2 = test_fes->GetFE(ftr->Elem2No);
-         }
-         else
+         FaceElementTransformations *ftr = mesh->GetFaceElementTransformations(i);
+         if (ftr != NULL)
          {
-            // The test_fe2 object is really a dummy and not used on the
-            // boundaries, but we can't dereference a NULL pointer, and we don't
-            // want to actually make a fake element.
-            test_fe2 = test_fe1;
-         }
-         for (int k = 0; k < trace_face_integs.Size(); k++)
-         {
-            trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe, *test_fe1,
-                                                     *test_fe2, *ftr, elemmat);
-            mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+            trial_fes->GetFaceVDofs(i, trial_vdofs);
+            test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
+            const FiniteElement *trial_face_fe = trial_fes->GetFaceElement(i);
+            const FiniteElement *test_fe1 = test_fes->GetFE(ftr->Elem1No);
+            const FiniteElement *test_fe2;
+            if (ftr->Elem2No >= 0)
+            {
+               test_fes->GetElementVDofs(ftr->Elem2No, test_vdofs2);
+               test_vdofs.Append(test_vdofs2);
+               test_fe2 = test_fes->GetFE(ftr->Elem2No);
+            }
+            else
+            {
+               // The test_fe2 object is really a dummy and not used on the
+               // boundaries, but we can't dereference a NULL pointer, and we don't
+               // want to actually make a fake element.
+               test_fe2 = test_fe1;
+            }
+            for (int k = 0; k < trace_face_integs.Size(); k++)
+            {
+               trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe, *test_fe1,
+                                                        *test_fe2, *ftr, elemmat);
+               mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+            }
          }
       }
    }
 
    if (boundary_trace_face_integs.Size())
    {
-      FaceElementTransformations *ftr;
-      Array<int> te_vdofs2;
-      const FiniteElement *trial_face_fe, *test_fe1, *test_fe2;
-
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_trace_face_integs.Size(); k++)
-      {
-         if (boundary_trace_face_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_trace_face_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary trace face"
-                     "integrator #" << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < trial_fes->GetNBE(); i++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         ftr = mesh->GetBdrFaceTransformations(i);
-         if (ftr)
+         int bdr_attr = mesh->GetBdrAttribute(i);
+         FaceElementTransformations *ftr = mesh->GetBdrFaceTransformations(i);
+         if (ftr != NULL)
          {
             trial_fes->GetFaceVDofs(ftr->ElementNo, trial_vdofs);
             test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
-            trial_face_fe = trial_fes->GetFaceElement(ftr->ElementNo);
-            test_fe1 = test_fes->GetFE(ftr->Elem1No);
+            const FiniteElement *trial_face_fe = trial_fes->GetFaceElement(ftr->ElementNo);
+            const FiniteElement *test_fe1 = test_fes->GetFE(ftr->Elem1No);
             // The test_fe2 object is really a dummy and not used on the
             // boundaries, but we can't dereference a NULL pointer, and we don't
             // want to actually make a fake element.
-            test_fe2 = test_fe1;
+            const FiniteElement *test_fe2 = test_fe1;
             for (int k = 0; k < boundary_trace_face_integs.Size(); k++)
             {
-               if (boundary_trace_face_integs_marker[k] &&
-                   (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 0)
-               { continue; }
-
-               boundary_trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe,
-                                                                 *test_fe1,
-                                                                 *test_fe2,
-                                                                 *ftr, elemmat);
-               mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+               if (boundary_trace_face_integs_marker[k] == NULL ||
+                   (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 1)
+               {
+                  boundary_trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe,
+                                                                    *test_fe1,
+                                                                    *test_fe2,
+                                                                    *ftr, elemmat);
+                  mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+               }
             }
          }
       }
@@ -1666,143 +1418,6 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (domain_integs.Size())
-   {
-      const FiniteElement &trial_fe = *trial_fes->GetFE(i);
-      const FiniteElement &test_fe = *test_fes->GetFE(i);
-      ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                               elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                                  elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetElementVDofs(i, trial_vdofs);
-      test_fes->GetElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &trial_be = *trial_fes->GetBE(i);
-      const FiniteElement &test_be = *test_fes->GetBE(i);
-      ElementTransformation *eltrans = test_fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                 elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                    elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-      test_fes->GetBdrElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetElementVDofs(i, trial_vdofs_);
-   test_fes->GetElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
-   test_fes->GetBdrElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
-
-void MixedBilinearForm::EliminateTrialDofs(
-   const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
-{
-   int i, j, k;
-   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
-
-   cols_marker = 0;
-   for (i = 0; i < trial_fes->GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
-      {
-         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
-         for (j = 0; j < tr_vdofs.Size(); j++)
-         {
-            if ((k = tr_vdofs[j]) < 0)
-            {
-               k = -1-k;
-            }
-            cols_marker[k] = 1;
-         }
-      }
-   mat->EliminateCols(cols_marker, &sol, &rhs);
-}
-
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
-   const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
-{
-   mat->EliminateCols(marked_vdofs, &sol, &rhs);
-}
-
-void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
-{
-   int i, j, k;
-   Array<int> te_vdofs;
-
-   for (i = 0; i < test_fes->GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
-      {
-         test_fes->GetBdrElementVDofs(i, te_vdofs);
-         for (j = 0; j < te_vdofs.Size(); j++)
-         {
-            if ((k = te_vdofs[j]) < 0)
-            {
-               k = -1-k;
-            }
-            mat->EliminateRow(k);
-         }
-      }
-}
-
 void MixedBilinearForm::FormRectangularLinearSystem(
    const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
@@ -1867,6 +1482,59 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    A.Reset(mat, false);
 }
 
+void MixedBilinearForm::EliminateTrialDofs(
+   const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs)
+{
+   int i, j, k;
+   Array<int> ess_dofs, cols_marker(trial_fes->GetVSize());
+   cols_marker = 0;
+
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+   {
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
+      {
+         trial_fes->GetBdrElementVDofs(i, ess_dofs);
+         for (j = 0; j < ess_dofs.Size(); j++)
+         {
+            if ((k = ess_dofs[j]) < 0)
+            {
+               k = -1-k;
+            }
+            cols_marker[k] = 1;
+         }
+      }
+   }
+   mat->EliminateCols(cols_marker, &sol, &rhs);
+}
+
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
+   const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
+{
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
+}
+
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
+{
+   int i, j, k;
+   Array<int> ess_dofs;
+
+   for (i = 0; i < test_fes->GetNBE(); i++)
+   {
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
+      {
+         test_fes->GetBdrElementVDofs(i, ess_dofs);
+         for (j = 0; j < ess_dofs.Size(); j++)
+         {
+            if ((k = ess_dofs[j]) < 0)
+            {
+               k = -1-k;
+            }
+            mat->EliminateRow(k);
+         }
+      }
+   }
+}
+
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1931,11 +1599,9 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *dom_dof_trans;
-   DofTransformation *ran_dof_trans;
    Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
+   Array<int> trial_vdofs, test_vdofs;
 
    if (mat == NULL)
    {
@@ -1944,11 +1610,11 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes->GetNE(); i++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetElementTransformation(i);
+         DofTransformation *dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         DofTransformation *ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1969,12 +1635,11 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
          trial_fes->GetFaceVDofs(i, trial_vdofs);
          test_fes->GetFaceVDofs(i, test_vdofs);
-         eltrans = mesh->GetFaceTransformation(i);
+         ElementTransformation *eltrans = mesh->GetFaceTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index 0788d9185..92f9e9d6d 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -36,8 +36,6 @@ enum class AssemblyLevel
    /// is fully evaluated on the fly.
    /// This assembly level is ALWAYS performed on the host.
    LEGACY = 0,
-   /// @deprecated Use LEGACY instead.
-   LEGACYFULL = 0,
    /// Fully assembled form, i.e. a global sparse matrix in MFEM format. This
    /// assembly is compatible with device execution.
    FULL,
@@ -66,7 +64,7 @@ protected:
    SparseMatrix *mat;
 
    /** @brief Sparse Matrix \f$ M_e \f$ used to store the eliminations
-        from the b.c.  Owned.
+        from the b.c. Owned.
        \f$ M + M_e = M_{original} \f$ */
    SparseMatrix *mat_e;
 
@@ -75,11 +73,11 @@ protected:
 
    /// The assembly level of the form (full, partial, etc.)
    AssemblyLevel assembly;
-   /// Element batch size used in the form action (1, 8, num_elems, etc.)
-   int batch;
+
    /** @brief Extension for supporting Full Assembly (FA), Element Assembly (EA),
        Partial Assembly (PA), or Matrix Free assembly (MF). */
    BilinearFormExtension *ext;
+
    /** Indicates if the sparse matrix is sorted after assembly when using
        Full Assembly (FA). */
    bool sort_sparse_matrix = false;
@@ -113,11 +111,6 @@ protected:
    Array<BilinearFormIntegrator*> boundary_face_integs;
    Array<Array<int>*> boundary_face_integs_marker; ///< Entries are not owned.
 
-   DenseMatrix elemmat;
-   Array<int>  vdofs;
-
-   DenseTensor *element_matrices; ///< Owned.
-
    StaticCondensation *static_cond; ///< Owned.
    Hybridization *hybridization; ///< Owned.
 
@@ -126,30 +119,28 @@ protected:
        the constrained DoFs. */
    DiagonalPolicy diag_policy;
 
-   int precompute_sparsity;
-
-   // Allocate appropriate SparseMatrix and assign it to mat
-   void AllocMat();
+   DenseMatrix elemmat;
 
    // may be used in the construction of derived classes
    BilinearForm() : Matrix(0)
    {
-      fes = NULL; sequence = -1;
-      mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
-      static_cond = NULL; hybridization = NULL;
-      precompute_sparsity = 0;
+      fes = NULL;
+      sequence = -1;
+      mat = mat_e = NULL;
+      extern_bfs = 0;
+      static_cond = NULL;
+      hybridization = NULL;
       diag_policy = DIAG_KEEP;
       assembly = AssemblyLevel::LEGACY;
-      batch = 1;
       ext = NULL;
    }
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   BilinearForm(const BilinearForm &);
+   /// Copy construction is not supported.
+   BilinearForm(const BilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   BilinearForm &operator=(const BilinearForm &);
+   /// Copy assignment is not supported.
+   BilinearForm &operator=(const BilinearForm &) = delete;
 
 public:
    /// Creates bilinear form associated with FE space @a *f.
@@ -162,11 +153,8 @@ public:
        The pointer @a f is not owned by the newly constructed object.
 
        The integrators in @a bf are copied as pointers and they are not owned by
-       the newly constructed BilinearForm.
-
-       The optional parameter @a ps is used to initialize the internal flag
-       #precompute_sparsity, see UsePrecomputedSparsity() for details. */
-   BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps = 0);
+       the newly constructed BilinearForm. */
+   BilinearForm(FiniteElementSpace *f, BilinearForm *bf);
 
    /// Get the size of the BilinearForm as a square matrix.
    int Size() const { return height; }
@@ -237,31 +225,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
-       (assuming dense element matrices) based on the types of integrators
-       present in the bilinear form. */
-   void UsePrecomputedSparsity(int ps = 1) { precompute_sparsity = ps; }
-
-   /** @brief Use the given CSR sparsity pattern to allocate the internal
-       SparseMatrix.
-
-       - The @a I and @a J arrays must define a square graph with size equal to
-         GetVSize() of the associated FiniteElementSpace.
-       - This method should be called after enabling static condensation or
-         hybridization, if used.
-       - In the case of static condensation, @a I and @a J are not used.
-       - The ownership of the arrays @a I and @a J remains with the caller. */
-   void UseSparsity(int *I, int *J, bool isSorted);
-
-   /// Use the sparsity of @a A to allocate the internal SparseMatrix.
-   void UseSparsity(SparseMatrix &A);
-
-   /// Pre-allocate the internal SparseMatrix before assembly.
-   /**  If the flag 'precompute sparsity'
-       is set, the matrix is allocated in CSR format (i.e.
-       finalized) and the entries are initialized with zeros. */
-   void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
@@ -286,7 +249,7 @@ public:
                          const double a = 1.0) const override;
 
    /** @brief Matrix vector multiplication with the original uneliminated
-       matrix.  The original matrix is \f$ M + M_e \f$ so we have:
+       matrix. The original matrix is \f$ M + M_e \f$ so we have:
        \f$ y = M x + M_e x \f$ */
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
@@ -374,9 +337,28 @@ public:
    bool HasSpMatElim() const { return mat_e != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
+        to it. Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const BilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   BilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
    /// Adds new Domain Integrator restricted to certain elements specified by
@@ -430,7 +412,49 @@ public:
    Array<Array<int>*> *GetBFBFI_Marker()
    { return &boundary_face_integs_marker; }
 
-   /// Assembles the form i.e. sums over all domain/bdr integrators.
+   /// Compute the element matrix of the given element
+   void ComputeElementMatrix(int i, DenseMatrix &elmat, Array<int> &vdofs);
+
+   /// Compute the boundary element matrix of the given boundary element
+   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat, Array<int> &vdofs);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The flag @a skip_zeros skips the zero
+       elements of the matrix, unless they are breaking the symmetry of
+       the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              int skip_zeros = 1);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The vdofs of the element are returned
+       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
+       matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              const Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
+       skips the zero elements of the matrix, unless they are breaking the
+       symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The vdofs of the element
+       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
+       of the matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 const Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assembles the form i.e. sums over all domain/boundary integrators.
    void Assemble(int skip_zeros = 1);
 
    /** For a partially conforming FE space, complete the assembly process by
@@ -542,59 +566,6 @@ public:
    */
    void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x) override;
 
-   /// Compute and store internally all element matrices.
-   void ComputeElementMatrices();
-
-   /// Free the memory used by the element matrices.
-   void FreeElementMatrices()
-   { delete element_matrices; element_matrices = NULL; }
-
-   /// Compute the element matrix of the given element
-   /** The element matrix is computed by calling the domain integrators
-       or the one stored internally by a prior call of ComputeElementMatrices()
-       is returned when available.
-   */
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The flag @a skip_zeros skips the zero
-       elements of the matrix, unless they are breaking the symmetry of
-       the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              int skip_zeros = 1);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The vdofs of the element are returned
-       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
-       matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &vdofs, int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
-       skips the zero elements of the matrix, unless they are breaking the
-       symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The vdofs of the element
-       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
-       of the matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &vdofs, int skip_zeros = 1);
-
    /// Eliminate essential boundary DOFs from the system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
        the essential part of the boundary. By default, the diagonal at the
@@ -666,7 +637,7 @@ public:
        a(u,v) = V^t M U
 
    where `U` and `V` are the vectors representing the functions `u` and `v`,
-   respectively.  The first argument, `u`, of `a(,)` is in the trial space
+   respectively. The first argument, `u`, of `a(,)` is in the trial space
    and the second argument, `v`, is in the test space. Thus,
 
        # of rows of M = dimension of the test space and
@@ -677,11 +648,12 @@ public:
 class MixedBilinearForm : public Matrix
 {
 protected:
-   SparseMatrix *mat; ///< Owned.
-   SparseMatrix *mat_e; ///< Owned.
+   /** Sparse matrices associated with the form and the eliminations from
+       the b.c. Owned. */
+   SparseMatrix *mat, *mat_e;
 
-   FiniteElementSpace *trial_fes, ///< Not owned
-                      *test_fes;  ///< Not owned
+   /// FE space on which the form lives. Not owned.
+   FiniteElementSpace *trial_fes, *test_fes;
 
    /// The form assembly level (full, partial, etc.)
    AssemblyLevel assembly;
@@ -711,14 +683,13 @@ protected:
    Array<Array<int>*> boundary_trace_face_integs_marker;
 
    DenseMatrix elemmat;
-   Array<int>  trial_vdofs, test_vdofs;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   MixedBilinearForm(const MixedBilinearForm &);
+   /// Copy construction is not supported.
+   MixedBilinearForm(const MixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   MixedBilinearForm &operator=(const MixedBilinearForm &);
+   /// Copy assignment is not supported.
+   MixedBilinearForm &operator=(const MixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a MixedBilinearForm on the given trial, @a tr_fes, and
@@ -779,18 +750,45 @@ public:
    void GetBlocks(Array2D<SparseMatrix *> &blocks) const;
 
    /// Returns a const reference to the sparse matrix:  \f$ M \f$
-   const SparseMatrix &SpMat() const { return *mat; }
+   const SparseMatrix &SpMat() const
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns a reference to the sparse matrix:  \f$ M \f$
-   SparseMatrix &SpMat() { return *mat; }
+   SparseMatrix &SpMat()
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns true if the sparse matrix is not null, false otherwise.
    bool HasSpMat() const { return mat != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
+        to it. Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const MixedBilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   MixedBilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds a domain integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
 
@@ -837,40 +835,13 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   void Assemble(int skip_zeros = 1);
-
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
-   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
-       bilinear form and D is a diagonal. */
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Get the input finite element space prolongation matrix
-   const Operator *GetProlongation() const override
-   { return trial_fes->GetProlongationMatrix(); }
-
-   /// Get the input finite element space restriction matrix
-   const Operator *GetRestriction() const override
-   { return trial_fes->GetRestrictionMatrix(); }
-
-   /// Get the test finite element space prolongation matrix
-   const Operator *GetOutputProlongation() const override
-   { return test_fes->GetProlongationMatrix(); }
-
-   /// Get the test finite element space restriction matrix
-   const Operator *GetOutputRestriction() const override
-   { return test_fes->GetRestrictionMatrix(); }
-
    /// Compute the element matrix of the given element
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
+   void ComputeElementMatrix(int i, DenseMatrix &elmat, Array<int> &trial_vdofs,
+                             Array<int> &test_vdofs);
 
    /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
+   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat, Array<int> &trial_vdofs,
+                                Array<int> &test_vdofs);
 
    /// Assemble the given element matrix
    /** The element matrix @a elmat is assembled for the element @a i, i.e.
@@ -889,7 +860,8 @@ public:
        of the system matrix.
    */
    void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &trial_vdofs, Array<int> &test_vdofs,
+                              const Array<int> &trial_vdofs,
+                              const Array<int> &test_vdofs,
                               int skip_zeros = 1);
 
    /// Assemble the given boundary element matrix
@@ -909,16 +881,39 @@ public:
        symmetry of the system matrix.
    */
    void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &trial_vdofs, Array<int> &test_vdofs,
+                                 const Array<int> &trial_vdofs,
+                                 const Array<int> &test_vdofs,
                                  int skip_zeros = 1);
 
-   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
-                           const Vector &sol, Vector &rhs);
+   /// Assembles the form i.e. sums over all domain/boundary integrators.
+   void Assemble(int skip_zeros = 1);
 
-   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
-                                          const Vector &sol, Vector &rhs);
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
+   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
+       bilinear form and D is a diagonal. */
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+
+   /// Get the input finite element space prolongation matrix
+   const Operator *GetProlongation() const override
+   { return trial_fes->GetProlongationMatrix(); }
+
+   /// Get the input finite element space restriction matrix
+   const Operator *GetRestriction() const override
+   { return trial_fes->GetRestrictionMatrix(); }
 
-   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+   /// Get the test finite element space prolongation matrix
+   const Operator *GetOutputProlongation() const override
+   { return test_fes->GetProlongationMatrix(); }
+
+   /// Get the test finite element space restriction matrix
+   const Operator *GetOutputRestriction() const override
+   { return test_fes->GetRestrictionMatrix(); }
 
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
@@ -1037,11 +1032,11 @@ public:
 class DiscreteLinearOperator : public MixedBilinearForm
 {
 private:
-   /// Copy construction is not supported; body is undefined.
-   DiscreteLinearOperator(const DiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   DiscreteLinearOperator(const DiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &) = delete;
 
 public:
    /** @brief Construct a DiscreteLinearOperator on the given
@@ -1066,7 +1061,7 @@ public:
    /// Access all interpolators added with AddTraceFaceInterpolator().
    Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
-   /// Set the desired assembly level. The default is AssemblyLevel::FULL.
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
    /** This method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
diff --git a/fem/coefficient.cpp b/fem/coefficient.cpp
index 04b96a355..5b51454d6 100644
--- a/fem/coefficient.cpp
+++ b/fem/coefficient.cpp
@@ -187,8 +187,8 @@ double SphericalPolarCoefficient::Eval(ElementTransformation & T,
                 transip[2]);
 }
 
-double GridFunctionCoefficient::Eval (ElementTransformation &T,
-                                      const IntegrationPoint &ip)
+double GridFunctionCoefficient::Eval(ElementTransformation &T,
+                                     const IntegrationPoint &ip)
 {
    Mesh *gf_mesh = GridF->FESpace()->GetMesh();
    if (T.mesh->GetNE() == gf_mesh->GetNE())
@@ -673,12 +673,6 @@ void PWMatrixCoefficient::UpdateCoefficient(int attr, MatrixCoefficient & coef)
    MFEM_VERIFY(coef.GetWidth() == width,
                "PWMatrixCoefficient::UpdateCoefficient:  "
                "MatrixCoefficient has incompatible width.");
-   if (symmetric)
-   {
-      MFEM_VERIFY(coef.IsSymmetric(),
-                  "PWMatrixCoefficient::UpdateCoefficient:  "
-                  "MatrixCoefficient has incompatible symmetry.");
-   }
    pieces[attr] = &coef;
 }
 
@@ -730,68 +724,17 @@ void MatrixFunctionCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
 
    K.SetSize(height, width);
 
-   if (symmetric) // Use SymmFunction (deprecated version)
-   {
-      MFEM_VERIFY(height == width && SymmFunction,
-                  "MatrixFunctionCoefficient is not symmetric");
-
-      Vector Ksym((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-      SymmFunction(transip, Ksym);
-
-      // Copy upper triangular values from Ksym to the full matrix K
-      int os = 0;
-      for (int i=0; i<height; ++i)
-      {
-         for (int j=i; j<width; ++j)
-         {
-            const double Kij = Ksym[j - i + os];
-            K(i,j) = Kij;
-            if (j != i) { K(j,i) = Kij; }
-         }
-
-         os += width - i;
-      }
-   }
-   else
+   if (Function)
    {
-      if (Function)
-      {
-         Function(transip, K);
-      }
-      else if (TDFunction)
-      {
-         TDFunction(transip, GetTime(), K);
-      }
-      else
-      {
-         K = mat;
-      }
+      Function(transip, K);
    }
-
-   if (Q)
+   else if (TDFunction)
    {
-      K *= Q->Eval(T, ip, GetTime());
+      TDFunction(transip, GetTime(), K);
    }
-}
-
-void MatrixFunctionCoefficient::EvalSymmetric(Vector &K,
-                                              ElementTransformation &T,
-                                              const IntegrationPoint &ip)
-{
-   MFEM_VERIFY(symmetric && height == width && SymmFunction,
-               "MatrixFunctionCoefficient is not symmetric");
-
-   double x[3];
-   Vector transip(x, 3);
-
-   T.Transform(ip, transip);
-
-   K.SetSize((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-   if (SymmFunction)
+   else
    {
-      SymmFunction(transip, K);
+      K = mat;
    }
 
    if (Q)
@@ -832,7 +775,7 @@ void SymmetricMatrixCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
    Eval(mat, T, ip);
    for (int j = 0; j < width; ++j)
    {
-      for (int i = 0; i < height; ++ i)
+      for (int i = 0; i < height; ++i)
       {
          K(i, j) = mat(i, j);
       }
@@ -1832,3 +1775,4 @@ CoefficientVector::~CoefficientVector()
 }
 
 }
+
diff --git a/fem/coefficient.hpp b/fem/coefficient.hpp
index b98ac360b..ecc4ab7b1 100644
--- a/fem/coefficient.hpp
+++ b/fem/coefficient.hpp
@@ -106,7 +106,6 @@ private:
    Vector constants;
 
 public:
-
    /// Constructs a piecewise constant coefficient in NumOfSubD subdomains
    explicit PWConstCoefficient(int NumOfSubD = 0) : constants(NumOfSubD)
    { constants = 0.0; }
@@ -177,7 +176,6 @@ private:
                 const Array<Coefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise coefficient
    explicit PWCoefficient() {}
 
@@ -458,7 +456,6 @@ protected:
    double (*tdf)(double);
 
 public:
-
    /// Construct a unit delta function centered at (0.0,0.0,0.0)
    DeltaCoefficient()
    {
@@ -621,15 +618,16 @@ class VectorConstantCoefficient : public VectorCoefficient
 {
 private:
    Vector vec;
+
 public:
    /// Construct the coefficient with constant vector @a v.
    VectorConstantCoefficient(const Vector &v)
       : VectorCoefficient(v.Size()), vec(v) { }
-   using VectorCoefficient::Eval;
 
    ///  Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip) { V = vec; }
+   using VectorCoefficient::Eval;
 
    /// Return a reference to the constant vector in this class.
    const Vector& GetVec() const { return vec; }
@@ -679,7 +677,6 @@ private:
                 const Array<VectorCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise vector coefficient of dimension vd
    explicit PWVectorCoefficient(int vd): VectorCoefficient(vd) {}
 
@@ -763,10 +760,10 @@ public:
       : VectorCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
    { }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~VectorFunctionCoefficient() { }
 };
@@ -803,11 +800,11 @@ public:
    double Eval(int i, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i] ? Coeff[i]->Eval(T, ip, GetTime()) : 0.0; }
 
-   using VectorCoefficient::Eval;
    /** @brief Evaluate the coefficient. Each element of vector V comes from the
        associated array of scalar coefficients. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    /// Destroys vector coefficient.
    virtual ~VectorArrayCoefficient();
@@ -862,7 +859,6 @@ protected:
    const GridFunction *GridFunc;
 
 public:
-
    /** @brief Construct the coefficient with a scalar grid function @a gf. The
        grid function is not owned by the coefficient. */
    GradientGridFunctionCoefficient(const GridFunction *gf);
@@ -903,10 +899,10 @@ public:
    /// Get the vector grid function.
    const GridFunction * GetGridFunction() const { return GridFunc; }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector curl coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~CurlGridFunctionCoefficient() { }
 };
@@ -995,12 +991,13 @@ public:
    virtual void EvalDelta(Vector &V, ElementTransformation &T,
                           const IntegrationPoint &ip);
 
-   using VectorCoefficient::Eval;
    /** @brief A VectorDeltaFunction cannot be evaluated. Calling this method
        will cause an MFEM error, terminating the application. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip)
    { mfem_error("VectorDeltaCoefficient::Eval"); }
+   using VectorCoefficient::Eval;
+
    virtual ~VectorDeltaCoefficient() { }
 };
 
@@ -1042,16 +1039,15 @@ class MatrixCoefficient
 protected:
    int height, width;
    double time;
-   bool symmetric;  // deprecated
 
 public:
    /// Construct a dim x dim matrix coefficient.
-   explicit MatrixCoefficient(int dim, bool symm=false)
-   { height = width = dim; time = 0.; symmetric = symm; }
+   explicit MatrixCoefficient(int dim)
+   { height = width = dim; time = 0.; }
 
    /// Construct a h x w matrix coefficient.
-   MatrixCoefficient(int h, int w, bool symm=false) :
-      height(h), width(w), time(0.), symmetric(symm) { }
+   MatrixCoefficient(int h, int w) :
+      height(h), width(w), time(0.) { }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t) { time = t; }
@@ -1068,9 +1064,6 @@ public:
    /// For backward compatibility get the width of the matrix.
    int GetVDim() const { return width; }
 
-   /** @deprecated Use SymmetricMatrixCoefficient instead */
-   bool IsSymmetric() const { return symmetric; }
-
    /** @brief Evaluate the matrix coefficient in the element described by @a T
        at the point @a ip, storing the result in @a K. */
    /** @note When this method is called, the caller must make sure that the
@@ -1087,17 +1080,6 @@ public:
    /// the width of the matrix.
    virtual void Project(QuadratureFunction &qf, bool transpose=false);
 
-   /// (DEPRECATED) Evaluate a symmetric matrix coefficient.
-   /** @brief Evaluate the upper triangular entries of the matrix coefficient
-       in the symmetric case, similarly to Eval. Matrix entry (i,j) is stored
-       in K[j - i + os_i] for 0 <= i <= j < width, os_0 = 0,
-       os_{i+1} = os_i + width - i. That is, K = {M(0,0), ..., M(0,w-1),
-       M(1,1), ..., M(1,w-1), ..., M(w-1,w-1) with w = width.
-       @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip)
-   { mfem_error("MatrixCoefficient::EvalSymmetric"); }
-
    virtual ~MatrixCoefficient() { }
 };
 
@@ -1107,14 +1089,17 @@ class MatrixConstantCoefficient : public MatrixCoefficient
 {
 private:
    DenseMatrix mat;
+
 public:
    ///Construct using matrix @a m for the constant.
    MatrixConstantCoefficient(const DenseMatrix &m)
       : MatrixCoefficient(m.Height(), m.Width()), mat(m) { }
-   using MatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using MatrixCoefficient::Eval;
+
    /// Return a reference to the constant matrix.
    const DenseMatrix& GetMatrix() { return mat; }
 };
@@ -1164,20 +1149,18 @@ private:
                 const Array<MatrixCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise matrix coefficient of dimension dim by dim
-   explicit PWMatrixCoefficient(int dim, bool symm = false)
-      : MatrixCoefficient(dim, symm) {}
+   explicit PWMatrixCoefficient(int dim)
+      : MatrixCoefficient(dim) {}
 
    /// Constructs a piecewise matrix coefficient of dimension h by w
-   explicit PWMatrixCoefficient(int h, int w, bool symm = false)
-      : MatrixCoefficient(h, w, symm) {}
+   explicit PWMatrixCoefficient(int h, int w)
+      : MatrixCoefficient(h, w) {}
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param dim - size of the square matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned.
 
@@ -1185,16 +1168,14 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int dim, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(dim, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(dim) { InitMap(attr, coefs); }
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param h - height of the matrix-valued result
        \param w - width of the matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned for that attribute.
 
@@ -1202,9 +1183,8 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int h, int w, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(h, w, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(h, w) { InitMap(attr, coefs); }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t);
@@ -1233,7 +1213,6 @@ class MatrixFunctionCoefficient : public MatrixCoefficient
 {
 private:
    std::function<void(const Vector &, DenseMatrix &)> Function;
-   std::function<void(const Vector &, Vector &)> SymmFunction;  // deprecated
    std::function<void(const Vector &, double, DenseMatrix &)> TDFunction;
 
    Coefficient *Q;
@@ -1257,28 +1236,6 @@ public:
       : MatrixCoefficient(m.Height(), m.Width()), Q(&q), mat(m)
    { }
 
-   /** @brief Define a time-independent symmetric square matrix coefficient from
-       a std function */
-   /** \param dim - the size of the matrix
-       \param SymmF - function used in EvalSymmetric
-       \param q - optional scalar Coefficient to scale the matrix coefficient
-       @deprecated Use another constructor without setting SymmFunction. */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, Vector &)> SymmF,
-                             Coefficient *q = NULL)
-      : MatrixCoefficient(dim, true), SymmFunction(std::move(SymmF)), Q(q), mat(0)
-   { }
-
-   /// Define a time-dependent square matrix coefficient from a std function
-   /** \param dim - the size of the matrix
-       \param TDF - time-dependent function
-       \param q - optional scalar Coefficient to scale the matrix coefficient */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, double, DenseMatrix &)> TDF,
-                             Coefficient *q = nullptr)
-      : MatrixCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
-   { }
-
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
@@ -1286,11 +1243,6 @@ public:
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
 
-   /// (DEPRECATED) Evaluate the symmetric matrix coefficient at @a ip.
-   /** @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip);
-
    virtual ~MatrixFunctionCoefficient() { }
 };
 
@@ -1320,12 +1272,11 @@ public:
        can be overridden with the @a own parameter. */
    void Set(int i, int j, Coefficient * c, bool own=true);
 
-   using MatrixCoefficient::Eval;
-
    /// Evaluate coefficient located at (i,j) in the matrix using integration
    /// point @a ip.
    double Eval(int i, int j, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i*width+j] ? Coeff[i*width+j] -> Eval(T, ip, GetTime()) : 0.0; }
+   using MatrixCoefficient::Eval;
 
    /// Evaluate the matrix coefficient @a ip.
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
@@ -1428,10 +1379,11 @@ class SymmetricMatrixCoefficient : public MatrixCoefficient
 protected:
    /// Internal matrix used when evaluating this coefficient as a DenseMatrix.
    DenseSymmetricMatrix mat;
+
 public:
    /// Construct a dim x dim matrix coefficient.
    explicit SymmetricMatrixCoefficient(int dimension)
-      : MatrixCoefficient(dimension, true) { }
+      : MatrixCoefficient(dimension) { }
 
    /// Get the size of the matrix.
    int GetSize() const { return height; }
@@ -1481,10 +1433,11 @@ public:
    ///Construct using matrix @a m for the constant.
    SymmetricMatrixConstantCoefficient(const DenseSymmetricMatrix &m)
       : SymmetricMatrixCoefficient(m.Height()), mat(m) { }
-   using SymmetricMatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using SymmetricMatrixCoefficient::Eval;
 };
 
 
@@ -1532,10 +1485,10 @@ public:
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
-   using SymmetricMatrixCoefficient::Eval;
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using SymmetricMatrixCoefficient::Eval;
 
    virtual ~SymmetricMatrixFunctionCoefficient() { }
 };
@@ -1682,6 +1635,7 @@ private:
 
    mutable Vector va;
    mutable Vector vb;
+
 public:
    /// Construct with the two vector coefficients.  Result is \f$ A \cdot B \f$.
    InnerProductCoefficient(VectorCoefficient &A, VectorCoefficient &B);
@@ -2254,9 +2208,9 @@ public:
 
    const QuadratureFunction& GetQuadFunction() const { return QuadF; }
 
-   using VectorCoefficient::Eval;
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual void Project(QuadratureFunction &qf);
 
@@ -2320,6 +2274,7 @@ protected:
    int vdim; ///< Number of values per quadrature point.
    QuadratureSpaceBase &qs; ///< Associated QuadratureSpaceBase.
    QuadratureFunction *qf; ///< Internal QuadratureFunction (owned, may be NULL).
+
 public:
    /// Create an empty CoefficientVector.
    CoefficientVector(QuadratureSpaceBase &qs_,
@@ -2421,3 +2376,4 @@ double ComputeGlobalLpNorm(double p, VectorCoefficient &coeff, ParMesh &pmesh,
 }
 
 #endif
+
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index 86d81f566..1fb6e0669 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -19,108 +19,6 @@
 namespace mfem
 {
 
-void ParBilinearForm::pAllocMat()
-{
-   int nbr_size = pfes->GetFaceNbrVSize();
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      if (keep_nbr_block)
-      {
-         mat = new SparseMatrix(height + nbr_size, width + nbr_size);
-      }
-      else
-      {
-         mat = new SparseMatrix(height, width + nbr_size);
-      }
-      return;
-   }
-
-   // the sparsity pattern is defined from the map: face->element->dof
-   const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
-   const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
-   Table elem_dof; // element + nbr-element <---> dof
-   if (nbr_size > 0)
-   {
-      // merge lelem_ldof and nelem_ndof into elem_dof
-      int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
-      const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
-      const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
-      const int nnz1 = I1[s1], nnz2 = I2[s2];
-
-      elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
-
-      int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
-      for (int i = 0; i <= s1; i++)
-      {
-         I[i] = I1[i];
-      }
-      for (int j = 0; j < nnz1; j++)
-      {
-         J[j] = J1[j];
-      }
-      for (int i = 0; i <= s2; i++)
-      {
-         I[s1+i] = I2[i] + nnz1;
-      }
-      for (int j = 0; j < nnz2; j++)
-      {
-         J[nnz1+j] = J2[j] + height;
-      }
-   }
-   //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
-   // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
-   Table dof_dof;
-   {
-      Table face_dof; // face_elem x elem_dof
-      {
-         Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
-         if (nbr_size > 0)
-         {
-            mfem::Mult(*face_elem, elem_dof, face_dof);
-         }
-         else
-         {
-            mfem::Mult(*face_elem, lelem_ldof, face_dof);
-         }
-         delete face_elem;
-         if (nbr_size > 0)
-         {
-            elem_dof.Clear();
-         }
-      }
-
-      if (keep_nbr_block)
-      {
-         Table dof_face;
-         Transpose(face_dof, dof_face, height + nbr_size);
-         mfem::Mult(dof_face, face_dof, dof_dof);
-      }
-      else
-      {
-         Table ldof_face;
-         {
-            Table face_ldof;
-            Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
-            mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
-            delete face_lelem;
-            Transpose(face_ldof, ldof_face, height);
-         }
-         mfem::Mult(ldof_face, face_dof, dof_dof);
-      }
-   }
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   int nrows = dof_dof.Size();
-   double *data = Memory<double>(I[nrows]);
-
-   mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
 void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
                                   bool steal_loc_A)
 {
@@ -224,10 +122,8 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
    ParMesh *pmesh = pfes->GetParMesh();
    FaceElementTransformations *T;
    Array<int> vdofs1, vdofs2, vdofs_all;
-   DenseMatrix elemmat;
 
-   int nfaces = pmesh->GetNSharedFaces();
-   for (int i = 0; i < nfaces; i++)
+   for (int i = 0; i < pmesh->GetNSharedFaces(); i++)
    {
       T = pmesh->GetSharedFaceTransformations(i);
       int Elem2NbrNo = T->Elem2No - pmesh->GetNE();
@@ -270,7 +166,15 @@ void ParBilinearForm::Assemble(int skip_zeros)
       pfes->ExchangeFaceNbrData();
       if (!ext && mat == NULL)
       {
-         pAllocMat();
+         int nbr_size = pfes->GetFaceNbrVSize();
+         if (keep_nbr_block)
+         {
+            mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+         }
+         else
+         {
+            mat = new SparseMatrix(height, width + nbr_size);
+         }
       }
    }
 
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index 712c29234..7bdb468c0 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -30,26 +30,25 @@ class ParBilinearForm : public BilinearForm
    friend FABilinearFormExtension;
 
 protected:
-   ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
+   ///< Points to the same object as #fes
+   ParFiniteElementSpace *pfes;
 
    /// Auxiliary vectors used in TrueAddMult(): L-, L-, and T-vector, resp.
    mutable Vector Xaux, Yaux, Ytmp;
 
+   /// Matrix and eliminated matrix
    OperatorHandle p_mat, p_mat_e;
 
    bool keep_nbr_block;
 
-   // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
-   void pAllocMat();
-
    void AssembleSharedFaces(int skip_zeros = 1);
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParBilinearForm(const ParBilinearForm &);
+   /// Copy construction is not supported.
+   ParBilinearForm(const ParBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParBilinearForm &operator=(const ParBilinearForm &);
+   /// Copy assignment is not supported.
+   ParBilinearForm &operator=(const ParBilinearForm &) = delete;
 
 public:
    /// Creates parallel bilinear form associated with the FE space @a *pf.
@@ -211,6 +210,7 @@ protected:
    ParFiniteElementSpace *trial_pfes;
    /// Points to the same object as #test_fes
    ParFiniteElementSpace *test_pfes;
+
    /// Auxiliary objects used in TrueAddMult().
    mutable ParGridFunction Xaux, Yaux;
 
@@ -218,11 +218,11 @@ protected:
    OperatorHandle p_mat, p_mat_e;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParMixedBilinearForm(const ParMixedBilinearForm &);
+   /// Copy construction is not supported.
+   ParMixedBilinearForm(const ParMixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &);
+   /// Copy assignment is not supported.
+   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a ParMixedBilinearForm on the given FiniteElementSpace%s
@@ -304,11 +304,12 @@ protected:
    ParFiniteElementSpace *range_fes;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &) =
+      delete;
 
 public:
    /** @brief Construct a ParDiscreteLinearOperator on the given
@@ -318,7 +319,11 @@ public:
        object. */
    ParDiscreteLinearOperator(ParFiniteElementSpace *dfes,
                              ParFiniteElementSpace *rfes)
-      : DiscreteLinearOperator(dfes, rfes) { domain_fes=dfes; range_fes=rfes; }
+      : DiscreteLinearOperator(dfes, rfes)
+   {
+      domain_fes = dfes;
+      range_fes = rfes;
+   }
 
    /// Returns the matrix "assembled" on the true dofs
    HypreParMatrix *ParallelAssemble() const;
diff --git a/general/version.cpp b/general/version.cpp
index d2b05f8ed..f4c402d51 100644
--- a/general/version.cpp
+++ b/general/version.cpp
@@ -103,9 +103,6 @@ const char *GetConfigStr()
 #ifdef MFEM_USE_LAPACK
       "MFEM_USE_LAPACK\n"
 #endif
-#ifdef MFEM_USE_LEGACY_OPENMP
-      "MFEM_USE_LEGACY_OPENMP\n"
-#endif
 #ifdef MFEM_USE_LIBUNWIND
       "MFEM_USE_LIBUNWIND\n"
 #endif
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 22c2aa8e0..bcb55ca3e 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -171,7 +171,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new VectorMassIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    a_lor.EliminateEssentialBC(ess_bdr, policy);
    a_lor.Finalize();
@@ -244,7 +243,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new DiffusionIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    if (ess_bdr.Size())
    {
diff --git a/linalg/sparsemat.cpp b/linalg/sparsemat.cpp
index 6f1b0d682..81c678540 100644
--- a/linalg/sparsemat.cpp
+++ b/linalg/sparsemat.cpp
@@ -764,7 +764,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       return;
    }
 
-#ifndef MFEM_USE_LEGACY_OPENMP
    const int height = this->height;
    const int nnz = J.Capacity();
    auto d_I = Read(I, height+1);
@@ -885,24 +884,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       });
 
    }
-
-#else // MFEM_USE_LEGACY_OPENMP
-   const double *Ap = A, *xp = x.GetData();
-   double *yp = y.GetData();
-   const int *Jp = J, *Ip = I;
-
-   #pragma omp parallel for
-   for (int i = 0; i < height; i++)
-   {
-      double d = 0.0;
-      const int end = Ip[i+1];
-      for (int j = Ip[i]; j < end; j++)
-      {
-         d += Ap[j] * xp[Jp[j]];
-      }
-      yp[i] += a * d;
-   }
-#endif // MFEM_USE_LEGACY_OPENMP
 }
 
 void SparseMatrix::MultTranspose(const Vector &x, Vector &y) const
diff --git a/linalg/vector.cpp b/linalg/vector.cpp
index a51d6ac9c..ef68efe77 100644
--- a/linalg/vector.cpp
+++ b/linalg/vector.cpp
@@ -106,9 +106,6 @@ const double &Vector::Elem(int i) const
 double Vector::operator*(const double *v) const
 {
    double dot = 0.0;
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for reduction(+:dot)
-#endif
    for (int i = 0; i < size; i++)
    {
       dot += data[i] * v[i];
@@ -319,7 +316,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    MFEM_ASSERT(v.size == v1.size && v.size == v2.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
    const int N = v.size;
    // Note: get read access first, in case v is the same as v1/v2.
@@ -327,13 +323,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    auto x2 = v2.Read(use_dev);
    auto y = v.Write(use_dev);
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = x1[i] + x2[i]; });
-#else
-   #pragma omp parallel for
-   for (int i = 0; i < v.size; i++)
-   {
-      v.data[i] = v1.data[i] + v2.data[i];
-   }
-#endif
 }
 
 void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
@@ -351,7 +340,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
       const int N = v.size;
       // Note: get read access first, in case v is the same as v1/v2.
@@ -362,16 +350,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
       {
          d_z[i] = d_x[i] + alpha * d_y[i];
       });
-#else
-      const double *v1p = v1.data, *v2p = v2.data;
-      double *vp = v.data;
-      const int s = v.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         vp[i] = v1p[i] + alpha*v2p[i];
-      }
-#endif
    }
 }
 
@@ -390,7 +368,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -401,17 +378,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] + yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] + yp[i]);
-      }
-#endif
    }
 }
 
@@ -445,7 +411,6 @@ void add(const double a, const Vector &x,
 #endif
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -456,17 +421,6 @@ void add(const double a, const Vector &x,
       {
          zd[i] = a * xd[i] + b * yd[i];
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * xp[i] + b * yp[i];
-      }
-#endif
    }
 }
 
@@ -475,7 +429,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    MFEM_ASSERT(x.size == y.size && x.size == z.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
    const int N = x.size;
    // Note: get read access first, in case z is the same as x/y.
@@ -486,17 +439,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    {
       zd[i] = xd[i] - yd[i];
    });
-#else
-   const double *xp = x.data;
-   const double *yp = y.data;
-   double       *zp = z.data;
-   const int     s = x.size;
-   #pragma omp parallel for
-   for (int i = 0; i < s; i++)
-   {
-      zp[i] = xp[i] - yp[i];
-   }
-#endif
 }
 
 void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
@@ -514,7 +456,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -525,17 +466,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] - yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] - yp[i]);
-      }
-#endif
    }
 }
 
diff --git a/makefile b/makefile
index 6f71bd0fd..b16112ccd 100644
--- a/makefile
+++ b/makefile
@@ -265,16 +265,6 @@ endif
 
 DEP_CXX ?= $(MFEM_CXX)
 
-# Check legacy OpenMP configuration
-ifeq ($(MFEM_USE_LEGACY_OPENMP),YES)
-   MFEM_THREAD_SAFE ?= YES
-   ifneq ($(MFEM_THREAD_SAFE),YES)
-      $(error Incompatible config: MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE)
-   endif
-   # NOTE: MFEM_USE_LEGACY_OPENMP cannot be combined with any of:
-   # MFEM_USE_OPENMP, MFEM_USE_CUDA, MFEM_USE_RAJA, MFEM_USE_OCCA
-endif
-
 # List of MFEM dependencies, that require the *_LIB variable to be non-empty
 MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS\
  SUITESPARSE STRUMPACK GINKGO GNUTLS NETCDF PETSC SLEPC MPFR PUMI HIOP\
@@ -339,16 +329,16 @@ endif
 MFEM_DEFINES = MFEM_VERSION MFEM_VERSION_STRING MFEM_GIT_STRING MFEM_USE_MPI\
  MFEM_USE_METIS MFEM_USE_METIS_5 MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB\
  MFEM_USE_LIBUNWIND MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP\
- MFEM_USE_LEGACY_OPENMP MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS\
- MFEM_USE_SUITESPARSE MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5\
- MFEM_USE_STRUMPACK MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC\
- MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT\
- MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP\
- MFEM_USE_OCCA MFEM_USE_MOONOLITH MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE\
- MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_MKL_PARDISO MFEM_USE_AMGX\
- MFEM_USE_MUMPS MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER\
- MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME\
- MFEM_SOURCE_DIR MFEM_INSTALL_DIR MFEM_SHARED_BUILD
+ MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE\
+ MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_STRUMPACK\
+ MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR\
+ MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP\
+ MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_OCCA MFEM_USE_MOONOLITH\
+ MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2\
+ MFEM_USE_MKL_CPARDISO MFEM_USE_MKL_PARDISO MFEM_USE_AMGX MFEM_USE_MUMPS\
+ MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER MFEM_USE_BENCHMARK\
+ MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME MFEM_SOURCE_DIR\
+ MFEM_INSTALL_DIR MFEM_SHARED_BUILD
 
 # List of makefile variables that will be written to config.mk:
 MFEM_CONFIG_VARS = MFEM_CXX MFEM_HOST_CXX MFEM_CPPFLAGS MFEM_CXXFLAGS\
@@ -672,7 +662,6 @@ status info:
 	$(info MFEM_USE_LAPACK        = $(MFEM_USE_LAPACK))
 	$(info MFEM_THREAD_SAFE       = $(MFEM_THREAD_SAFE))
 	$(info MFEM_USE_OPENMP        = $(MFEM_USE_OPENMP))
-	$(info MFEM_USE_LEGACY_OPENMP = $(MFEM_USE_LEGACY_OPENMP))
 	$(info MFEM_USE_MEMALLOC      = $(MFEM_USE_MEMALLOC))
 	$(info MFEM_TIMER_TYPE        = $(MFEM_TIMER_TYPE))
 	$(info MFEM_USE_SUNDIALS      = $(MFEM_USE_SUNDIALS))
@@ -757,10 +746,6 @@ deprecation-warnings:
 	@if [ -t 1 ]; then\
 	   red="\033[0;31m"; yellow="\033[0;33m"; end="\033[0m";\
 	 fi;\
-	if [ $(MFEM_USE_LEGACY_OPENMP) = YES ]; then\
-	  printf $$red"[MFEM_USE_LEGACY_OPENMP]"$$end": "$$yellow"%s"$$end"\n"\
-	  $(DEPRECATION_WARNING);\
-	fi
 
 # $(call mfem_check_command, command-to-execute, success_msg, failed_msg)
 mfem_check_command = \
diff --git a/miniapps/performance/ex1.cpp b/miniapps/performance/ex1.cpp
index e2271585c..916e7022e 100644
--- a/miniapps/performance/ex1.cpp
+++ b/miniapps/performance/ex1.cpp
@@ -317,8 +317,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    cout << "Assembling the bilinear form ..." << flush;
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -373,7 +371,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -385,7 +382,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/miniapps/performance/ex1p.cpp b/miniapps/performance/ex1p.cpp
index 79735c7ff..1e80576bb 100644
--- a/miniapps/performance/ex1p.cpp
+++ b/miniapps/performance/ex1p.cpp
@@ -390,8 +390,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    }
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -460,7 +458,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -472,7 +469,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/tests/unit/fem/test_bilinearform.cpp b/tests/unit/fem/test_bilinearform.cpp
index 5fd00b3e1..647ae38f2 100644
--- a/tests/unit/fem/test_bilinearform.cpp
+++ b/tests/unit/fem/test_bilinearform.cpp
@@ -127,7 +127,7 @@ TEST_CASE("FormLinearSystem/SolutionScope",
    // Legacy full assembly
    {
       GridFunction sol(&fes);
-      SolvePDE(AssemblyLevel::LEGACYFULL, sol);
+      SolvePDE(AssemblyLevel::LEGACY, sol);
       // Make sure the solution is still accessible after 'X' is destroyed
       sol.HostRead();
       REQUIRE(AsConst(sol)(bdr_dof) == 0.0);
