diff --git a/data/p1_prism.msh b/data/p1_prism.msh
new file mode 100644
index 000000000..b05d1470c
--- /dev/null
+++ b/data/p1_prism.msh
@@ -0,0 +1,53 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+15
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 2.74 0 2.74
+7 -7.133049998451843e-15 2.74 5.48
+8 -2.74 -3.31486008200114e-15 5.48
+9 4.363887905507124e-15 -2.74 5.48
+10 -5.920473312798202e-16 -4.967313603494313e-16 0
+11 -7.133049998451843e-15 2.74 2.74
+12 -2.74 -3.31486008200114e-15 2.74
+13 4.363887905507124e-15 -2.74 2.74
+14 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+15 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+$EndNodes
+$Elements
+24
+1 2 2 2 1 3 10 1
+2 2 2 2 1 5 10 4
+3 2 2 2 1 4 10 3
+4 2 2 2 1 1 10 5
+5 2 2 2 3 7 14 2
+6 2 2 2 3 9 14 8
+7 2 2 2 3 8 14 7
+8 2 2 2 3 2 14 9
+9 3 2 2 2 1 3 11 6
+10 3 2 2 2 6 11 7 2
+11 3 2 2 2 3 4 12 11
+12 3 2 2 2 11 12 8 7
+13 3 2 2 2 4 5 13 12
+14 3 2 2 2 12 13 9 8
+15 3 2 2 2 5 1 6 13
+16 3 2 2 2 13 6 2 9
+17 6 2 1 1 1 3 10 6 11 15
+18 6 2 1 1 6 11 15 2 7 14
+19 6 2 1 1 4 5 10 12 13 15
+20 6 2 1 1 12 13 15 8 9 14
+21 6 2 1 1 3 4 10 11 12 15
+22 6 2 1 1 11 12 15 7 8 14
+23 6 2 1 1 5 1 10 13 6 15
+24 6 2 1 1 13 6 15 9 2 14
+$EndElements
diff --git a/data/p2_prism.msh b/data/p2_prism.msh
new file mode 100644
index 000000000..0cb3f66d6
--- /dev/null
+++ b/data/p2_prism.msh
@@ -0,0 +1,103 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+65
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 1.937472580451138 1.937472580451143 0
+7 -1.937472580451143 1.937472580451137 0
+8 -1.937472580451138 -1.937472580451143 0
+9 1.937472580451142 -1.937472580451139 0
+10 2.74 0 2.74
+11 2.74 0 1.37
+12 2.74 0 4.11
+13 -7.133049998451843e-15 2.74 5.48
+14 -2.74 -3.31486008200114e-15 5.48
+15 4.363887905507124e-15 -2.74 5.48
+16 1.937472580451138 1.937472580451143 5.48
+17 -1.937472580451143 1.937472580451137 5.48
+18 -1.937472580451138 -1.937472580451143 5.48
+19 1.937472580451142 -1.937472580451139 5.48
+20 -5.920473312798202e-16 -4.967313603494313e-16 0
+21 -3.862548664865832e-15 1.37 0
+22 1.37 -2.483656801747156e-16 0
+23 1.885920287113652e-15 -1.37 0
+24 -1.370000000000001 -1.905795721175286e-15 0
+25 -7.133049998451843e-15 2.74 2.74
+26 -2.74 -3.31486008200114e-15 2.74
+27 4.363887905507124e-15 -2.74 2.74
+28 1.677766114831874e-16 2.74 1.37
+29 1.937472580451138 1.937472580451143 2.74
+30 1.937472580451141 1.937472580451143 1.37
+31 1.677766114831874e-16 2.74 4.11
+32 1.937472580451141 1.937472580451143 4.11
+33 -2.74 3.355532229663748e-16 1.37
+34 -1.937472580451143 1.937472580451137 2.74
+35 -1.93747258045114 1.937472580451139 1.37
+36 -2.74 3.355532229663748e-16 4.11
+37 -1.93747258045114 1.937472580451139 4.11
+38 -5.033298344495622e-16 -2.74 1.37
+39 -1.937472580451138 -1.937472580451143 2.74
+40 -1.937472580451141 -1.937472580451141 1.37
+41 -5.033298344495622e-16 -2.74 4.11
+42 -1.937472580451141 -1.937472580451141 4.11
+43 1.937472580451142 -1.937472580451139 2.74
+44 1.937472580451139 -1.937472580451139 1.37
+45 1.937472580451139 -1.937472580451139 4.11
+46 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+47 -3.862548664865832e-15 1.37 5.48
+48 1.37 -2.483656801747157e-16 5.48
+49 1.885920287113652e-15 -1.37 5.48
+50 -1.370000000000001 -1.905795721175286e-15 5.48
+51 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+52 -5.920473312798202e-16 -4.967313603494313e-16 1.37
+53 1.37 -2.483656801747157e-16 2.74
+54 -3.862548664865832e-15 1.37 2.74
+55 1.37 -2.483656801747157e-16 1.37
+56 -2.121353598983164e-16 1.37 1.37
+57 -5.920473312798202e-16 -4.967313603494313e-16 4.11
+58 1.37 -2.483656801747157e-16 4.11
+59 -2.121353598983164e-16 1.37 4.11
+60 -1.37 -1.905795721175286e-15 2.74
+61 1.885920287113652e-15 -1.37 2.74
+62 -1.37 -8.058906869152782e-17 1.37
+63 -5.476885828646913e-16 -1.37 1.37
+64 -1.37 -8.058906869152802e-17 4.11
+65 -5.476885828646913e-16 -1.37 4.11
+$EndNodes
+$Elements
+24
+1 9 2 2 1 3 20 1 21 22 6
+2 9 2 2 1 5 20 4 23 24 8
+3 9 2 2 1 4 20 3 24 21 7
+4 9 2 2 1 1 20 5 22 23 9
+5 9 2 2 3 13 46 2 47 48 16
+6 9 2 2 3 15 46 14 49 50 18
+7 9 2 2 3 14 46 13 50 47 17
+8 9 2 2 3 2 46 15 48 49 19
+9 10 2 2 2 1 3 25 10 6 28 29 11 30
+10 10 2 2 2 10 25 13 2 29 31 16 12 32
+11 10 2 2 2 3 4 26 25 7 33 34 28 35
+12 10 2 2 2 25 26 14 13 34 36 17 31 37
+13 10 2 2 2 4 5 27 26 8 38 39 33 40
+14 10 2 2 2 26 27 15 14 39 41 18 36 42
+15 10 2 2 2 5 1 10 27 9 11 43 38 44
+16 10 2 2 2 27 10 2 15 43 12 19 41 45
+17 13 2 1 1 1 3 20 10 25 51 6 22 11 21 28 52 29 53 54 30 55 56
+18 13 2 1 1 10 25 51 2 13 46 29 53 12 54 31 57 16 48 47 32 58 59
+19 13 2 1 1 4 5 20 26 27 51 8 24 33 23 38 52 39 60 61 40 62 63
+20 13 2 1 1 26 27 51 14 15 46 39 60 36 61 41 57 18 50 49 42 64 65
+21 13 2 1 1 3 4 20 25 26 51 7 21 28 24 33 52 34 54 60 35 56 62
+22 13 2 1 1 25 26 51 13 14 46 34 54 31 60 36 57 17 47 50 37 59 64
+23 13 2 1 1 5 1 20 27 10 51 9 23 38 22 11 52 43 61 53 44 63 55
+24 13 2 1 1 27 10 51 15 2 46 43 61 41 53 12 57 19 49 48 45 65 58
+$EndElements
diff --git a/examples/ex13p.cpp b/examples/ex13p.cpp
index da3a7cdba..af3cbc696 100644
--- a/examples/ex13p.cpp
+++ b/examples/ex13p.cpp
@@ -54,6 +54,7 @@ int main(int argc, char *argv[])
    int par_ref_levels = 1;
    int order = 1;
    int nev = 5;
+   bool nc = false;
    bool visualization = 1;
    const char *device_config = "cpu";
 
@@ -69,6 +70,9 @@ int main(int argc, char *argv[])
                   " isoparametric space.");
    args.AddOption(&nev, "-n", "--num-eigs",
                   "Number of desired eigenmodes.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-c",
+                  "--conforming",
+                  "Mark the mesh as nonconforming before partitioning.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -107,6 +111,11 @@ int main(int argc, char *argv[])
       mesh->UniformRefinement();
    }
 
+   if (nc)
+   {
+      mesh->EnsureNCMesh(true);
+   }
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution (1 time by
    //    default, or specified on the command line with -rp). Once the parallel
diff --git a/examples/ex3.cpp b/examples/ex3.cpp
index edbfdac7d..d36ec62bf 100644
--- a/examples/ex3.cpp
+++ b/examples/ex3.cpp
@@ -63,6 +63,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = 1;
 
@@ -77,6 +78,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -103,19 +106,26 @@ int main(int argc, char *argv[])
    dim = mesh->Dimension();
    int sdim = mesh->SpaceDimension();
 
+
    // 4. Refine the mesh to increase the resolution. In this example we do
    //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    //    largest number that gives a final mesh with no more than 50,000
    //    elements.
+
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+   mesh->UniformRefinement();
    {
       int ref_levels =
-         (int)floor(log(50000./mesh->GetNE())/log(2.)/dim);
+         (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
       {
          mesh->UniformRefinement();
       }
    }
-
    // 5. Define a finite element space on the mesh. Here we use the Nedelec
    //    finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex3p.cpp b/examples/ex3p.cpp
index e24c52809..285fcc8e8 100644
--- a/examples/ex3p.cpp
+++ b/examples/ex3p.cpp
@@ -70,6 +70,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = true;
 #ifdef MFEM_USE_AMGX
@@ -87,6 +88,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -129,6 +132,12 @@ int main(int argc, char *argv[])
    //    this example we do 'ref_levels' of uniform refinement. We choose
    //    'ref_levels' to be the largest number that gives a final mesh with no
    //    more than 1,000 elements.
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+
    {
       int ref_levels = (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
@@ -137,19 +146,20 @@ int main(int argc, char *argv[])
       }
    }
 
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution. Once the
    //    parallel mesh is defined, the serial mesh can be deleted.
    ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);
+
    delete mesh;
    {
-      int par_ref_levels = 2;
+      int par_ref_levels = 1;
       for (int l = 0; l < par_ref_levels; l++)
       {
          pmesh->UniformRefinement();
       }
    }
-
    // 7. Define a parallel finite element space on the parallel mesh. Here we
    //    use the Nedelec finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/fem/doftrans.cpp b/fem/doftrans.cpp
index 95da3859d..8494ddbf2 100644
--- a/fem/doftrans.cpp
+++ b/fem/doftrans.cpp
@@ -14,54 +14,6 @@
 namespace mfem
 {
 
-void DofTransformation::TransformPrimal(Vector &v) const
-{
-   TransformPrimal(v.GetData());
-}
-
-void DofTransformation::TransformPrimalCols(DenseMatrix &V) const
-{
-   for (int c=0; c<V.Width(); c++)
-   {
-      TransformPrimal(V.GetColumn(c));
-   }
-}
-
-void DofTransformation::TransformDual(Vector &v) const
-{
-   TransformDual(v.GetData());
-}
-
-void DofTransformation::TransformDual(DenseMatrix &V) const
-{
-   TransformDualCols(V);
-   TransformDualRows(V);
-}
-
-void DofTransformation::TransformDualRows(DenseMatrix &V) const
-{
-   Vector row;
-   for (int r=0; r<V.Height(); r++)
-   {
-      V.GetRow(r, row);
-      TransformDual(row);
-      V.SetRow(r, row);
-   }
-}
-
-void DofTransformation::TransformDualCols(DenseMatrix &V) const
-{
-   for (int c=0; c<V.Width(); c++)
-   {
-      TransformDual(V.GetColumn(c));
-   }
-}
-
-void DofTransformation::InvTransformPrimal(Vector &v) const
-{
-   InvTransformPrimal(v.GetData());
-}
-
 void TransformPrimal(const DofTransformation *ran_dof_trans,
                      const DofTransformation *dom_dof_trans,
                      DenseMatrix &elmat)
@@ -85,11 +37,6 @@ void TransformPrimal(const DofTransformation *ran_dof_trans,
    }
 }
 
-void DofTransformation::InvTransformDual(Vector &v) const
-{
-   InvTransformDual(v.GetData());
-}
-
 void TransformDual(const DofTransformation *ran_dof_trans,
                    const DofTransformation *dom_dof_trans,
                    DenseMatrix &elmat)
@@ -229,6 +176,7 @@ void VDofTransformation::InvTransformDual(double *v) const
    }
 }
 
+// ordering (i0j0, i1j0, i0j1, i1j1), each row is a column major matrix
 const double ND_DofTransformation::T_data[24] =
 {
    1.0,  0.0,  0.0,  1.0,
@@ -290,8 +238,7 @@ void ND_TriDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformPrimal(double *v) const
+void ND_TriDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -313,8 +260,7 @@ ND_TriDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::TransformDual(double *v) const
+void ND_TriDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -336,8 +282,7 @@ ND_TriDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformDual(double *v) const
+void ND_TriDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -386,8 +331,7 @@ void ND_TetDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformPrimal(double *v) const
+void ND_TetDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -401,6 +345,17 @@ ND_TetDofTransformation::InvTransformPrimal(double *v) const
    // Transform face DoFs
    for (int f=0; f<4; f++)
    {
+      MFEM_ASSERT(Fo[f] >=0 && Fo[f] <= 5,
+                  [this]()
+      {
+         std::stringstream msg;
+         msg << "Orientations = ";
+         for (const auto &x : Fo)
+         {
+            msg << x << " ";
+         }
+         return msg.str();
+      }() << " are invalid");
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[6*nedofs + f*nfdofs + 2*i];
@@ -409,8 +364,7 @@ ND_TetDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::TransformDual(double *v) const
+void ND_TetDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -432,8 +386,7 @@ ND_TetDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformDual(double *v) const
+void ND_TetDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -482,8 +435,7 @@ void ND_WedgeDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
+void ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -505,8 +457,7 @@ ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::TransformDual(double *v) const
+void ND_WedgeDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -528,8 +479,7 @@ ND_WedgeDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformDual(double *v) const
+void ND_WedgeDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
diff --git a/fem/doftrans.hpp b/fem/doftrans.hpp
index 9375246b5..ddbb902a8 100644
--- a/fem/doftrans.hpp
+++ b/fem/doftrans.hpp
@@ -63,6 +63,12 @@ protected:
    DofTransformation(int size)
       : size_(size) {}
 
+   virtual void TransformPrimal(double *v) const = 0;
+   virtual void InvTransformPrimal(double *v) const = 0;
+   virtual void TransformDual(double *v) const = 0;
+   virtual void InvTransformDual(double *v) const = 0;
+
+   friend class VDofTransformation;
 public:
 
    inline int Size() const { return size_; }
@@ -75,7 +81,9 @@ public:
        current element. */
    /// The face_orientation array can be obtained from Mesh::GetElementFaces.
    inline void SetFaceOrientations(const Array<int> & face_orientation)
-   { Fo = face_orientation; }
+   {
+      Fo = face_orientation;
+   }
 
    inline const Array<int> & GetFaceOrientations() const { return Fo; }
 
@@ -83,38 +91,71 @@ public:
        transformation can be used to map the local vector computed by
        FiniteElement::Project() to the transformed vector stored within a
        GridFunction object. */
-   virtual void TransformPrimal(double *v) const = 0;
-   virtual void TransformPrimal(Vector &v) const;
+   inline void TransformPrimal(Vector &v) const
+   {
+      TransformPrimal(v.GetData());
+   }
 
    /// Transform groups of DoFs stored as dense matrices
-   virtual void TransformPrimalCols(DenseMatrix &V) const;
+   inline void TransformPrimalCols(DenseMatrix &V) const
+   {
+      for (int c=0; c<V.Width(); c++)
+      {
+         TransformPrimal(V.GetColumn(c));
+      }
+   }
 
    /** Inverse transform local DoFs. Used to transform DoFs from a global vector
        back to their element-local form. For example, this must be used to
        transform the vector obtained using GridFunction::GetSubVector before it
        can be used to compute a local interpolation.
    */
-   virtual void InvTransformPrimal(double *v) const = 0;
-   virtual void InvTransformPrimal(Vector &v) const;
+   inline void InvTransformPrimal(Vector &v) const
+   {
+      InvTransformPrimal(v.GetData());
+   }
 
    /** Transform dual DoFs as computed by a LinearFormIntegrator before summing
        into a LinearForm object. */
-   virtual void TransformDual(double *v) const = 0;
-   virtual void TransformDual(Vector &v) const;
+   inline void TransformDual(Vector &v) const
+   {
+      TransformDual(v.GetData());
+   }
 
    /** Inverse Transform dual DoFs */
-   virtual void InvTransformDual(double *v) const = 0;
-   virtual void InvTransformDual(Vector &v) const;
+   inline void InvTransformDual(Vector &v) const
+   {
+      InvTransformDual(v.GetData());
+   }
 
    /** Transform a matrix of dual DoFs entries as computed by a
        BilinearFormIntegrator before summing into a BilinearForm object. */
-   virtual void TransformDual(DenseMatrix &V) const;
+   inline void TransformDual(DenseMatrix &V) const
+   {
+      TransformDualCols(V);
+      TransformDualRows(V);
+   }
 
    /// Transform groups of dual DoFs stored as dense matrices
-   virtual void TransformDualRows(DenseMatrix &V) const;
-   virtual void TransformDualCols(DenseMatrix &V) const;
+   inline void TransformDualRows(DenseMatrix &V) const
+   {
+      Vector row;
+      for (int r=0; r<V.Height(); r++)
+      {
+         V.GetRow(r, row);
+         TransformDual(row);
+         V.SetRow(r, row);
+      }
+   }
+   inline void TransformDualCols(DenseMatrix &V) const
+   {
+      for (int c=0; c<V.Width(); c++)
+      {
+         TransformDual(V.GetColumn(c));
+      }
+   }
 
-   virtual ~DofTransformation() {}
+   virtual ~DofTransformation() = default;
 };
 
 /** Transform a matrix of DoFs entries from different finite element spaces as
@@ -181,18 +222,16 @@ public:
    /// Return the nested DofTransformation object
    inline DofTransformation * GetDofTransformation() const { return doftrans_; }
 
-   inline void SetFaceOrientation(const Array<int> & face_orientation)
-   { Fo = face_orientation; doftrans_->SetFaceOrientations(face_orientation); }
-
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-   void InvTransformPrimal(double *v) const;
-   void TransformDual(double *v) const;
-   void InvTransformDual(double *v) const;
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /** Abstract base class for high-order Nedelec spaces on elements with
@@ -237,15 +276,13 @@ public:
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
-
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
    using DofTransformation::InvTransformDual;
+
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /// DoF transformation implementation for the Nedelec basis on tetrahedra
@@ -259,13 +296,11 @@ public:
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /// DoF transformation implementation for the Nedelec basis on wedge elements
@@ -279,14 +314,11 @@ public:
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
-
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 } // namespace mfem
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index a4af691d7..4b98d3ea2 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -492,6 +492,7 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
 void IsoparametricTransformation::Transform (const IntegrationPoint &ip,
                                              Vector &trans)
 {
+   MFEM_ASSERT(FElem != nullptr, "!");
    shape.SetSize(FElem->GetDof());
    trans.SetSize(PointMat.Height());
 
diff --git a/fem/fe_coll.cpp b/fem/fe_coll.cpp
index fd7af135d..9dfb677f6 100644
--- a/fem/fe_coll.cpp
+++ b/fem/fe_coll.cpp
@@ -1713,7 +1713,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::SEGMENT] = new H1_SegmentElement(p, btype);
       }
 
-      SegDofOrd[0] = new int[2*pm1];
+      SegDofOrd[0] = (pm1 > 0) ? new int[2*pm1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pm1;
       for (int i = 0; i < pm1; i++)
       {
@@ -1751,7 +1751,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
 
       const int &TriDof = H1_dof[Geometry::TRIANGLE];
       const int &QuadDof = H1_dof[Geometry::SQUARE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -1772,7 +1772,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          }
       }
 
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -1855,7 +1855,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::PYRAMID] = new LinearPyramidFiniteElement;
 
          const int &TetDof = H1_dof[Geometry::TETRAHEDRON];
-         TetDofOrd[0] = new int[24*TetDof];
+         TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
          for (int i = 1; i < 24; i++)
          {
             TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2127,7 +2127,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       // No need to set the map_type for Tr_Elements.
 
       const int pp1 = p + 1;
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2160,7 +2160,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       }
 
       const int TriDof = L2_Elements[Geometry::TRIANGLE]->GetDof();
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2181,7 +2181,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
          }
       }
       const int QuadDof = L2_Elements[Geometry::SQUARE]->GetDof();
-      OtherDofOrd = new int[QuadDof];
+      OtherDofOrd = (QuadDof > 0) ? new int[QuadDof] : nullptr;
       for (int j = 0; j < QuadDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2225,7 +2225,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       const int PriDof = L2_Elements[Geometry::PRISM]->GetDof();
       const int MaxDof = std::max(TetDof, std::max(PriDof, HexDof));
 
-      TetDofOrd[0] = new int[24*TetDof];
+      TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
       for (int i = 1; i < 24; i++)
       {
          TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2314,7 +2314,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
             }
          }
       }
-      OtherDofOrd = new int[MaxDof];
+      OtherDofOrd = (MaxDof > 0) ? new int[MaxDof] : nullptr;
       for (int j = 0; j < MaxDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2502,7 +2502,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2523,7 +2523,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_dof[Geometry::SQUARE] = pp1*pp1;
 
       int TriDof = RT_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2553,7 +2553,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       }
 
       int QuadDof = RT_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2749,7 +2749,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_Elements[Geometry::SEGMENT] = new ND_SegmentElement(p, ob_type);
       ND_dof[Geometry::SEGMENT] = p;
 
-      SegDofOrd[0] = new int[2*p];
+      SegDofOrd[0] = (p > 0) ? new int[2*p] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + p;
       for (int i = 0; i < p; i++)
       {
@@ -2769,7 +2769,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_dof[Geometry::TRIANGLE] = p*pm1;
 
       int QuadDof = ND_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2813,7 +2813,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       }
 
       int TriDof = ND_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -3150,7 +3150,7 @@ ND_R2D_FECollection::ND_R2D_FECollection(const int p, const int dim,
                                                                  ob_type);
       ND_dof[Geometry::SEGMENT] = 2 * p - 1;
 
-      SegDofOrd[0] = new int[4 * p - 2];
+      SegDofOrd[0] = (4*p > 2) ? new int[4 * p - 2] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + 2 * p - 1;
       for (int i = 0; i < p; i++)
       {
@@ -3334,7 +3334,7 @@ void RT_R2D_FECollection::InitFaces(const int p, const int dim,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index 928b4e2ad..8ac7e590c 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -836,6 +836,9 @@ double GridFunction::GetValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -975,6 +978,9 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -999,6 +1005,8 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
          FaceElementTransformations * FET =
             dynamic_cast<FaceElementTransformations *>(&T);
 
+         MFEM_ASSERT(FET != nullptr,
+                     "FaceElementTransformation must be valid for a boundary element");
          // Evaluate in neighboring element for both continuous and
          // discontinuous fields (the integration point in T1 should have
          // already been set).
@@ -1116,11 +1124,10 @@ int GridFunction::GetFaceVectorValues(
    int i, int side, const IntegrationRule &ir,
    DenseMatrix &vals, DenseMatrix &tr) const
 {
-   int n, di;
+   int di;
    FaceElementTransformations *Transf;
 
-   n = ir.GetNPoints();
-   IntegrationRule eir(n);  // ---
+   IntegrationRule eir(ir.GetNPoints());  // ---
    Transf = fes->GetMesh()->GetFaceElementTransformations(i, 0);
    if (side == 2)
    {
@@ -1142,12 +1149,14 @@ int GridFunction::GetFaceVectorValues(
    if (di == 0)
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 5);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc1.Transform(ir, eir);
       GetVectorValues(*Transf->Elem1, eir, vals, &tr);
    }
    else
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 10);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc2.Transform(ir, eir);
       GetVectorValues(*Transf->Elem2, eir, vals, &tr);
    }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 6f0af11c6..8ff398bad 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -163,18 +163,18 @@ void ParFiniteElementSpace::Construct()
 
       // calculate number of ghost DOFs
       ngvdofs = pncmesh->GetNGhostVertices()
-                * fec->DofForGeometry(Geometry::POINT);
+                * fec->DofForGeometry(Geometry::Type::POINT);
 
       if (pmesh->Dimension() > 1)
       {
          ngedofs = pncmesh->GetNGhostEdges()
-                   * fec->DofForGeometry(Geometry::SEGMENT);
+                   * fec->DofForGeometry(Geometry::Type::SEGMENT);
       }
 
       if (pmesh->Dimension() > 2)
       {
-         int stride = fec->DofForGeometry(Geometry::SQUARE);
-         ngfdofs = pncmesh->GetNGhostFaces() * stride;
+         ngfdofs = pncmesh->GetNGhostFaces()
+                   * fec->DofForGeometry(Geometry::Type::SQUARE);
       }
 
       // total number of ghost DOFs. Ghost DOFs start at index 'ndofs', i.e.,
@@ -1173,6 +1173,7 @@ const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
             Pconf = new DeviceConformingProlongationOperator(*this);
          }
       }
+
       return Pconf;
    }
    else
@@ -1293,6 +1294,7 @@ void ParFiniteElementSpace::ExchangeFaceNbrData()
    // element)
    face_nbr_element_dof.MakeI(recv_el_off[num_face_nbrs]);
 
+
    int *send_I = send_nbr_elem_dof.GetI();
    int *recv_I = face_nbr_element_dof.GetI();
    for (int fn = 0; fn < num_face_nbrs; fn++)
@@ -1842,9 +1844,13 @@ int ParFiniteElementSpace::PackDof(int entity, int index, int edof) const
 static int bisect(const int* array, int size, int value)
 {
    const int* end = array + size;
-   const int* pos = std::lower_bound(array, end, value);
-   MFEM_VERIFY(pos != end, "value not found");
-   return pos - array;
+   const int* pos = std::upper_bound(array, end, value);
+   MFEM_VERIFY(pos != array, "value not found");
+   if (pos == end)
+   {
+      MFEM_VERIFY(*(array+size - 1) == value, "Last entry must be exact")
+   }
+   return pos - array - 1;
 }
 
 /** Dissect a DOF number to obtain the entity type (0=vertex, 1=edge, 2=face),
@@ -1880,7 +1886,8 @@ void ParFiniteElementSpace::UnpackDof(int dof,
          else // mixed faces or var-order space
          {
             const Table &table = var_face_dofs;
-            MFEM_ASSERT(table.Size(), "");
+
+            MFEM_ASSERT(table.Size() > 0, "");
             int jpos = bisect(table.GetJ(), table.Size_of_connections(), dof);
             index = bisect(table.GetI(), table.Size(), jpos);
             edof = dof - table.GetRow(index)[0];
@@ -1948,9 +1955,8 @@ struct PMatrixRow
    void AddRow(const PMatrixRow &other, double coef)
    {
       elems.reserve(elems.size() + other.elems.size());
-      for (unsigned i = 0; i < other.elems.size(); i++)
+      for (const PMatrixElement &oei : other.elems)
       {
-         const PMatrixElement &oei = other.elems[i];
          elems.push_back(
             PMatrixElement(oei.column, oei.stride, coef * oei.value));
       }
@@ -2010,7 +2016,6 @@ class NeighborRowMessage : public VarMessage<314>
 public:
    typedef NCMesh::MeshId MeshId;
    typedef ParNCMesh::GroupId GroupId;
-
    struct RowInfo
    {
       int entity, index, edof;
@@ -2022,8 +2027,6 @@ public:
 
       RowInfo(int ent, int idx, int edof, GroupId grp)
          : entity(ent), index(idx), edof(edof), group(grp) {}
-
-      typedef std::vector<RowInfo> List;
    };
 
    NeighborRowMessage() : pncmesh(NULL) {}
@@ -2034,7 +2037,7 @@ public:
       rows.push_back(RowInfo(entity, index, edof, group, row));
    }
 
-   const RowInfo::List& GetRows() const { return rows; }
+   const std::vector<RowInfo>& GetRows() const { return rows; }
 
    void SetNCMesh(ParNCMesh* pnc) { pncmesh = pnc; }
    void SetFEC(const FiniteElementCollection* fec_) { this->fec = fec_; }
@@ -2042,7 +2045,7 @@ public:
    typedef std::map<int, NeighborRowMessage> Map;
 
 protected:
-   RowInfo::List rows;
+   std::vector<RowInfo> rows;
 
    ParNCMesh *pncmesh;
    const FiniteElementCollection* fec;
@@ -2051,7 +2054,6 @@ protected:
    virtual void Decode(int);
 };
 
-
 void NeighborRowMessage::Encode(int rank)
 {
    std::ostringstream stream;
@@ -2088,6 +2090,7 @@ void NeighborRowMessage::Encode(int rank)
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+
          const RowInfo &ri = rows[row_idx[ent][i]];
          MFEM_ASSERT(ent == ri.entity, "");
 
@@ -2139,35 +2142,58 @@ void NeighborRowMessage::Decode(int rank)
    rows.reserve(nrows);
 
    // read rows
+   // ent = {0,1,2} means vertex, edge and face entity
    for (int ent = 0, gi = 0; ent < 3; ent++)
    {
+      // extract the vertex list, edge list or face list.
       const Array<MeshId> &ids = ent_ids[ent];
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+         // read the particular element dof value off the stream.
          int edof = bin_io::read<int>(stream);
 
-         // handle orientation and sign change
-         const int *ind = NULL;
+         // Handle orientation and sign change.
+         // This flips the sign on dofs where necessary, and for edges and faces
+         // also reorders if flipped, i.e. an edge with
+         //    1 -> 2 -> 3 -> 4
+         // might become
+         //    -4 -> -3 -> -2 -> -1
+         // This cannot treat all face dofs, as they can have rotations and
+         // reflections.
+         const int *ind = nullptr;
+         Geometry::Type geom;
          if (ent == 1)
          {
+            // edge NC orientation is element defined.
             int eo = pncmesh->GetEdgeNCOrientation(id);
             ind = fec->DofOrderForOrientation(Geometry::SEGMENT, eo);
          }
          else if (ent == 2)
          {
-            Geometry::Type geom = pncmesh->GetFaceGeometry(id.index);
+            geom = pncmesh->GetFaceGeometry(id.index);
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
 
-         double s = 1.0;
+#ifdef MFEM_DEBUG_PMATRIX
+         mfem::out << "Rank " << pncmesh->MyRank << " receiving from " << rank
+                   << ": ent " << ent << ", index " << id.index
+                   << ", edof " << edof << " (id " << id.element << "/"
+                   << int(id.local) << ")" << std::endl;
+#endif
+
+         // If edof arrived with a negative index, flip it, and the scaling.
+         double s = (edof < 0) ? -1.0 : 1.0;
+         edof = (edof < 0) ? -1 - edof : edof;
+
          if (ind && (edof = ind[edof]) < 0)
          {
             edof = -1 - edof;
-            s = -1.0;
+            s *= -1.0;
          }
 
+         // Create a row for this entity, recording the index of the mesh element
          rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
          rows.back().row.read(stream, s);
 
@@ -2177,6 +2203,65 @@ void NeighborRowMessage::Decode(int rank)
                    << rows.back().index << ", edof " << rows.back().edof
                    << std::endl;
 #endif
+
+         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
+             && !Geometry::IsTensorProduct(geom))
+         {
+            // ND face dofs need to be processed together, as the transformation
+            // is given by a 2x2 matrix, so we manually apply an extra increment
+            // to the loop counter and add in a new row. Once these rows are placed, they
+            // represent the Identity transformation. To map across the
+            // processor boundary, we also need to apply a Primal Transformation
+            // (see doftrans.hpp) to a notional "global dof" orientation.
+            // For simplicity we perform the action of these 2x2 matrices
+            // manually using the AddRow capability, followed by a Collapse.
+
+            // To perform the operations, we add and subtract initial versions
+            // of the rows, that represent [1 0; 0 1] in row major notation.
+            // The first row represents the 1 at (0,0) in [1 0; 0 1]
+            // The second row represents the 1 at (1,1) in [1 0; 0 1]
+
+            // We can safely bind this reference as rows was reserved above so
+            // there is no hidden copying that could result in a dangling reference.
+            auto &first_row = rows.back().row;
+            // This is the first "fundamental unit" used in the transformation.
+            const auto initial_first_row = first_row;
+            // Extract the next dof too, and apply any dof order transformation expected.
+            const MeshId &next_id = ids[++i];
+            int fo = pncmesh->GetFaceOrientation(next_id.index);
+            ind = fec->DofOrderForOrientation(geom, fo);
+
+            s = 1.0;
+            edof = bin_io::read<int>(stream);
+            if (ind && (edof = ind[edof]) < 0)
+            {
+               edof = -1 - edof;
+               s = -1.0;
+            }
+            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+            rows.back().row.read(stream, s);
+
+            auto &second_row = rows.back().row;
+
+            // This is the second "fundamental unit" used in the transformation.
+            const auto initial_second_row = second_row;
+
+            const auto T = [&fo]()
+            {
+               auto T = ND_DofTransformation::GetFaceTransform(fo);
+               T(0,0) -= 1;
+               T(1,1) -= 1;
+               return T;
+            }();
+
+            first_row.AddRow(initial_first_row, T(0,0));
+            first_row.AddRow(initial_second_row, T(0,1));
+            second_row.AddRow(initial_first_row, T(1,0));
+            second_row.AddRow(initial_second_row, T(1,1));
+
+            first_row.Collapse();
+            second_row.Collapse();
+         }
       }
    }
 }
@@ -2189,10 +2274,8 @@ ParFiniteElementSpace::ScheduleSendRow(const PMatrixRow &row, int dof,
    int ent, idx, edof;
    UnpackDof(dof, ent, idx, edof);
 
-   const ParNCMesh::CommGroup &group = pncmesh->GetGroup(group_id);
-   for (unsigned i = 0; i < group.size(); i++)
+   for (const auto &rank : pncmesh->GetGroup(group_id))
    {
-      int rank = group[i];
       if (rank != MyRank)
       {
          NeighborRowMessage &msg = send_msg[rank];
@@ -2306,13 +2389,7 @@ int ParFiniteElementSpace
                                        Array<int> *dof_tdof,
                                        bool partial) const
 {
-   // TODO: general face DOF transformations in NeighborRowMessage::Decode()
-   MFEM_VERIFY(!(fec->GetOrder() >= 2
-                 && pmesh->HasGeometry(Geometry::TETRAHEDRON)
-                 && fec->GetContType() == FiniteElementCollection::TANGENTIAL),
-               "Nedelec NC tets of order >= 2 are not supported yet.");
-
-   bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
+   const bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
 
 #ifdef MFEM_PMATRIX_STATS
    n_msgs_sent = n_msgs_recv = 0;
@@ -2321,7 +2398,7 @@ int ParFiniteElementSpace
 
    // *** STEP 1: build master-slave dependency lists ***
 
-   int total_dofs = ndofs + ngdofs;
+   const int total_dofs = ndofs + ngdofs;
    SparseMatrix deps(ndofs, total_dofs);
 
    if (!dg && !partial)
@@ -2332,16 +2409,14 @@ int ParFiniteElementSpace
       for (int entity = 0; entity <= 2; entity++)
       {
          const NCMesh::NCList &list = pncmesh->GetNCList(entity);
-         if (!list.masters.Size()) { continue; }
+         if (list.masters.Size() == 0) { continue; }
 
          IsoparametricTransformation T;
          DenseMatrix I;
 
          // process masters that we own or that affect our edges/faces
-         for (int mi = 0; mi < list.masters.Size(); mi++)
+         for (const auto &mf : list.masters)
          {
-            const NCMesh::Master &mf = list.masters[mi];
-
             // get master DOFs
             if (pncmesh->IsGhost(entity, mf.index))
             {
@@ -2352,10 +2427,10 @@ int ParFiniteElementSpace
                GetEntityDofs(entity, mf.index, master_dofs, mf.Geom());
             }
 
-            if (!master_dofs.Size()) { continue; }
+            if (master_dofs.Size() == 0) { continue; }
 
             const FiniteElement* fe = fec->FiniteElementForGeometry(mf.Geom());
-            if (!fe) { continue; }
+            if (fe == nullptr) { continue; }
 
             switch (mf.Geom())
             {
@@ -2371,7 +2446,7 @@ int ParFiniteElementSpace
                const NCMesh::Slave &sf = list.slaves[si];
                if (pncmesh->IsGhost(entity, sf.index)) { continue; }
 
-               const int variant = 0; // TODO parallel var-order
+               constexpr int variant = 0; // TODO parallel var-order
                GetEntityDofs(entity, sf.index, slave_dofs, mf.Geom(), variant);
                if (!slave_dofs.Size()) { continue; }
 
@@ -2398,37 +2473,37 @@ int ParFiniteElementSpace
    {
       Array<int> dofs;
 
-      // initialize dof_group[], dof_owner[]
-      for (int entity = 0; entity <= 2; entity++)
+      auto initialize_group_and_owner = [&dof_group, &dof_owner, &dofs,
+                                                     this](int entity, const MeshId &id)
       {
-         const NCMesh::NCList &list = pncmesh->GetNCList(entity);
-
-         int lsize[3] =
-         { list.conforming.Size(), list.masters.Size(), list.slaves.Size() };
+         if (id.index < 0) { return; }
 
-         for (int l = 0; l < 3; l++)
-         {
-            for (int i = 0; i < lsize[l]; i++)
-            {
-               const MeshId &id =
-                  (l == 0) ? list.conforming[i] :
-                  (l == 1) ? (const MeshId&) list.masters[i]
-                  /*    */ : (const MeshId&) list.slaves[i];
+         GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
+         GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
 
-               if (id.index < 0) { continue; }
+         GetBareDofs(entity, id.index, dofs);
 
-               GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
-               GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
-
-               GetBareDofs(entity, id.index, dofs);
+         for (auto dof : dofs)
+         {
+            dof_owner[dof] = owner;
+            dof_group[dof] = group;
+         }
+      };
 
-               for (int j = 0; j < dofs.Size(); j++)
-               {
-                  int dof = dofs[j];
-                  dof_owner[dof] = owner;
-                  dof_group[dof] = group;
-               }
-            }
+      // initialize dof_group[], dof_owner[] in sequence
+      for (int entity : {0,1,2})
+      {
+         for (const auto &id : pncmesh->GetNCList(entity).conforming)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).masters)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).slaves)
+         {
+            initialize_group_and_owner(entity, id);
          }
       }
    }
@@ -2440,15 +2515,50 @@ int ParFiniteElementSpace
 
    // DOFs that stayed independent and are ours are true DOFs
    int num_true_dofs = 0;
-   for (int i = 0; i < ndofs; i++)
+   for (int i = 0; i < ndofs; ++i)
    {
       if (dof_owner[i] == 0 && deps.RowSize(i) == 0)
       {
-         num_true_dofs++;
+         ++num_true_dofs;
          finalized[i] = true;
       }
    }
 
+#ifdef MFEM_DEBUG_PMATRIX
+   // Helper for dumping diagnostics on one dof
+   auto dof_diagnostics = [&](int dof, bool print_diagnostic)
+   {
+      const auto &comm_group = pncmesh->GetGroup(dof_group[dof]);
+      std::stringstream msg;
+      msg << std::boolalpha;
+      msg << "R" << Mpi::WorldRank() << " dof " << dof
+          << " owner_rank " << pncmesh->GetGroup(dof_owner[dof])[0] << " CommGroup {";
+      for (const auto &x : comm_group)
+      {
+         msg << x << ' ';
+      }
+      msg << "} finalized " << finalized[dof];
+
+      Array<int> cols;
+      if (dof < ndofs)
+      {
+         Vector row;
+         deps.GetRow(dof, cols, row);
+         msg << " deps cols {";
+         for (const auto &x : cols)
+         {
+            msg << x << ' ';
+         }
+         msg << '}';
+      }
+
+      int entity, index, edof;
+      UnpackDof(dof, entity, index, edof);
+      msg << " entity " << entity << " index " << index << " edof " << edof;
+      return msg.str();
+   };
+#endif
+
    // calculate global offsets
    HYPRE_BigInt loc_sizes[2] = { ndofs*vdim, num_true_dofs*vdim };
    Array<HYPRE_BigInt>* offsets[2] = { &dof_offs, &tdof_offs };
@@ -2470,10 +2580,10 @@ int ParFiniteElementSpace
 
    std::vector<PMatrixRow> pmatrix(total_dofs);
 
-   bool bynodes = (ordering == Ordering::byNODES);
-   int vdim_factor = bynodes ? 1 : vdim;
-   int dof_stride = bynodes ? ndofs : 1;
-   int tdof_stride = bynodes ? num_true_dofs : 1;
+   const bool bynodes = (ordering == Ordering::byNODES);
+   const int vdim_factor = bynodes ? 1 : vdim;
+   const int dof_stride = bynodes ? ndofs : 1;
+   const int tdof_stride = bynodes ? num_true_dofs : 1;
 
    // big container for all messages we send (the list is for iterations)
    std::list<NeighborRowMessage::Map> send_msg;
@@ -2495,13 +2605,13 @@ int ParFiniteElementSpace
 
          for (int vd = 0; vd < vdim; vd++)
          {
-            int vdof = dof*vdim_factor + vd*dof_stride;
-            int vtdof = tdof*vdim_factor + vd*tdof_stride;
+            const int vdof = dof*vdim_factor + vd*dof_stride;
+            const int vtdof = tdof*vdim_factor + vd*tdof_stride;
 
             if (R_) { (*R_)->Add(vtdof, vdof, 1.0); }
             if (dof_tdof) { (*dof_tdof)[vdof] = vtdof; }
          }
-         tdof++;
+         ++tdof;
       }
    }
 
@@ -2542,14 +2652,12 @@ int ParFiniteElementSpace
          n_rows_recv += recv_msg.GetRows().size();
 #endif
 
-         const NeighborRowMessage::RowInfo::List &rows = recv_msg.GetRows();
-         for (unsigned i = 0; i < rows.size(); i++)
+         for (const auto &ri : recv_msg.GetRows())
          {
-            const NeighborRowMessage::RowInfo &ri = rows[i];
-            int dof = PackDof(ri.entity, ri.index, ri.edof);
+            const int dof = PackDof(ri.entity, ri.index, ri.edof);
             pmatrix[dof] = ri.row;
 
-            if (dof < ndofs && !finalized[dof]) { num_finalized++; }
+            if (dof < ndofs && !finalized[dof]) { ++num_finalized; }
             finalized[dof] = true;
 
             if (ri.group >= 0 && dof_group[dof] != ri.group)
@@ -2567,13 +2675,14 @@ int ParFiniteElementSpace
          done = true;
          for (int dof = 0; dof < ndofs; dof++)
          {
-            if (finalized[dof]) { continue; }
-
-            bool owned = (dof_owner[dof] == 0);
-            bool shared = (dof_group[dof] != 0);
-
-            if (owned && DofFinalizable(dof, finalized, deps))
+            const bool owned = (dof_owner[dof] == 0);
+            if (!finalized[dof]
+                && owned
+                && DofFinalizable(dof, finalized, deps))
             {
+               int ent, idx, edof;
+               UnpackDof(dof, ent, idx, edof);
+
                const int* dep_col = deps.GetRowColumns(dof);
                const double* dep_coef = deps.GetRowEntries(dof);
                int num_dep = deps.RowSize(dof);
@@ -2588,10 +2697,11 @@ int ParFiniteElementSpace
                pmatrix[dof] = buffer;
 
                finalized[dof] = true;
-               num_finalized++;
+               ++num_finalized;
                done = false;
 
                // send row to neighbors who need it
+               const bool shared = (dof_group[dof] != 0);
                if (shared)
                {
                   ScheduleSendRow(pmatrix[dof], dof, dof_group[dof],
@@ -2602,7 +2712,7 @@ int ParFiniteElementSpace
       }
 
 #ifdef MFEM_DEBUG_PMATRIX
-      /*static int dump = 0;
+      static int dump = 0;
       if (dump < 10)
       {
          char fname[100];
@@ -2610,7 +2720,7 @@ int ParFiniteElementSpace
          std::ofstream f(fname);
          DebugDumpDOFs(f, deps, dof_group, dof_owner, finalized);
          dump++;
-      }*/
+      }
 #endif
 
       // send current batch of messages
@@ -2635,10 +2745,9 @@ int ParFiniteElementSpace
    }
 
    // make sure we can discard all send buffers
-   for (std::list<NeighborRowMessage::Map>::iterator
-        it = send_msg.begin(); it != send_msg.end(); ++it)
+   for (auto &msg : send_msg)
    {
-      NeighborRowMessage::WaitAllSent(*it);
+      NeighborRowMessage::WaitAllSent(msg);
    }
 
 #ifdef MFEM_PMATRIX_STATS
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index 182f1b12a..fd6fa2260 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -469,17 +469,17 @@ void ParGridFunction::GetVectorValue(ElementTransformation &T,
    }
 
    Array<int> vdofs;
-   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no,
-                                                               vdofs);
-   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
-
-   int dof = fe->GetDof();
+   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no, vdofs);
    Vector loc_data;
    face_nbr_data.GetSubVector(vdofs, loc_data);
    if (doftrans)
    {
       doftrans->InvTransformPrimal(loc_data);
    }
+
+   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
+   int dof = fe->GetDof();
+
    if (fe->GetRangeType() == FiniteElement::SCALAR)
    {
       Vector shape(dof);
diff --git a/general/table.cpp b/general/table.cpp
index 4c0bb68ee..da4c0187b 100644
--- a/general/table.cpp
+++ b/general/table.cpp
@@ -218,7 +218,8 @@ void Table::SetIJ(int *newI, int *newJ, int newsize)
 
 int Table::Push(int i, int j)
 {
-   MFEM_ASSERT( i >=0 && i<size, "Index out of bounds.  i = "<<i);
+   MFEM_ASSERT( i >=0 &&
+                i<size, "Index out of bounds.  i = " << i << " size " << size);
 
    for (int k = I[i], end = I[i+1]; k < end; k++)
    {
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 446257416..4ef3ae34c 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1102,6 +1102,7 @@ FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
    {
       return NULL;
    }
+
    tr = GetFaceElementTransformations(fn, 21);
    tr->Attribute = boundary[BdrElemNo]->GetAttribute();
    tr->ElementNo = BdrElemNo;
@@ -1932,7 +1933,7 @@ void Mesh::GenerateBoundaryElements()
          be2face[j++] = i;
       }
    }
-   // In 3D, 'bel_to_edge' is destroyed but it's not updated.
+   // In 3D, 'be_to_edge' is destroyed but it's not updated.
 }
 
 void Mesh::FinalizeCheck()
@@ -6864,7 +6865,7 @@ STable3D *Mesh::GetFacesTable()
             break;
          }
          default:
-            MFEM_ABORT("Unexpected type of Element.");
+            MFEM_ABORT("Unexpected type of Element: " << GetElementType(i));
       }
    }
    return faces_tbl;
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index d15dbed23..381e73f60 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -2176,9 +2176,9 @@ void NCMesh::UpdateVertices()
    //   - ghost (non-local) vertices (code -3)
    //   - vertices beyond the ghost layer (code -4)
 
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto & node : nodes)
    {
-      node->vert_index = -4; // assume beyond ghost layer
+      node.vert_index = -4; // assume beyond ghost layer
    }
 
    for (int i = 0; i < leaf_elements.Size(); i++)
@@ -2208,11 +2208,11 @@ void NCMesh::UpdateVertices()
    // STEP 2: assign indices of top-level local vertices, in original order
 
    NVertices = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->vert_index == -1)
+      if (node.vert_index == -1)
       {
-         node->vert_index = NVertices++;
+         node.vert_index = NVertices++;
       }
    }
 
@@ -2308,20 +2308,20 @@ void NCMesh::UpdateVertices()
       }
 
       vertex_nodeId.SetSize(NVertices);
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index >= 0)
+         if (node.HasVertex() && node.vert_index >= 0)
          {
-            vertex_nodeId[node->vert_index] = node.index();
+            vertex_nodeId[node.vert_index] = node.index();
          }
       }
 
       NGhostVertices = 0;
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index < 0)
+         if (node.HasVertex() && node.vert_index < 0)
          {
-            node->vert_index = NVertices + (NGhostVertices++);
+            node.vert_index = NVertices + (NGhostVertices++);
          }
       }
    }
@@ -2545,13 +2545,13 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
    NFaces = mesh->GetNumFaces();
    if (Dim < 2) { NFaces = 0; }
    // clear Node::edge_index and Face::index
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge()) { node->edge_index = -1; }
+      if (node.HasEdge()) { node.edge_index = -1; }
    }
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      face->index = -1;
+      face.index = -1;
    }
 
    // get edge enumeration from the Mesh
@@ -2615,19 +2615,19 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
 
    // count ghost edges and assign their indices
    NGhostEdges = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge() && node->edge_index < 0)
+      if (node.HasEdge() && node.edge_index < 0)
       {
-         node->edge_index = NEdges + (NGhostEdges++);
+         node.edge_index = NEdges + (NGhostEdges++);
       }
    }
 
    // count ghost faces
    NGhostFaces = 0;
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { NGhostFaces++; }
+      if (face.index < 0) { NGhostFaces++; }
    }
 
    if (Dim == 2)
@@ -2671,9 +2671,9 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
    }
 
    // assign valid indices also to faces beyond the ghost layer
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { face->index = NFaces + (nghosts++); }
+      if (face.index < 0) { face.index = NFaces + (nghosts++); }
    }
    MFEM_ASSERT(nghosts == NGhostFaces, "");
 }
@@ -3452,7 +3452,7 @@ const NCMesh::MeshId& NCMesh::NCList::LookUp(int index, int *type) const
 
    if (!type)
    {
-      MFEM_VERIFY(key >= 0, "entity not found.");
+      MFEM_VERIFY(key >= 0, "index " << index << " not found.");
    }
    else // return entity type if requested, don't abort when not found
    {
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index 8392d2b67..83710fb50 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -34,7 +34,6 @@ ParMesh::ParMesh(const ParMesh &pmesh, bool copy_nodes)
      group_sedge(pmesh.group_sedge),
      group_stria(pmesh.group_stria),
      group_squad(pmesh.group_squad),
-     face_nbr_el_to_face(NULL),
      glob_elem_offset(-1),
      glob_offset_sequence(-1),
      gtopo(pmesh.gtopo)
@@ -106,8 +105,7 @@ ParMesh& ParMesh::operator=(ParMesh &&mesh)
 
 ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
                  int part_method)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -854,7 +852,6 @@ ParMesh::ParMesh(const ParNCMesh &pncmesh)
    : MyComm(pncmesh.MyComm)
    , NRanks(pncmesh.NRanks)
    , MyRank(pncmesh.MyRank)
-   , face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(MyComm)
@@ -906,7 +903,7 @@ void ParMesh::FinalizeParTopo()
    sface_lface.SetSize(nst + shared_quads.Size());
    if (sface_lface.Size())
    {
-      STable3D *faces_tbl = GetFacesTable();
+      auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
       for (int st = 0; st < nst; st++)
       {
          const int *v = shared_trias[st].v;
@@ -917,13 +914,11 @@ void ParMesh::FinalizeParTopo()
          const int *v = shared_quads[sq].v;
          sface_lface[nst+sq] = (*faces_tbl)(v[0], v[1], v[2], v[3]);
       }
-      delete faces_tbl;
    }
 }
 
 ParMesh::ParMesh(MPI_Comm comm, istream &input, bool refine)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -1134,7 +1129,7 @@ void ParMesh::MakeRefined_(ParMesh &orig_mesh, int ref_factor, int ref_type)
    MyComm = orig_mesh.GetComm();
    NRanks = orig_mesh.GetNRanks();
    MyRank = orig_mesh.GetMyRank();
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
    glob_elem_offset = -1;
    glob_offset_sequence = -1;
    gtopo = orig_mesh.gtopo;
@@ -2123,11 +2118,10 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors without communication
+      // with ParNCMesh we can set up face neighbors mostly without communication
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
-      ExchangeFaceNbrNodes();
       return;
    }
 
@@ -2192,7 +2186,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Dim == 3)
    {
-      GetFaceNbrElementToFaceTable();
+      BuildFaceNbrElementToFaceTable();
    }
 
    if (del_tables) { delete gr_sface; }
@@ -2320,6 +2314,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
    el_marker = -1;
    vertex_marker = -1;
    const int nst = shared_trias.Size();
+
    for (int fn = 0; fn < num_face_nbrs; fn++)
    {
       int nbr_group = face_nbr_group[fn];
@@ -2457,8 +2452,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
 
    // convert the element data into face_nbr_elements
    face_nbr_elements.SetSize(face_nbr_elements_offset[num_face_nbrs]);
-   face_nbr_el_ori.Clear();
-   face_nbr_el_ori.SetSize(face_nbr_elements_offset[num_face_nbrs], 6);
+   face_nbr_el_ori.reset(new Table(face_nbr_elements_offset[num_face_nbrs], 6));
    while (true)
    {
       int fn;
@@ -2489,7 +2483,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          if (Dim == 3)
          {
             int nf = el->GetNFaces();
-            int * fn_ori = face_nbr_el_ori.GetRow(elem_off);
+            int * fn_ori = face_nbr_el_ori->GetRow(elem_off);
             for (int j = 0; j < nf; j++)
             {
                fn_ori[j] = recv_elemdata[j];
@@ -2499,7 +2493,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          face_nbr_elements[elem_off++] = el;
       }
    }
-   face_nbr_el_ori.Finalize();
+   face_nbr_el_ori->Finalize();
 
    MPI_Waitall(num_face_nbrs, send_requests, statuses);
 
@@ -2721,191 +2715,118 @@ STable3D *ParMesh::GetSharedFacesTable()
    return sfaces_tbl;
 }
 
-STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
+template <int N>
+void
+ParMesh::AddTriFaces(const Array<int> &elem_vertices,
+                     const std::unique_ptr<STable3D> &faces,
+                     const std::unique_ptr<STable3D> &shared_faces,
+                     int elem, int start, int end, const int fverts[][N])
 {
-   int i, *v;
-   STable3D * faces_tbl = GetFacesTable();
-   STable3D * sfaces_tbl = GetSharedFacesTable();
-
-   if (face_nbr_el_to_face != NULL)
+   for (int i = start; i < end; ++i)
    {
-      delete face_nbr_el_to_face;
+      // Reference face vertices.
+      const auto fv = fverts[i];
+      // Element specific face vertices.
+      const Vert3 elem_fv(elem_vertices[fv[0]], elem_vertices[fv[1]],
+                          elem_vertices[fv[2]]);
+
+      // Check amongst the faces of elements local to this rank for this set of vertices
+      const int lf = faces->Index(elem_fv.v[0], elem_fv.v[1], elem_fv.v[2]);
+
+      // If the face wasn't found amonst processor local elements, search the
+      // ghosts for this set of vertices.
+      const int sf = lf < 0 ? shared_faces->Index(elem_fv.v[0], elem_fv.v[1],
+                                                  elem_fv.v[2]) : -1;
+      // If find local face -> use that
+      //    else if find shared face -> shift and use that
+      //       else no face found -> set to -1
+      const int face_to_add = lf < 0 ? (sf >= 0 ? sf + NumOfFaces : -1) : lf;
+
+      MFEM_ASSERT(sf >= 0 ||
+                  lf >= 0, "Face must be from a local or a face neighbor element");
+
+      // Add this discovered face to the list of faces of this face neighbor element
+      face_nbr_el_to_face->Push(elem, face_to_add);
    }
-   face_nbr_el_to_face = new Table(face_nbr_elements.Size(), 6);
-   for (i = 0; i < face_nbr_elements.Size(); i++)
+}
+
+void ParMesh::BuildFaceNbrElementToFaceTable()
+{
+   const auto faces = std::unique_ptr<STable3D>(GetFacesTable());
+   const auto shared_faces = std::unique_ptr<STable3D>(GetSharedFacesTable());
+
+   face_nbr_el_to_face.reset(new Table(face_nbr_elements.Size(), 6));
+
+   mfem::Array<int> v;
+
+   // Helper for adding quadrilateral faces.
+   auto add_quad_faces = [&faces, &shared_faces, &v, this]
+                         (int elem, int start, int end, const int fverts[][4])
    {
-      v = face_nbr_elements[i]->GetVertices();
-      switch (face_nbr_elements[i]->GetType())
+      for (int i = start; i < end; ++i)
       {
-         case Element::TETRAHEDRON:
+         const int * const fv = fverts[i];
+         int k = 0;
+         int max = v[fv[0]];
+
+         if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
+         if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
+         if (max < v[fv[3]]) { k = 3; }
+
+         int v0 = -1, v1 = -1, v2 = -1;
+         switch (k)
          {
-            for (int j = 0; j < 4; j++)
+            case 0:
+               v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 1:
+               v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 2:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
+               break;
+            case 3:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
+               break;
+         }
+         int lf = faces->Index(v0, v1, v2);
+         if (lf < 0)
+         {
+            lf = shared_faces->Index(v0, v1, v2);
+            if (lf >= 0)
             {
-               const int *fv = tet_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
+               lf += NumOfFaces;
             }
+         }
+         face_nbr_el_to_face->Push(elem, lf);
+      }
+   };
+
+   for (int i = 0; i < face_nbr_elements.Size(); i++)
+   {
+      face_nbr_elements[i]->GetVertices(v);
+      switch (face_nbr_elements[i]->GetType())
+      {
+         case Element::TETRAHEDRON:
+         {
+            AddTriFaces(v, faces, shared_faces, i, 0, 4, tet_t::FaceVert);
             break;
          }
          case Element::WEDGE:
          {
-            for (int j = 0; j < 2; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 2; j < 5; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            AddTriFaces(v, faces, shared_faces, i, 0, 2, pri_t::FaceVert);
+            add_quad_faces(i, 2, 5, pri_t::FaceVert);
             break;
          }
          case Element::PYRAMID:
          {
-            for (int j = 0; j < 1; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 1; j < 5; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 1, pyr_t::FaceVert);
+            AddTriFaces(v, faces, shared_faces, i, 1, 5, pyr_t::FaceVert);
             break;
          }
          case Element::HEXAHEDRON:
          {
-            // find the face by the vertices with the smallest 3 numbers
-            // z = 0, y = 0, x = 1, y = 1, x = 0, z = 1
-            for (int j = 0; j < 6; j++)
-            {
-               const int *fv = hex_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 6, hex_t::FaceVert);
             break;
          }
          default:
@@ -2913,14 +2834,6 @@ STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
       }
    }
    face_nbr_el_to_face->Finalize();
-
-   delete sfaces_tbl;
-   if (ret_ftbl)
-   {
-      return faces_tbl;
-   }
-   delete faces_tbl;
-   return NULL;
 }
 
 int ParMesh::GetFaceNbrRank(int fn) const
@@ -2941,33 +2854,31 @@ int ParMesh::GetFaceNbrRank(int fn) const
 }
 
 void
-ParMesh::GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const
+ParMesh::GetFaceNbrElementFaces(int i, Array<int> &faces,
+                                Array<int> &orientations) const
 {
-   int n, j;
    int el_nbr = i - GetNE();
-   if (face_nbr_el_to_face)
+   if (face_nbr_el_to_face != nullptr && el_nbr < face_nbr_el_to_face->Size())
    {
-      face_nbr_el_to_face->GetRow(el_nbr, fcs);
+      face_nbr_el_to_face->GetRow(el_nbr, faces);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
                  "face_nbr_el_to_face not generated.");
    }
-   if (el_nbr < face_nbr_el_ori.Size())
+
+   if (face_nbr_el_ori != nullptr && el_nbr < face_nbr_el_ori->Size())
    {
-      const int * row = face_nbr_el_ori.GetRow(el_nbr);
-      n = fcs.Size();
-      cor.SetSize(n);
-      for (j=0; j<n; j++)
-      {
-         cor[j] = row[j];
-      }
+      face_nbr_el_ori->GetRow(el_nbr, orientations);
    }
    else
    {
-      MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+      // No face_nbr_el_ori was generated, make the orientations invalid.
+      // This will cause errors if the face orientations are necessary to
+      // evaluate the basis in face neighbor elements.
+      orientations.SetSize(faces.Size());
+      orientations = -1;
    }
 }
 
@@ -3227,7 +3138,7 @@ int ParMesh::GetSharedFace(int sface) const
    {
       MFEM_ASSERT(Dim > 1, "");
       const NCMesh::NCList &shared = pncmesh->GetSharedList(Dim-1);
-      int csize = (int) shared.conforming.Size();
+      int csize = shared.conforming.Size();
       return sface < csize
              ? shared.conforming[sface].index
              : shared.slaves[sface - csize].index;
@@ -4593,7 +4504,7 @@ void ParMesh::UniformRefinement3D()
 
    DSTable v_to_v(NumOfVertices);
    GetVertexToVertexTable(v_to_v);
-   STable3D *faces_tbl = GetFacesTable();
+   auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
 
    // call Mesh::UniformRefinement3D_base so that it won't update the nodes
    Array<int> f2qf;
@@ -4608,7 +4519,6 @@ void ParMesh::UniformRefinement3D()
    // update the groups
    UniformRefineGroups3D(old_nv, old_nedges, v_to_v, *faces_tbl,
                          f2qf.Size() ? &f2qf : NULL);
-   delete faces_tbl;
 
    UpdateNodes();
 }
@@ -6707,6 +6617,8 @@ void ParMesh::Swap(ParMesh &other)
    mfem::Swap(face_nbr_vertices, other.face_nbr_vertices);
    mfem::Swap(send_face_nbr_elements, other.send_face_nbr_elements);
    mfem::Swap(send_face_nbr_vertices, other.send_face_nbr_vertices);
+   std::swap(face_nbr_el_ori, other.face_nbr_el_ori);
+   std::swap(face_nbr_el_to_face, other.face_nbr_el_to_face);
 
    // Nodes, NCMesh, and NURBSExtension are taken care of by Mesh::Swap
    mfem::Swap(pncmesh, other.pncmesh);
@@ -6727,8 +6639,7 @@ void ParMesh::Destroy()
    }
    shared_edges.DeleteAll();
 
-   delete face_nbr_el_to_face;
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
 }
 
 ParMesh::~ParMesh()
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 6ad702b58..fc688c360 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -77,8 +77,11 @@ protected:
    // sface ids: all triangles first, then all quads
    Array<int> sface_lface;
 
-   Table *face_nbr_el_to_face;
-   Table  face_nbr_el_ori; // orientations for each face (from nbr processor)
+   /// Table that maps from face neighbor element number, to the face numbers of
+   /// that element.
+   std::unique_ptr<Table> face_nbr_el_to_face;
+   /// orientations for each face (from nbr processor)
+   std::unique_ptr<Table> face_nbr_el_ori;
 
    IsoparametricTransformation FaceNbrTransformation;
 
@@ -113,7 +116,32 @@ protected:
    bool DecodeFaceSplittings(HashTable<Hashed2> &v_to_v, const int *v,
                              const Array<unsigned> &codes, int &pos);
 
-   STable3D *GetFaceNbrElementToFaceTable(int ret_ftbl = 0);
+   // Given a completed FacesTable and SharedFacesTable, construct a table that
+   // maps from face neighbor element number, to the set of faces of that
+   // element. Store the resulting data in the member variable
+   // face_nbr_el_to_face. If the mesh is nonconforming, this also builds the
+   // the face_nbr_el_ori variable from the faces_info.
+   void BuildFaceNbrElementToFaceTable();
+
+   /**
+    * @brief Helper function for adding triangle face neighbor element to face
+    * table entries. Have to use a template here rather than lambda capture
+    * because the FaceVert entries in Geometry have inner size of 3 for tets and
+    * 4 for everything else.
+    *
+    * @tparam N Inner dimension on the fvert variable, 3 for tet, 4 otherwise
+    * @param v Set of vertices for this element
+    * @param faces Table of faces interior to this rank
+    * @param shared_faces Table of faces shared by this rank and another
+    * @param elem The face neighbor element
+    * @param start Starting index into fverts
+    * @param end End index into fverts
+    * @param fverts Array of face vertices for this particular geometry.
+    */
+   template <int N>
+   void AddTriFaces(const Array<int> &v, const std::unique_ptr<STable3D> &faces,
+                    const std::unique_ptr<STable3D> &shared_faces,
+                    int elem, int start, int end, const int fverts[][N]);
 
    void GetFaceNbrElementTransformation(
       int i, IsoparametricTransformation *ElTr);
@@ -287,7 +315,7 @@ protected:
 
 public:
    /// Default constructor. Create an empty @a ParMesh.
-   ParMesh() : MyComm(0), NRanks(0), MyRank(-1), face_nbr_el_to_face(NULL),
+   ParMesh() : MyComm(0), NRanks(0), MyRank(-1),
       glob_elem_offset(-1), glob_offset_sequence(-1),
       have_face_nbr_data(false), pncmesh(NULL) { }
 
@@ -465,7 +493,8 @@ public:
    int GetFaceNbrRank(int fn) const;
 
    /** Similar to Mesh::GetElementFaces */
-   void GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const;
+   void GetFaceNbrElementFaces(int i, Array<int> &faces,
+                               Array<int> &orientation) const;
 
    /** Similar to Mesh::GetFaceToElementTable with added face-neighbor elements
        with indices offset by the local number of elements. */
@@ -555,6 +584,8 @@ public:
    /// Return the local face index for the given shared face.
    int GetSharedFace(int sface) const;
 
+
+
    /** @brief Returns the number of local faces according to the requested type,
        does not count master non-conforming faces.
 
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index 4a14d0c1d..300595296 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -16,10 +16,12 @@
 #include "mesh_headers.hpp"
 #include "pncmesh.hpp"
 #include "../general/binaryio.hpp"
+#include "../general/communication.hpp"
 
 #include <numeric> // std::accumulate
 #include <map>
 #include <climits> // INT_MIN, INT_MAX
+#include <array>
 
 namespace mfem
 {
@@ -435,25 +437,21 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
    entity_group = 0;
 
    CommGroup group;
-   group.reserve(128);
 
-   int begin = 0, end = 0;
-   while (begin < index_rank.Size())
+   for (auto begin = index_rank.begin(); begin != index_rank.end(); /* nothing */)
    {
-      int index = index_rank[begin].from;
-      if (index >= nentities)
-      {
-         break; // probably creating entity_conf_group (no ghosts)
-      }
-      while (end < index_rank.Size() && index_rank[end].from == index)
-      {
-         end++;
-      }
-      group.resize(end - begin);
-      for (int i = begin; i < end; i++)
-      {
-         group[i - begin] = index_rank[i].to;
-      }
+      const auto &index = begin->from;
+      if (index >= nentities) { break; }
+
+      // Locate the next connection that is not from this index
+      const auto end = std::find_if(begin, index_rank.end(),
+      [&index](const mfem::Connection &c) { return c.from != index;});
+
+      // For each connection from this index, collect the ranks connected.
+      group.resize(std::distance(begin, end));
+      std::transform(begin, end, group.begin(), [](const mfem::Connection &c) { return c.to; });
+
+      // assign this entity's group and advance the search start
       entity_group[index] = GetGroupId(group);
       begin = end;
    }
@@ -461,9 +459,9 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
 
 void ParNCMesh::AddConnections(int entity, int index, const Array<int> &ranks)
 {
-   for (int i = 0; i < ranks.Size(); i++)
+   for (auto rank : ranks)
    {
-      entity_index_rank[entity].Append(Connection(index, ranks[i]));
+      entity_index_rank[entity].Append(Connection(index, rank));
    }
 }
 
@@ -480,9 +478,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    ranks.Reserve(256);
 
    // connect slave edges to master edges and their vertices
-   for (int i = 0; i < shared_edges.masters.Size(); i++)
+   for (const auto &master_edge : shared_edges.masters)
    {
-      const Master &master_edge = shared_edges.masters[i];
       ranks.SetSize(0);
       for (int j = master_edge.slaves_begin; j < master_edge.slaves_end; j++)
       {
@@ -502,9 +499,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    }
 
    // connect slave faces to master faces and their edges and vertices
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const auto &master_face : shared_faces.masters)
    {
-      const Master &master_face = shared_faces.masters[i];
       ranks.SetSize(0);
       for (int j = master_face.slaves_begin; j < master_face.slaves_end; j++)
       {
@@ -893,6 +889,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
 
    Array<Element*> fnbr;
    Array<Connection> send_elems;
+   std::map<int, std::vector<int>> recv_elems;
 
    // Counts the number of slave faces of a master. This may be larger than the
    // number of shared slaves if there exist degenerate slave-faces from face-edge constraints.
@@ -907,8 +904,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    fnbr.Reserve(bound);
    send_elems.Reserve(bound);
 
+   // If there are face neighbor elements with triangular faces, the
+   // `face_nbr_el_ori` structure will need to be built. This requires
+   // communication so we attempt to avoid it by checking first.
+   bool face_nbr_w_tri_faces = false;
+
    // go over all shared faces and collect face neighbor elements
-   for (int i = 0; i < shared.conforming.Size(); i++)
+   for (int i = 0; i < shared.conforming.Size(); ++i)
    {
       const MeshId &cf = shared.conforming[i];
       Face* face = GetFace(elements[cf.element], cf.local);
@@ -920,8 +922,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       if (e[0]->rank == MyRank) { std::swap(e[0], e[1]); }
       MFEM_ASSERT(e[0]->rank != MyRank && e[1]->rank == MyRank, "");
 
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
       fnbr.Append(e[0]);
       send_elems.Append(Connection(e[0]->rank, e[1]->index));
+      recv_elems[e[0]->rank].push_back(e[0]->index);
    }
 
    for (int i = 0; i < shared.masters.Size(); i++)
@@ -944,8 +950,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          }
          if (loc0) { std::swap(e[0], e[1]); }
 
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
          fnbr.Append(e[0]);
          send_elems.Append(Connection(e[0]->rank, e[1]->index));
+         recv_elems[e[0]->rank].push_back(e[0]->index);
       }
    }
 
@@ -1028,6 +1038,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    send_elems.Sort();
    send_elems.Unique();
 
+   for (auto &kv : recv_elems)
+   {
+      std::sort(kv.second.begin(), kv.second.end());
+      kv.second.erase(std::unique(kv.second.begin(), kv.second.end()),
+                      kv.second.end());
+   }
+
    for (int i = 0, last_rank = -1; i < send_elems.Size(); i++)
    {
       Connection &c = send_elems[i];
@@ -1181,6 +1198,118 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       }
    }
 
+
+   // In 3D some extra orientation data structures can be needed.
+   if (Dim == 3)
+   {
+      // Populates face_nbr_el_to_face, always needed.
+      pmesh.BuildFaceNbrElementToFaceTable();
+
+      if (face_nbr_w_tri_faces)
+      {
+         // There are face neighbor elements with triangular faces, need to
+         // perform communication to ensure the orientation is valid.
+         using RankToOrientation = std::map<int, std::vector<std::array<int, 6>>>;
+         constexpr std::array<int, 6> unset_ori{{-1,-1,-1,-1,-1,-1}};
+         const int rank = pmesh.GetMyRank();
+
+         // Loop over send elems, compute the orientation and place in the buffer to
+         // send to each processor. Note elements are lexicographically sorted
+         // with rank and element number, and this ordering holds across processors.
+         RankToOrientation send_rank_to_face_neighbor_orientations;
+         Array<int> orientations, faces;
+
+         // send_elems goes from rank of the receiving processor, to the index
+         // of the face neighbor element on this processor.
+         for (const auto &se : send_elems)
+         {
+            const auto &true_rank = pmesh.face_nbr_group[se.from];
+            pmesh.GetElementFaces(se.to, faces, orientations);
+
+            // Place a new entry of unset orientations
+            send_rank_to_face_neighbor_orientations[true_rank].emplace_back(unset_ori);
+
+            // Copy the entries, any unset faces will remain -1.
+            std::copy(orientations.begin(), orientations.end(),
+                      send_rank_to_face_neighbor_orientations[true_rank].back().begin());
+         }
+
+         // Initialize the receive buffers and resize to match the expected
+         // number of elements coming in. The copy ensures the appropriate rank
+         // pairings are in place, and for a purely conformal interface, the
+         // resize is a no-op.
+         auto recv_rank_to_face_neighbor_orientations =
+            send_rank_to_face_neighbor_orientations;
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            kv.second.resize(recv_elems[kv.first].size());
+         }
+
+         // For asynchronous send/recv, will use arrays of requests to monitor the
+         // status of the connections.
+         std::vector<MPI_Request> send_requests, recv_requests;
+         std::vector<MPI_Status> status(nranks);
+
+         // NOTE: This is CRITICAL, to ensure the addresses of these requests
+         // do not change between the send/recv and the wait.
+         send_requests.reserve(nranks);
+         recv_requests.reserve(nranks);
+
+         // Shared face communication is bidirectional -> any rank to whom
+         // orientations must be sent, will need to send orientations back.
+         // The orientation data is contiguous because std::array<int,6> is an
+         // aggregate.
+
+         // Loop over each communication pairing, and dispatch the buffer loaded
+         // with  all the orientation data.
+         for (const auto &kv : send_rank_to_face_neighbor_orientations)
+         {
+            send_requests.emplace_back(); // instantiate a request for tracking.
+
+            // low rank sends on low, high rank sends on high.
+            const int send_tag = (rank < kv.first)
+                                 ? std::min(rank, kv.first)
+                                 : std::max(rank, kv.first);
+            MPI_Isend(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, send_tag, pmesh.MyComm, &send_requests.back());
+         }
+
+         // Loop over the communication pairing again, and receive the
+         // symmetric buffer from the other processor.
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            recv_requests.emplace_back(); // instantiate a request for tracking
+
+            // low rank receives on high, high rank receives on low.
+            const int recv_tag = (rank < kv.first)
+                                 ? std::max(rank, kv.first)
+                                 : std::min(rank, kv.first);
+            MPI_Irecv(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, recv_tag, pmesh.MyComm, &recv_requests.back());
+         }
+
+         // Wait until all receive buffers are full before beginning to process.
+         MPI_Waitall(int(recv_requests.size()), recv_requests.data(), status.data());
+
+         pmesh.face_nbr_el_ori.reset(new Table(pmesh.face_nbr_elements.Size(), 6));
+         int elem = 0;
+         for (const auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            // All elements associated to this face-neighbor rank
+            for (const auto &eo : kv.second)
+            {
+               std::copy(eo.begin(), eo.end(), pmesh.face_nbr_el_ori->GetRow(elem));
+               ++elem;
+            }
+         }
+         pmesh.face_nbr_el_ori->Finalize();
+
+         // Must wait for all send buffers to be released before the scope closes.
+         MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
+      }
+   }
+
+
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index ed919f14c..df5fb929e 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -82,23 +82,23 @@ public:
    /** An override of NCMesh::Refine, which is called eventually, after making
        sure that refinements that occur on the processor boundary are sent to
        the neighbor processors so they can keep their ghost layers up to date.*/
-   virtual void Refine(const Array<Refinement> &refinements);
+   void Refine(const Array<Refinement> &refinements) override;
 
    /// Parallel version of NCMesh::LimitNCLevel.
-   virtual void LimitNCLevel(int max_nc_level);
+   void LimitNCLevel(int max_nc_level) override;
 
    /** Parallel version of NCMesh::CheckDerefinementNCLevel. */
-   virtual void CheckDerefinementNCLevel(const Table &deref_table,
-                                         Array<int> &level_ok, int max_nc_level);
+   void CheckDerefinementNCLevel(const Table &deref_table,
+                                 Array<int> &level_ok, int max_nc_level) override;
 
    /** Parallel reimplementation of NCMesh::Derefine, keeps ghost layers
        in sync. The interface is identical. */
-   virtual void Derefine(const Array<int> &derefs);
+   void Derefine(const Array<int> &derefs) override;
 
    /** Gets partitioning for the coarse mesh if the current fine mesh were to
        be derefined. */
-   virtual void GetFineToCoarsePartitioning(const Array<int> &derefs,
-                                            Array<int> &new_ranks) const;
+   void GetFineToCoarsePartitioning(const Array<int> &derefs,
+                                    Array<int> &new_ranks) const;
 
    /** Migrate leaf elements of the global refinement hierarchy (including ghost
        elements) so that each processor owns the same number of leaves (+-1).
@@ -108,15 +108,13 @@ public:
        passed. */
    void Rebalance(const Array<int> *custom_partition = NULL);
 
-
    // interface for ParFiniteElementSpace
-
    int GetNElements() const { return NElements; }
 
    int GetNGhostVertices() const { return NGhostVertices; }
    int GetNGhostEdges() const { return NGhostEdges; }
    int GetNGhostFaces() const { return NGhostFaces; }
-   int GetNGhostElements() const { return NGhostElements; }
+   int GetNGhostElements() const override { return NGhostElements; }
 
    // Return a list of vertices/edges/faces shared by this processor and at
    // least one other processor. These are subsets of NCMesh::<entity>_list. */
@@ -141,8 +139,8 @@ public:
       return (index < NFaces) ? face_orient[index] : 0;
    }
 
-   typedef short GroupId;
-   typedef std::vector<int> CommGroup;
+   using GroupId = short;
+   using CommGroup = std::vector<int>;
 
    /// Return vertex/edge/face ('entity' == 0/1/2, resp.) owner.
    GroupId GetEntityOwnerId(int entity, int index)
@@ -232,12 +230,12 @@ public:
 
    /** Extension of NCMesh::GetBoundaryClosure. Filters out ghost vertices and
        ghost edges from 'bdr_vertices' and 'bdr_edges'. */
-   virtual void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
-                                   Array<int> &bdr_vertices,
-                                   Array<int> &bdr_edges);
+   void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
+                           Array<int> &bdr_vertices,
+                           Array<int> &bdr_edges) override;
 
    /// Save memory by releasing all non-essential and cached data.
-   virtual void Trim();
+   void Trim() override;
 
    /// Return total number of bytes allocated.
    std::size_t MemoryUsage(bool with_base = true) const;
@@ -267,8 +265,8 @@ protected: // implementation
    MPI_Comm MyComm;
    int NRanks;
 
-   typedef std::vector<CommGroup> GroupList;
-   typedef std::map<CommGroup, GroupId> GroupMap;
+   using GroupList = std::vector<CommGroup>;
+   using GroupMap = std::map<CommGroup, GroupId>;
 
    GroupList groups;  // comm group list; NOTE: groups[0] = { MyRank }
    GroupMap group_id; // search index over groups
@@ -299,7 +297,7 @@ protected: // implementation
    Array<int> ghost_layer;    ///< list of elements whose 'element_type' == 2.
    Array<int> boundary_layer; ///< list of type 3 elements
 
-   virtual void Update();
+   void Update() override;
 
    /// Return the processor number for a global element number.
    int Partition(long index, long total_elements) const
@@ -313,13 +311,13 @@ protected: // implementation
    long PartitionFirstIndex(int rank, long total_elements) const
    { return (rank * total_elements + NRanks-1) / NRanks; }
 
-   virtual void BuildFaceList();
-   virtual void BuildEdgeList();
-   virtual void BuildVertexList();
+   void BuildFaceList() override;
+   void BuildEdgeList() override;
+   void BuildVertexList() override;
 
-   virtual void ElementSharesFace(int elem, int local, int face);
-   virtual void ElementSharesEdge(int elem, int local, int enode);
-   virtual void ElementSharesVertex(int elem, int local, int vnode);
+   void ElementSharesFace(int elem, int local, int face) override;
+   void ElementSharesEdge(int elem, int local, int enode) override;
+   void ElementSharesVertex(int elem, int local, int vnode) override;
 
    GroupId GetGroupId(const CommGroup &group);
    GroupId GetSingletonGroup(int rank);
@@ -451,8 +449,8 @@ protected: // implementation
    protected:
       ParNCMesh* pncmesh;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Used by ParNCMesh::Refine() to inform neighbors about refinements at
@@ -513,8 +511,8 @@ protected: // implementation
    protected:
       ElementSet eset;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Assign new Element::rank to leaf elements and send them to their new
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index 2277efdfa..a77e1a531 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -361,17 +361,17 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    }
    int dim = mesh.Dimension();
 
-   FiniteElementCollection *fec;
+   std::unique_ptr<FiniteElementCollection> fec;
    if (prob)
    {
       auto basis = prob==3 ? BasisType::Positive : BasisType::GaussLobatto;
-      fec = new L2_FECollection(order, dim, basis);
+      fec.reset(new L2_FECollection(order, dim, basis));
    }
    else
    {
-      fec = new H1_FECollection(order, dim);
+      fec.reset(new H1_FECollection(order, dim));
    }
-   FiniteElementSpace fespace(&mesh, fec);
+   FiniteElementSpace fespace(&mesh, fec.get());
 
    L2_FECollection vel_fec(order, dim, BasisType::GaussLobatto);
    FiniteElementSpace vel_fespace(&mesh, &vel_fec, dim);
@@ -381,21 +381,21 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    BilinearForm k_pa(&fespace);
    BilinearForm k_fa(&fespace);
 
-   VectorCoefficient *vel_coeff;
-   Coefficient *rho;
+   std::unique_ptr<VectorCoefficient> vel_coeff;
+   std::unique_ptr<Coefficient> rho;
 
    // prob: 0: CG, 1: DG continuous coeff, 2: DG discontinuous coeff
    if (prob >= 2)
    {
       vel_gf.Randomize(1);
-      vel_coeff = new VectorGridFunctionCoefficient(&vel_gf);
+      vel_coeff.reset(new VectorGridFunctionCoefficient(&vel_gf));
       rho_gf.Randomize(1);
-      rho = new GridFunctionCoefficient(&rho_gf);
+      rho.reset(new GridFunctionCoefficient(&rho_gf));
    }
    else
    {
-      vel_coeff = new VectorFunctionCoefficient(dim, velocity_function);
-      rho = new ConstantCoefficient(1.0);
+      vel_coeff.reset(new VectorFunctionCoefficient(dim, velocity_function));
+      rho.reset(new ConstantCoefficient(1.0));
    }
 
 
@@ -427,10 +427,6 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    y_pa -= y_fa;
 
    REQUIRE(y_pa.Norml2() < 1.e-12);
-
-   delete vel_coeff;
-   delete rho;
-   delete fec;
 }
 
 // Basic unit tests for convection
@@ -444,7 +440,7 @@ TEST_CASE("PA Convection", "[PartialAssembly], [CUDA]")
    auto prob = GENERATE(0, 1, 2, 3);
    auto order = GENERATE(2);
    // refinement > 0 => Non-conforming mesh
-   auto refinement = GENERATE(0,1);
+   auto refinement = GENERATE(0, 1);
 
    SECTION("2D")
    {
diff --git a/tests/unit/linalg/test_operator.cpp b/tests/unit/linalg/test_operator.cpp
index 8ed47de3f..8e6fe0fd0 100644
--- a/tests/unit/linalg/test_operator.cpp
+++ b/tests/unit/linalg/test_operator.cpp
@@ -31,23 +31,19 @@ TEST_CASE("Operator", "[Operator]")
    {
       // When cg is in a product (on the right), we require cg->iterative_mode to be false.
 
-      ProductOperator *product = NULL;
-      RAPOperator *rap = NULL;
-      TripleProductOperator *triple = NULL;
-
       // First, test that the failing version throws an exception.
       cg.iterative_mode = true;
-      REQUIRE_THROWS(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_THROWS(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                        false));
-      REQUIRE_THROWS(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_THROWS(ProductOperator(&A, &cg, false, false));
+      REQUIRE_THROWS(TripleProductOperator(&A, &cg, &cg, false, false,
+                                           false));
+      REQUIRE_THROWS(RAPOperator(A, cg, cg));
 
       // Second, test that the correct version does not throw.
       cg.iterative_mode = false;
-      REQUIRE_NOTHROW(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_NOTHROW(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                         false));
-      REQUIRE_NOTHROW(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_NOTHROW(ProductOperator(&A, &cg, false, false));
+      REQUIRE_NOTHROW(TripleProductOperator(&A, &cg, &cg, false, false,
+                                            false));
+      REQUIRE_NOTHROW(RAPOperator(A, cg, cg));
    }
 }
 
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index e78c68401..0d5b550b1 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -297,125 +297,128 @@ TEST_CASE("pNCMesh PA diagonal",  "[Parallel], [NCMesh]")
 
 } // test case
 
-TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+namespace {
+
+// Given a parallel and a serial mesh, perform an L2 projection and check the
+// solutions match exactly.
+void CheckL2Projection(std::function<double(const Vector&)> exact_soln,
+                       ParMesh& pmesh, Mesh& smesh, int order)
 {
-   constexpr int refining_rank = 0;
-   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
+   REQUIRE(pmesh.Dimension() == smesh.Dimension());
+   REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
 
-   REQUIRE(smesh.GetNE() == 1);
-   {
-      // Start the test with two tetrahedra attached by triangle.
-      auto single_edge_refine = Array<Refinement>(1);
-      single_edge_refine[0].index = 0;
-      single_edge_refine[0].ref_type = Refinement::X;
+   // Make an H1 space, then a mass matrix operator and invert it.
+   // If all non-conformal constraints have been conveyed correctly, the
+   // resulting DOF should match exactly on the serial and the parallel
+   // solution.
 
-      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
-   }
+   H1_FECollection fec(order, smesh.Dimension());
+   ConstantCoefficient one(1.0);
+   FunctionCoefficient rhs_coef(exact_soln);
 
-   auto exact_soln = [](const Vector& x)
-   {
-      // sin(|| x - d ||^2) -> non polynomial but very smooth.
-      Vector d(3);
-      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
-      d -= x;
-      return std::sin(d * d);
-   };
+   constexpr double linear_tol = 1e-16;
 
-   // Given a parallel and a serial mesh, perform an L2 projection and check the
-   // solutions match exactly.
-   auto check_l2_projection = [&exact_soln](ParMesh& pmesh, Mesh& smesh, int order)
+   // serial solve
+   auto serror = [&]
    {
+      FiniteElementSpace fes(&smesh, &fec);
+      // solution vectors
+      GridFunction x(&fes);
+      x = 0.0;
 
-      REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
-      REQUIRE(pmesh.Dimension() == smesh.Dimension());
-      REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
-
-      // Make an H1 space, then a mass matrix operator and invert it.
-      // If all non-conformal constraints have been conveyed correctly, the
-      // resulting DOF should match exactly on the serial and the parallel
-      // solution.
-
-      H1_FECollection fec(order, smesh.Dimension());
-      ConstantCoefficient one(1.0);
-      FunctionCoefficient rhs_coef(exact_soln);
+      LinearForm b(&fes);
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
 
-      constexpr double linear_tol = 1e-16;
-
-      // serial solve
-      auto serror = [&]
-      {
-         FiniteElementSpace fes(&smesh, &fec);
-         // solution vectors
-         GridFunction x(&fes);
-         x = 0.0;
-
-         LinearForm b(&fes);
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
-
-         BilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
+      BilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
 
-         SparseMatrix A;
-         Vector B, X;
+      SparseMatrix A;
+      Vector B, X;
 
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
 
 #ifndef MFEM_USE_SUITESPARSE
-         // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
-         //    solve the system AX=B with PCG.
-         GSSmoother M(A);
-         PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
+      // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
+      //    solve the system AX=B with PCG.
+      GSSmoother M(A);
+      PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
 #else
-         // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
-         UMFPackSolver umf_solver;
-         umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
-         umf_solver.SetOperator(A);
-         umf_solver.Mult(B, X);
+      // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
+      UMFPackSolver umf_solver;
+      umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
+      umf_solver.SetOperator(A);
+      umf_solver.Mult(B, X);
 #endif
 
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
+      a.RecoverFEMSolution(X, b, x);
+      return x.ComputeL2Error(rhs_coef);
+   }();
 
-      auto perror = [&]
-      {
-         // parallel solve
-         ParFiniteElementSpace fes(&pmesh, &fec);
-         ParLinearForm b(&fes);
+   auto perror = [&]
+   {
+      // parallel solve
+      ParFiniteElementSpace fes(&pmesh, &fec);
+      ParLinearForm b(&fes);
+
+      ParGridFunction x(&fes);
+      x = 0.0;
+
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
+
+      ParBilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
+
+      HypreParMatrix A;
+      Vector B, X;
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+
+      HypreBoomerAMG amg(A);
+      HyprePCG pcg(A);
+      amg.SetPrintLevel(-1);
+      pcg.SetTol(linear_tol);
+      pcg.SetMaxIter(500);
+      pcg.SetPrintLevel(-1);
+      pcg.SetPreconditioner(amg);
+      pcg.Mult(B, X);
+      a.RecoverFEMSolution(X, b, x);
+      return x.ComputeL2Error(rhs_coef);
+   }();
 
-         ParGridFunction x(&fes);
-         x = 0.0;
+      constexpr double test_tol = 1e-9;
+      CHECK(std::abs(serror - perror) < test_tol);
 
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
+}
+}
 
-         ParBilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
+TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+{
+   constexpr int refining_rank = 0;
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
 
-         HypreParMatrix A;
-         Vector B, X;
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
-
-         HypreBoomerAMG amg(A);
-         HyprePCG pcg(A);
-         amg.SetPrintLevel(-1);
-         pcg.SetTol(linear_tol);
-         pcg.SetMaxIter(500);
-         pcg.SetPrintLevel(-1);
-         pcg.SetPreconditioner(amg);
-         pcg.Mult(B, X);
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
+   REQUIRE(smesh.GetNE() == 1);
+   {
+      // Start the test with two tetrahedra attached by triangle.
+      auto single_edge_refine = Array<Refinement>(1);
+      single_edge_refine[0].index = 0;
+      single_edge_refine[0].ref_type = Refinement::X;
 
-      constexpr double test_tol = 1e-9;
-      CHECK(std::abs(serror - perror) < test_tol);
+      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
+   }
 
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
    };
 
    REQUIRE(smesh.GetNE() == 2);
@@ -510,15 +513,224 @@ TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
       }
 
       // Use P4 to ensure there's a few fully interior DOF.
-      check_l2_projection(ttmp, sttmp, 4);
+
+      CheckL2Projection(exact_soln, ttmp, sttmp, 4);
 
       ttmp.ExchangeFaceNbrData();
       ttmp.Rebalance();
 
-      check_l2_projection(ttmp, sttmp, 4);
+      CheckL2Projection(exact_soln, ttmp, sttmp, 4);
    }
 } // test case
 
+/**
+ * @brief Test GetVectorValue on face neighbor elements for nonconformal meshes
+ *
+ * @param smesh The serial mesh to start from
+ * @param nc_level Depth of refinement on processor boundaries
+ * @param skip Refine every "skip" processor boundary element
+ * @param use_ND Whether to use Nedelec elements (which are sensitive to orientation)
+ */
+void TestVectorValueInVolume(Mesh &smesh, int nc_level, int skip, bool use_ND)
+{
+   auto vector_exact_soln = [](const Vector& x, Vector& v)
+   {
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      v = (d -= x);
+   };
+
+   smesh.Finalize();
+   smesh.EnsureNCMesh(true); // uncomment this to trigger the failure
+
+   auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+   // Apply refinement on face neighbors to achieve a given nc level mismatch.
+   for (int i = 0; i < nc_level; ++i)
+   {
+      // To refine the face neighbors, need to know where they are.
+      pmesh.ExchangeFaceNbrData();
+      Array<int> elem_to_refine;
+      // Refine only on odd ranks.
+      if ((Mpi::WorldRank() + 1) % 2 == 0)
+      {
+         // Refine a subset of all shared faces. Using a subset helps to
+         // mix in conformal faces with nonconformal faces.
+         for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+         {
+            if (n % skip != 0) { continue; }
+            const int local_face = pmesh.GetSharedFace(n);
+            const auto &face_info = pmesh.GetFaceInformation(local_face);
+            REQUIRE(face_info.IsShared());
+            REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+            elem_to_refine.Append(face_info.element[0].index);
+         }
+      }
+      pmesh.GeneralRefinement(elem_to_refine);
+   }
+
+   // Do not rebalance again! The test is also checking for nc refinements
+   // along the processor boundary.
+
+   // Create a grid function of the mesh coordinates
+   pmesh.ExchangeFaceNbrData();
+   pmesh.EnsureNodes();
+   REQUIRE(pmesh.OwnsNodes());
+   GridFunction * const coords = pmesh.GetNodes();
+   dynamic_cast<ParGridFunction *>(pmesh.GetNodes())->ExchangeFaceNbrData();
+
+   // Project the linear function onto the mesh. Quadratic ND tetrahedral
+   // elements are the first to require face orientations.
+   const int order = 2, dim = 3;
+   std::unique_ptr<FiniteElementCollection> fec;
+   if (use_ND)
+   {
+      fec = std::unique_ptr<ND_FECollection>(new ND_FECollection(order, dim));
+   }
+   else
+   {
+      fec = std::unique_ptr<RT_FECollection>(new RT_FECollection(order, dim));
+   }
+   ParFiniteElementSpace pnd_fes(&pmesh, fec.get());
+
+   ParGridFunction psol(&pnd_fes);
+
+   VectorFunctionCoefficient func(3, vector_exact_soln);
+   psol.ProjectCoefficient(func);
+   psol.ExchangeFaceNbrData();
+
+   mfem::Vector value(3), exact(3), position(3);
+   const IntegrationRule &ir = mfem::IntRules.Get(Geometry::Type::TETRAHEDRON,
+                                                  order + 1);
+
+   // Check that non-ghost elements match up on the serial and parallel spaces.
+   for (int n = 0; n < pmesh.GetNE(); ++n)
+   {
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         coords->GetVectorValue(n, ip, position);
+         psol.GetVectorValue(n, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+
+   // Loop over face neighbor elements and check the vector values match in the
+   // face neighbor elements.
+   for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+   {
+      const int local_face = pmesh.GetSharedFace(n);
+      const auto &face_info = pmesh.GetFaceInformation(local_face);
+      REQUIRE(face_info.IsShared());
+      REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+
+      auto &T = *pmesh.GetFaceNbrElementTransformation(face_info.element[1].index);
+
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         T.SetIntPoint(&ip);
+         coords->GetVectorValue(T, ip, position);
+         psol.GetVectorValue(T, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+}
+
+TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
+{
+   // The aim of this test is to verify the correct behaviour of the
+   // GetVectorValue method when called on face neighbor elements in a non
+   // conforming mesh.
+   auto smesh = Mesh("../../data/beam-tet.mesh");
+
+   for (int nc_level : {0,1,2,3})
+   {
+      for (int skip : {1,2})
+      {
+         for (bool use_ND : {false, true})
+         {
+            TestVectorValueInVolume(smesh, nc_level, skip, use_ND);
+         }
+      }
+   }
+}
+
+
+TEST_CASE("P2Q1PurePrism",  "[Parallel], [NCMesh]")
+{
+   auto smesh = Mesh("../../data/p1_prism.msh");
+
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      // P2 ensures there are triangles without dofs
+      CheckL2Projection(exact_soln, pmesh, smesh, 2);
+   }
+
+} // test case
+
+TEST_CASE("PNQ2PurePrism",  "[Parallel], [NCMesh]")
+{
+   auto smesh = Mesh("../../data/p2_prism.msh");
+
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      for (int p = 1; p < 4; ++p)
+      {
+         CheckL2Projection(exact_soln, pmesh, smesh, p);
+      }
+   }
+
+
+} // test case
+
+
 
 #endif // MFEM_USE_MPI
 
