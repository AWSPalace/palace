diff --git a/.gitignore b/.gitignore
index dbdb54ce1..300702000 100644
--- a/.gitignore
+++ b/.gitignore
@@ -220,7 +220,7 @@ miniapps/meshing/mobius-strip.mesh
 miniapps/meshing/klein-bottle.mesh
 miniapps/meshing/toroid-*.mesh
 miniapps/meshing/twist-*.mesh
-miniapps/meshing/mesh-explorer.mesh
+miniapps/meshing/mesh-explorer.mesh*
 miniapps/meshing/partitioning.txt
 miniapps/meshing/mesh-explorer-visit*
 miniapps/meshing/mesh-explorer-paraview/
@@ -352,6 +352,8 @@ tests/unit/tmop_pa_tests_*
 tests/unit/ptmop_pa_tests_*
 tests/unit/ceed_tests
 tests/unit/debug_device_tests
+tests/unit/parallel_in_serial.mesh
+tests/unit/parallel_in_serial.gf
 
 # Benchmark binaries
 tests/benchmarks/bench_ceed
diff --git a/CHANGELOG b/CHANGELOG
index 66eaffbc6..aa6a83dca 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -41,6 +41,8 @@ Meshing improvements
 - Added new methods in the Mesh class to set and get attributes on NURBS patches
   and patch boundaries.
 
+- Added HIP support to the SUNDIALS interface.
+
 - TMOP improvement: added asymptotically-balanced compound metrics 90, 94, 328,
   338. Added the tmop-metric-magnitude tool for tracking how metrics change
   under geometric perturbations.
@@ -54,12 +56,23 @@ Discretization improvements
 
 - Added support for p-refined meshes in FindPointsGSLIB.
 
+- Introduced support for higher order non conformal Nedelec elements on
+  simplices.
+
+- Introduced support for internal boundary elements in nonconformal adapted
+  meshes.
+
 Linear and nonlinear solvers
 ----------------------------
 - Updated interface to MUMPS direct solver to support multiple right-hand
   sides, block low-rank compression, builds using 64-bit integers, and other
   improvements.
 
+- Added an interface to the MKL Pardiso sparse direct solver developed by Intel.
+  This interface provides a serial (OpenMP shared memory) version of Pardiso for
+  use with SparseMatrix. This complements the existing parallel (MPI distributed
+  memory) version already available through the CPardiso MFEM integration.
+
 Integrations, testing and documentation
 ---------------------------------------
 - Added an address sanitizer GitHub action for a serial build/test on Ubuntu,
@@ -71,6 +84,9 @@ Miscellaneous
   These functions can take the place of the MFEM_FORALL macros, which have been
   preserved for backwards compatibility.
 
+- Reorganized files for bilinear form, linear form, and nonlinear form integrators
+  in the fem/integ/ subdirectory.
+
 
 Version 4.5.2, released on March 23, 2023
 =========================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
index e9e6ae0b7..9e9aa895d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -317,6 +317,9 @@ if (MFEM_USE_SUNDIALS)
   if (MFEM_USE_CUDA)
     list(APPEND SUNDIALS_COMPONENTS NVector_Cuda)
   endif()
+  if (MFEM_USE_HIP)
+    list(APPEND SUNDIALS_COMPONENTS NVector_Hip)
+  endif()
   find_package(SUNDIALS REQUIRED ${SUNDIALS_COMPONENTS})
 endif()
 
@@ -467,12 +470,18 @@ if (MFEM_USE_ADIOS2)
    find_package(ADIOS2 REQUIRED)
 endif()
 
+# MKL CPardiso
 if (MFEM_USE_MKL_CPARDISO)
   if (MFEM_USE_MPI)
    find_package(MKL_CPARDISO REQUIRED MKL_SEQUENTIAL MKL_LP64 MKL_MPI_WRAPPER)
   endif()
 endif()
 
+# MKL Pardiso
+if (MFEM_USE_MKL_PARDISO)
+   find_package(MKL_PARDISO REQUIRED MKL_SEQUENTIAL MKL_LP64)
+endif()
+
 # PARELAG
 if (MFEM_USE_PARELAG)
    find_package(PARELAG REQUIRED)
@@ -522,8 +531,8 @@ find_package(Threads REQUIRED)
 set(MFEM_TPLS OPENMP HYPRE LAPACK BLAS SuperLUDist STRUMPACK METIS SuiteSparse
     SUNDIALS PETSC SLEPC MUMPS AXOM FMS CONDUIT Ginkgo GNUTLS GSLIB
     NETCDF MPFR PUMI HIOP POSIXCLOCKS MFEMBacktrace ZLIB OCCA CEED RAJA UMPIRE
-    ADIOS2 CUBLAS CUSPARSE MKL_CPARDISO AMGX CALIPER CODIPACK BENCHMARK PARELAG
-    MPI_CXX HIP HIPSPARSE MOONOLITH BLITZ ALGOIM ENZYME)
+    ADIOS2 CUBLAS CUSPARSE MKL_CPARDISO MKL_PARDISO AMGX CALIPER CODIPACK
+    BENCHMARK PARELAG MPI_CXX HIP HIPSPARSE MOONOLITH BLITZ ALGOIM ENZYME)
 
 # Add all *_FOUND libraries in the variable TPL_LIBRARIES.
 set(TPL_LIBRARIES "")
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 371f73119..33a316f9d 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -121,6 +121,7 @@ The MFEM source code has the following structure:
   ├── fem
   │   ├── ceed
   │   ├── fe
+  │   ├── integ
   │   ├── lor
   │   ├── moonolith
   │   ├── qinterp
diff --git a/INSTALL b/INSTALL
index cb092cc1b..1a325fdf6 100644
--- a/INSTALL
+++ b/INSTALL
@@ -628,9 +628,13 @@ The specific libraries and their options are:
   both MPI and hypre.
   If MFEM_USE_CUDA is enabled, we expect that SUNDIALS is built with support
   for CUDA.
-  URL: http://computation.llnl.gov/projects/sundials/sundials-software
+  If MFEM_USE_HIP is enabled, we expect that SUNDIALS is built with support
+  for HIP.
+  URL: http://computing.llnl.gov/projects/sundials/sundials-software
   Options: SUNDIALS_OPT, SUNDIALS_LIB.
-  Versions: SUNDIALS >= 5.0.0, SUNDIALS >= 5.4.0 for CUDA support.
+  Versions: SUNDIALS >= 5.0.0,
+            SUNDIALS >= 5.4.0 for CUDA support, and
+            SUNDIALS >= 5.7.0 for HIP support.
 
 - SuiteSparse (optional), used when MFEM_USE_SUITESPARSE = YES.
   URL: http://faculty.cse.tamu.edu/davis/suitesparse.html
diff --git a/config/cmake/MFEMConfig.cmake.in b/config/cmake/MFEMConfig.cmake.in
index 9d5eef52f..ed271311a 100644
--- a/config/cmake/MFEMConfig.cmake.in
+++ b/config/cmake/MFEMConfig.cmake.in
@@ -55,6 +55,8 @@ set(MFEM_USE_SIMD @MFEM_USE_SIMD@)
 set(MFEM_USE_ADIOS2 @MFEM_USE_ADIOS2@)
 set(MFEM_USE_MOONOLITH @MFEM_USE_MOONOLITH@)
 set(MFEM_USE_CODIPACK @MFEM_USE_CODIPACK@)
+set(MFEM_USE_MKL_CPARDISO @MFEM_USE_MKL_CPARDISO@)
+set(MFEM_USE_MKL_PARDISO @MFEM_USE_MKL_PARDISO@)
 set(MFEM_USE_ADFORWARD @MFEM_USE_ADFORWARD@)
 set(MFEM_USE_CALIPER @MFEM_USE_CALIPER@)
 set(MFEM_USE_ALGOIM @MFEM_USE_ALGOIM@)
diff --git a/config/cmake/config.hpp.in b/config/cmake/config.hpp.in
index adde511fb..7cb2a958d 100644
--- a/config/cmake/config.hpp.in
+++ b/config/cmake/config.hpp.in
@@ -186,6 +186,9 @@
 // Enable interface to the MKL CPardiso library.
 #cmakedefine MFEM_USE_MKL_CPARDISO
 
+// Enable interface to the MKL Pardiso library.
+#cmakedefine MFEM_USE_MKL_PARDISO
+
 // Use forward mode for automatic differentiation.
 #cmakedefine MFEM_USE_ADFORWARD
 
diff --git a/config/cmake/modules/FindMKL_PARDISO.cmake b/config/cmake/modules/FindMKL_PARDISO.cmake
new file mode 100644
index 000000000..9a3d62080
--- /dev/null
+++ b/config/cmake/modules/FindMKL_PARDISO.cmake
@@ -0,0 +1,27 @@
+# Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+# at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+# LICENSE and NOTICE for details. LLNL-CODE-806117.
+#
+# This file is part of the MFEM library. For more information and source code
+# availability visit https://mfem.org.
+#
+# MFEM is free software; you can redistribute it and/or modify it under the
+# terms of the BSD-3 license. We welcome feedback and contributions, see file
+# CONTRIBUTING.md for details.
+
+# Defines the following variables:
+#   - MKL_PARDISO_FOUND
+#   - MKL_PARDISO_LIBRARIES
+#   - MKL_PARDISO_INCLUDE_DIRS
+
+if(NOT MKL_LIBRARY_DIR)
+  message(WARNING "Using default MKL library path. Double check the variable MKL_LIBRARY_DIR")
+  set(MKL_LIBRARY_DIR "lib/intel64")
+endif()
+
+include(MfemCmakeUtilities)
+mfem_find_package(MKL_PARDISO MKL_PARDISO
+    MKL_PARDISO_DIR "include" mkl_pardiso.h ${MKL_LIBRARY_DIR} mkl_core
+  "Paths to headers required by MKL Pardiso." "Libraries required by MKL PARDISO."
+  ADD_COMPONENT MKL_LP64 "include" "" ${MKL_LIBRARY_DIR} mkl_intel_lp64
+  ADD_COMPONENT MKL_SEQUENTIAL "include" "" ${MKL_LIBRARY_DIR} mkl_sequential)
diff --git a/config/cmake/modules/FindSUNDIALS.cmake b/config/cmake/modules/FindSUNDIALS.cmake
index a3b296f2d..889ca0317 100644
--- a/config/cmake/modules/FindSUNDIALS.cmake
+++ b/config/cmake/modules/FindSUNDIALS.cmake
@@ -22,8 +22,8 @@ mfem_find_package(SUNDIALS SUNDIALS SUNDIALS_DIR
     "include" nvector/nvector_serial.h "lib" sundials_nvecserial
   ADD_COMPONENT NVector_Cuda
     "include" nvector/nvector_cuda.h "lib" sundials_nveccuda
-  ADD_COMPONENT NVector_ParHyp
-    "include" nvector/nvector_parhyp.h "lib" sundials_nvecparhyp
+  ADD_COMPONENT NVector_Hip
+    "include" nvector/nvector_hip.h "lib" sundials_nvechip
   ADD_COMPONENT NVector_Parallel
     "include" nvector/nvector_parallel.h "lib" sundials_nvecparallel
   ADD_COMPONENT NVector_MPIPlusX
diff --git a/config/config.hpp.in b/config/config.hpp.in
index 7a737720e..39d7737c7 100644
--- a/config/config.hpp.in
+++ b/config/config.hpp.in
@@ -186,6 +186,9 @@
 // Enable interface to the MKL CPardiso library.
 // #define MFEM_USE_MKL_CPARDISO
 
+// Enable interface to the MKL Pardiso library.
+// #define MFEM_USE_MKL_PARDISO
+
 // Use forward mode for automatic differentiation.
 // #define MFEM_USE_ADFORWARD
 
diff --git a/config/config.mk.in b/config/config.mk.in
index baf5c2955..303750bf5 100644
--- a/config/config.mk.in
+++ b/config/config.mk.in
@@ -57,6 +57,7 @@ MFEM_USE_UMPIRE        = @MFEM_USE_UMPIRE@
 MFEM_USE_SIMD          = @MFEM_USE_SIMD@
 MFEM_USE_ADIOS2        = @MFEM_USE_ADIOS2@
 MFEM_USE_MKL_CPARDISO  = @MFEM_USE_MKL_CPARDISO@
+MFEM_USE_MKL_PARDISO   = @MFEM_USE_MKL_PARDISO@
 MFEM_USE_MOONOLITH     = @MFEM_USE_MOONOLITH@
 MFEM_USE_ADFORWARD     = @MFEM_USE_ADFORWARD@
 MFEM_USE_CODIPACK      = @MFEM_USE_CODIPACK@
diff --git a/config/defaults.cmake b/config/defaults.cmake
index 390026414..06531934d 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -60,6 +60,7 @@ option(MFEM_USE_ADIOS2 "Enable ADIOS2" OFF)
 option(MFEM_USE_CALIPER "Enable Caliper support" OFF)
 option(MFEM_USE_ALGOIM "Enable Algoim support" OFF)
 option(MFEM_USE_MKL_CPARDISO "Enable MKL CPardiso" OFF)
+option(MFEM_USE_MKL_PARDISO "Enable MKL Pardiso" OFF)
 option(MFEM_USE_ADFORWARD "Enable forward mode for AD" OFF)
 option(MFEM_USE_CODIPACK "Enable automatic differentiation (AD) using CoDiPack" OFF)
 option(MFEM_USE_BENCHMARK "Enable Google Benchmark" OFF)
@@ -228,6 +229,8 @@ set(MKL_CPARDISO_DIR "" CACHE STRING "MKL installation path.")
 set(MKL_MPI_WRAPPER_LIB "mkl_blacs_mpich_lp64" CACHE STRING "MKL MPI wrapper library")
 set(MKL_LIBRARY_DIR "" CACHE STRING "Custom library subdirectory")
 
+set(MKL_PARDISO_DIR "" CACHE STRING "MKL installation path.")
+
 set(OCCA_DIR "${MFEM_DIR}/../occa" CACHE PATH "Path to OCCA")
 set(RAJA_DIR "${MFEM_DIR}/../raja" CACHE PATH "Path to RAJA")
 set(CEED_DIR "${MFEM_DIR}/../libCEED" CACHE PATH "Path to libCEED")
diff --git a/config/defaults.mk b/config/defaults.mk
index e149ae452..237e9ed24 100644
--- a/config/defaults.mk
+++ b/config/defaults.mk
@@ -160,6 +160,7 @@ MFEM_USE_UMPIRE        = NO
 MFEM_USE_SIMD          = NO
 MFEM_USE_ADIOS2        = NO
 MFEM_USE_MKL_CPARDISO  = NO
+MFEM_USE_MKL_PARDISO   = NO
 MFEM_USE_MOONOLITH     = NO
 MFEM_USE_ADFORWARD     = NO
 MFEM_USE_CODIPACK      = NO
@@ -266,6 +267,9 @@ endif
 ifeq ($(MFEM_USE_CUDA),YES)
    SUNDIALS_LIB += -lsundials_nveccuda
 endif
+ifeq ($(MFEM_USE_HIP),YES)
+   SUNDIALS_LIB += -lsundials_nvechip
+endif
 # If SUNDIALS was built with KLU:
 # MFEM_USE_SUITESPARSE = YES
 
@@ -484,7 +488,6 @@ ifdef GOTCHA_DIR
    CALIPER_LIB += $(XLINKER)-rpath,$(GOTCHA_DIR)/lib64 $(XLINKER)-rpath,$(GOTCHA_DIR)/lib -L$(GOTCHA_DIR)/lib64 -L$(GOTCHA_DIR)/lib -lgotcha
 endif
 
-
 # BLITZ library configuration
 BLITZ_DIR = @MFEM_DIR@/../blitz
 BLITZ_OPT = -I$(BLITZ_DIR)/include
@@ -539,6 +542,14 @@ MKL_CPARDISO_LIB = $(XLINKER)-rpath,$(MKL_CPARDISO_DIR)/$(MKL_LIBRARY_SUBDIR)\
    -L$(MKL_CPARDISO_DIR)/$(MKL_LIBRARY_SUBDIR) -l$(MKL_MPI_WRAPPER)\
    -lmkl_intel_lp64 -lmkl_sequential -lmkl_core
 
+# MKL Pardiso library configuration
+MKL_PARDISO_DIR ?=
+MKL_LIBRARY_SUBDIR ?= lib
+MKL_PARDISO_OPT = -I$(MKL_PARDISO_DIR)/include
+MKL_PARDISO_LIB = $(XLINKER)-rpath,$(MKL_PARDISO_DIR)/$(MKL_LIBRARY_SUBDIR)\
+   -L$(MKL_PARDISO_DIR)/$(MKL_LIBRARY_SUBDIR)\
+   -lmkl_intel_lp64 -lmkl_sequential -lmkl_core
+
 # PARELAG library configuration
 PARELAG_DIR = @MFEM_DIR@/../parelag
 PARELAG_OPT = -I$(PARELAG_DIR)/src -I$(PARELAG_DIR)/build/src
diff --git a/examples/ex13p.cpp b/examples/ex13p.cpp
index da3a7cdba..af3cbc696 100644
--- a/examples/ex13p.cpp
+++ b/examples/ex13p.cpp
@@ -54,6 +54,7 @@ int main(int argc, char *argv[])
    int par_ref_levels = 1;
    int order = 1;
    int nev = 5;
+   bool nc = false;
    bool visualization = 1;
    const char *device_config = "cpu";
 
@@ -69,6 +70,9 @@ int main(int argc, char *argv[])
                   " isoparametric space.");
    args.AddOption(&nev, "-n", "--num-eigs",
                   "Number of desired eigenmodes.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-c",
+                  "--conforming",
+                  "Mark the mesh as nonconforming before partitioning.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -107,6 +111,11 @@ int main(int argc, char *argv[])
       mesh->UniformRefinement();
    }
 
+   if (nc)
+   {
+      mesh->EnsureNCMesh(true);
+   }
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution (1 time by
    //    default, or specified on the command line with -rp). Once the parallel
diff --git a/examples/ex1p-test.cpp b/examples/ex1p-test.cpp
new file mode 100644
index 000000000..9b17ae982
--- /dev/null
+++ b/examples/ex1p-test.cpp
@@ -0,0 +1,301 @@
+//                       MFEM Example 1 - Parallel Version
+//
+// Compile with: make ex1p
+//
+// Sample runs:  mpirun -np 4 ex1p -m ../data/square-disc.mesh
+//               mpirun -np 4 ex1p -m ../data/star.mesh
+//               mpirun -np 4 ex1p -m ../data/star-mixed.mesh
+//               mpirun -np 4 ex1p -m ../data/escher.mesh
+//               mpirun -np 4 ex1p -m ../data/fichera.mesh
+//               mpirun -np 4 ex1p -m ../data/fichera-mixed.mesh
+//               mpirun -np 4 ex1p -m ../data/toroid-wedge.mesh
+//               mpirun -np 4 ex1p -m ../data/octahedron.mesh -o 1
+//               mpirun -np 4 ex1p -m ../data/periodic-annulus-sector.msh
+//               mpirun -np 4 ex1p -m ../data/periodic-torus-sector.msh
+//               mpirun -np 4 ex1p -m ../data/square-disc-p2.vtk -o 2
+//               mpirun -np 4 ex1p -m ../data/square-disc-p3.mesh -o 3
+//               mpirun -np 4 ex1p -m ../data/square-disc-nurbs.mesh -o -1
+//               mpirun -np 4 ex1p -m ../data/star-mixed-p2.mesh -o 2
+//               mpirun -np 4 ex1p -m ../data/disc-nurbs.mesh -o -1
+//               mpirun -np 4 ex1p -m ../data/pipe-nurbs.mesh -o -1
+//               mpirun -np 4 ex1p -m ../data/ball-nurbs.mesh -o 2
+//               mpirun -np 4 ex1p -m ../data/fichera-mixed-p2.mesh -o 2
+//               mpirun -np 4 ex1p -m ../data/star-surf.mesh
+//               mpirun -np 4 ex1p -m ../data/square-disc-surf.mesh
+//               mpirun -np 4 ex1p -m ../data/inline-segment.mesh
+//               mpirun -np 4 ex1p -m ../data/amr-quad.mesh
+//               mpirun -np 4 ex1p -m ../data/amr-hex.mesh
+//               mpirun -np 4 ex1p -m ../data/mobius-strip.mesh
+//               mpirun -np 4 ex1p -m ../data/mobius-strip.mesh -o -1 -sc
+//
+// Device sample runs:
+//               mpirun -np 4 ex1p -pa -d cuda
+//               mpirun -np 4 ex1p -pa -d occa-cuda
+//               mpirun -np 4 ex1p -pa -d raja-omp
+//               mpirun -np 4 ex1p -pa -d ceed-cpu
+//               mpirun -np 4 ex1p -pa -d ceed-cpu -o 4 -a
+//             * mpirun -np 4 ex1p -pa -d ceed-cuda
+//             * mpirun -np 4 ex1p -pa -d ceed-hip
+//               mpirun -np 4 ex1p -pa -d ceed-cuda:/gpu/cuda/shared
+//               mpirun -np 4 ex1p -m ../data/beam-tet.mesh -pa -d ceed-cpu
+//
+// Description:  This example code demonstrates the use of MFEM to define a
+//               simple finite element discretization of the Laplace problem
+//               -Delta u = 1 with homogeneous Dirichlet boundary conditions.
+//               Specifically, we discretize using a FE space of the specified
+//               order, or if order < 1 using an isoparametric/isogeometric
+//               space (i.e. quadratic for quadratic curvilinear mesh, NURBS for
+//               NURBS mesh, etc.)
+//
+//               The example highlights the use of mesh refinement, finite
+//               element grid functions, as well as linear and bilinear forms
+//               corresponding to the left-hand side and right-hand side of the
+//               discrete linear system. We also cover the explicit elimination
+//               of essential boundary conditions, static condensation, and the
+//               optional connection to the GLVis tool for visualization.
+
+#include "mfem.hpp"
+#include <fstream>
+#include <iostream>
+
+using namespace std;
+using namespace mfem;
+
+int main(int argc, char *argv[])
+{
+   // 1. Initialize MPI.
+   MPI_Session mpi;
+   int num_procs = mpi.WorldSize();
+   int myid = mpi.WorldRank();
+
+   // 2. Parse command-line options.
+   const char *mesh_file = "../data/star.mesh";
+   int order = 1;
+   bool static_cond = false;
+   bool pa = false;
+   const char *device_config = "cpu";
+   bool visualization = true;
+   bool algebraic_ceed = false;
+
+   OptionsParser args(argc, argv);
+   args.AddOption(&mesh_file, "-m", "--mesh",
+                  "Mesh file to use.");
+   args.AddOption(&order, "-o", "--order",
+                  "Finite element order (polynomial degree) or -1 for"
+                  " isoparametric space.");
+   args.AddOption(&static_cond, "-sc", "--static-condensation", "-no-sc",
+                  "--no-static-condensation", "Enable static condensation.");
+   args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
+                  "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&device_config, "-d", "--device",
+                  "Device configuration string, see Device::Configure().");
+#ifdef MFEM_USE_CEED
+   args.AddOption(&algebraic_ceed, "-a", "--algebraic",
+                  "-no-a", "--no-algebraic",
+                  "Use algebraic Ceed solver");
+#endif
+   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
+                  "--no-visualization",
+                  "Enable or disable GLVis visualization.");
+   args.Parse();
+   if (!args.Good())
+   {
+      if (myid == 0)
+      {
+         args.PrintUsage(cout);
+      }
+      return 1;
+   }
+   if (myid == 0)
+   {
+      args.PrintOptions(cout);
+   }
+
+   // 3. Enable hardware devices such as GPUs, and programming models such as
+   //    CUDA, OCCA, RAJA and OpenMP based on command line options.
+   Device device(device_config);
+   if (myid == 0) { device.Print(); }
+
+   // 4. Read the (serial) mesh from the given mesh file on all processors.  We
+   //    can handle triangular, quadrilateral, tetrahedral, hexahedral, surface
+   //    and volume meshes with the same code.
+   Mesh mesh(mesh_file, 1, 1);
+   int dim = mesh.Dimension();
+
+   // 5. Refine the serial mesh on all processors to increase the resolution. In
+   //    this example we do 'ref_levels' of uniform refinement. We choose
+   //    'ref_levels' to be the largest number that gives a final mesh with no
+   //    more than 10,000 elements.
+   {
+      int ref_levels =
+         (int)floor(log(10000./mesh.GetNE())/log(2.)/dim);
+      for (int l = 0; l < ref_levels; l++)
+      {
+         mesh.UniformRefinement();
+      }
+   }
+
+   // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
+   //    this mesh further in parallel to increase the resolution. Once the
+   //    parallel mesh is defined, the serial mesh can be deleted.
+   // ParMesh pmesh(MPI_COMM_WORLD, mesh);
+   mesh.Clear();
+   ifstream mesh_ifs(
+      MakeParFilename("../miniapps/meshing/mesh-explorer.mesh.",
+                      myid));
+   ParMesh pmesh(MPI_COMM_WORLD, mesh_ifs, /* refine: */ false);
+   dim = pmesh.Dimension();
+   pmesh.PrintInfo(cout);
+   {
+      int par_ref_levels = 0;
+      for (int l = 0; l < par_ref_levels; l++)
+      {
+         pmesh.UniformRefinement();
+      }
+   }
+
+   // 7. Define a parallel finite element space on the parallel mesh. Here we
+   //    use continuous Lagrange finite elements of the specified order. If
+   //    order < 1, we instead use an isoparametric/isogeometric space.
+   FiniteElementCollection *fec;
+   bool delete_fec;
+   if (order > 0)
+   {
+      fec = new H1_FECollection(order, dim);
+      delete_fec = true;
+   }
+   else if (pmesh.GetNodes())
+   {
+      fec = pmesh.GetNodes()->OwnFEC();
+      delete_fec = false;
+      if (myid == 0)
+      {
+         cout << "Using isoparametric FEs: " << fec->Name() << endl;
+      }
+   }
+   else
+   {
+      fec = new H1_FECollection(order = 1, dim);
+      delete_fec = true;
+   }
+   ParFiniteElementSpace fespace(&pmesh, fec);
+   HYPRE_BigInt size = fespace.GlobalTrueVSize();
+   if (myid == 0)
+   {
+      cout << "Number of finite element unknowns: " << size << endl;
+   }
+
+   // 8. Determine the list of true (i.e. parallel conforming) essential
+   //    boundary dofs. In this example, the boundary conditions are defined
+   //    by marking all the boundary attributes from the mesh as essential
+   //    (Dirichlet) and converting them to a list of true dofs.
+   Array<int> ess_tdof_list;
+   if (pmesh.bdr_attributes.Size())
+   {
+      Array<int> ess_bdr(pmesh.bdr_attributes.Max());
+      ess_bdr = 1;
+      fespace.GetEssentialTrueDofs(ess_bdr, ess_tdof_list);
+   }
+
+   // 9. Set up the parallel linear form b(.) which corresponds to the
+   //    right-hand side of the FEM linear system, which in this case is
+   //    (1,phi_i) where phi_i are the basis functions in fespace.
+   ParLinearForm b(&fespace);
+   ConstantCoefficient one(1.0);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // 10. Define the solution vector x as a parallel finite element grid
+   //     function corresponding to fespace. Initialize x with initial guess of
+   //     zero, which satisfies the boundary conditions.
+   ParGridFunction x(&fespace);
+   x = 0.0;
+
+   // 11. Set up the parallel bilinear form a(.,.) on the finite element space
+   //     corresponding to the Laplacian operator -Delta, by adding the
+   //     Diffusion domain integrator.
+   ParBilinearForm a(&fespace);
+   if (pa) { a.SetAssemblyLevel(AssemblyLevel::PARTIAL); }
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+
+   // 12. Assemble the parallel bilinear form and the corresponding linear
+   //     system, applying any necessary transformations such as: parallel
+   //     assembly, eliminating boundary conditions, applying conforming
+   //     constraints for non-conforming AMR, static condensation, etc.
+   if (static_cond) { a.EnableStaticCondensation(); }
+   a.Assemble();
+
+   OperatorPtr A;
+   Vector B, X;
+   a.FormLinearSystem(ess_tdof_list, x, b, A, X, B);
+
+   // 13. Solve the linear system A X = B.
+   //     * With full assembly, use the BoomerAMG preconditioner from hypre.
+   //     * With partial assembly, use Jacobi smoothing, for now.
+   Solver *prec = NULL;
+   if (pa)
+   {
+      if (UsesTensorBasis(fespace))
+      {
+         if (algebraic_ceed)
+         {
+            prec = new ceed::AlgebraicSolver(a, ess_tdof_list);
+         }
+         else
+         {
+            prec = new OperatorJacobiSmoother(a, ess_tdof_list);
+         }
+      }
+   }
+   else
+   {
+      prec = new HypreBoomerAMG;
+   }
+   CGSolver cg(MPI_COMM_WORLD);
+   cg.SetRelTol(1e-12);
+   cg.SetMaxIter(2000);
+   cg.SetPrintLevel(1);
+   if (prec) { cg.SetPreconditioner(*prec); }
+   cg.SetOperator(*A);
+   cg.Mult(B, X);
+   delete prec;
+
+   // 14. Recover the parallel grid function corresponding to X. This is the
+   //     local finite element solution on each processor.
+   a.RecoverFEMSolution(X, b, x);
+
+   // 15. Save the refined mesh and the solution in parallel. This output can
+   //     be viewed later using GLVis: "glvis -np <np> -m mesh -g sol".
+   {
+      ostringstream mesh_name, sol_name;
+      mesh_name << "mesh." << setfill('0') << setw(6) << myid;
+      sol_name << "sol." << setfill('0') << setw(6) << myid;
+
+      ofstream mesh_ofs(mesh_name.str().c_str());
+      mesh_ofs.precision(8);
+      pmesh.Print(mesh_ofs);
+
+      ofstream sol_ofs(sol_name.str().c_str());
+      sol_ofs.precision(8);
+      x.Save(sol_ofs);
+   }
+
+   // 16. Send the solution by socket to a GLVis server.
+   if (visualization)
+   {
+      char vishost[] = "localhost";
+      int  visport   = 19916;
+      socketstream sol_sock(vishost, visport);
+      sol_sock << "parallel " << num_procs << " " << myid << "\n";
+      sol_sock.precision(8);
+      sol_sock << "solution\n" << pmesh << x << flush;
+   }
+
+   // 17. Free the used memory.
+   if (delete_fec)
+   {
+      delete fec;
+   }
+
+   return 0;
+}
diff --git a/examples/ex3.cpp b/examples/ex3.cpp
index edbfdac7d..d36ec62bf 100644
--- a/examples/ex3.cpp
+++ b/examples/ex3.cpp
@@ -63,6 +63,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = 1;
 
@@ -77,6 +78,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -103,19 +106,26 @@ int main(int argc, char *argv[])
    dim = mesh->Dimension();
    int sdim = mesh->SpaceDimension();
 
+
    // 4. Refine the mesh to increase the resolution. In this example we do
    //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    //    largest number that gives a final mesh with no more than 50,000
    //    elements.
+
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+   mesh->UniformRefinement();
    {
       int ref_levels =
-         (int)floor(log(50000./mesh->GetNE())/log(2.)/dim);
+         (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
       {
          mesh->UniformRefinement();
       }
    }
-
    // 5. Define a finite element space on the mesh. Here we use the Nedelec
    //    finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex3p.cpp b/examples/ex3p.cpp
index e24c52809..285fcc8e8 100644
--- a/examples/ex3p.cpp
+++ b/examples/ex3p.cpp
@@ -70,6 +70,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = true;
 #ifdef MFEM_USE_AMGX
@@ -87,6 +88,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -129,6 +132,12 @@ int main(int argc, char *argv[])
    //    this example we do 'ref_levels' of uniform refinement. We choose
    //    'ref_levels' to be the largest number that gives a final mesh with no
    //    more than 1,000 elements.
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+
    {
       int ref_levels = (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
@@ -137,19 +146,20 @@ int main(int argc, char *argv[])
       }
    }
 
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution. Once the
    //    parallel mesh is defined, the serial mesh can be deleted.
    ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);
+
    delete mesh;
    {
-      int par_ref_levels = 2;
+      int par_ref_levels = 1;
       for (int l = 0; l < par_ref_levels; l++)
       {
          pmesh->UniformRefinement();
       }
    }
-
    // 7. Define a parallel finite element space on the parallel mesh. Here we
    //    use the Nedelec finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex9p.cpp b/examples/ex9p.cpp
index 03d161b86..6b468ffb9 100644
--- a/examples/ex9p.cpp
+++ b/examples/ex9p.cpp
@@ -536,8 +536,10 @@ int main(int argc, char *argv[])
       if (!sout)
       {
          if (Mpi::Root())
+         {
             cout << "Unable to connect to GLVis server at "
                  << vishost << ':' << visport << endl;
+         }
          visualization = false;
          if (Mpi::Root())
          {
@@ -552,8 +554,10 @@ int main(int argc, char *argv[])
          sout << "pause\n";
          sout << flush;
          if (Mpi::Root())
+         {
             cout << "GLVis visualization paused."
                  << " Press space (in the GLVis window) to resume it.\n";
+         }
       }
    }
 
diff --git a/examples/sundials/CMakeLists.txt b/examples/sundials/CMakeLists.txt
index f7c1808c4..ce1800a36 100644
--- a/examples/sundials/CMakeLists.txt
+++ b/examples/sundials/CMakeLists.txt
@@ -68,11 +68,43 @@ if (MFEM_ENABLE_TESTING)
       add_test(NAME ${TEST_NAME}_ser
         COMMAND ${TEST_NAME} ${THIS_TEST_OPTIONS})
     else()
-      add_test(NAME ${TEST_NAME}_np=4
+      add_test(NAME ${TEST_NAME}_np=${MFEM_MPI_NP}
         COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${MFEM_MPI_NP}
         ${MPIEXEC_PREFLAGS}
         $<TARGET_FILE:${TEST_NAME}> ${THIS_TEST_OPTIONS}
         ${MPIEXEC_POSTFLAGS})
     endif()
   endforeach()
-endif()
+
+  # Add CUDA/HIP tests.
+  set(DEVICE_EXAMPLES
+      # serial examples with device support:
+      ex9
+      # parallel examples with device support:
+      ex9p)
+  set(MFEM_TEST_DEVICE)
+  if (MFEM_USE_CUDA)
+    set(MFEM_TEST_DEVICE "cuda")
+  elseif (MFEM_USE_HIP)
+    set(MFEM_TEST_DEVICE "hip")
+  endif()
+  if (MFEM_TEST_DEVICE)
+    foreach(TEST_NAME ${DEVICE_EXAMPLES})
+      string(TOUPPER ${TEST_NAME} UP_TEST_NAME)
+
+      set(THIS_TEST_OPTIONS "-no-vis" "-d" "${MFEM_TEST_DEVICE}")
+      list(APPEND THIS_TEST_OPTIONS ${${UP_TEST_NAME}_TEST_OPTS})
+
+      if (NOT (${TEST_NAME} MATCHES ".*p$"))
+        add_test(NAME ${PFX}${TEST_NAME}_${MFEM_TEST_DEVICE}_ser
+          COMMAND ${PFX}${TEST_NAME} ${THIS_TEST_OPTIONS})
+      else()
+        add_test(NAME ${PFX}${TEST_NAME}_${MFEM_TEST_DEVICE}_np=${MFEM_MPI_NP}
+          COMMAND ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${MFEM_MPI_NP}
+          ${MPIEXEC_PREFLAGS}
+          $<TARGET_FILE:${PFX}${TEST_NAME}> ${THIS_TEST_OPTIONS}
+          ${MPIEXEC_POSTFLAGS})
+      endif()
+    endforeach()
+  endif(MFEM_TEST_DEVICE)
+endif(MFEM_ENABLE_TESTING)
diff --git a/examples/sundials/README b/examples/sundials/README
index c3a9524f5..a18708529 100644
--- a/examples/sundials/README
+++ b/examples/sundials/README
@@ -12,8 +12,7 @@ use of MFEM features based on the SUNDIALS suite of time integration and
 non-linear solvers.
 
 To build these examples, make sure that MFEM is configured with the option
-"MFEM_USE_SUNDIALS = YES", see the top-level INSTALL file for details (version
-2.7 or higher of SUNDIALS is required).
+"MFEM_USE_SUNDIALS = YES", see the top-level INSTALL file for details.
 
 We recommend comparing the original example codes with the corresponding files
 in the current directory.
diff --git a/examples/sundials/ex9.cpp b/examples/sundials/ex9.cpp
index d680310f6..3107fef24 100644
--- a/examples/sundials/ex9.cpp
+++ b/examples/sundials/ex9.cpp
@@ -280,15 +280,16 @@ int main(int argc, char *argv[])
       k.SetAssemblyLevel(AssemblyLevel::FULL);
    }
    m.AddDomainIntegrator(new MassIntegrator);
-   k.AddDomainIntegrator(new ConvectionIntegrator(velocity, -1.0));
+   constexpr double alpha = -1.0;
+   k.AddDomainIntegrator(new ConvectionIntegrator(velocity, alpha));
    k.AddInteriorFaceIntegrator(
-      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));
+      new NonconservativeDGTraceIntegrator(velocity, alpha));
    k.AddBdrFaceIntegrator(
-      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));
+      new NonconservativeDGTraceIntegrator(velocity, alpha));
 
    LinearForm b(&fes);
    b.AddBdrFaceIntegrator(
-      new BoundaryFlowIntegrator(inflow, velocity, -1.0, -0.5));
+      new BoundaryFlowIntegrator(inflow, velocity, alpha));
 
    m.Assemble();
    int skip_zeros = 0;
diff --git a/examples/sundials/ex9p.cpp b/examples/sundials/ex9p.cpp
index 9896ebd09..03704f41d 100644
--- a/examples/sundials/ex9p.cpp
+++ b/examples/sundials/ex9p.cpp
@@ -63,6 +63,66 @@ double inflow_function(const Vector &x);
 // Mesh bounding box
 Vector bb_min, bb_max;
 
+// Type of preconditioner for implicit time integrator
+enum class PrecType : int
+{
+   ILU = 0,
+   AIR = 1
+};
+
+#if MFEM_HYPRE_VERSION >= 21800
+// Algebraic multigrid preconditioner for advective problems based on
+// approximate ideal restriction (AIR). Most effective when matrix is
+// first scaled by DG block inverse, and AIR applied to scaled matrix.
+// See https://doi.org/10.1137/17M1144350.
+class AIR_prec : public Solver
+{
+private:
+   const HypreParMatrix *A;
+   // Copy of A scaled by block-diagonal inverse
+   HypreParMatrix A_s;
+
+   HypreBoomerAMG *AIR_solver;
+   int blocksize;
+
+public:
+   AIR_prec(int blocksize_) : AIR_solver(NULL), blocksize(blocksize_) { }
+
+   void SetOperator(const Operator &op)
+   {
+      width = op.Width();
+      height = op.Height();
+
+      A = dynamic_cast<const HypreParMatrix *>(&op);
+      MFEM_VERIFY(A != NULL, "AIR_prec requires a HypreParMatrix.")
+
+      // Scale A by block-diagonal inverse
+      BlockInverseScale(A, &A_s, NULL, NULL, blocksize,
+                        BlockInverseScaleJob::MATRIX_ONLY);
+      delete AIR_solver;
+      AIR_solver = new HypreBoomerAMG(A_s);
+      AIR_solver->SetAdvectiveOptions(1, "", "FA");
+      AIR_solver->SetPrintLevel(0);
+      AIR_solver->SetMaxLevels(50);
+   }
+
+   virtual void Mult(const Vector &x, Vector &y) const
+   {
+      // Scale the rhs by block inverse and solve system
+      HypreParVector z_s;
+      BlockInverseScale(A, NULL, &x, &z_s, blocksize,
+                        BlockInverseScaleJob::RHS_ONLY);
+      AIR_solver->Mult(z_s, y);
+   }
+
+   ~AIR_prec()
+   {
+      delete AIR_solver;
+   }
+};
+#endif
+
+
 class DG_Solver : public Solver
 {
 private:
@@ -70,24 +130,37 @@ private:
    SparseMatrix M_diag;
    HypreParMatrix *A;
    GMRESSolver linear_solver;
-   BlockILU prec;
+   Solver *prec;
    double dt;
 public:
-   DG_Solver(HypreParMatrix &M_, HypreParMatrix &K_, const FiniteElementSpace &fes)
+   DG_Solver(HypreParMatrix &M_, HypreParMatrix &K_, const FiniteElementSpace &fes,
+             PrecType prec_type)
       : M(M_),
         K(K_),
         A(NULL),
         linear_solver(M.GetComm()),
-        prec(fes.GetFE(0)->GetDof(),
-             BlockILU::Reordering::MINIMUM_DISCARDED_FILL),
         dt(-1.0)
    {
+      int block_size = fes.GetFE(0)->GetDof();
+      if (prec_type == PrecType::ILU)
+      {
+         prec = new BlockILU(block_size,
+                             BlockILU::Reordering::MINIMUM_DISCARDED_FILL);
+      }
+      else if (prec_type == PrecType::AIR)
+      {
+#if MFEM_HYPRE_VERSION >= 21800
+         prec = new AIR_prec(block_size);
+#else
+         MFEM_ABORT("Must have MFEM_HYPRE_VERSION >= 21800 to use AIR.\n");
+#endif
+      }
       linear_solver.iterative_mode = false;
       linear_solver.SetRelTol(1e-9);
       linear_solver.SetAbsTol(0.0);
       linear_solver.SetMaxIter(100);
       linear_solver.SetPrintLevel(0);
-      linear_solver.SetPreconditioner(prec);
+      linear_solver.SetPreconditioner(*prec);
 
       M.GetDiag(M_diag);
    }
@@ -120,10 +193,12 @@ public:
 
    ~DG_Solver()
    {
+      delete prec;
       delete A;
    }
 };
 
+
 /** A time-dependent operator for the right-hand side of the ODE. The DG weak
     form of du/dt = -v.grad(u) is M du/dt = K u + b, where M and K are the mass
     and advection matrices, and b describes the flow on the boundary. This can
@@ -141,7 +216,8 @@ private:
    mutable Vector z;
 
 public:
-   FE_Evolution(ParBilinearForm &M_, ParBilinearForm &K_, const Vector &b_);
+   FE_Evolution(ParBilinearForm &M_, ParBilinearForm &K_, const Vector &b_,
+                PrecType prec_type);
 
    virtual void Mult(const Vector &x, Vector &y) const;
    virtual void ImplicitSolve(const double dt, const Vector &x, Vector &k);
@@ -178,6 +254,11 @@ int main(int argc, char *argv[])
    bool adios2 = false;
    bool binary = false;
    int vis_steps = 5;
+#if MFEM_HYPRE_VERSION >= 21800
+   PrecType prec_type = PrecType::AIR;
+#else
+   PrecType prec_type = PrecType::ILU;
+#endif
 
    // Relative and absolute tolerances for CVODE and ARKODE.
    const double reltol = 1e-2, abstol = 1e-2;
@@ -218,6 +299,8 @@ int main(int argc, char *argv[])
                   "Final time; start time is 0.");
    args.AddOption(&dt, "-dt", "--time-step",
                   "Time step.");
+   args.AddOption((int *)&prec_type, "-pt", "--prec-type", "Preconditioner for "
+                  "implicit solves. 0 for ILU, 1 for pAIR-AMG.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -238,13 +321,13 @@ int main(int argc, char *argv[])
    args.Parse();
    if (!args.Good())
    {
-      if (myid == 0)
+      if (Mpi::Root())
       {
          args.PrintUsage(cout);
       }
       return 1;
    }
-   if (myid == 0)
+   if (Mpi::Root())
    {
       args.PrintOptions(cout);
    }
@@ -252,7 +335,7 @@ int main(int argc, char *argv[])
    // check for valid ODE solver option
    if (ode_solver_type < 1 || ode_solver_type > 9)
    {
-      if (myid == 0)
+      if (Mpi::Root())
       {
          cout << "Unknown ODE solver type: " << ode_solver_type << '\n';
       }
@@ -260,7 +343,7 @@ int main(int argc, char *argv[])
    }
 
    Device device(device_config);
-   if (myid == 0) { device.Print(); }
+   if (Mpi::Root()) { device.Print(); }
 
    // 3. Read the serial mesh from the given mesh file on all processors. We can
    //    handle geometrically periodic meshes in this code.
@@ -297,7 +380,7 @@ int main(int argc, char *argv[])
    ParFiniteElementSpace *fes = new ParFiniteElementSpace(pmesh, &fec);
 
    HYPRE_BigInt global_vSize = fes->GlobalTrueVSize();
-   if (myid == 0)
+   if (Mpi::Root())
    {
       cout << "Number of unknowns: " << global_vSize << endl;
    }
@@ -328,15 +411,16 @@ int main(int argc, char *argv[])
    }
 
    m->AddDomainIntegrator(new MassIntegrator);
-   k->AddDomainIntegrator(new ConvectionIntegrator(velocity, -1.0));
+   constexpr double alpha = -1.0;
+   k->AddDomainIntegrator(new ConvectionIntegrator(velocity, alpha));
    k->AddInteriorFaceIntegrator(
-      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));
+      new NonconservativeDGTraceIntegrator(velocity, alpha));
    k->AddBdrFaceIntegrator(
-      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));
+      new NonconservativeDGTraceIntegrator(velocity, alpha));
 
    ParLinearForm *b = new ParLinearForm(fes);
    b->AddBdrFaceIntegrator(
-      new BoundaryFlowIntegrator(inflow, velocity, -1.0, -0.5));
+      new BoundaryFlowIntegrator(inflow, velocity, alpha));
 
    int skip_zeros = 0;
    m->Assemble();
@@ -435,11 +519,13 @@ int main(int argc, char *argv[])
       sout.open(vishost, visport);
       if (!sout)
       {
-         if (myid == 0)
+         if (Mpi::Root())
+         {
             cout << "Unable to connect to GLVis server at "
                  << vishost << ':' << visport << endl;
+         }
          visualization = false;
-         if (myid == 0)
+         if (Mpi::Root())
          {
             cout << "GLVis visualization disabled.\n";
          }
@@ -451,15 +537,17 @@ int main(int argc, char *argv[])
          sout << "solution\n" << *pmesh << *u;
          sout << "pause\n";
          sout << flush;
-         if (myid == 0)
+         if (Mpi::Root())
+         {
             cout << "GLVis visualization paused."
                  << " Press space (in the GLVis window) to resume it.\n";
+         }
       }
    }
 
    // 9. Define the time-dependent evolution operator describing the ODE
    //    right-hand side, and define the ODE solver used for time integration.
-   FE_Evolution adv(*m, *k, *B);
+   FE_Evolution adv(*m, *k, *B, prec_type);
 
    double t = 0.0;
    adv.SetTime(t);
@@ -511,7 +599,7 @@ int main(int argc, char *argv[])
 
       if (done || ti % vis_steps == 0)
       {
-         if (myid == 0)
+         if (Mpi::Root())
          {
             cout << "time step: " << ti << ", time: " << t << endl;
             if (cvode) { cvode->PrintInfo(); }
@@ -590,7 +678,7 @@ int main(int argc, char *argv[])
 
 // Implementation of class FE_Evolution
 FE_Evolution::FE_Evolution(ParBilinearForm &M_, ParBilinearForm &K_,
-                           const Vector &b_)
+                           const Vector &b_, PrecType prec_type)
    : TimeDependentOperator(M_.Height()),
      b(b_),
      M_solver(M_.ParFESpace()->GetComm()),
@@ -617,7 +705,7 @@ FE_Evolution::FE_Evolution(ParBilinearForm &M_, ParBilinearForm &K_,
       HypreSmoother *hypre_prec = new HypreSmoother(M_mat, HypreSmoother::Jacobi);
       M_prec = hypre_prec;
 
-      dg_solver = new DG_Solver(M_mat, K_mat, *M_.FESpace());
+      dg_solver = new DG_Solver(M_mat, K_mat, *M_.FESpace(), prec_type);
    }
    else
    {
@@ -633,6 +721,10 @@ FE_Evolution::FE_Evolution(ParBilinearForm &M_, ParBilinearForm &K_,
    M_solver.SetPrintLevel(0);
 }
 
+// Solve the equation:
+//    u_t = M^{-1}(Ku + b),
+// by solving associated linear system
+//    (M - dt*K) d = K*u + b
 void FE_Evolution::ImplicitSolve(const double dt, const Vector &x, Vector &k)
 {
    K->Mult(x, z);
diff --git a/examples/sundials/makefile b/examples/sundials/makefile
index d8579a9e9..15c5615de 100644
--- a/examples/sundials/makefile
+++ b/examples/sundials/makefile
@@ -23,6 +23,8 @@ MFEM_LIB_FILE = mfem_is_not_built
 
 SEQ_EXAMPLES = ex9 ex10 ex16
 PAR_EXAMPLES = ex9p ex10p ex16p
+SEQ_DEVICE_EXAMPLES = ex9
+PAR_DEVICE_EXAMPLES = ex9p
 ifeq ($(MFEM_USE_MPI),NO)
    EXAMPLES = $(SEQ_EXAMPLES)
 else
@@ -54,10 +56,22 @@ include $(MFEM_TEST_MK)
 RUN_MPI = $(MFEM_MPIEXEC) $(MFEM_MPIEXEC_NP) $(MFEM_MPI_NP)
 SERIAL_NAME := Serial SUNDIALS example
 PARALLEL_NAME := Parallel SUNDIALS example
+SERIAL_CUDA_NAME := Serial SUNDIALS CUDA example
+PARALLEL_CUDA_NAME := Parallel SUNDIALS CUDA example
+SERIAL_HIP_NAME := Serial SUNDIALS HIP example
+PARALLEL_HIP_NAME := Parallel SUNDIALS HIP example
 %-test-par: %
 	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_NAME))
 %-test-seq: %
 	@$(call mfem-test,$<,, $(SERIAL_NAME))
+%-test-par-cuda: %
+	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_CUDA_NAME),-d cuda)
+%-test-seq-cuda: %
+	@$(call mfem-test,$<,, $(SERIAL_CUDA_NAME),-d cuda)
+%-test-par-hip: %
+	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_HIP_NAME),-d hip)
+%-test-seq-hip: %
+	@$(call mfem-test,$<,, $(SERIAL_HIP_NAME),-d hip)
 
 # Testing: Specific execution options:
 # Example 9: test CVODE with CV_ADAMS (non-stiff implicit) time stepping
@@ -68,6 +82,16 @@ ex9-test-seq: ex9
 	@$(call mfem-test,$<,, $(SERIAL_NAME),$(EX9_ARGS))
 ex9p-test-par: ex9p
 	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_NAME),$(EX9P_ARGS))
+ex9-test-seq-cuda: ex9
+	@$(call mfem-test,$<,, $(SERIAL_CUDA_NAME),-d cuda $(EX9_ARGS))
+ex9p-test-par-cuda: ex9p
+	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_CUDA_NAME),-d cuda \
+	   $(EX9P_ARGS))
+ex9-test-seq-hip: ex9
+	@$(call mfem-test,$<,, $(SERIAL_HIP_NAME),-d hip $(EX9_ARGS))
+ex9p-test-par-hip: ex9p
+	@$(call mfem-test,$<, $(RUN_MPI), $(PARALLEL_HIP_NAME),-d hip \
+	   $(EX9P_ARGS))
 # Example 10: test CVODE with CV_BDF (stiff implicit) time stepping
 EX10_COMMON_ARGS := -m ../../data/beam-quad.mesh -o 2 -s 5 -dt 0.15 -tf 6 -vs 10
 EX10_ARGS  := $(EX10_COMMON_ARGS) -r  2
diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index 462ef72aa..aea1f901d 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -13,28 +13,44 @@ set(SRCS
   bilinearform.cpp
   bilinearform_ext.cpp
   bilininteg.cpp
-  bilininteg_br2.cpp
-  bilininteg_convection_mf.cpp
-  bilininteg_convection_pa.cpp
-  bilininteg_convection_ea.cpp
-  bilininteg_dgtrace_pa.cpp
-  bilininteg_dgtrace_ea.cpp
-  bilininteg_diffusion_mf.cpp
-  bilininteg_diffusion_pa.cpp
-  bilininteg_diffusion_ea.cpp
-  bilininteg_divergence.cpp
-  bilininteg_hcurl.cpp
-  bilininteg_hdiv.cpp
-  bilininteg_vectorfe.cpp
-  bilininteg_gradient.cpp
-  bilininteg_mass_mf.cpp
-  bilininteg_mass_pa.cpp
-  bilininteg_mass_ea.cpp
-  bilininteg_transpose_ea.cpp
-  bilininteg_vecdiffusion.cpp
-  bilininteg_vecdiffusion_mf.cpp
-  bilininteg_vecmass.cpp
-  bilininteg_vecmass_mf.cpp
+  integ/bilininteg_br2.cpp
+  integ/bilininteg_convection_mf.cpp
+  integ/bilininteg_convection_pa.cpp
+  integ/bilininteg_convection_ea.cpp
+  integ/bilininteg_curlcurl_pa.cpp
+  integ/bilininteg_dgtrace_pa.cpp
+  integ/bilininteg_dgtrace_ea.cpp
+  integ/bilininteg_diffusion_mf.cpp
+  integ/bilininteg_diffusion_pa.cpp
+  integ/bilininteg_diffusion_ea.cpp
+  integ/bilininteg_divdiv_pa.cpp
+  integ/bilininteg_gradient_pa.cpp
+  integ/bilininteg_interp_pa.cpp
+  integ/bilininteg_mass_mf.cpp
+  integ/bilininteg_mass_pa.cpp
+  integ/bilininteg_mass_ea.cpp
+  integ/bilininteg_mixedcurl_pa.cpp
+  integ/bilininteg_mixedvecgrad_pa.cpp
+  integ/bilininteg_transpose_ea.cpp
+  integ/bilininteg_vecdiffusion_mf.cpp
+  integ/bilininteg_vecdiffusion_pa.cpp
+  integ/bilininteg_vecdiv_pa.cpp
+  integ/bilininteg_vecmass_mf.cpp
+  integ/bilininteg_vecmass_pa.cpp
+  integ/bilininteg_vectorfediv_pa.cpp
+  integ/bilininteg_vectorfemass_pa.cpp
+  integ/bilininteg_diffusion_kernels.cpp
+  integ/bilininteg_hcurl_kernels.cpp
+  integ/bilininteg_hdiv_kernels.cpp
+  integ/bilininteg_hcurlhdiv_kernels.cpp
+  integ/bilininteg_mass_kernels.cpp
+  integ/lininteg_boundary.cpp
+  integ/lininteg_boundary_flux.cpp
+  integ/lininteg_domain.cpp
+  integ/lininteg_domain_grad.cpp
+  integ/lininteg_domain_vectorfe.cpp
+  integ/nonlininteg_vecconvection_pa.cpp
+  integ/nonlininteg_vecconvection_mf.cpp
   coefficient.cpp
   complex_fem.cpp
   convergence.cpp
@@ -74,11 +90,6 @@ set(SRCS
   linearform.cpp
   linearform_ext.cpp
   lininteg.cpp
-  lininteg_boundary.cpp
-  lininteg_boundary_flux.cpp
-  lininteg_domain.cpp
-  lininteg_domain_grad.cpp
-  lininteg_vectorfe_domain.cpp
   lor/lor.cpp
   lor/lor_ads.cpp
   lor/lor_ams.cpp
@@ -91,8 +102,6 @@ set(SRCS
   nonlinearform_ext.cpp
   nonlininteg.cpp
   fespacehierarchy.cpp
-  nonlininteg_vectorconvection.cpp
-  nonlininteg_vectorconvection_mf.cpp
   qfunction.cpp
   qinterp/det.cpp
   qinterp/eval_by_nodes.cpp
@@ -143,7 +152,11 @@ set(HDRS
   bilinearform.hpp
   bilinearform_ext.hpp
   bilininteg.hpp
-  bilininteg_mass_pa.hpp
+  integ/bilininteg_diffusion_kernels.hpp
+  integ/bilininteg_hcurl_kernels.hpp
+  integ/bilininteg_hdiv_kernels.hpp
+  integ/bilininteg_hcurlhdiv_kernels.hpp
+  integ/bilininteg_mass_kernels.hpp
   coefficient.hpp
   complex_fem.hpp
   convergence.hpp
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index 50c2cf198..d21a43ccc 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -56,6 +56,9 @@ void MFBilinearFormExtension::Assemble()
    {
       integrators[i]->AssembleMF(*a->FESpace());
    }
+
+   MFEM_VERIFY(a->GetBBFI()->Size() == 0, "AddBoundaryIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
 }
 
 void MFBilinearFormExtension::AssembleDiagonal(Vector &y) const
@@ -275,7 +278,9 @@ void PABilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
       int_face_Y.UseDevice(true); // ensure 'int_face_Y = 0.0' is done on device
    }
 
-   if (bdr_face_restrict_lex == NULL && a->GetBFBFI()->Size() > 0)
+   const bool has_bdr_integs = (a->GetBFBFI()->Size() > 0 ||
+                                a->GetBBFI()->Size() > 0);
+   if (bdr_face_restrict_lex == NULL && has_bdr_integs)
    {
       bdr_face_restrict_lex = trial_fes->GetFaceRestriction(
                                  ElementDofOrdering::LEXICOGRAPHIC,
@@ -292,27 +297,27 @@ void PABilinearFormExtension::Assemble()
    SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
    Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      integrators[i]->AssemblePA(*a->FESpace());
+      integ->AssemblePA(*a->FESpace());
    }
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
+   Array<BilinearFormIntegrator*> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssemblePABoundary(*a->FESpace());
+   }
 
    Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+   for (BilinearFormIntegrator *integ : intFaceIntegrators)
    {
-      intFaceIntegrators[i]->AssemblePAInteriorFaces(*a->FESpace());
+      integ->AssemblePAInteriorFaces(*a->FESpace());
    }
 
    Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+   for (BilinearFormIntegrator *integ : bdrFaceIntegrators)
    {
-      bdrFaceIntegrators[i]->AssemblePABoundaryFaces(*a->FESpace());
+      integ->AssemblePABoundaryFaces(*a->FESpace());
    }
 }
 
@@ -323,20 +328,27 @@ void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
    const int iSz = integrators.Size();
    if (elem_restrict && !DeviceCanUseCeed())
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalPA(localY);
-      }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
+      if (iSz > 0)
       {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
+         localY = 0.0;
+         for (int i = 0; i < iSz; ++i)
+         {
+            integrators[i]->AssembleDiagonalPA(localY);
+         }
+         const ElementRestriction* H1elem_restrict =
+            dynamic_cast<const ElementRestriction*>(elem_restrict);
+         if (H1elem_restrict)
+         {
+            H1elem_restrict->MultTransposeUnsigned(localY, y);
+         }
+         else
+         {
+            elem_restrict->MultTranspose(localY, y);
+         }
       }
       else
       {
-         elem_restrict->MultTranspose(localY, y);
+         y = 0.0;
       }
    }
    else
@@ -348,6 +360,18 @@ void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
          integrators[i]->AssembleDiagonalPA(y);
       }
    }
+
+   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
+   const int n_bdr_integs = bdr_integs.Size();
+   if (bdr_face_restrict_lex && n_bdr_integs > 0)
+   {
+      bdr_face_Y = 0.0;
+      for (int i = 0; i < n_bdr_integs; ++i)
+      {
+         bdr_integs[i]->AssembleDiagonalPA(bdr_face_Y);
+      }
+      bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_Y, y);
+   }
 }
 
 void PABilinearFormExtension::Update()
@@ -397,13 +421,20 @@ void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (iSz)
+      {
+         elem_restrict->Mult(x, localX);
+         localY = 0.0;
+         for (int i = 0; i < iSz; ++i)
+         {
+            integrators[i]->AddMultPA(localX, localY);
+         }
+         elem_restrict->MultTranspose(localY, y);
+      }
+      else
       {
-         integrators[i]->AddMultPA(localX, localY);
+         y = 0.0;
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
    Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
@@ -422,17 +453,24 @@ void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
       }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
+   Array<BilinearFormIntegrator*> &bdr_face_integs = *a->GetBFBFI();
+   const int n_bdr_integs = bdr_integs.Size();
+   const int n_bdr_face_integs = bdr_face_integs.Size();
+   const bool has_bdr_integs = (n_bdr_face_integs > 0 || n_bdr_integs > 0);
+   if (bdr_face_restrict_lex && has_bdr_integs)
    {
       bdr_face_restrict_lex->Mult(x, bdr_face_X);
       if (bdr_face_X.Size()>0)
       {
          bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (int i = 0; i < n_bdr_integs; ++i)
+         {
+            bdr_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
+         }
+         for (int i = 0; i < n_bdr_face_integs; ++i)
          {
-            bdrFaceIntegrators[i]->AddMultPA(bdr_face_X, bdr_face_Y);
+            bdr_face_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
          }
          bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index c552e9510..cd7570c69 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -22,41 +22,47 @@ namespace mfem
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&,
                                         const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleDiagonalPA(Vector &)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace &fes,
                                         Vector &emat,
                                         const bool add)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
@@ -65,8 +71,8 @@ void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
                                                      Vector &ea_data_ext,
                                                      const bool add)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
@@ -74,8 +80,8 @@ void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
                                                      Vector &ea_data_bdr,
                                                      const bool add)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
@@ -86,62 +92,62 @@ void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
 
 void BilinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
 {
-   mfem_error ("BilinearFormIntegrator::MultAssembled(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AddMultTransposePA(const Vector &, Vector &) const
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
 {
-   mfem_error ("BilinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AddMultTransposeMF(const Vector &, Vector &) const
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleDiagonalMF(Vector &)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleElementMatrix (
    const FiniteElement &el, ElementTransformation &Trans,
    DenseMatrix &elmat )
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleElementMatrix2 (
    const FiniteElement &el1, const FiniteElement &el2,
    ElementTransformation &Trans, DenseMatrix &elmat )
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleFaceMatrix (
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleFaceMatrix(
@@ -2643,7 +2649,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
    else
    {
-      mfem_error("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
+      MFEM_ABORT("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
                  "   is not implemented for given trial and test bases.");
    }
 }
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index a4b09543d..62a16935a 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -61,6 +61,8 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
@@ -2198,8 +2200,9 @@ protected:
    // PA extension
    const FiniteElementSpace *fespace;
    Vector pa_data;
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
+   const DofToQuad *maps;                 ///< Not owned
+   const GeometricFactors *geom;          ///< Not owned
+   const FaceGeometricFactors *face_geom; ///< Not owned
    int dim, ne, nq, dofs1D, quad1D;
 
 public:
@@ -2226,6 +2229,8 @@ public:
 
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
                            const bool add);
 
@@ -3622,17 +3627,5 @@ protected:
    VectorCoefficient *VQ;
 };
 
-
-
-// PA Diffusion Assemble 2D kernel
-template<const int T_SDIM>
-void PADiffusionSetup2D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const Array<double> &w,
-                        const Vector &j,
-                        const Vector &c,
-                        Vector &d);
-
 }
 #endif
diff --git a/fem/bilininteg_hcurl.cpp b/fem/bilininteg_hcurl.cpp
deleted file mode 100644
index e8762a71e..000000000
--- a/fem/bilininteg_hcurl.cpp
+++ /dev/null
@@ -1,7764 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qspace.hpp"
-
-using namespace std;
-
-namespace mfem
-{
-
-void PAHcurlHdivSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op);
-
-void PAHcurlMassApply2D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O21 = op(qx,qy,1,e);
-            const double O12 = symmetric ? O21 : op(qx,qy,2,e);
-            const double O22 = symmetric ? op(qx,qy,2,e) : op(qx,qy,3,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O21*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double massX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-void PAHcurlMassAssembleDiagonal2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double mass[MAX_Q1D];
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-
-                  mass[qx] += wy * wy * ((c == 0) ? op(qx,qy,0,e) :
-                                         op(qx,qy,symmetric ? 2 : 3, e));
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  D(dx + (dy * D1Dx) + osc, e) += mass[qx] * wx * wx;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-void PAHcurlMassAssembleDiagonal3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                         (symmetric ? 5 : 8));
-
-         double mass[MAX_Q1D];
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qx] = 0.0;
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-
-                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
-                     }
-                  }
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                     D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += mass[qx] * wx * wx;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int T_D1D, int T_Q1D>
-void SmemPAHcurlMassAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const bool symmetric,
-                                       const Array<double> &bo,
-                                       const Array<double> &bc,
-                                       const Vector &pa_data,
-                                       Vector &diag)
-{
-   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int tD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
-      constexpr int tQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
-
-      MFEM_SHARED double sBo[tQ1D][tD1D];
-      MFEM_SHARED double sBc[tQ1D][tD1D];
-
-      double op3[3];
-      MFEM_SHARED double sop[3][tQ1D][tQ1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               op3[0] = op(qx,qy,qz,0,e);
-               op3[1] = op(qx,qy,qz,symmetric ? 3 : 4,e);
-               op3[2] = op(qx,qy,qz,symmetric ? 5 : 8,e);
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double dxyz = 0.0;
-
-         for (int qz=0; qz < Q1D; ++qz)
-         {
-            if (tidz == qz)
-            {
-               for (int i=0; i<3; ++i)
-               {
-                  sop[i][tidx][tidy] = op3[i];
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
-
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
-                           dxyz += sop[c][qx][qy] * wx * wx * wy * wy * wz * wz;
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-         }  // qz loop
-
-         MFEM_FOREACH_THREAD(dz,z,D1Dz)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1Dy)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1Dx)
-               {
-                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // c loop
-   }); // end of element loop
-}
-
-void PAHcurlMassApply3D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
-               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
-               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
-               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
-               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
-               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-template<int T_D1D, int T_Q1D>
-void SmemPAHcurlMassApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const bool symmetric,
-                            const Array<double> &bo,
-                            const Array<double> &bc,
-                            const Array<double> &bot,
-                            const Array<double> &bct,
-                            const Vector &pa_data,
-                            const Vector &x,
-                            Vector &y)
-{
-   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   const int dataSize = symmetric ? 6 : 9;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, dataSize, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int tD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
-      constexpr int tQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
-
-      MFEM_SHARED double sBo[tQ1D][tD1D];
-      MFEM_SHARED double sBc[tQ1D][tD1D];
-
-      double op9[9];
-      MFEM_SHARED double sop[9*tQ1D*tQ1D];
-      MFEM_SHARED double mass[tQ1D][tQ1D][3];
-
-      MFEM_SHARED double sX[tD1D][tD1D][tD1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<dataSize; ++i)
-               {
-                  op9[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               for (int i=0; i<dataSize; ++i)
-               {
-                  sop[i + (dataSize*tidx) + (dataSize*Q1D*tidy)] = op9[i];
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              const double t = sX[dz][dy][dx];
-                              const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
-                              u += t * wx * wy * wz;
-                           }
-                        }
-                     }
-
-                     mass[qy][qx][c] = u;
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         MFEM_SYNC_THREAD;  // Sync mass[qy][qx][d] and sop
-
-         osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double dxyz = 0.0;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const int os = (dataSize*qx) + (dataSize*Q1D*qy);
-                           const int id1 = os + ((c == 0) ? 0 : ((c == 1) ? (symmetric ? 1 : 3) :
-                                                                 (symmetric ? 2 : 6))); // O11, O21, O31
-                           const int id2 = os + ((c == 0) ? 1 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                                                 (symmetric ? 4 : 7))); // O12, O22, O32
-                           const int id3 = os + ((c == 0) ? 2 : ((c == 1) ? (symmetric ? 4 : 5) :
-                                                                 (symmetric ? 5 : 8))); // O13, O23, O33
-
-                           const double m_c = (sop[id1] * mass[qy][qx][0]) + (sop[id2] * mass[qy][qx][1]) +
-                                              (sop[id3] * mass[qy][qx][2]);
-
-                           const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
-                           dxyz += m_c * wx * wy * wz;
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         } // c loop
-      } // qz
-   }); // end of element loop
-}
-
-// PA H(curl) curl-curl assemble 2D kernel
-static void PACurlCurlSetup2D(const int Q1D,
-                              const int NE,
-                              const Array<double> &w,
-                              const Vector &j,
-                              Vector &coeff,
-                              Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
-   auto C = Reshape(coeff.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double detJ = (J11*J22)-(J21*J12);
-         y(q,e) = W[q] * C(q,e) / detJ;
-      }
-   });
-}
-
-// PA H(curl) curl-curl assemble 3D kernel
-static void PACurlCurlSetup3D(const int Q1D,
-                              const int coeffDim,
-                              const int NE,
-                              const Array<double> &w,
-                              const Vector &j,
-                              Vector &coeff,
-                              Vector &op)
-{
-   const int NQ = Q1D*Q1D*Q1D;
-   const bool symmetric = (coeffDim != 9);
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
-   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
-   auto y = Reshape(op.Write(), NQ, symmetric ? 6 : 9, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J31 = J(q,2,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double J32 = J(q,2,1,e);
-         const double J13 = J(q,0,2,e);
-         const double J23 = J(q,1,2,e);
-         const double J33 = J(q,2,2,e);
-         const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                             J21 * (J12 * J33 - J32 * J13) +
-                             J31 * (J12 * J23 - J22 * J13);
-
-         const double c_detJ = W[q] / detJ;
-
-         if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-         {
-            // Set y to the 6 or 9 entries of J^T M J / det
-            const double M11 = C(0, q, e);
-            const double M12 = C(1, q, e);
-            const double M13 = C(2, q, e);
-            const double M21 = (!symmetric) ? C(3, q, e) : M12;
-            const double M22 = (!symmetric) ? C(4, q, e) : C(3, q, e);
-            const double M23 = (!symmetric) ? C(5, q, e) : C(4, q, e);
-            const double M31 = (!symmetric) ? C(6, q, e) : M13;
-            const double M32 = (!symmetric) ? C(7, q, e) : M23;
-            const double M33 = (!symmetric) ? C(8, q, e) : C(5, q, e);
-
-            // First compute R = MJ
-            const double R11 = M11*J11 + M12*J21 + M13*J31;
-            const double R12 = M11*J12 + M12*J22 + M13*J32;
-            const double R13 = M11*J13 + M12*J23 + M13*J33;
-            const double R21 = M21*J11 + M22*J21 + M23*J31;
-            const double R22 = M21*J12 + M22*J22 + M23*J32;
-            const double R23 = M21*J13 + M22*J23 + M23*J33;
-            const double R31 = M31*J11 + M32*J21 + M33*J31;
-            const double R32 = M31*J12 + M32*J22 + M33*J32;
-            const double R33 = M31*J13 + M32*J23 + M33*J33;
-
-            // Now set y to J^T R / det
-            y(q,0,e) = c_detJ * (J11*R11 + J21*R21 + J31*R31); // 1,1
-            const double Y12 = c_detJ * (J11*R12 + J21*R22 + J31*R32);
-            y(q,1,e) = Y12; // 1,2
-            y(q,2,e) = c_detJ * (J11*R13 + J21*R23 + J31*R33); // 1,3
-
-            const double Y21 = c_detJ * (J12*R11 + J22*R21 + J32*R31);
-            const double Y22 = c_detJ * (J12*R12 + J22*R22 + J32*R32);
-            const double Y23 = c_detJ * (J12*R13 + J22*R23 + J32*R33);
-
-            const double Y33 = c_detJ * (J13*R13 + J23*R23 + J33*R33);
-
-            y(q,3,e) = symmetric ? Y22 : Y21; // 2,2 or 2,1
-            y(q,4,e) = symmetric ? Y23 : Y22; // 2,3 or 2,2
-            y(q,5,e) = symmetric ? Y33 : Y23; // 3,3 or 2,3
-
-            if (!symmetric)
-            {
-               y(q,6,e) = c_detJ * (J13*R11 + J23*R21 + J33*R31); // 3,1
-               y(q,7,e) = c_detJ * (J13*R12 + J23*R22 + J33*R32); // 3,2
-               y(q,8,e) = Y33; // 3,3
-            }
-         }
-         else  // Vector or scalar coefficient version
-         {
-            // Set y to the 6 entries of J^T D J / det^2
-            const double D1 = C(0, q, e);
-            const double D2 = coeffDim == 3 ? C(1, q, e) : D1;
-            const double D3 = coeffDim == 3 ? C(2, q, e) : D1;
-
-            y(q,0,e) = c_detJ * (D1*J11*J11 + D2*J21*J21 + D3*J31*J31); // 1,1
-            y(q,1,e) = c_detJ * (D1*J11*J12 + D2*J21*J22 + D3*J31*J32); // 1,2
-            y(q,2,e) = c_detJ * (D1*J11*J13 + D2*J21*J23 + D3*J31*J33); // 1,3
-            y(q,3,e) = c_detJ * (D1*J12*J12 + D2*J22*J22 + D3*J32*J32); // 2,2
-            y(q,4,e) = c_detJ * (D1*J12*J13 + D2*J22*J23 + D3*J32*J33); // 2,3
-            y(q,5,e) = c_detJ * (D1*J13*J13 + D2*J23*J23 + D3*J33*J33); // 3,3
-         }
-      }
-   });
-}
-
-// PA H(curl)-L2 assemble 2D kernel
-static void PACurlL2Setup2D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            Vector &coeff,
-                            Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto C = Reshape(coeff.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         y(q,e) = W[q] * C(q,e);
-      }
-   });
-}
-
-void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
-                                                     *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
-   if (Q) { coeff.Project(*Q); }
-   else if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dim*dim);
-   const int sym_dims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int ndata = (dim == 2) ? 1 : (symmetric ? sym_dims : dim*dim);
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   if (el->GetDerivType() != mfem::FiniteElement::CURL)
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-
-   if (dim == 3)
-   {
-      PACurlCurlSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      PACurlCurlSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-}
-
-static void PACurlCurlApply2D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &bo,
-                              const Array<double> &bot,
-                              const Array<double> &gc,
-                              const Array<double> &gct,
-                              const Vector &pa_data,
-                              const Vector &x,
-                              Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D];
-
-      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] = 0.0;
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double gradX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx] = 0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  curl[qy][qx] += gradX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double gradX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               gradX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradX[dx] += curl[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PACurlCurlApply3D(const int D1D,
-                              const int Q1D,
-                              const bool symmetric,
-                              const int NE,
-                              const Array<double> &bo,
-                              const Array<double> &bc,
-                              const Array<double> &bot,
-                              const Array<double> &bct,
-                              const Array<double> &gc,
-                              const Array<double> &gct,
-                              const Vector &pa_data,
-                              const Vector &x,
-                              Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
-               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
-               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
-               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
-               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
-               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
-
-               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
-                                 (O13 * curl[qz][qy][qx][2]);
-               const double c2 = (O21 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
-                                 (O23 * curl[qz][qy][qx][2]);
-               const double c3 = (O31 * curl[qz][qy][qx][0]) + (O32 * curl[qz][qy][qx][1]) +
-                                 (O33 * curl[qz][qy][qx][2]);
-
-               curl[qz][qy][qx][0] = c1;
-               curl[qz][qy][qx][1] = c2;
-               curl[qz][qy][qx][2] = c3;
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * curl[qz][qy][qx][1];
-                     massX[dx][1] += wx * curl[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * curl[qz][qy][qx][2];
-                     massY[dy][1] += wy * curl[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * curl[qz][qy][qx][0];
-                     massZ[dz][1] += wz * curl[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPACurlCurlApply3D(const int D1D,
-                                  const int Q1D,
-                                  const bool symmetric,
-                                  const int NE,
-                                  const Array<double> &bo,
-                                  const Array<double> &bc,
-                                  const Array<double> &bot,
-                                  const Array<double> &bct,
-                                  const Array<double> &gc,
-                                  const Array<double> &gct,
-                                  const Vector &pa_data,
-                                  const Vector &x,
-                                  Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double ope[9];
-      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  ope[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     curl[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     sop[i][tidx][tidy] = ope[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-                     double v = 0.0;
-
-                     // We treat x, y, z components separately for optimization specific to each.
-                     if (c == 0) // x component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
-                                 u += wx * wDy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][1] += v; // (u_0)_{x_2}
-                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
-                     }
-                     else if (c == 1)  // y component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBo[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
-                        curl[qy][qx][2] += u; // (u_1)_{x_0}
-                     }
-                     else // z component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBo[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wDy * wz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] += v; // (u_2)_{x_1}
-                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
-                     }
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wcDz = sGc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wcDy = sGc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        const double O12 = sop[1][qx][qy];
-                        const double O13 = sop[2][qx][qy];
-                        const double O21 = symmetric ? O12 : sop[3][qx][qy];
-                        const double O22 = symmetric ? sop[3][qx][qy] : sop[4][qx][qy];
-                        const double O23 = symmetric ? sop[4][qx][qy] : sop[5][qx][qy];
-                        const double O31 = symmetric ? O13 : sop[6][qx][qy];
-                        const double O32 = symmetric ? O23 : sop[7][qx][qy];
-                        const double O33 = symmetric ? sop[5][qx][qy] : sop[8][qx][qy];
-
-                        const double c1 = (O11 * curl[qy][qx][0]) + (O12 * curl[qy][qx][1]) +
-                                          (O13 * curl[qy][qx][2]);
-                        const double c2 = (O21 * curl[qy][qx][0]) + (O22 * curl[qy][qx][1]) +
-                                          (O23 * curl[qy][qx][2]);
-                        const double c3 = (O31 * curl[qy][qx][0]) + (O32 * curl[qy][qx][1]) +
-                                          (O33 * curl[qy][qx][2]);
-
-                        const double wcx = sBc[dx][qx];
-                        const double wDx = sGc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                           // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
-                        }
-
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                        // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
-
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                        // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-static void PACurlL2Apply2D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &bo,
-                            const Array<double> &bot,
-                            const Array<double> &bt,
-                            const Array<double> &gc,
-                            const Vector &pa_data,
-                            const Vector &x, // trial = H(curl)
-                            Vector &y)  // test = L2 or H1
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-   const int H1 = (D1Dtest == D1D);
-
-   MFEM_VERIFY(y.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bt = Reshape(bt.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1Dtest, D1Dtest, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D];
-
-      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] = 0.0;
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double gradX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx] = 0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  curl[qy][qx] += gradX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double sol_x[MAX_D1D];
-         for (int dx = 0; dx < D1Dtest; ++dx)
-         {
-            sol_x[dx] = 0.0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double s = curl[qy][qx];
-            for (int dx = 0; dx < D1Dtest; ++dx)
-            {
-               sol_x[dx] += s * ((H1 == 1) ? Bt(dx,qx) : Bot(dx,qx));
-            }
-         }
-         for (int dy = 0; dy < D1Dtest; ++dy)
-         {
-            const double wy = (H1 == 1) ? Bt(dy,qy) : Bot(dy,qy);
-
-            for (int dx = 0; dx < D1Dtest; ++dx)
-            {
-               Y(dx,dy,e) += sol_x[dx] * wy;
-            }
-         }
-      }  // loop qy
-   }); // end of element loop
-}
-
-static void PACurlL2ApplyTranspose2D(const int D1D,
-                                     const int D1Dtest,
-                                     const int Q1D,
-                                     const int NE,
-                                     const Array<double> &bo,
-                                     const Array<double> &bot,
-                                     const Array<double> &b,
-                                     const Array<double> &gct,
-                                     const Vector &pa_data,
-                                     const Vector &x, // trial = H(curl)
-                                     Vector &y)  // test = L2 or H1
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-   const int H1 = (D1Dtest == D1D);
-
-   MFEM_VERIFY(x.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), D1Dtest, D1Dtest, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D];
-
-      // Zero-order term in L2 or H1 test space
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            mass[qy][qx] = 0.0;
-         }
-      }
-
-      for (int dy = 0; dy < D1Dtest; ++dy)
-      {
-         double sol_x[MAX_Q1D];
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            sol_x[qy] = 0.0;
-         }
-         for (int dx = 0; dx < D1Dtest; ++dx)
-         {
-            const double s = X(dx,dy,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               sol_x[qx] += s * ((H1 == 1) ? B(qx,dx) : Bo(qx,dx));
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double d2q = (H1 == 1) ? B(qy,dy) : Bo(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qy][qx] += d2q * sol_x[qx];
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            mass[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double gradX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               gradX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradX[dx] += mass[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPACurlCurlApply3D<2,3>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x34: return SmemPACurlCurlApply3D<3,4>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x45: return SmemPACurlCurlApply3D<4,5>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B,
-                                                            mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x56: return SmemPACurlCurlApply3D<5,6>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            default: return SmemPACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B,
-                                                     mapsC->B, mapsO->Bt, mapsC->Bt,
-                                                     mapsC->G, mapsC->Gt, pa_data, x, y);
-         }
-      }
-      else
-         PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B, mapsO->Bt,
-                           mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
-                        mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-static void PACurlCurlAssembleDiagonal2D(const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &bo,
-                                         const Array<double> &gc,
-                                         const Vector &pa_data,
-                                         Vector &diag)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double t[MAX_Q1D];
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               t[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : -Gc(qy,dy);
-                  t[qx] += wy * wy * op(qx,qy,e);
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-                  D(dx + (dy * D1Dx) + osc, e) += t[qx] * wx * wx;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PACurlCurlAssembleDiagonal3D(const int D1D,
-                                         const int Q1D,
-                                         const bool symmetric,
-                                         const int NE,
-                                         const Array<double> &bo,
-                                         const Array<double> &bc,
-                                         const Array<double> &go,
-                                         const Array<double> &gc,
-                                         const Vector &pa_data,
-                                         Vector &diag)
-{
-   constexpr static int VDIM = 3;
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Go = Reshape(go.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-   const int i11 = 0;
-   const int i12 = 1;
-   const int i13 = 2;
-   const int i21 = symmetric ? i12 : 3;
-   const int i22 = symmetric ? 3 : 4;
-   const int i23 = symmetric ? 4 : 5;
-   const int i31 = symmetric ? i13 : 6;
-   const int i32 = symmetric ? i23 : 7;
-   const int i33 = symmetric ? 5 : 8;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-      // For each c, we will keep 9 arrays for derivatives multiplied by the 9 entries of the 3x3 matrix (dF^T C dF),
-      // which may be non-symmetric depending on a possibly non-symmetric matrix coefficient.
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double zt[MAX_Q1D][MAX_Q1D][MAX_D1D][9][3];
-
-         // z contraction
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     for (int d=0; d<3; ++d)
-                     {
-                        zt[qx][qy][dz][i][d] = 0.0;
-                     }
-                  }
-
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = ((c == 2) ? Bo(qz,dz) : Bc(qz,dz));
-                     const double wDz = ((c == 2) ? Go(qz,dz) : Gc(qz,dz));
-
-                     for (int i=0; i<s; ++i)
-                     {
-                        zt[qx][qy][dz][i][0] += wz * wz * op(qx,qy,qz,i,e);
-                        zt[qx][qy][dz][i][1] += wDz * wz * op(qx,qy,qz,i,e);
-                        zt[qx][qy][dz][i][2] += wDz * wDz * op(qx,qy,qz,i,e);
-                     }
-                  }
-               }
-            }
-         }  // end of z contraction
-
-         double yt[MAX_Q1D][MAX_D1D][MAX_D1D][9][3][3];
-
-         // y contraction
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     for (int d=0; d<3; ++d)
-                        for (int j=0; j<3; ++j)
-                        {
-                           yt[qx][dy][dz][i][d][j] = 0.0;
-                        }
-                  }
-
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = ((c == 1) ? Bo(qy,dy) : Bc(qy,dy));
-                     const double wDy = ((c == 1) ? Go(qy,dy) : Gc(qy,dy));
-
-                     for (int i=0; i<s; ++i)
-                     {
-                        for (int d=0; d<3; ++d)
-                        {
-                           yt[qx][dy][dz][i][d][0] += wy * wy * zt[qx][qy][dz][i][d];
-                           yt[qx][dy][dz][i][d][1] += wDy * wy * zt[qx][qy][dz][i][d];
-                           yt[qx][dy][dz][i][d][2] += wDy * wDy * zt[qx][qy][dz][i][d];
-                        }
-                     }
-                  }
-               }
-            }
-         }  // end of y contraction
-
-         // x contraction
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                     const double wDx = ((c == 0) ? Go(qx,dx) : Gc(qx,dx));
-
-                     // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-                     // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-                     // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                     /*
-                       const double O11 = op(q,0,e);
-                       const double O12 = op(q,1,e);
-                       const double O13 = op(q,2,e);
-                       const double O22 = op(q,3,e);
-                       const double O23 = op(q,4,e);
-                       const double O33 = op(q,5,e);
-                     */
-
-                     if (c == 0)
-                     {
-                        // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
-                        const double sumy = yt[qx][dy][dz][i22][2][0] - yt[qx][dy][dz][i23][1][1]
-                                            - yt[qx][dy][dz][i32][1][1] + yt[qx][dy][dz][i33][0][2];
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += sumy * wx * wx;
-                     }
-                     else if (c == 1)
-                     {
-                        // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
-                        const double d = (yt[qx][dy][dz][i11][2][0] * wx * wx)
-                                         - ((yt[qx][dy][dz][i13][1][0] + yt[qx][dy][dz][i31][1][0]) * wDx * wx)
-                                         + (yt[qx][dy][dz][i33][0][0] * wDx * wDx);
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
-                     }
-                     else
-                     {
-                        // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
-                        const double d = (yt[qx][dy][dz][i11][0][2] * wx * wx)
-                                         - ((yt[qx][dy][dz][i12][0][1] + yt[qx][dy][dz][i21][0][1]) * wDx * wx)
-                                         + (yt[qx][dy][dz][i22][0][0] * wDx * wDx);
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
-                     }
-                  }
-               }
-            }
-         }  // end of x contraction
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPACurlCurlAssembleDiagonal3D(const int D1D,
-                                             const int Q1D,
-                                             const bool symmetric,
-                                             const int NE,
-                                             const Array<double> &bo,
-                                             const Array<double> &bc,
-                                             const Array<double> &go,
-                                             const Array<double> &gc,
-                                             const Vector &pa_data,
-                                             Vector &diag)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Go = Reshape(go.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-   const int i11 = 0;
-   const int i12 = 1;
-   const int i13 = 2;
-   const int i21 = symmetric ? i12 : 3;
-   const int i22 = symmetric ? 3 : 4;
-   const int i23 = symmetric ? 4 : 5;
-   const int i31 = symmetric ? i13 : 6;
-   const int i32 = symmetric ? i23 : 7;
-   const int i33 = symmetric ? 5 : 8;
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-      constexpr int VDIM = 3;
-
-      MFEM_SHARED double sBo[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sBc[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sGo[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sGc[MAX_Q1D][MAX_D1D];
-
-      double ope[9];
-      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  ope[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               sGc[q][d] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-                  sGo[q][d] = Go(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double dxyz = 0.0;
-
-         for (int qz=0; qz < Q1D; ++qz)
-         {
-            if (tidz == qz)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  sop[i][tidx][tidy] = ope[i];
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
-               const double wDz = ((c == 2) ? sGo[qz][dz] : sGc[qz][dz]);
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
-                        const double wDy = ((c == 1) ? sGo[qy][dy] : sGc[qy][dy]);
-
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
-                           const double wDx = ((c == 0) ? sGo[qx][dx] : sGc[qx][dx]);
-
-                           if (c == 0)
-                           {
-                              // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
-
-                              // (u_0)_{x_2} O22 (u_0)_{x_2}
-                              dxyz += sop[i22][qx][qy] * wx * wx * wy * wy * wDz * wDz;
-
-                              // -(u_0)_{x_2} O23 (u_0)_{x_1} - (u_0)_{x_1} O32 (u_0)_{x_2}
-                              dxyz += -(sop[i23][qx][qy] + sop[i32][qx][qy]) * wx * wx * wDy * wy * wDz * wz;
-
-                              // (u_0)_{x_1} O33 (u_0)_{x_1}
-                              dxyz += sop[i33][qx][qy] * wx * wx * wDy * wDy * wz * wz;
-                           }
-                           else if (c == 1)
-                           {
-                              // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
-
-                              // (u_1)_{x_2} O11 (u_1)_{x_2}
-                              dxyz += sop[i11][qx][qy] * wx * wx * wy * wy * wDz * wDz;
-
-                              // -(u_1)_{x_2} O13 (u_1)_{x_0} - (u_1)_{x_0} O31 (u_1)_{x_2}
-                              dxyz += -(sop[i13][qx][qy] + sop[i31][qx][qy]) * wDx * wx * wy * wy * wDz * wz;
-
-                              // (u_1)_{x_0} O33 (u_1)_{x_0})
-                              dxyz += sop[i33][qx][qy] * wDx * wDx * wy * wy * wz * wz;
-                           }
-                           else
-                           {
-                              // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
-
-                              // (u_2)_{x_1} O11 (u_2)_{x_1}
-                              dxyz += sop[i11][qx][qy] * wx * wx * wDy * wDy * wz * wz;
-
-                              // -(u_2)_{x_1} O12 (u_2)_{x_0} - (u_2)_{x_0} O21 (u_2)_{x_1}
-                              dxyz += -(sop[i12][qx][qy] + sop[i21][qx][qy]) * wDx * wx * wDy * wy * wz * wz;
-
-                              // (u_2)_{x_0} O22 (u_2)_{x_0}
-                              dxyz += sop[i22][qx][qy] * wDx * wDx * wy * wy * wz * wz;
-                           }
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-         }  // qz loop
-
-         MFEM_FOREACH_THREAD(dz,z,D1Dz)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1Dy)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1Dx)
-               {
-                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // c loop
-   }); // end of element loop
-}
-
-void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
-{
-   if (dim == 3)
-   {
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPACurlCurlAssembleDiagonal3D<2,3>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x34: return SmemPACurlCurlAssembleDiagonal3D<3,4>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x45: return SmemPACurlCurlAssembleDiagonal3D<4,5>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x56: return SmemPACurlCurlAssembleDiagonal3D<5,6>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            default: return SmemPACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                                                mapsO->B, mapsC->B,
-                                                                mapsO->G, mapsC->G,
-                                                                pa_data, diag);
-         }
-      }
-      else
-         PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                      mapsO->B, mapsC->B,
-                                      mapsO->G, mapsC->G,
-                                      pa_data, diag);
-   }
-   else if (dim == 2)
-   {
-      PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                   mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
-// integrated against H(curl) test functions corresponding to y.
-void PAHcurlH1Apply3D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), D1D, D1D, D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         double gradXY[MAX_Q1D][MAX_Q1D][3];
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradXY[qy][qx][0] = 0.0;
-               gradXY[qy][qx][1] = 0.0;
-               gradXY[qy][qx][2] = 0.0;
-            }
-         }
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            double gradX[MAX_Q1D][2];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx][0] = 0.0;
-               gradX[qx][1] = 0.0;
-            }
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               const double s = X(dx,dy,dz,e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx][0] += s * Bc(qx,dx);
-                  gradX[qx][1] += s * Gc(qx,dx);
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy  = Bc(qy,dy);
-               const double wDy = Gc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx  = gradX[qx][0];
-                  const double wDx = gradX[qx][1];
-                  gradXY[qy][qx][0] += wDx * wy;
-                  gradXY[qy][qx][1] += wx * wDy;
-                  gradXY[qy][qx][2] += wx * wy;
-               }
-            }
-         }
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            const double wz  = Bc(qz,dz);
-            const double wDz = Gc(qz,dz);
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
-                  mass[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
-                  mass[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl), integrated
-// against gradients of H^1 functions corresponding to y.
-void PAHcurlH1ApplyTranspose3D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bt = Reshape(bct.Read(), D1D, Q1D);
-   auto Gt = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double gradXY[MAX_D1D][MAX_D1D][3];
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               gradXY[dy][dx][0] = 0;
-               gradXY[dy][dx][1] = 0;
-               gradXY[dy][dx][2] = 0;
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            double gradX[MAX_D1D][3];
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               gradX[dx][0] = 0;
-               gradX[dx][1] = 0;
-               gradX[dx][2] = 0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double gX = mass[qz][qy][qx][0];
-               const double gY = mass[qz][qy][qx][1];
-               const double gZ = mass[qz][qy][qx][2];
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  const double wx  = Bt(dx,qx);
-                  const double wDx = Gt(dx,qx);
-                  gradX[dx][0] += gX * wDx;
-                  gradX[dx][1] += gY * wx;
-                  gradX[dx][2] += gZ * wx;
-               }
-            }
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               const double wy  = Bt(dy,qy);
-               const double wDy = Gt(dy,qy);
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  gradXY[dy][dx][0] += gradX[dx][0] * wy;
-                  gradXY[dy][dx][1] += gradX[dx][1] * wDy;
-                  gradXY[dy][dx][2] += gradX[dx][2] * wy;
-               }
-            }
-         }
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            const double wz  = Bt(dz,qz);
-            const double wDz = Gt(dz,qz);
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  Y(dx,dy,dz,e) +=
-                     ((gradXY[dy][dx][0] * wz) +
-                      (gradXY[dy][dx][1] * wz) +
-                      (gradXY[dy][dx][2] * wDz));
-               }
-            }
-         }
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
-// integrated against H(curl) test functions corresponding to y.
-void PAHcurlH1Apply2D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
-   auto X = Reshape(x.Read(), D1D, D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         double gradX[MAX_Q1D][2];
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            gradX[qx][0] = 0.0;
-            gradX[qx][1] = 0.0;
-         }
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            const double s = X(dx,dy,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx][0] += s * Bc(qx,dx);
-               gradX[qx][1] += s * Gc(qx,dx);
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double wy  = Bc(qy,dy);
-            const double wDy = Gc(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx  = gradX[qx][0];
-               const double wDx = gradX[qx][1];
-               mass[qy][qx][0] += wDx * wy;
-               mass[qy][qx][1] += wx * wDy;
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O12 = op(qx,qy,1,e);
-            const double O22 = op(qx,qy,2,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O12*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double massX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl), integrated
-// against gradients of H^1 functions corresponding to y.
-void PAHcurlH1ApplyTranspose2D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bt = Reshape(bct.Read(), D1D, Q1D);
-   auto Gt = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O12 = op(qx,qy,1,e);
-            const double O22 = op(qx,qy,2,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O12*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double gradX[MAX_D1D][2];
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            gradX[dx][0] = 0;
-            gradX[dx][1] = 0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double gX = mass[qy][qx][0];
-            const double gY = mass[qy][qx][1];
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               const double wx  = Bt(dx,qx);
-               const double wDx = Gt(dx,qx);
-               gradX[dx][0] += gX * wDx;
-               gradX[dx][1] += gY * wx;
-            }
-         }
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            const double wy  = Bt(dy,qy);
-            const double wDy = Gt(dy,qy);
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               Y(dx,dy,e) += ((gradX[dx][0] * wy) + (gradX[dx][1] * wDy));
-            }
-         }
-      }
-   }); // end of element loop
-}
-
-// PA H(curl) Mass Assemble 3D kernel
-void PAHcurlL2Setup(const int NQ,
-                    const int coeffDim,
-                    const int NE,
-                    const Array<double> &w,
-                    Vector &coeff,
-                    Vector &op)
-{
-   auto W = w.Read();
-   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
-   auto y = Reshape(op.Write(), coeffDim, NQ, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         for (int c=0; c<coeffDim; ++c)
-         {
-            y(c,q,e) = W[q] * C(c,q,e);
-         }
-      }
-   });
-}
-
-void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                           const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *fel = trial_fes.GetFE(0); // In H(curl)
-   const FiniteElement *eltest = test_fes.GetFE(0); // In scalar space
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   if (el->GetDerivType() != mfem::FiniteElement::CURL)
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
-                                                     *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2, "");
-
-   ne = test_fes.GetNE();
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   if (el->GetOrder() == eltest->GetOrder())
-   {
-      dofs1Dtest = dofs1D;
-   }
-   else
-   {
-      dofs1Dtest = dofs1D - 1;
-   }
-
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   if (dim == 2)
-   {
-      PACurlL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedScalarCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 2)
-   {
-      PACurlL2Apply2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B, mapsO->Bt,
-                      mapsC->Bt, mapsC->G, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                   Vector &y) const
-{
-   if (dim == 2)
-   {
-      PACurlL2ApplyTranspose2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B, mapsO->Bt,
-                               mapsC->B, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                           const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with vector test and trial spaces.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-   dofs1Dtest = mapsCtest->ndof;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   testType = test_el->GetDerivType();
-   trialType = trial_el->GetDerivType();
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   coeffDim = (DQ ? 3 : 1);
-
-   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
-                            trialType == mfem::FiniteElement::CURL);
-
-   const int ndata = curlSpaces ? (coeffDim == 1 ? 1 : 9) : symmDims;
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::FULL);
-   if (Q) { coeff.Project(*Q); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      if (coeffDim == 1)
-      {
-         PAHcurlL2Setup(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         PAHcurlHdivSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
-                            geom->J, coeff, pa_data);
-      }
-   }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3 &&
-            test_fel->GetOrder() == trial_fel->GetOrder())
-   {
-      PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlL2Apply3D(const int D1D,
-                             const int Q1D,
-                             const int coeffDim,
-                             const int NE,
-                             const Array<double> &bo,
-                             const Array<double> &bc,
-                             const Array<double> &bot,
-                             const Array<double> &bct,
-                             const Array<double> &gc,
-                             const Vector &pa_data,
-                             const Vector &x,
-                             Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using u = dF^{-T} \hat{u} and (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot v = 1/det(dF) \hat{\nabla}\times\hat{u}^T dF^T dF^{-T} \hat{v}
-   // = 1/det(dF) \hat{\nabla}\times\hat{u}^T \hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               if (coeffDim == 1)
-               {
-                  for (int c = 0; c < VDIM; ++c)
-                  {
-                     curl[qz][qy][qx][c] *= O11;
-                  }
-               }
-               else
-               {
-                  const double O21 = op(1,qx,qy,qz,e);
-                  const double O31 = op(2,qx,qy,qz,e);
-                  const double O12 = op(3,qx,qy,qz,e);
-                  const double O22 = op(4,qx,qy,qz,e);
-                  const double O32 = op(5,qx,qy,qz,e);
-                  const double O13 = op(6,qx,qy,qz,e);
-                  const double O23 = op(7,qx,qy,qz,e);
-                  const double O33 = op(8,qx,qy,qz,e);
-                  const double curlX = curl[qz][qy][qx][0];
-                  const double curlY = curl[qz][qy][qx][1];
-                  const double curlZ = curl[qz][qy][qx][2];
-                  curl[qz][qy][qx][0] = (O11*curlX)+(O12*curlY)+(O13*curlZ);
-                  curl[qz][qy][qx][1] = (O21*curlX)+(O22*curlY)+(O23*curlZ);
-                  curl[qz][qy][qx][2] = (O31*curlX)+(O32*curlY)+(O33*curlZ);
-               }
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0.0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += curl[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPAHcurlL2Apply3D(const int D1D,
-                                 const int Q1D,
-                                 const int coeffDim,
-                                 const int NE,
-                                 const Array<double> &bo,
-                                 const Array<double> &bc,
-                                 const Array<double> &gc,
-                                 const Vector &pa_data,
-                                 const Vector &x,
-                                 Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int maxCoeffDim = 9;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double opc[maxCoeffDim];
-      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<coeffDim; ++i)
-               {
-                  opc[i] = op(i,qx,qy,qz,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     curl[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<coeffDim; ++i)
-                  {
-                     sop[i][tidx][tidy] = opc[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-                     double v = 0.0;
-
-                     // We treat x, y, z components separately for optimization specific to each.
-                     if (c == 0) // x component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
-                                 u += wx * wDy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][1] += v; // (u_0)_{x_2}
-                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
-                     }
-                     else if (c == 1)  // y component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBo[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
-                        curl[qy][qx][2] += u; // (u_1)_{x_0}
-                     }
-                     else // z component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBo[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wDy * wz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] += v; // (u_2)_{x_1}
-                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
-                     }
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        double c1, c2, c3;
-                        if (coeffDim == 1)
-                        {
-                           c1 = O11 * curl[qy][qx][0];
-                           c2 = O11 * curl[qy][qx][1];
-                           c3 = O11 * curl[qy][qx][2];
-                        }
-                        else
-                        {
-                           const double O21 = sop[1][qx][qy];
-                           const double O31 = sop[2][qx][qy];
-                           const double O12 = sop[3][qx][qy];
-                           const double O22 = sop[4][qx][qy];
-                           const double O32 = sop[5][qx][qy];
-                           const double O13 = sop[6][qx][qy];
-                           const double O23 = sop[7][qx][qy];
-                           const double O33 = sop[8][qx][qy];
-                           c1 = (O11*curl[qy][qx][0])+(O12*curl[qy][qx][1])+(O13*curl[qy][qx][2]);
-                           c2 = (O21*curl[qy][qx][0])+(O22*curl[qy][qx][1])+(O23*curl[qy][qx][2]);
-                           c3 = (O31*curl[qy][qx][0])+(O32*curl[qy][qx][1])+(O33*curl[qy][qx][2]);
-                        }
-
-                        const double wcx = sBc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += c1 * wx * wcy * wcz;
-                        }
-
-                        dxyz2 += c2 * wcx * wy * wcz;
-                        dxyz3 += c3 * wcx * wcy * wz;
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(div) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlHdivApply3D(const int D1D,
-                               const int D1Dtest,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bo,
-                               const Array<double> &bc,
-                               const Array<double> &bot,
-                               const Array<double> &bct,
-                               const Array<double> &gc,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
-   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
-   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-
-               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
-                                 (O13 * curl[qz][qy][qx][2]);
-               const double c2 = (O12 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
-                                 (O23 * curl[qz][qy][qx][2]);
-               const double c3 = (O13 * curl[qz][qy][qx][0]) + (O23 * curl[qz][qy][qx][1]) +
-                                 (O33 * curl[qz][qy][qx][2]);
-
-               curl[qz][qy][qx][0] = c1;
-               curl[qz][qy][qx][1] = c2;
-               curl[qz][qy][qx][2] = c3;
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[HCURL_MAX_D1D][HCURL_MAX_D1D];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1Dtest : D1Dtest - 1;
-            const int D1Dy = (c == 1) ? D1Dtest : D1Dtest - 1;
-            const int D1Dx = (c == 0) ? D1Dtest : D1Dtest - 1;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[HCURL_MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += curl[qz][qy][qx][c] *
-                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bct(dy,qy) : Bot(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bct(dz,qz) : Bot(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
-                        massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(div) (test), integrated against the
-// curl of H(curl) trial functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlHdivApply3DTranspose(const int D1D,
-                                        const int D1Dtest,
-                                        const int Q1D,
-                                        const int NE,
-                                        const Array<double> &bo,
-                                        const Array<double> &bc,
-                                        const Array<double> &bot,
-                                        const Array<double> &bct,
-                                        const Array<double> &gct,
-                                        const Vector &pa_data,
-                                        const Vector &x,
-                                        Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
-   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
-   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[HDIV_MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bc(qx,dx) : Bo(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * mass[qz][qy][qx][1];
-                     massX[dx][1] += wx * mass[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * mass[qz][qy][qx][2];
-                     massY[dy][1] += wy * mass[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
-                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   }); // end of element loop
-}
-
-void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPAHcurlL2Apply3D<2,3>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x34: return SmemPAHcurlL2Apply3D<3,4>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x45: return SmemPAHcurlL2Apply3D<4,5>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x56: return SmemPAHcurlL2Apply3D<5,6>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            default: return SmemPAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne,
-                                                    mapsO->B, mapsC->B, mapsC->G,
-                                                    pa_data, x, y);
-         }
-      }
-      else
-         PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
-                          mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
-   }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3)
-      PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                         mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
-                         pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                   Vector &y) const
-{
-   if (testType == mfem::FiniteElement::DIV &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-      PAHcurlHdivApply3DTranspose(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                  mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
-                                  mapsC->Gt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with vector test and trial spaces.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   testType = test_el->GetDerivType();
-   trialType = trial_el->GetDerivType();
-
-   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
-                            trialType == mfem::FiniteElement::CURL);
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-
-   coeffDim = DQ ? 3 : 1;
-   const int ndata = curlSpaces ? (DQ ? 9 : 1) : symmDims;
-
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::FULL);
-   if (Q) { coeff.Project(*Q); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   if (trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      if (coeffDim == 1)
-      {
-         PAHcurlL2Setup(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         PAHcurlHdivSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
-                            geom->J, coeff, pa_data);
-      }
-   }
-   else if (trialType == mfem::FiniteElement::DIV && dim == 3 &&
-            test_el->GetOrder() == trial_el->GetOrder())
-   {
-      PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), integrated against curl
-// of H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlL2Apply3DTranspose(const int D1D,
-                                      const int Q1D,
-                                      const int coeffDim,
-                                      const int NE,
-                                      const Array<double> &bo,
-                                      const Array<double> &bc,
-                                      const Array<double> &bot,
-                                      const Array<double> &bct,
-                                      const Array<double> &gct,
-                                      const Vector &pa_data,
-                                      const Vector &x,
-                                      Vector &y)
-{
-   // See PAHcurlL2Apply3D for comments.
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               if (coeffDim == 1)
-               {
-                  for (int c = 0; c < VDIM; ++c)
-                  {
-                     mass[qz][qy][qx][c] *= O11;
-                  }
-               }
-               else
-               {
-                  const double O12 = op(1,qx,qy,qz,e);
-                  const double O13 = op(2,qx,qy,qz,e);
-                  const double O21 = op(3,qx,qy,qz,e);
-                  const double O22 = op(4,qx,qy,qz,e);
-                  const double O23 = op(5,qx,qy,qz,e);
-                  const double O31 = op(6,qx,qy,qz,e);
-                  const double O32 = op(7,qx,qy,qz,e);
-                  const double O33 = op(8,qx,qy,qz,e);
-                  const double massX = mass[qz][qy][qx][0];
-                  const double massY = mass[qz][qy][qx][1];
-                  const double massZ = mass[qz][qy][qx][2];
-                  mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-                  mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-                  mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-               }
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * mass[qz][qy][qx][1];
-                     massX[dx][1] += wx * mass[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * mass[qz][qy][qx][2];
-                     massY[dy][1] += wy * mass[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
-                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   });
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPAHcurlL2Apply3DTranspose(const int D1D,
-                                          const int Q1D,
-                                          const int coeffDim,
-                                          const int NE,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &gc,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int maxCoeffDim = 9;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double opc[maxCoeffDim];
-      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double mass[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<coeffDim; ++i)
-               {
-                  opc[i] = op(i,qx,qy,qz,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     mass[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<coeffDim; ++i)
-                  {
-                     sop[i][tidx][tidy] = opc[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? sBo[dz][qz] : sBc[dz][qz];
-
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? sBo[dy][qy] : sBc[dy][qy];
-
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              const double wx = sX[dz][dy][dx] * ((c == 0) ? sBo[dx][qx] : sBc[dx][qx]);
-                              u += wx * wy * wz;
-                           }
-                        }
-                     }
-
-                     mass[qy][qx][c] += u;
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wcDz = sGc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wcDy = sGc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        double c1, c2, c3;
-                        if (coeffDim == 1)
-                        {
-                           c1 = O11 * mass[qy][qx][0];
-                           c2 = O11 * mass[qy][qx][1];
-                           c3 = O11 * mass[qy][qx][2];
-                        }
-                        else
-                        {
-                           const double O12 = sop[1][qx][qy];
-                           const double O13 = sop[2][qx][qy];
-                           const double O21 = sop[3][qx][qy];
-                           const double O22 = sop[4][qx][qy];
-                           const double O23 = sop[5][qx][qy];
-                           const double O31 = sop[6][qx][qy];
-                           const double O32 = sop[7][qx][qy];
-                           const double O33 = sop[8][qx][qy];
-
-                           c1 = (O11*mass[qy][qx][0])+(O12*mass[qy][qx][1])+(O13*mass[qy][qx][2]);
-                           c2 = (O21*mass[qy][qx][0])+(O22*mass[qy][qx][1])+(O23*mass[qy][qx][2]);
-                           c3 = (O31*mass[qy][qx][0])+(O32*mass[qy][qx][1])+(O33*mass[qy][qx][2]);
-                        }
-
-                        const double wcx = sBc[dx][qx];
-                        const double wDx = sGc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
-                        }
-
-                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
-
-                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPAHcurlL2Apply3DTranspose<2,3>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x34: return SmemPAHcurlL2Apply3DTranspose<3,4>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x45: return SmemPAHcurlL2Apply3DTranspose<4,5>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x56: return SmemPAHcurlL2Apply3DTranspose<5,6>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            default: return SmemPAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne,
-                                                             mapsO->B, mapsC->B,
-                                                             mapsC->G, pa_data, x, y);
-         }
-      }
-      else
-         PAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne, mapsO->B,
-                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   }
-   else if (testType == mfem::FiniteElement::CURL &&
-            trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PAHcurlHdivApply3DTranspose(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                  mapsC->B, mapsO->Bt, mapsC->Bt,
-                                  mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                         mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
-                         pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-// Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
-// to get a dof in H(curl) (range). You can think of the range as the "test" space
-// and the domain as the "trial" space, but there's no integration.
-static void PAHcurlApplyGradient2D(const int c_dofs1D,
-                                   const int o_dofs1D,
-                                   const int NE,
-                                   const Array<double> &B_,
-                                   const Array<double> &G_,
-                                   const Vector &x_,
-                                   Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += B(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += G(ex, dx) * w[dx][ey];
-            }
-            const int local_index = ey*o_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-
-      // vertical part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += B(ex, dx) * w[dx][ey];
-            }
-            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradient2D to the case where B is identity
-static void PAHcurlApplyGradient2DBId(const int c_dofs1D,
-                                      const int o_dofs1D,
-                                      const int NE,
-                                      const Array<double> &G_,
-                                      const Vector &x_,
-                                      Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            const int dy = ey;
-            w[dx][ey] = x(dx, dy, e);
-         }
-      }
-
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += G(ex, dx) * w[dx][ey];
-            }
-            const int local_index = ey*o_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-
-      // vertical part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int dx = ex;
-            const double s = w[dx][ey];
-            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradientTranspose2D(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &B_, const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part (open x, closed y)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               const int local_index = ey*o_dofs1D + ex;
-               w[dy][ex] += B(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               s += G(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-
-      // vertical part (open y, closed x)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-               w[dy][ex] += G(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               s += B(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradientTranspose2D to the case where
-// B is identity
-static void PAHcurlApplyGradientTranspose2DBId(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part (open x, closed y)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            const int ey = dy;
-            const int local_index = ey*o_dofs1D + ex;
-            w[dy][ex] = x(local_index, e);
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               s += G(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-
-      // vertical part (open y, closed x)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-               w[dy][ex] += G(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            const int ex = dx;
-            const double s = w[dy][ex];
-            y(dx, dy, e) += s;
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradient3D(const int c_dofs1D,
-                                   const int o_dofs1D,
-                                   const int NE,
-                                   const Array<double> &B_,
-                                   const Array<double> &G_,
-                                   const Vector &x_,
-                                   Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += G(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += B(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += B(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradient3D to the case where
-static void PAHcurlApplyGradient3DBId(const int c_dofs1D,
-                                      const int o_dofs1D,
-                                      const int NE,
-                                      const Array<double> &G_,
-                                      const Vector &x_,
-                                      Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               const int dz = ez;
-               w1[dx][dy][ez] = x(dx, dy, dz, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int dy = ey;
-               w2[dx][ey][ez] = w1[dx][dy][ez];
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += G(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               const int dz = ez;
-               w1[dx][dy][ez] = x(dx, dy, dz, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int dx = ex;
-               const double s = w2[dx][ey][ez];
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int dy = ey;
-               w2[dx][ey][ez] = w1[dx][dy][ez];
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int dx = ex;
-               const double s = w2[dx][ey][ez];
-               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradientTranspose3D(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &B_, const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < c_dofs1D; ++ez)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  s += G(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < c_dofs1D; ++ez)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  s += B(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < o_dofs1D; ++ez)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  s += B(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradientTranspose3D to the case where
-static void PAHcurlApplyGradientTranspose3DBId(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               const int ez = dz;
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               w1[ex][ey][dz] = x(local_index, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               const int ey = dy;
-               w2[ex][dy][dz] = w1[ex][ey][dz];
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  s += G(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int ez = dz;
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               w1[ex][ey][dz] = x(local_index, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int ex = dx;
-               double s = w2[ex][dy][dz];
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < o_dofs1D; ++ez)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int ey = dy;
-               w2[ex][dy][dz] = w1[ex][ey][dz];
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int ex = dx;
-               double s = w2[ex][dy][dz];
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-   });
-}
-
-void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
-               "Orders do not match!");
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-   o_dofs1D = maps_O_C->nqpt;
-   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
-   {
-      B_id = true;
-      c_dofs1D = maps_O_C->ndof;
-   }
-   else
-   {
-      B_id = false;
-      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-      c_dofs1D = maps_C_C->nqpt;
-   }
-}
-
-void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
-                                x, y);
-      }
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < o_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < o_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
-   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in y
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bo(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = ey*o_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in y
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bc(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            const int local_index = ey*o_dofs1D + ex;
-            const double xd = x(local_index, e);
-
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bc(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-            const double xd = x(local_index, e);
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bo(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-   });
-}
-
-void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order);
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-
-   o_dofs1D = maps_O_C->nqpt;
-   c_dofs1D = maps_C_C->nqpt;
-   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
-               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
-
-   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
-                         : 2 * c_dofs1D * o_dofs1D;
-
-   const IntegrationRule & Nodes = test_el->GetNodes();
-
-   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
-   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
-
-   const Array<int> &dofmap = test_el->GetDofMap();
-
-   if (dim == 3)
-   {
-      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
-      // the last 3 having negative signs. Here the signs are all positive, as
-      // signs are applied in ElementRestriction.
-
-      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
-
-      for (int c=0; c<3; ++c)
-      {
-         for (int i=0; i<ndof_test/3; ++i)
-         {
-            const int d = (c*ndof_test/3) + i;
-            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[3];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<3; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-   else // 2D case
-   {
-      const double tk[4] = { 1.,0.,  0.,1. };
-      for (int c=0; c<2; ++c)
-      {
-         for (int i=0; i<ndof_test/2; ++i)
-         {
-            const int d = (c*ndof_test/2) + i;
-            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[2];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<2; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-}
-
-void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-template void SmemPAHcurlMassAssembleDiagonal3D<0,0>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<2,3>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<3,4>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<4,5>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<5,6>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassApply3D<0,0>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<2,3>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<3,4>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<4,5>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<5,6>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-} // namespace mfem
diff --git a/fem/bilininteg_mass_pa.cpp b/fem/bilininteg_mass_pa.cpp
deleted file mode 100644
index 06156d030..000000000
--- a/fem/bilininteg_mass_pa.cpp
+++ /dev/null
@@ -1,737 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-#include "bilininteg_mass_pa.hpp"
-
-using namespace std;
-
-namespace mfem
-{
-
-// PA Mass Integrator
-
-// PA Mass Assemble kernel
-
-void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
-   fespace = &fes;
-   Mesh *mesh = fes.GetMesh();
-   if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T0 = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
-      return;
-   }
-   int map_type = el.GetMapType();
-   dim = mesh->Dimension();
-   ne = fes.GetMesh()->GetNE();
-   nq = ir->GetNPoints();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS, mt);
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-   pa_data.SetSize(ne*nq, mt);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-
-   if (dim==1) { MFEM_ABORT("Not supported yet... stay tuned!"); }
-   if (dim==2)
-   {
-      const int NE = ne;
-      const int Q1D = quad1D;
-      const bool const_c = coeff.Size() == 1;
-      const bool by_val = map_type == FiniteElement::VALUE;
-      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
-      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,NE);
-      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
-                     Reshape(coeff.Read(), Q1D,Q1D,NE);
-      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
-      mfem::forall_2D(NE,Q1D,Q1D, [=] MFEM_HOST_DEVICE (int e)
-      {
-         MFEM_FOREACH_THREAD(qx,x,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               const double detJ = J(qx,qy,e);
-               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
-            }
-         }
-      });
-   }
-   if (dim==3)
-   {
-      const int NE = ne;
-      const int Q1D = quad1D;
-      const bool const_c = coeff.Size() == 1;
-      const bool by_val = map_type == FiniteElement::VALUE;
-      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D,Q1D);
-      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,Q1D,NE);
-      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1,1) :
-                     Reshape(coeff.Read(), Q1D,Q1D,Q1D,NE);
-      auto v = Reshape(pa_data.Write(), Q1D,Q1D,Q1D,NE);
-      mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-      {
-         MFEM_FOREACH_THREAD(qx,x,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qz,z,Q1D)
-               {
-                  const double detJ = J(qx,qy,qz,e);
-                  const double coeff = const_c ? C(0,0,0,0) : C(qx,qy,qz,e);
-                  v(qx,qy,qz,e) = W(qx,qy,qz) * coeff * (by_val ? detJ : 1.0/detJ);
-               }
-            }
-         }
-      });
-   }
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassAssembleDiagonal2D(const int NE,
-                                     const Array<double> &b,
-                                     const Vector &d,
-                                     Vector &y,
-                                     const int d1d = 0,
-                                     const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto D = Reshape(d.Read(), Q1D, Q1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QD[MQ1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            QD[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               QD[qx][dy] += B(qy, dy) * B(qy, dy) * D(qx, qy, e);
-            }
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               Y(dx,dy,e) += B(qx, dx) * B(qx, dx) * QD[qx][dy];
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPAMassAssembleDiagonal2D(const int NE,
-                                         const Array<double> &b_,
-                                         const Vector &d_,
-                                         Vector &y_,
-                                         const int d1d = 0,
-                                         const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto b = Reshape(b_.Read(), Q1D, D1D);
-   auto D = Reshape(d_.Read(), Q1D, Q1D, NE);
-   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, NE);
-   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int tidz = MFEM_THREAD_ID(z);
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      MFEM_SHARED double B[MQ1][MD1];
-      MFEM_SHARED double QDZ[NBZ][MQ1][MD1];
-      double (*QD)[MD1] = (double (*)[MD1])(QDZ + tidz);
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               B[q][d] = b(q,d);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(dy,y,D1D)
-         {
-            QD[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               QD[qx][dy] += B[qy][dy] * B[qy][dy] * D(qx, qy, e);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(dy,y,D1D)
-      {
-         MFEM_FOREACH_THREAD(dx,x,D1D)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               // might need absolute values on next line
-               Y(dx,dy,e) += B[qx][dx] * B[qx][dx] * QD[qx][dy];
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassAssembleDiagonal3D(const int NE,
-                                     const Array<double> &b,
-                                     const Vector &d,
-                                     Vector &y,
-                                     const int d1d = 0,
-                                     const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto D = Reshape(d.Read(), Q1D, Q1D, Q1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QQD[MQ1][MQ1][MD1];
-      double QDD[MQ1][MD1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               QQD[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  QQD[qx][qy][dz] += B(qz, dz) * B(qz, dz) * D(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               QDD[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  QDD[qx][dy][dz] += B(qy, dy) * B(qy, dy) * QQD[qx][qy][dz];
-               }
-            }
-         }
-      }
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               double t = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  t += B(qx, dx) * B(qx, dx) * QDD[qx][dy][dz];
-               }
-               Y(dx, dy, dz, e) += t;
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPAMassAssembleDiagonal3D(const int NE,
-                                         const Array<double> &b_,
-                                         const Vector &d_,
-                                         Vector &y_,
-                                         const int d1d = 0,
-                                         const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto b = Reshape(b_.Read(), Q1D, D1D);
-   auto D = Reshape(d_.Read(), Q1D, Q1D, Q1D, NE);
-   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, D1D, NE);
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int tidz = MFEM_THREAD_ID(z);
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      MFEM_SHARED double B[MQ1][MD1];
-      MFEM_SHARED double QQD[MQ1][MQ1][MD1];
-      MFEM_SHARED double QDD[MQ1][MD1][MD1];
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               B[q][d] = b(q,d);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(dz,z,D1D)
-            {
-               QQD[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  QQD[qx][qy][dz] += B[qz][dz] * B[qz][dz] * D(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               QDD[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  QDD[qx][dy][dz] += B[qy][dy] * B[qy][dy] * QQD[qx][qy][dz];
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(dz,z,D1D)
-      {
-         MFEM_FOREACH_THREAD(dy,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(dx,x,D1D)
-            {
-               double t = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  t += B[qx][dx] * B[qx][dx] * QDD[qx][dy][dz];
-               }
-               Y(dx, dy, dz, e) += t;
-            }
-         }
-      }
-   });
-}
-
-static void PAMassAssembleDiagonal(const int dim, const int D1D,
-                                   const int Q1D, const int NE,
-                                   const Array<double> &B,
-                                   const Vector &D,
-                                   Vector &Y)
-{
-   if (dim == 2)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x22: return SmemPAMassAssembleDiagonal2D<2,2,16>(NE,B,D,Y);
-         case 0x33: return SmemPAMassAssembleDiagonal2D<3,3,16>(NE,B,D,Y);
-         case 0x44: return SmemPAMassAssembleDiagonal2D<4,4,8>(NE,B,D,Y);
-         case 0x55: return SmemPAMassAssembleDiagonal2D<5,5,8>(NE,B,D,Y);
-         case 0x66: return SmemPAMassAssembleDiagonal2D<6,6,4>(NE,B,D,Y);
-         case 0x77: return SmemPAMassAssembleDiagonal2D<7,7,4>(NE,B,D,Y);
-         case 0x88: return SmemPAMassAssembleDiagonal2D<8,8,2>(NE,B,D,Y);
-         case 0x99: return SmemPAMassAssembleDiagonal2D<9,9,2>(NE,B,D,Y);
-         default:   return PAMassAssembleDiagonal2D(NE,B,D,Y,D1D,Q1D);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x23: return SmemPAMassAssembleDiagonal3D<2,3>(NE,B,D,Y);
-         case 0x24: return SmemPAMassAssembleDiagonal3D<2,4>(NE,B,D,Y);
-         case 0x26: return SmemPAMassAssembleDiagonal3D<2,6>(NE,B,D,Y);
-         case 0x34: return SmemPAMassAssembleDiagonal3D<3,4>(NE,B,D,Y);
-         case 0x35: return SmemPAMassAssembleDiagonal3D<3,5>(NE,B,D,Y);
-         case 0x45: return SmemPAMassAssembleDiagonal3D<4,5>(NE,B,D,Y);
-         case 0x48: return SmemPAMassAssembleDiagonal3D<4,8>(NE,B,D,Y);
-         case 0x56: return SmemPAMassAssembleDiagonal3D<5,6>(NE,B,D,Y);
-         case 0x67: return SmemPAMassAssembleDiagonal3D<6,7>(NE,B,D,Y);
-         case 0x78: return SmemPAMassAssembleDiagonal3D<7,8>(NE,B,D,Y);
-         case 0x89: return SmemPAMassAssembleDiagonal3D<8,9>(NE,B,D,Y);
-         default:   return PAMassAssembleDiagonal3D(NE,B,D,Y,D1D,Q1D);
-      }
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
-void MassIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAMassAssembleDiagonal(dim, dofs1D, quad1D, ne, maps->B, pa_data, diag);
-   }
-}
-
-
-#ifdef MFEM_USE_OCCA
-// OCCA PA Mass Apply 2D kernel
-static void OccaPAMassApply2D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &D,
-                              const Vector &X,
-                              Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaMassApply2D_cpu;
-      if (OccaMassApply2D_cpu.find(id) == OccaMassApply2D_cpu.end())
-      {
-         const occa::kernel MassApply2D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply2D_CPU", props);
-         OccaMassApply2D_cpu.emplace(id, MassApply2D_CPU);
-      }
-      OccaMassApply2D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaMassApply2D_gpu;
-      if (OccaMassApply2D_gpu.find(id) == OccaMassApply2D_gpu.end())
-      {
-         const occa::kernel MassApply2D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply2D_GPU", props);
-         OccaMassApply2D_gpu.emplace(id, MassApply2D_GPU);
-      }
-      OccaMassApply2D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-}
-
-// OCCA PA Mass Apply 3D kernel
-static void OccaPAMassApply3D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &D,
-                              const Vector &X,
-                              Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaMassApply3D_cpu;
-      if (OccaMassApply3D_cpu.find(id) == OccaMassApply3D_cpu.end())
-      {
-         const occa::kernel MassApply3D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply3D_CPU", props);
-         OccaMassApply3D_cpu.emplace(id, MassApply3D_CPU);
-      }
-      OccaMassApply3D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaMassApply3D_gpu;
-      if (OccaMassApply3D_gpu.find(id) == OccaMassApply3D_gpu.end())
-      {
-         const occa::kernel MassApply3D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply3D_GPU", props);
-         OccaMassApply3D_gpu.emplace(id, MassApply3D_GPU);
-      }
-      OccaMassApply3D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-}
-#endif // MFEM_USE_OCCA
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassApply2D(const int NE,
-                          const Array<double> &b_,
-                          const Array<double> &bt_,
-                          const Vector &d_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
-{
-   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
-   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
-
-   const auto B = b_.Read();
-   const auto Bt = bt_.Read();
-   const auto D = d_.Read();
-   const auto X = x_.Read();
-   auto Y = y_.ReadWrite();
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::PAMassApply2D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPAMassApply2D(const int NE,
-                              const Array<double> &b_,
-                              const Array<double> &bt_,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
-{
-   MFEM_CONTRACT_VAR(bt_);
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   const auto b = b_.Read();
-   const auto D = d_.Read();
-   const auto x = x_.Read();
-   auto Y = y_.ReadWrite();
-   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::SmemPAMassApply2D_Element<T_D1D,T_Q1D,T_NBZ>(e, NE, b, D, x, Y, d1d,
-                                                             q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassApply3D(const int NE,
-                          const Array<double> &b_,
-                          const Array<double> &bt_,
-                          const Vector &d_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
-{
-   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
-   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
-
-   const auto B = b_.Read();
-   const auto Bt = bt_.Read();
-   const auto D = d_.Read();
-   const auto X = x_.Read();
-   auto Y = y_.ReadWrite();
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::PAMassApply3D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPAMassApply3D(const int NE,
-                              const Array<double> &b_,
-                              const Array<double> &bt_,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
-{
-   MFEM_CONTRACT_VAR(bt_);
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int M1Q = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int M1D = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= M1D, "");
-   MFEM_VERIFY(Q1D <= M1Q, "");
-   auto b = b_.Read();
-   auto d = d_.Read();
-   auto x = x_.Read();
-   auto y = y_.ReadWrite();
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::SmemPAMassApply3D_Element<T_D1D,T_Q1D>(e, NE, b, d, x, y, d1d, q1d);
-   });
-}
-
-static void PAMassApply(const int dim,
-                        const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const Array<double> &B,
-                        const Array<double> &Bt,
-                        const Vector &D,
-                        const Vector &X,
-                        Vector &Y)
-{
-#ifdef MFEM_USE_OCCA
-   if (DeviceCanUseOcca())
-   {
-      if (dim == 2)
-      {
-         return OccaPAMassApply2D(D1D,Q1D,NE,B,Bt,D,X,Y);
-      }
-      if (dim == 3)
-      {
-         return OccaPAMassApply3D(D1D,Q1D,NE,B,Bt,D,X,Y);
-      }
-      MFEM_ABORT("OCCA PA Mass Apply unknown kernel!");
-   }
-#endif // MFEM_USE_OCCA
-   const int id = (D1D << 4) | Q1D;
-
-   if (dim == 2)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPAMassApply2D<2,2,16>(NE,B,Bt,D,X,Y);
-         case 0x24: return SmemPAMassApply2D<2,4,16>(NE,B,Bt,D,X,Y);
-         case 0x33: return SmemPAMassApply2D<3,3,16>(NE,B,Bt,D,X,Y);
-         case 0x34: return SmemPAMassApply2D<3,4,16>(NE,B,Bt,D,X,Y);
-         case 0x35: return SmemPAMassApply2D<3,5,16>(NE,B,Bt,D,X,Y);
-         case 0x36: return SmemPAMassApply2D<3,6,16>(NE,B,Bt,D,X,Y);
-         case 0x44: return SmemPAMassApply2D<4,4,8>(NE,B,Bt,D,X,Y);
-         case 0x46: return SmemPAMassApply2D<4,6,8>(NE,B,Bt,D,X,Y);
-         case 0x48: return SmemPAMassApply2D<4,8,4>(NE,B,Bt,D,X,Y);
-         case 0x55: return SmemPAMassApply2D<5,5,8>(NE,B,Bt,D,X,Y);
-         case 0x57: return SmemPAMassApply2D<5,7,8>(NE,B,Bt,D,X,Y);
-         case 0x58: return SmemPAMassApply2D<5,8,2>(NE,B,Bt,D,X,Y);
-         case 0x66: return SmemPAMassApply2D<6,6,4>(NE,B,Bt,D,X,Y);
-         case 0x77: return SmemPAMassApply2D<7,7,4>(NE,B,Bt,D,X,Y);
-         case 0x88: return SmemPAMassApply2D<8,8,2>(NE,B,Bt,D,X,Y);
-         case 0x99: return SmemPAMassApply2D<9,9,2>(NE,B,Bt,D,X,Y);
-         default:   return PAMassApply2D(NE,B,Bt,D,X,Y,D1D,Q1D);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPAMassApply3D<2,2>(NE,B,Bt,D,X,Y);
-         case 0x23: return SmemPAMassApply3D<2,3>(NE,B,Bt,D,X,Y);
-         case 0x24: return SmemPAMassApply3D<2,4>(NE,B,Bt,D,X,Y);
-         case 0x26: return SmemPAMassApply3D<2,6>(NE,B,Bt,D,X,Y);
-         case 0x34: return SmemPAMassApply3D<3,4>(NE,B,Bt,D,X,Y);
-         case 0x35: return SmemPAMassApply3D<3,5>(NE,B,Bt,D,X,Y);
-         case 0x36: return SmemPAMassApply3D<3,6>(NE,B,Bt,D,X,Y);
-         case 0x37: return SmemPAMassApply3D<3,7>(NE,B,Bt,D,X,Y);
-         case 0x45: return SmemPAMassApply3D<4,5>(NE,B,Bt,D,X,Y);
-         case 0x46: return SmemPAMassApply3D<4,6>(NE,B,Bt,D,X,Y);
-         case 0x48: return SmemPAMassApply3D<4,8>(NE,B,Bt,D,X,Y);
-         case 0x56: return SmemPAMassApply3D<5,6>(NE,B,Bt,D,X,Y);
-         case 0x58: return SmemPAMassApply3D<5,8>(NE,B,Bt,D,X,Y);
-         case 0x67: return SmemPAMassApply3D<6,7>(NE,B,Bt,D,X,Y);
-         case 0x78: return SmemPAMassApply3D<7,8>(NE,B,Bt,D,X,Y);
-         case 0x89: return SmemPAMassApply3D<8,9>(NE,B,Bt,D,X,Y);
-         case 0x9A: return SmemPAMassApply3D<9,10>(NE,B,Bt,D,X,Y);
-         default:   return PAMassApply3D(NE,B,Bt,D,X,Y,D1D,Q1D);
-      }
-   }
-   mfem::out << "Unknown kernel 0x" << std::hex << id << std::endl;
-   MFEM_ABORT("Unknown kernel.");
-}
-
-void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      PAMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
-   }
-}
-
-void MassIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   // Mass integrator is symmetric
-   AddMultPA(x, y);
-}
-
-} // namespace mfem
diff --git a/fem/bilininteg_vectorfe.cpp b/fem/bilininteg_vectorfe.cpp
deleted file mode 100644
index 4c2180cf5..000000000
--- a/fem/bilininteg_vectorfe.cpp
+++ /dev/null
@@ -1,1144 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "qspace.hpp"
-#include "gridfunc.hpp"
-
-namespace mfem
-{
-
-void PADiffusionSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const Array<double> &w,
-                        const Vector &j,
-                        const Vector &coeff_,
-                        Vector &op);
-
-void PAHcurlMassAssembleDiagonal2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag);
-
-void PAHcurlMassAssembleDiagonal3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag);
-
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHcurlMassAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const bool symmetric,
-                                       const Array<double> &bo,
-                                       const Array<double> &bc,
-                                       const Vector &pa_data,
-                                       Vector &diag);
-
-void PAHcurlMassApply2D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y);
-
-void PAHcurlMassApply3D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y);
-
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHcurlMassApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const bool symmetric,
-                            const Array<double> &bo,
-                            const Array<double> &bc,
-                            const Array<double> &bot,
-                            const Array<double> &bct,
-                            const Vector &pa_data,
-                            const Vector &x,
-                            Vector &y);
-
-void PAHdivSetup2D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op);
-
-void PAHdivSetup3D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op);
-
-void PAHcurlH1Apply2D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y);
-
-void PAHcurlH1ApplyTranspose2D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y);
-
-void PAHcurlH1Apply3D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y);
-
-void PAHcurlH1ApplyTranspose3D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y);
-
-void PAHdivMassAssembleDiagonal2D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_);
-
-void PAHdivMassAssembleDiagonal3D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_);
-
-void PAHdivMassApply(const int dim,
-                     const int D1D,
-                     const int Q1D,
-                     const int NE,
-                     const bool symmetric,
-                     const Array<double> &Bo,
-                     const Array<double> &Bc,
-                     const Array<double> &Bot,
-                     const Array<double> &Bct,
-                     const Vector &op,
-                     const Vector &x,
-                     Vector &y);
-
-void PAHcurlL2Setup(const int NQ,
-                    const int coeffDim,
-                    const int NE,
-                    const Array<double> &w,
-                    Vector &coeff_,
-                    Vector &op);
-
-// PA H(curl) x H(div) mass assemble 3D kernel, with factor
-// dF^{-1} C dF for a vector or matrix coefficient C.
-// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
-void PAHcurlHdivSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op)
-{
-   const bool symmetric = (coeffDim != 9);
-   auto W = Reshape(w_.Read(), Q1D, Q1D, Q1D);
-   auto J = Reshape(j.Read(), Q1D, Q1D, Q1D, 3, 3, NE);
-   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto y = Reshape(op.Write(), 9, Q1D, Q1D, Q1D, NE);
-
-   const int i11 = 0;
-   const int i12 = transpose ? 3 : 1;
-   const int i13 = transpose ? 6 : 2;
-   const int i21 = transpose ? 1 : 3;
-   const int i22 = 4;
-   const int i23 = transpose ? 7 : 5;
-   const int i31 = transpose ? 2 : 6;
-   const int i32 = transpose ? 5 : 7;
-   const int i33 = 8;
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               const double J11 = J(qx,qy,qz,0,0,e);
-               const double J21 = J(qx,qy,qz,1,0,e);
-               const double J31 = J(qx,qy,qz,2,0,e);
-               const double J12 = J(qx,qy,qz,0,1,e);
-               const double J22 = J(qx,qy,qz,1,1,e);
-               const double J32 = J(qx,qy,qz,2,1,e);
-               const double J13 = J(qx,qy,qz,0,2,e);
-               const double J23 = J(qx,qy,qz,1,2,e);
-               const double J33 = J(qx,qy,qz,2,2,e);
-               const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                                   J21 * (J12 * J33 - J32 * J13) +
-                                   J31 * (J12 * J23 - J22 * J13);
-               const double w_detJ = W(qx,qy,qz) / detJ;
-               // adj(J)
-               const double A11 = (J22 * J33) - (J23 * J32);
-               const double A12 = (J32 * J13) - (J12 * J33);
-               const double A13 = (J12 * J23) - (J22 * J13);
-               const double A21 = (J31 * J23) - (J21 * J33);
-               const double A22 = (J11 * J33) - (J13 * J31);
-               const double A23 = (J21 * J13) - (J11 * J23);
-               const double A31 = (J21 * J32) - (J31 * J22);
-               const double A32 = (J31 * J12) - (J11 * J32);
-               const double A33 = (J11 * J22) - (J12 * J21);
-
-               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-               {
-                  // First compute entries of R = M^T J
-                  const double M11 = (!symmetric) ? coeff(i11,qx,qy,qz,e) : coeff(0,qx,qy,qz,e);
-                  const double M12 = (!symmetric) ? coeff(i12,qx,qy,qz,e) : coeff(1,qx,qy,qz,e);
-                  const double M13 = (!symmetric) ? coeff(i13,qx,qy,qz,e) : coeff(2,qx,qy,qz,e);
-                  const double M21 = (!symmetric) ? coeff(i21,qx,qy,qz,e) : M12;
-                  const double M22 = (!symmetric) ? coeff(i22,qx,qy,qz,e) : coeff(3,qx,qy,qz,e);
-                  const double M23 = (!symmetric) ? coeff(i23,qx,qy,qz,e) : coeff(4,qx,qy,qz,e);
-                  const double M31 = (!symmetric) ? coeff(i31,qx,qy,qz,e) : M13;
-                  const double M32 = (!symmetric) ? coeff(i32,qx,qy,qz,e) : M23;
-                  const double M33 = (!symmetric) ? coeff(i33,qx,qy,qz,e) : coeff(5,qx,qy,qz,e);
-
-                  const double R11 = M11*J11 + M21*J21 + M31*J31;
-                  const double R12 = M11*J12 + M21*J22 + M31*J32;
-                  const double R13 = M11*J13 + M21*J23 + M31*J33;
-                  const double R21 = M12*J11 + M22*J21 + M32*J31;
-                  const double R22 = M12*J12 + M22*J22 + M32*J32;
-                  const double R23 = M12*J13 + M22*J23 + M32*J33;
-                  const double R31 = M13*J11 + M23*J21 + M33*J31;
-                  const double R32 = M13*J12 + M23*J22 + M33*J32;
-                  const double R33 = M13*J13 + M23*J23 + M33*J33;
-
-                  // y = (J^{-1} M^T J)^T
-                  y(i11,qx,qy,qz,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
-                  y(i21,qx,qy,qz,e) = w_detJ * (A11*R12 + A12*R22 + A13*R32); // 1,2
-                  y(i31,qx,qy,qz,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
-                  y(i12,qx,qy,qz,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
-                  y(i22,qx,qy,qz,e) = w_detJ * (A21*R12 + A22*R22 + A23*R32); // 2,2
-                  y(i32,qx,qy,qz,e) = w_detJ * (A21*R13 + A22*R23 + A23*R33); // 2,3
-                  y(i13,qx,qy,qz,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
-                  y(i23,qx,qy,qz,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
-                  y(i33,qx,qy,qz,e) = w_detJ * (A31*R13 + A32*R23 + A33*R33); // 3,3
-               }
-               else if (coeffDim == 3)  // Vector coefficient version
-               {
-                  const double D1 = coeff(0,qx,qy,qz,e);
-                  const double D2 = coeff(1,qx,qy,qz,e);
-                  const double D3 = coeff(2,qx,qy,qz,e);
-                  // detJ J^{-1} DJ = adj(J) DJ
-                  // transpose
-                  y(i11,qx,qy,qz,e) = w_detJ * (D1*A11*J11 + D2*A12*J21 + D3*A13*J31); // 1,1
-                  y(i21,qx,qy,qz,e) = w_detJ * (D1*A11*J12 + D2*A12*J22 + D3*A13*J32); // 1,2
-                  y(i31,qx,qy,qz,e) = w_detJ * (D1*A11*J13 + D2*A12*J23 + D3*A13*J33); // 1,3
-                  y(i12,qx,qy,qz,e) = w_detJ * (D1*A21*J11 + D2*A22*J21 + D3*A23*J31); // 2,1
-                  y(i22,qx,qy,qz,e) = w_detJ * (D1*A21*J12 + D2*A22*J22 + D3*A23*J32); // 2,2
-                  y(i32,qx,qy,qz,e) = w_detJ * (D1*A21*J13 + D2*A22*J23 + D3*A23*J33); // 2,3
-                  y(i13,qx,qy,qz,e) = w_detJ * (D1*A31*J11 + D2*A32*J21 + D3*A33*J31); // 3,1
-                  y(i23,qx,qy,qz,e) = w_detJ * (D1*A31*J12 + D2*A32*J22 + D3*A33*J32); // 3,2
-                  y(i33,qx,qy,qz,e) = w_detJ * (D1*A31*J13 + D2*A32*J23 + D3*A33*J33); // 3,3
-               }
-            }
-         }
-      }
-   });
-}
-
-// PA H(curl) x H(div) mass assemble 2D kernel, with factor
-// dF^{-1} C dF for a vector or matrix coefficient C.
-// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
-void PAHcurlHdivSetup2D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op)
-{
-   const bool symmetric = (coeffDim != 4);
-   auto W = Reshape(w_.Read(), Q1D, Q1D);
-   auto J = Reshape(j.Read(), Q1D, Q1D, 2, 2, NE);
-   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, NE);
-   auto y = Reshape(op.Write(), 4, Q1D, Q1D, NE);
-
-   const int i11 = 0;
-   const int i12 = transpose ? 2 : 1;
-   const int i21 = transpose ? 1 : 2;
-   const int i22 = 3;
-
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            const double J11 = J(qx,qy,0,0,e);
-            const double J21 = J(qx,qy,1,0,e);
-            const double J12 = J(qx,qy,0,1,e);
-            const double J22 = J(qx,qy,1,1,e);
-            const double w_detJ = W(qx,qy) / ((J11*J22) - (J21*J12));
-
-            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient version
-            {
-               // First compute entries of R = MJ
-               const double M11 = coeff(i11,qx,qy,e);
-               const double M12 = (!symmetric) ? coeff(i12,qx,qy,e) : coeff(1,qx,qy,e);
-               const double M21 = (!symmetric) ? coeff(i21,qx,qy,e) : M12;
-               const double M22 = (!symmetric) ? coeff(i22,qx,qy,e) : coeff(2,qx,qy,e);
-
-               // J^{-1} M^T
-               const double R11 = ( J22*M11 - J12*M12); // 1,1
-               const double R12 = ( J22*M21 - J12*M22); // 1,2
-               const double R21 = (-J21*M11 + J11*M12); // 2,1
-               const double R22 = (-J21*M21 + J11*M22); // 2,2
-
-               // (RJ)^T
-               y(i11,qx,qy,e) = w_detJ * (R11*J11 + R12*J21); // 1,1
-               y(i21,qx,qy,e) = w_detJ * (R11*J12 + R12*J22); // 1,2 (transpose)
-               y(i12,qx,qy,e) = w_detJ * (R21*J11 + R22*J21); // 2,1 (transpose)
-               y(i22,qx,qy,e) = w_detJ * (R21*J12 + R22*J22); // 2,2
-            }
-            else if (coeffDim == 2) // Vector coefficient version
-            {
-               const double D1 = coeff(0,qx,qy,e);
-               const double D2 = coeff(1,qx,qy,e);
-               const double R11 = D1*J11;
-               const double R12 = D1*J12;
-               const double R21 = D2*J21;
-               const double R22 = D2*J22;
-               y(i11,qx,qy,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
-               y(i21,qx,qy,e) = w_detJ * ( J22*R12 - J12*R22); // 1,2 (transpose)
-               y(i12,qx,qy,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1 (transpose)
-               y(i22,qx,qy,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
-            }
-         }
-      }
-   });
-}
-
-// Mass operator for H(curl) and H(div) functions, using Piola transformations
-// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
-void PAHcurlHdivMassApply3D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const bool scalarCoeff,
-                            const bool trialHcurl,
-                            const bool transpose,
-                            const Array<double> &Bo_,
-                            const Array<double> &Bc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Bct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
-   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 9, Q1D, Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), 3*(D1D-1)*D1D*(trialHcurl ? D1D : D1D-1), NE);
-   auto y = Reshape(y_.ReadWrite(), 3*(D1Dtest-1)*D1Dtest*
-                    (trialHcurl ? D1Dtest-1 : D1Dtest), NE);
-
-   const int i12 = transpose ? 3 : 1;
-   const int i13 = transpose ? 6 : 2;
-   const int i21 = transpose ? 1 : 3;
-   const int i23 = transpose ? 7 : 5;
-   const int i31 = transpose ? 2 : 6;
-   const int i32 = transpose ? 5 : 7;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z trial components
-      {
-         const int D1Dz = trialHcurl ? ((c == 2) ? D1D - 1 : D1D) :
-                          ((c == 2) ? D1D : D1D - 1);
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
-                          ((c == 1) ? D1D : D1D - 1);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
-                          ((c == 0) ? D1D : D1D - 1);
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = x(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
-                                       ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
-                                    ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = trialHcurl ? ((c == 2) ? Bo(qz,dz) : Bc(qz,dz)) :
-                                 ((c == 2) ? Bc(qz,dz) : Bo(qz,dz));
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,qz,e);
-               const double O13 = scalarCoeff ? 0.0 : op(i13,qx,qy,qz,e);
-               const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,qz,e);
-               const double O22 = scalarCoeff ? O11 : op(4,qx,qy,qz,e);
-               const double O23 = scalarCoeff ? 0.0 : op(i23,qx,qy,qz,e);
-               const double O31 = scalarCoeff ? 0.0 : op(i31,qx,qy,qz,e);
-               const double O32 = scalarCoeff ? 0.0 : op(i32,qx,qy,qz,e);
-               const double O33 = scalarCoeff ? O11 : op(8,qx,qy,qz,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
-
-         osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z test components
-         {
-            const int D1Dz = trialHcurl ? ((c == 2) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 2) ? D1Dtest - 1 : D1Dtest);
-            const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 1) ? D1Dtest - 1 : D1Dtest);
-            const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 0) ? D1Dtest - 1 : D1Dtest);
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[HDIV_MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0.0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * (trialHcurl ?
-                                                         ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
-                                                         ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
-                                    ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = trialHcurl ? ((c == 2) ? Bct(dz,qz) : Bot(dz,qz)) :
-                                 ((c == 2) ? Bot(dz,qz) : Bct(dz,qz));
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
-                        massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Mass operator for H(curl) and H(div) functions, using Piola transformations
-// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
-void PAHcurlHdivMassApply2D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const bool scalarCoeff,
-                            const bool trialHcurl,
-                            const bool transpose,
-                            const Array<double> &Bo_,
-                            const Array<double> &Bc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Bct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 2;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
-   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 4, Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2*(D1Dtest-1)*D1Dtest, NE);
-
-   const int i12 = transpose ? 2 : 1;
-   const int i21 = transpose ? 1 : 2;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y trial components
-      {
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
-                          ((c == 1) ? D1D : D1D - 1);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
-                          ((c == 0) ? D1D : D1D - 1);
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = x(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
-                                    ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
-                                 ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(0,qx,qy,e);
-            const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,e);
-            const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,e);
-            const double O22 = scalarCoeff ? O11 : op(3,qx,qy,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O21*massX)+(O22*massY);
-         }
-      }
-
-      osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y test components
-      {
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
-                          ((c == 1) ? D1Dtest - 1 : D1Dtest);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
-                          ((c == 0) ? D1Dtest - 1 : D1Dtest);
-
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            double massX[HDIV_MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * (trialHcurl ?
-                                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
-                                                  ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
-                                 ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   AssemblePA(fes, fes);
-}
-
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                        const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = trial_fes.GetMesh();
-
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = trial_fes.GetNE();
-   MFEM_VERIFY(ne == test_fes.GetNE(),
-               "Different meshes for test and trial spaces");
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1Dtest = mapsCtest->ndof;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   trial_fetype = trial_el->GetDerivType();
-   test_fetype = test_el->GetDerivType();
-
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
-   if (Q) { coeff.Project(*Q); }
-   else if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dim*dim);
-
-   if ((trial_curl && test_div) || (trial_div && test_curl))
-      pa_data.SetSize((coeff_dim == 1 ? 1 : dim*dim) * nq * ne,
-                      Device::GetMemoryType());
-   else
-      pa_data.SetSize((symmetric ? symmDims : dims*dims) * nq * ne,
-                      Device::GetMemoryType());
-
-   if (trial_curl && test_curl && dim == 3)
-   {
-      PADiffusionSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                         coeff, pa_data);
-   }
-   else if (trial_curl && test_curl && dim == 2)
-   {
-      PADiffusionSetup2D<2>(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                            coeff, pa_data);
-   }
-   else if (trial_div && test_div && dim == 3)
-   {
-      PAHdivSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                    coeff, pa_data);
-   }
-   else if (trial_div && test_div && dim == 2)
-   {
-      PAHdivSetup2D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                    coeff, pa_data);
-   }
-   else if (((trial_curl && test_div) || (trial_div && test_curl)) &&
-            test_fel->GetOrder() == trial_fel->GetOrder())
-   {
-      if (coeff_dim == 1)
-      {
-         PAHcurlL2Setup(nq, coeff_dim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         const bool tr = (trial_div && test_curl);
-         if (dim == 3)
-            PAHcurlHdivSetup3D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
-                               geom->J, coeff, pa_data);
-         else
-            PAHcurlHdivSetup2D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
-                               geom->J, coeff, pa_data);
-      }
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
-{
-   if (dim == 3)
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         if (Device::Allows(Backend::DEVICE_MASK))
-         {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
-            {
-               case 0x23: return SmemPAHcurlMassAssembleDiagonal3D<2,3>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x34: return SmemPAHcurlMassAssembleDiagonal3D<3,4>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x45: return SmemPAHcurlMassAssembleDiagonal3D<4,5>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x56: return SmemPAHcurlMassAssembleDiagonal3D<5,6>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               default: return SmemPAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                                    mapsO->B, mapsC->B, pa_data, diag);
-            }
-         }
-         else
-            PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                          mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                      mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                       mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                      mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-}
-
-void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   if (dim == 3)
-   {
-      if (trial_curl && test_curl)
-      {
-         if (Device::Allows(Backend::DEVICE_MASK))
-         {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
-            {
-               case 0x23: return SmemPAHcurlMassApply3D<2,3>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x34: return SmemPAHcurlMassApply3D<3,4>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x45: return SmemPAHcurlMassApply3D<4,5>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x56: return SmemPAHcurlMassApply3D<5,6>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               default: return SmemPAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B,
-                                                         mapsC->B,
-                                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
-            }
-         }
-         else
-            PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                               mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                         mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_curl && test_div)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                mapsCtest->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_curl)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_curl && test_curl)
-      {
-         PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                            mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                         mapsC->Bt, pa_data, x, y);
-      }
-      else if ((trial_curl && test_div) || (trial_div && test_curl))
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                trial_curl, false, mapsO->B, mapsC->B,
-                                mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-}
-
-void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
-                                                Vector &y) const
-{
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   bool symmetricSpaces = true;
-
-   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                             trial_div, true, mapsO->B, mapsC->B, mapsOtest->Bt,
-                             mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                             !trial_curl, true, mapsO->B, mapsC->B, mapsOtest->Bt,
-                             mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-
-   if (symmetricSpaces)
-   {
-      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
-      {
-         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
-      }
-
-      this->AddMultPA(x, y);
-   }
-}
-
-void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   // Use the same setup functions as VectorFEMassIntegrator.
-   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
-   {
-      PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                         coeff, pa_data);
-   }
-   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
-   {
-      PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                            coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
-{
-   if (dim == 3)
-      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-} // namespace mfem
diff --git a/fem/datacollection.cpp b/fem/datacollection.cpp
index fde0f1490..25111438d 100644
--- a/fem/datacollection.cpp
+++ b/fem/datacollection.cpp
@@ -210,6 +210,11 @@ void DataCollection::Save()
    {
       SaveOneQField(it);
    }
+
+   MFEM_VERIFY(coeff_field_map.begin() == coeff_field_map.end() &&
+               vcoeff_field_map.begin() == vcoeff_field_map.end(),
+               "Coefficient/VectorCoefficient output is not supported for "
+               "DataCollection class!");
 }
 
 void DataCollection::SaveMesh()
@@ -309,9 +314,9 @@ void DataCollection::SaveField(const std::string &field_name)
    }
 }
 
-void DataCollection::SaveQField(const std::string &q_field_name)
+void DataCollection::SaveQField(const std::string &field_name)
 {
-   QFieldMapIterator it = q_field_map.find(q_field_name);
+   QFieldMapIterator it = q_field_map.find(field_name);
    if (it != q_field_map.end())
    {
       SaveOneQField(it);
@@ -765,7 +770,9 @@ ParaViewDataCollection::ParaViewDataCollection(const std::string&
      levels_of_detail(1),
      pv_data_format(VTKFormat::BINARY),
      high_order_output(false),
-     restart_mode(false)
+     restart_mode(false),
+     bdr_output(false),
+     length_scale(1.0)
 {
    cycle = 0; // always include a valid cycle index in file names
 
@@ -910,16 +917,19 @@ void ParaViewDataCollection::Save()
    std::string vtu_prefix = col_path + "/" + GenerateVTUPath() + "/";
 
    // Save the local part of the mesh and grid functions fields to the local
-   // VTU file
+   // VTU file. Also save coefficient fields.
    {
       std::ofstream os(vtu_prefix + GenerateVTUFileName("proc", myid));
       os.precision(precision);
       SaveDataVTU(os, levels_of_detail);
    }
 
-   // Save the local part of the quadrature function fields
+   // Save the local part of the quadrature function fields.
    for (const auto &qfield : q_field_map)
    {
+      MFEM_VERIFY(!bdr_output,
+                  "QuadratureFunction output is not supported for "
+                  "ParaViewDataCollection on domain boundary!");
       const std::string &field_name = qfield.first;
       std::ofstream os(vtu_prefix + GenerateVTUFileName(field_name, myid));
       qfield.second->SaveVTU(os, pv_data_format, GetCompressionLevel());
@@ -935,7 +945,7 @@ void ParaViewDataCollection::Save()
          std::ofstream pvtu_out(vtu_prefix + GeneratePVTUFileName("data"));
          WritePVTUHeader(pvtu_out);
 
-         // Grid function fields
+         // Grid function fields and coefficient fields
          pvtu_out << "<PPointData>\n";
          for (auto &field_it : field_map)
          {
@@ -945,7 +955,24 @@ void ParaViewDataCollection::Save()
                      << "\" NumberOfComponents=\"" << vec_dim << "\" "
                      << "format=\"" << GetDataFormatString() << "\" />\n";
          }
+         for (auto &field_it : coeff_field_map)
+         {
+            int vec_dim = 1;
+            pvtu_out << "<PDataArray type=\"" << GetDataTypeString()
+                     << "\" Name=\"" << field_it.first
+                     << "\" NumberOfComponents=\"" << vec_dim << "\" "
+                     << "format=\"" << GetDataFormatString() << "\" />\n";
+         }
+         for (auto &field_it : vcoeff_field_map)
+         {
+            int vec_dim = field_it.second->GetVDim();
+            pvtu_out << "<PDataArray type=\"" << GetDataTypeString()
+                     << "\" Name=\"" << field_it.first
+                     << "\" NumberOfComponents=\"" << vec_dim << "\" "
+                     << "format=\"" << GetDataFormatString() << "\" />\n";
+         }
          pvtu_out << "</PPointData>\n";
+
          // Element attributes
          pvtu_out << "<PCellData>\n";
          pvtu_out << "\t<PDataArray type=\"Int32\" Name=\"" << "attribute"
@@ -1042,7 +1069,8 @@ void ParaViewDataCollection::SaveDataVTU(std::ostream &os, int ref)
    }
    os << " version=\"0.1\" byte_order=\"" << VTKByteOrder() << "\">\n";
    os << "<UnstructuredGrid>\n";
-   mesh->PrintVTU(os,ref,pv_data_format,high_order_output,GetCompressionLevel());
+   mesh->PrintVTU(os,ref,pv_data_format,high_order_output,GetCompressionLevel(),
+                  bdr_output,length_scale);
 
    // dump out the grid functions as point data
    os << "<PointData >\n";
@@ -1050,8 +1078,23 @@ void ParaViewDataCollection::SaveDataVTU(std::ostream &os, int ref)
    // iterate over all grid functions
    for (FieldMapIterator it=field_map.begin(); it!=field_map.end(); ++it)
    {
+      MFEM_VERIFY(!bdr_output,
+                  "GridFunction output is not supported for "
+                  "ParaViewDataCollection on domain boundary!");
       SaveGFieldVTU(os,ref,it);
    }
+   // save the coefficient functions
+   // iterate over all Coefficient and VectorCoefficient functions
+   for (CoeffFieldMapIterator it=coeff_field_map.begin();
+        it!=coeff_field_map.end(); ++it)
+   {
+      SaveCoeffFieldVTU(os,ref,it);
+   }
+   for (VCoeffFieldMapIterator it=vcoeff_field_map.begin();
+        it!=vcoeff_field_map.end(); ++it)
+   {
+      SaveVCoeffFieldVTU(os,ref,it);
+   }
    os << "</PointData>\n";
    // close the mesh
    os << "</Piece>\n"; // close the piece open in the PrintVTU method
@@ -1073,7 +1116,6 @@ void ParaViewDataCollection::SaveGFieldVTU(std::ostream &os, int ref_,
       << " format=\"" << GetDataFormatString() << "\" >" << '\n';
    if (vec_dim == 1)
    {
-      // scalar data
       for (int i = 0; i < mesh->GetNE(); i++)
       {
          RefG = GlobGeometryRefiner.Refine(
@@ -1103,11 +1145,131 @@ void ParaViewDataCollection::SaveGFieldVTU(std::ostream &os, int ref_,
          }
       }
    }
+   if (pv_data_format != VTKFormat::ASCII)
+   {
+      WriteBase64WithSizeAndClear(os, buf, GetCompressionLevel());
+   }
+   os << "</DataArray>" << std::endl;
+}
 
-   if (IsBinaryFormat())
+void ParaViewDataCollection::SaveCoeffFieldVTU(std::ostream &os, int ref_,
+                                               const CoeffFieldMapIterator &it)
+{
+   RefinedGeometry *RefG;
+   double val;
+   std::vector<char> buf;
+   int vec_dim = 1;
+   os << "<DataArray type=\"" << GetDataTypeString()
+      << "\" Name=\"" << it->first
+      << "\" NumberOfComponents=\"" << vec_dim << "\""
+      << " format=\"" << GetDataFormatString() << "\" >" << '\n';
    {
-      WriteVTKEncodedCompressed(os,buf.data(),buf.size(),GetCompressionLevel());
-      os << '\n';
+      // scalar data
+      if (!bdr_output)
+      {
+         for (int i = 0; i < mesh->GetNE(); i++)
+         {
+            RefG = GlobGeometryRefiner.Refine(
+                      mesh->GetElementBaseGeometry(i), ref_, 1);
+
+            ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+            const IntegrationRule *ir = &RefG->RefPts;
+            for (int j = 0; j < ir->GetNPoints(); j++)
+            {
+               const IntegrationPoint &ip = ir->IntPoint(j);
+               eltrans->SetIntPoint(&ip);
+               val = it->second->Eval(*eltrans, ip);
+               WriteBinaryOrASCII(os, buf, val, "\n", pv_data_format);
+            }
+         }
+      }
+      else
+      {
+         for (int i = 0; i < mesh->GetNBE(); i++)
+         {
+            RefG = GlobGeometryRefiner.Refine(
+                      mesh->GetBdrElementBaseGeometry(i), ref_, 1);
+
+            ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+            const IntegrationRule *ir = &RefG->RefPts;
+            for (int j = 0; j < ir->GetNPoints(); j++)
+            {
+               const IntegrationPoint &ip = ir->IntPoint(j);
+               eltrans->SetIntPoint(&ip);
+               val = it->second->Eval(*eltrans, ip);
+               WriteBinaryOrASCII(os, buf, val, "\n", pv_data_format);
+            }
+         }
+      }
+   }
+   if (pv_data_format != VTKFormat::ASCII)
+   {
+      WriteBase64WithSizeAndClear(os, buf, compression);
+   }
+   os << "</DataArray>" << std::endl;
+}
+
+void ParaViewDataCollection::SaveVCoeffFieldVTU(std::ostream &os, int ref_,
+                                                const VCoeffFieldMapIterator &it)
+{
+   RefinedGeometry *RefG;
+   Vector val;
+   std::vector<char> buf;
+   int vec_dim = it->second->GetVDim();
+   os << "<DataArray type=\"" << GetDataTypeString()
+      << "\" Name=\"" << it->first
+      << "\" NumberOfComponents=\"" << vec_dim << "\""
+      << " format=\"" << GetDataFormatString() << "\" >" << '\n';
+   {
+      // vector data
+      if (!bdr_output)
+      {
+         for (int i = 0; i < mesh->GetNE(); i++)
+         {
+            RefG = GlobGeometryRefiner.Refine(
+                      mesh->GetElementBaseGeometry(i), ref_, 1);
+
+            ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+            const IntegrationRule *ir = &RefG->RefPts;
+            for (int j = 0; j < ir->GetNPoints(); j++)
+            {
+               const IntegrationPoint &ip = ir->IntPoint(j);
+               eltrans->SetIntPoint(&ip);
+               it->second->Eval(val, *eltrans, ip);
+               for (int jj = 0; jj < val.Size(); jj++)
+               {
+                  WriteBinaryOrASCII(os, buf, val(jj), " ", pv_data_format);
+               }
+               if (pv_data_format == VTKFormat::ASCII) { os << '\n'; }
+            }
+         }
+      }
+      else
+      {
+         for (int i = 0; i < mesh->GetNBE(); i++)
+         {
+            RefG = GlobGeometryRefiner.Refine(
+                      mesh->GetBdrElementBaseGeometry(i), ref_, 1);
+
+            ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+            const IntegrationRule *ir = &RefG->RefPts;
+            for (int j = 0; j < ir->GetNPoints(); j++)
+            {
+               const IntegrationPoint &ip = ir->IntPoint(j);
+               eltrans->SetIntPoint(&ip);
+               it->second->Eval(val, *eltrans, ip);
+               for (int jj = 0; jj < val.Size(); jj++)
+               {
+                  WriteBinaryOrASCII(os, buf, val(jj), " ", pv_data_format);
+               }
+               if (pv_data_format == VTKFormat::ASCII) { os << '\n'; }
+            }
+         }
+      }
+   }
+   if (pv_data_format != VTKFormat::ASCII)
+   {
+      WriteBase64WithSizeAndClear(os, buf, GetCompressionLevel());
    }
    os << "</DataArray>" << std::endl;
 }
@@ -1140,6 +1302,16 @@ void ParaViewDataCollection::SetCompression(bool compression_)
    compression = compression_;
 }
 
+void ParaViewDataCollection::SetBoundaryOutput(bool bdr_output_)
+{
+   bdr_output = bdr_output_;
+}
+
+void ParaViewDataCollection::SetLengthScale(double length_scale_)
+{
+   length_scale = length_scale_;
+}
+
 void ParaViewDataCollection::UseRestartMode(bool restart_mode_)
 {
    restart_mode = restart_mode_;
diff --git a/fem/datacollection.hpp b/fem/datacollection.hpp
index c216188af..9f40e52af 100644
--- a/fem/datacollection.hpp
+++ b/fem/datacollection.hpp
@@ -133,6 +133,10 @@ private:
 
    /// A collection of named QuadratureFunctions
    typedef NamedFieldsMap<QuadratureFunction> QFieldMap;
+
+   /// A collection of named Coefficients and VectorCoefficients
+   typedef NamedFieldsMap<Coefficient> CoeffFieldMap;
+   typedef NamedFieldsMap<VectorCoefficient> VCoeffFieldMap;
 public:
    typedef GFieldMap::MapType FieldMapType;
    typedef GFieldMap::iterator FieldMapIterator;
@@ -142,6 +146,14 @@ public:
    typedef QFieldMap::iterator QFieldMapIterator;
    typedef QFieldMap::const_iterator QFieldMapConstIterator;
 
+   typedef CoeffFieldMap::MapType CoeffFieldMapType;
+   typedef CoeffFieldMap::iterator CoeffFieldMapIterator;
+   typedef CoeffFieldMap::const_iterator CoeffFieldMapConstIterator;
+
+   typedef VCoeffFieldMap::MapType VCoeffFieldMapType;
+   typedef VCoeffFieldMap::iterator VCoeffFieldMapIterator;
+   typedef VCoeffFieldMap::const_iterator VCoeffFieldMapConstIterator;
+
    /// Format constants to be used with SetFormat().
    /** Derived classes can define their own format enumerations and override the
        method SetFormat() to perform input validation. */
@@ -169,6 +181,11 @@ protected:
    /** A FieldMap mapping registered names to QuadratureFunction pointers. */
    QFieldMap q_field_map;
 
+   /** A FieldMap mapping registered names to Coefficient and VectorCoefficient
+       pointers. */
+   CoeffFieldMap coeff_field_map;
+   VCoeffFieldMap vcoeff_field_map;
+
    /// The (common) mesh for the collected fields
    Mesh *mesh;
 
@@ -249,15 +266,28 @@ public:
    { field_map.Deregister(field_name, own_data); }
 
    /// Add a QuadratureFunction to the collection.
-   virtual void RegisterQField(const std::string& q_field_name,
+   virtual void RegisterQField(const std::string& field_name,
                                QuadratureFunction *qf)
-   { q_field_map.Register(q_field_name, qf, own_data); }
-
+   { q_field_map.Register(field_name, qf, own_data); }
 
    /// Remove a QuadratureFunction from the collection
    virtual void DeregisterQField(const std::string& field_name)
    { q_field_map.Deregister(field_name, own_data); }
 
+   /// Add a Coefficient or VectorCoefficient to the collection.
+   virtual void RegisterCoeffField(const std::string& field_name,
+                                   Coefficient *coeff)
+   { coeff_field_map.Register(field_name, coeff, own_data); }
+   virtual void RegisterVCoeffField(const std::string& field_name,
+                                    VectorCoefficient *vcoeff)
+   { vcoeff_field_map.Register(field_name, vcoeff, own_data); }
+
+   /// Remove a Coefficient or VectorCoefficient from the collection
+   virtual void DeregisterCoeffField(const std::string& field_name)
+   { coeff_field_map.Deregister(field_name, own_data); }
+   virtual void DeregisterVCoeffField(const std::string& field_name)
+   { vcoeff_field_map.Deregister(field_name, own_data); }
+
    /// Check if a grid function is part of the collection
    bool HasField(const std::string& field_name) const
    { return field_map.Has(field_name); }
@@ -280,13 +310,27 @@ public:
 #endif
 
    /// Check if a QuadratureFunction with the given name is in the collection.
-   bool HasQField(const std::string& q_field_name) const
-   { return q_field_map.Has(q_field_name); }
+   bool HasQField(const std::string& field_name) const
+   { return q_field_map.Has(field_name); }
 
    /// Get a pointer to a QuadratureFunction in the collection.
    /** Returns NULL if @a field_name is not in the collection. */
-   QuadratureFunction *GetQField(const std::string& q_field_name)
-   { return q_field_map.Get(q_field_name); }
+   QuadratureFunction *GetQField(const std::string& field_name)
+   { return q_field_map.Get(field_name); }
+
+   /** Check if a Coefficient or VectorCoefficient with the given name is in
+       the collection. */
+   bool HasCoeffField(const std::string& field_name) const
+   { return coeff_field_map.Has(field_name); }
+   bool HasVCoeffField(const std::string& field_name) const
+   { return vcoeff_field_map.Has(field_name); }
+
+   /// Get a pointer to a Coefficient or VectorCoefficient in the collection.
+   /** Returns NULL if @a field_name is not in the collection. */
+   Coefficient *GetCoeffField(const std::string& field_name)
+   { return coeff_field_map.Get(field_name); }
+   VectorCoefficient *GetVCoeffField(const std::string& field_name)
+   { return vcoeff_field_map.Get(field_name); }
 
    /// Get a const reference to the internal field map.
    /** The keys in the map are the field names and the values are pointers to
@@ -300,13 +344,23 @@ public:
    const QFieldMapType &GetQFieldMap() const
    { return q_field_map.GetMap(); }
 
+   /// Get a const reference to the internal coefficient-field map.
+   /** The keys in the map are the coefficient-field names and the values are
+       pointers to Coefficient%s or VectorCoefficient%s. */
+   const CoeffFieldMapType &GetCoeffFieldMap() const
+   { return coeff_field_map.GetMap(); }
+   const VCoeffFieldMapType &GetVCoeffFieldMap() const
+   { return vcoeff_field_map.GetMap(); }
+
    /// Get a pointer to the mesh in the collection
    Mesh *GetMesh() { return mesh; }
+
    /// Set/change the mesh associated with the collection
    /** When passed a Mesh, assumes the serial case: MPI rank id is set to 0 and
        MPI num_procs is set to 1.  When passed a ParMesh, MPI info from the
        ParMesh is used to set the DataCollection's MPI rank and num_procs. */
    virtual void SetMesh(Mesh *new_mesh);
+
 #ifdef MFEM_USE_MPI
    /// Set/change the mesh associated with the collection.
    /** For this case, @a comm is used to set the DataCollection's MPI rank id
@@ -369,7 +423,19 @@ public:
    /// Save one field, assuming the collection directory already exists.
    virtual void SaveField(const std::string &field_name);
    /// Save one q-field, assuming the collection directory already exists.
-   virtual void SaveQField(const std::string &q_field_name);
+   virtual void SaveQField(const std::string &field_name);
+   /** Save one coefficient-field, assuming the collection directory already
+       exists. */
+   virtual void SaveCoeffField(const std::string &field_name)
+   {
+      MFEM_ABORT("SaveCoeffField not implemented for DataCollection class!");
+   }
+   /** Save one coefficient-field, assuming the collection directory already
+       exists. */
+   virtual void SaveVCoeffField(const std::string &field_name)
+   {
+      MFEM_ABORT("SaveVCoeffField not implemented for DataCollection class!");
+   }
 
    /// Load the collection. Not implemented in the base class DataCollection.
    virtual void Load(int cycle_ = 0);
@@ -512,12 +578,18 @@ private:
    VTKFormat pv_data_format;
    bool high_order_output;
    bool restart_mode;
+   bool bdr_output;
+   double length_scale;
 
 protected:
    void WritePVTUHeader(std::ostream &out);
    void WritePVTUFooter(std::ostream &out, const std::string &vtu_prefix);
    void SaveDataVTU(std::ostream &out, int ref);
    void SaveGFieldVTU(std::ostream& out, int ref_, const FieldMapIterator& it);
+   void SaveCoeffFieldVTU(std::ostream& out, int ref_,
+                          const CoeffFieldMapIterator& it);
+   void SaveVCoeffFieldVTU(std::ostream& out, int ref_,
+                           const VCoeffFieldMapIterator& it);
    const char *GetDataFormatString() const;
    const char *GetDataTypeString() const;
    /// @brief If compression is enabled, return the compression level, otherwise
@@ -531,7 +603,6 @@ protected:
    std::string GeneratePVTUFileName(const std::string &prefix);
    std::string GeneratePVTUPath();
 
-
 public:
    /// Constructor. The collection name is used when saving the data.
    /** If @a mesh_ is NULL, then the mesh can be set later by calling SetMesh().
@@ -582,6 +653,14 @@ public:
    /// by default). Reading high-order data requires ParaView 5.5 or later.
    void SetHighOrderOutput(bool high_order_output_);
 
+   /// Configures collection to save only fields evaluated on boundaries of
+   /// the mesh.
+   void SetBoundaryOutput(bool bdr_output_);
+
+   /// Sets length scale used to scale mesh point coordinates on output.
+   /// The default if unset is 1.0 (unscaled).
+   void SetLengthScale(double length_scale_);
+
    /// Enable or disable restart mode. If restart is enabled, new writes will
    /// preserve timestep metadata for any solutions prior to the currently
    /// defined time.
diff --git a/fem/dgmassinv.cpp b/fem/dgmassinv.cpp
index 88774b3ad..3cff5d05d 100644
--- a/fem/dgmassinv.cpp
+++ b/fem/dgmassinv.cpp
@@ -107,7 +107,7 @@ void DGMassInverse::Update()
 {
    M->Assemble();
    M->AssembleDiagonal(diag_inv);
-   internal::MakeReciprocal(diag_inv.Size(), diag_inv.ReadWrite());
+   diag_inv.Reciprocal();
 }
 
 DGMassInverse::~DGMassInverse()
diff --git a/fem/dgmassinv_kernels.hpp b/fem/dgmassinv_kernels.hpp
index c497621d4..e78a9bc98 100644
--- a/fem/dgmassinv_kernels.hpp
+++ b/fem/dgmassinv_kernels.hpp
@@ -12,9 +12,9 @@
 #ifndef MFEM_DGMASSINV_KERNELS_HPP
 #define MFEM_DGMASSINV_KERNELS_HPP
 
-#include "bilininteg_mass_pa.hpp"
 #include "../linalg/kernels.hpp"
 #include "kernels.hpp"
+#include "integ/bilininteg_mass_kernels.hpp"
 
 namespace mfem
 {
@@ -22,11 +22,6 @@ namespace mfem
 namespace internal
 {
 
-void MakeReciprocal(int n, double *x)
-{
-   mfem::forall(n, [=] MFEM_HOST_DEVICE (int i) { x[i] = 1.0/x[i]; });
-}
-
 template <int DIM, int D1D, int Q1D>
 MFEM_HOST_DEVICE inline
 void DGMassApply(const int e,
diff --git a/fem/doftrans.cpp b/fem/doftrans.cpp
index 95da3859d..8494ddbf2 100644
--- a/fem/doftrans.cpp
+++ b/fem/doftrans.cpp
@@ -14,54 +14,6 @@
 namespace mfem
 {
 
-void DofTransformation::TransformPrimal(Vector &v) const
-{
-   TransformPrimal(v.GetData());
-}
-
-void DofTransformation::TransformPrimalCols(DenseMatrix &V) const
-{
-   for (int c=0; c<V.Width(); c++)
-   {
-      TransformPrimal(V.GetColumn(c));
-   }
-}
-
-void DofTransformation::TransformDual(Vector &v) const
-{
-   TransformDual(v.GetData());
-}
-
-void DofTransformation::TransformDual(DenseMatrix &V) const
-{
-   TransformDualCols(V);
-   TransformDualRows(V);
-}
-
-void DofTransformation::TransformDualRows(DenseMatrix &V) const
-{
-   Vector row;
-   for (int r=0; r<V.Height(); r++)
-   {
-      V.GetRow(r, row);
-      TransformDual(row);
-      V.SetRow(r, row);
-   }
-}
-
-void DofTransformation::TransformDualCols(DenseMatrix &V) const
-{
-   for (int c=0; c<V.Width(); c++)
-   {
-      TransformDual(V.GetColumn(c));
-   }
-}
-
-void DofTransformation::InvTransformPrimal(Vector &v) const
-{
-   InvTransformPrimal(v.GetData());
-}
-
 void TransformPrimal(const DofTransformation *ran_dof_trans,
                      const DofTransformation *dom_dof_trans,
                      DenseMatrix &elmat)
@@ -85,11 +37,6 @@ void TransformPrimal(const DofTransformation *ran_dof_trans,
    }
 }
 
-void DofTransformation::InvTransformDual(Vector &v) const
-{
-   InvTransformDual(v.GetData());
-}
-
 void TransformDual(const DofTransformation *ran_dof_trans,
                    const DofTransformation *dom_dof_trans,
                    DenseMatrix &elmat)
@@ -229,6 +176,7 @@ void VDofTransformation::InvTransformDual(double *v) const
    }
 }
 
+// ordering (i0j0, i1j0, i0j1, i1j1), each row is a column major matrix
 const double ND_DofTransformation::T_data[24] =
 {
    1.0,  0.0,  0.0,  1.0,
@@ -290,8 +238,7 @@ void ND_TriDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformPrimal(double *v) const
+void ND_TriDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -313,8 +260,7 @@ ND_TriDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::TransformDual(double *v) const
+void ND_TriDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -336,8 +282,7 @@ ND_TriDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformDual(double *v) const
+void ND_TriDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -386,8 +331,7 @@ void ND_TetDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformPrimal(double *v) const
+void ND_TetDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -401,6 +345,17 @@ ND_TetDofTransformation::InvTransformPrimal(double *v) const
    // Transform face DoFs
    for (int f=0; f<4; f++)
    {
+      MFEM_ASSERT(Fo[f] >=0 && Fo[f] <= 5,
+                  [this]()
+      {
+         std::stringstream msg;
+         msg << "Orientations = ";
+         for (const auto &x : Fo)
+         {
+            msg << x << " ";
+         }
+         return msg.str();
+      }() << " are invalid");
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[6*nedofs + f*nfdofs + 2*i];
@@ -409,8 +364,7 @@ ND_TetDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::TransformDual(double *v) const
+void ND_TetDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -432,8 +386,7 @@ ND_TetDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformDual(double *v) const
+void ND_TetDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -482,8 +435,7 @@ void ND_WedgeDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
+void ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -505,8 +457,7 @@ ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::TransformDual(double *v) const
+void ND_WedgeDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
@@ -528,8 +479,7 @@ ND_WedgeDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformDual(double *v) const
+void ND_WedgeDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
    if (nfdofs < 2) { return; }
diff --git a/fem/doftrans.hpp b/fem/doftrans.hpp
index 9375246b5..ddbb902a8 100644
--- a/fem/doftrans.hpp
+++ b/fem/doftrans.hpp
@@ -63,6 +63,12 @@ protected:
    DofTransformation(int size)
       : size_(size) {}
 
+   virtual void TransformPrimal(double *v) const = 0;
+   virtual void InvTransformPrimal(double *v) const = 0;
+   virtual void TransformDual(double *v) const = 0;
+   virtual void InvTransformDual(double *v) const = 0;
+
+   friend class VDofTransformation;
 public:
 
    inline int Size() const { return size_; }
@@ -75,7 +81,9 @@ public:
        current element. */
    /// The face_orientation array can be obtained from Mesh::GetElementFaces.
    inline void SetFaceOrientations(const Array<int> & face_orientation)
-   { Fo = face_orientation; }
+   {
+      Fo = face_orientation;
+   }
 
    inline const Array<int> & GetFaceOrientations() const { return Fo; }
 
@@ -83,38 +91,71 @@ public:
        transformation can be used to map the local vector computed by
        FiniteElement::Project() to the transformed vector stored within a
        GridFunction object. */
-   virtual void TransformPrimal(double *v) const = 0;
-   virtual void TransformPrimal(Vector &v) const;
+   inline void TransformPrimal(Vector &v) const
+   {
+      TransformPrimal(v.GetData());
+   }
 
    /// Transform groups of DoFs stored as dense matrices
-   virtual void TransformPrimalCols(DenseMatrix &V) const;
+   inline void TransformPrimalCols(DenseMatrix &V) const
+   {
+      for (int c=0; c<V.Width(); c++)
+      {
+         TransformPrimal(V.GetColumn(c));
+      }
+   }
 
    /** Inverse transform local DoFs. Used to transform DoFs from a global vector
        back to their element-local form. For example, this must be used to
        transform the vector obtained using GridFunction::GetSubVector before it
        can be used to compute a local interpolation.
    */
-   virtual void InvTransformPrimal(double *v) const = 0;
-   virtual void InvTransformPrimal(Vector &v) const;
+   inline void InvTransformPrimal(Vector &v) const
+   {
+      InvTransformPrimal(v.GetData());
+   }
 
    /** Transform dual DoFs as computed by a LinearFormIntegrator before summing
        into a LinearForm object. */
-   virtual void TransformDual(double *v) const = 0;
-   virtual void TransformDual(Vector &v) const;
+   inline void TransformDual(Vector &v) const
+   {
+      TransformDual(v.GetData());
+   }
 
    /** Inverse Transform dual DoFs */
-   virtual void InvTransformDual(double *v) const = 0;
-   virtual void InvTransformDual(Vector &v) const;
+   inline void InvTransformDual(Vector &v) const
+   {
+      InvTransformDual(v.GetData());
+   }
 
    /** Transform a matrix of dual DoFs entries as computed by a
        BilinearFormIntegrator before summing into a BilinearForm object. */
-   virtual void TransformDual(DenseMatrix &V) const;
+   inline void TransformDual(DenseMatrix &V) const
+   {
+      TransformDualCols(V);
+      TransformDualRows(V);
+   }
 
    /// Transform groups of dual DoFs stored as dense matrices
-   virtual void TransformDualRows(DenseMatrix &V) const;
-   virtual void TransformDualCols(DenseMatrix &V) const;
+   inline void TransformDualRows(DenseMatrix &V) const
+   {
+      Vector row;
+      for (int r=0; r<V.Height(); r++)
+      {
+         V.GetRow(r, row);
+         TransformDual(row);
+         V.SetRow(r, row);
+      }
+   }
+   inline void TransformDualCols(DenseMatrix &V) const
+   {
+      for (int c=0; c<V.Width(); c++)
+      {
+         TransformDual(V.GetColumn(c));
+      }
+   }
 
-   virtual ~DofTransformation() {}
+   virtual ~DofTransformation() = default;
 };
 
 /** Transform a matrix of DoFs entries from different finite element spaces as
@@ -181,18 +222,16 @@ public:
    /// Return the nested DofTransformation object
    inline DofTransformation * GetDofTransformation() const { return doftrans_; }
 
-   inline void SetFaceOrientation(const Array<int> & face_orientation)
-   { Fo = face_orientation; doftrans_->SetFaceOrientations(face_orientation); }
-
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-   void InvTransformPrimal(double *v) const;
-   void TransformDual(double *v) const;
-   void InvTransformDual(double *v) const;
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /** Abstract base class for high-order Nedelec spaces on elements with
@@ -237,15 +276,13 @@ public:
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
-
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
    using DofTransformation::InvTransformDual;
+
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /// DoF transformation implementation for the Nedelec basis on tetrahedra
@@ -259,13 +296,11 @@ public:
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 /// DoF transformation implementation for the Nedelec basis on wedge elements
@@ -279,14 +314,11 @@ public:
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   void TransformPrimal(double *v) const;
-
-   void InvTransformPrimal(double *v) const;
-
-   void TransformDual(double *v) const;
-
-   void InvTransformDual(double *v) const;
-
+protected:
+   void TransformPrimal(double *v) const final;
+   void InvTransformPrimal(double *v) const final;
+   void TransformDual(double *v) const final;
+   void InvTransformDual(double *v) const final;
 };
 
 } // namespace mfem
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index a4af691d7..4b98d3ea2 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -492,6 +492,7 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
 void IsoparametricTransformation::Transform (const IntegrationPoint &ip,
                                              Vector &trans)
 {
+   MFEM_ASSERT(FElem != nullptr, "!");
    shape.SetSize(FElem->GetDof());
    trans.SetSize(PointMat.Height());
 
diff --git a/fem/fe/fe_base.cpp b/fem/fe/fe_base.cpp
index 6f665bfa3..ded2ffc9c 100644
--- a/fem/fe/fe_base.cpp
+++ b/fem/fe/fe_base.cpp
@@ -401,7 +401,7 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
          }
       }
    }
-   else
+   else if (range_type == VECTOR)
    {
       d2q->B.SetSize(nqpt*dim*dof);
       d2q->Bt.SetSize(dof*nqpt*dim);
@@ -419,6 +419,10 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
          }
       }
    }
+   else
+   {
+      // Skip B and Bt for unknown range type
+   }
    switch (deriv_type)
    {
       case GRAD:
@@ -472,7 +476,7 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
             {
                for (int j = 0; j < dof; j++)
                {
-                  d2q->G[i+nqpt*(d+dim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                  d2q->G[i+nqpt*(d+cdim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
                }
             }
          }
@@ -480,7 +484,8 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
       }
       case NONE:
       default:
-         MFEM_ABORT("invalid finite element derivative type");
+         // Skip G and Gt for unknown derivative type
+         break;
    }
    dof2quad_array.Append(d2q);
    return *d2q;
diff --git a/fem/fe/fe_base.hpp b/fem/fe/fe_base.hpp
index b533525f0..6582140df 100644
--- a/fem/fe/fe_base.hpp
+++ b/fem/fe/fe_base.hpp
@@ -1288,9 +1288,9 @@ public:
    const DofToQuad &GetDofToQuad(const IntegrationRule &ir,
                                  DofToQuad::Mode mode) const override
    {
-      MFEM_VERIFY(mode != DofToQuad::FULL, "invalid mode requested");
-      return GetTensorDofToQuad(*this, ir, mode, basis1d, true,
-                                dof2quad_array);
+      return (mode == DofToQuad::FULL) ?
+             FiniteElement::GetDofToQuad(ir, mode) :
+             GetTensorDofToQuad(*this, ir, mode, basis1d, true, dof2quad_array);
    }
 
    const DofToQuad &GetDofToQuadOpen(const IntegrationRule &ir,
diff --git a/fem/fe_coll.cpp b/fem/fe_coll.cpp
index fd7af135d..9dfb677f6 100644
--- a/fem/fe_coll.cpp
+++ b/fem/fe_coll.cpp
@@ -1713,7 +1713,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::SEGMENT] = new H1_SegmentElement(p, btype);
       }
 
-      SegDofOrd[0] = new int[2*pm1];
+      SegDofOrd[0] = (pm1 > 0) ? new int[2*pm1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pm1;
       for (int i = 0; i < pm1; i++)
       {
@@ -1751,7 +1751,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
 
       const int &TriDof = H1_dof[Geometry::TRIANGLE];
       const int &QuadDof = H1_dof[Geometry::SQUARE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -1772,7 +1772,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          }
       }
 
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -1855,7 +1855,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::PYRAMID] = new LinearPyramidFiniteElement;
 
          const int &TetDof = H1_dof[Geometry::TETRAHEDRON];
-         TetDofOrd[0] = new int[24*TetDof];
+         TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
          for (int i = 1; i < 24; i++)
          {
             TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2127,7 +2127,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       // No need to set the map_type for Tr_Elements.
 
       const int pp1 = p + 1;
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2160,7 +2160,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       }
 
       const int TriDof = L2_Elements[Geometry::TRIANGLE]->GetDof();
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2181,7 +2181,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
          }
       }
       const int QuadDof = L2_Elements[Geometry::SQUARE]->GetDof();
-      OtherDofOrd = new int[QuadDof];
+      OtherDofOrd = (QuadDof > 0) ? new int[QuadDof] : nullptr;
       for (int j = 0; j < QuadDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2225,7 +2225,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       const int PriDof = L2_Elements[Geometry::PRISM]->GetDof();
       const int MaxDof = std::max(TetDof, std::max(PriDof, HexDof));
 
-      TetDofOrd[0] = new int[24*TetDof];
+      TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
       for (int i = 1; i < 24; i++)
       {
          TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2314,7 +2314,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
             }
          }
       }
-      OtherDofOrd = new int[MaxDof];
+      OtherDofOrd = (MaxDof > 0) ? new int[MaxDof] : nullptr;
       for (int j = 0; j < MaxDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2502,7 +2502,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2523,7 +2523,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_dof[Geometry::SQUARE] = pp1*pp1;
 
       int TriDof = RT_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2553,7 +2553,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       }
 
       int QuadDof = RT_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2749,7 +2749,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_Elements[Geometry::SEGMENT] = new ND_SegmentElement(p, ob_type);
       ND_dof[Geometry::SEGMENT] = p;
 
-      SegDofOrd[0] = new int[2*p];
+      SegDofOrd[0] = (p > 0) ? new int[2*p] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + p;
       for (int i = 0; i < p; i++)
       {
@@ -2769,7 +2769,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_dof[Geometry::TRIANGLE] = p*pm1;
 
       int QuadDof = ND_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2813,7 +2813,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       }
 
       int TriDof = ND_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -3150,7 +3150,7 @@ ND_R2D_FECollection::ND_R2D_FECollection(const int p, const int dim,
                                                                  ob_type);
       ND_dof[Geometry::SEGMENT] = 2 * p - 1;
 
-      SegDofOrd[0] = new int[4 * p - 2];
+      SegDofOrd[0] = (4*p > 2) ? new int[4 * p - 2] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + 2 * p - 1;
       for (int i = 0; i < p; i++)
       {
@@ -3334,7 +3334,7 @@ void RT_R2D_FECollection::InitFaces(const int p, const int dim,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 29a1aa980..aa8621382 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -385,21 +385,38 @@ void FiniteElementSpace::BuildBdrElementToDofTable() const
    if (bdr_elem_dof) { return; }
 
    Table *bel_dof = new Table;
+   Table *bel_fos = (mesh->Dimension() == 3) ? (new Table) : NULL;
    Array<int> dofs;
+   int F, Fo;
    bel_dof->MakeI(mesh->GetNBE());
+   if (bel_fos) { bel_fos->MakeI(mesh->GetNBE()); }
    for (int i = 0; i < mesh->GetNBE(); i++)
    {
       GetBdrElementDofs(i, dofs);
       bel_dof->AddColumnsInRow(i, dofs.Size());
+
+      if (bel_fos)
+      {
+         bel_fos->AddAColumnInRow(i);
+      }
    }
    bel_dof->MakeJ();
+   if (bel_fos) { bel_fos->MakeJ(); }
    for (int i = 0; i < mesh->GetNBE(); i++)
    {
       GetBdrElementDofs(i, dofs);
       bel_dof->AddConnections(i, (int *)dofs, dofs.Size());
+
+      if (bel_fos)
+      {
+         mesh->GetBdrElementFace(i, &F, &Fo);
+         bel_fos->AddConnection(i, Fo);
+      }
    }
    bel_dof->ShiftUpI();
+   if (bel_fos) { bel_fos->ShiftUpI(); }
    bdr_elem_dof = bel_dof;
+   bdr_elem_fos = bel_fos;
 }
 
 void FiniteElementSpace::BuildFaceToDofTable() const
@@ -482,13 +499,12 @@ void FiniteElementSpace::BuildDofToArrays()
    }
 }
 
-static void mark_dofs(const Array<int> &dofs, Array<int> &mark_array)
+void
+FiniteElementSpace::MarkDofs(const Array<int> &dofs, Array<int> &mark_array)
 {
-   for (int i = 0; i < dofs.Size(); i++)
+   for (auto d : dofs)
    {
-      int k = dofs[i];
-      if (k < 0) { k = -1 - k; }
-      mark_array[k] = -1;
+      mark_array[d >= 0 ? d : -1 - d] = -1;
    }
 }
 
@@ -496,7 +512,7 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
                                            Array<int> &ess_vdofs,
                                            int component) const
 {
-   Array<int> vdofs, dofs;
+   Array<int> dofs;
 
    ess_vdofs.SetSize(GetVSize());
    ess_vdofs = 0;
@@ -505,19 +521,49 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
    {
       if (bdr_attr_is_ess[GetBdrAttribute(i)-1])
       {
-         if (component < 0)
+         int ncface = -1;
+         if (Nonconforming())
+         {
+            // Need to take care on internal non-conforming "boundaries". Boundary
+            // elements are conforming or slave. The only exception to this
+            // being "ghost boundary elements" which are master faces
+            int f = mesh->GetBdrElementEdgeIndex(i);
+            int inf1, inf2;
+            mesh->GetFaceInfos(f, &inf1, &inf2, &ncface);
+         }
+
+         if (ncface >= 0)
+         {
+            auto face_index = mesh->GetNCMasterFaceIndex(ncface);
+            int inf1, inf2;
+            mesh->GetFaceInfos(face_index, &inf1, &inf2, &ncface);
+            if (face_index >= mesh->GetNumFaces() && ncface < 0)
+            {
+               // Ghost master face, do not process on this rank
+               continue;
+            }
+            else if (component < 0)
+            {
+               GetEntityVDofs(mesh->Dimension() - 1, face_index, dofs);
+            }
+            else
+            {
+               GetEntityDofs(mesh->Dimension() - 1, face_index, dofs);
+               for (auto &d : dofs) { d = DofToVDof(d, component); }
+            }
+         }
+         else if (component < 0)
          {
             // Mark all components.
-            GetBdrElementVDofs(i, vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetBdrElementVDofs(i, dofs);
          }
          else
          {
             GetBdrElementDofs(i, dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 
@@ -532,31 +578,27 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
       {
          if (component < 0)
          {
-            GetVertexVDofs(bdr_verts[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetVertexVDofs(bdr_verts[i], dofs);
          }
          else
          {
             GetVertexDofs(bdr_verts[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
       for (int i = 0; i < bdr_edges.Size(); i++)
       {
          if (component < 0)
          {
-            GetEdgeVDofs(bdr_edges[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetEdgeVDofs(bdr_edges[i], dofs);
          }
          else
          {
             GetEdgeDofs(bdr_edges[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 }
@@ -575,6 +617,19 @@ void FiniteElementSpace::GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
    else
    {
       R->BooleanMult(ess_vdofs, ess_tdofs);
+#ifdef MFEM_DEBUG
+      // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs
+      Array<int> ess_tdofs2(ess_tdofs.Size());
+      GetConformingProlongation()->BooleanMultTranspose(ess_vdofs, ess_tdofs2);
+
+      int counter = 0;
+      for (int i = 0; i < ess_tdofs2.Size(); ++i)
+      {
+         if (bool(ess_tdofs[i]) != bool(ess_tdofs2[i])) { ++counter; }
+      }
+
+      MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter);
+#endif
    }
    MarkerToList(ess_tdofs, ess_tdof_list);
 }
@@ -925,6 +980,15 @@ int FiniteElementSpace::GetEntityDofs(int entity, int index, Array<int> &dofs,
    }
 }
 
+int FiniteElementSpace::GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                                       Geometry::Type master_geom,
+                                       int variant) const
+{
+   int n = GetEntityDofs(entity, index, dofs, master_geom, variant);
+   DofsToVDofs(dofs);
+   return n;
+}
+
 void FiniteElementSpace::BuildConformingInterpolation() const
 {
 #ifdef MFEM_USE_MPI
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index c30299bfe..88e4d0770 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -392,6 +392,10 @@ protected:
    int GetEntityDofs(int entity, int index, Array<int> &dofs,
                      Geometry::Type master_geom = Geometry::INVALID,
                      int variant = 0) const;
+   /// Helper to get vertex, edge or face VDOFs (entity=0,1,2 resp.).
+   int GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                      Geometry::Type master_geom = Geometry::INVALID,
+                      int variant = 0) const;
 
    // Get degenerate face DOFs: see explanation in method implementation.
    int GetDegenerateFaceDofs(int index, Array<int> &dofs,
@@ -825,6 +829,7 @@ public:
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
+   ///
    /// In variable order spaces, multiple variants of DOFs can be returned.
    /// See GetEdgeDofs() for more details.
    /// @return Order of the selected variant, or -1 if there are no more
@@ -1158,6 +1163,15 @@ public:
    static void ListToMarker(const Array<int> &list, int marker_size,
                             Array<int> &marker, int mark_val = -1);
 
+   /**
+    * @brief Helper for looping over entries in mark_array, and setting equal
+    * to -1 if present in dofs. Used in GetEssentialVDofs.
+    *
+    * @param[in] dofs The set of dofs to mark
+    * @param[out] mark_array Array of dofs to mark, indices with
+    */
+   static void MarkDofs(const Array<int> &dofs, Array<int> &mark_array);
+
    /** @brief For a partially conforming FE space, convert a marker array (nonzero
        entries are true) on the partially conforming dofs to a marker array on
        the conforming dofs. A conforming dofs is marked iff at least one of its
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index 928b4e2ad..8ac7e590c 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -836,6 +836,9 @@ double GridFunction::GetValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -975,6 +978,9 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -999,6 +1005,8 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
          FaceElementTransformations * FET =
             dynamic_cast<FaceElementTransformations *>(&T);
 
+         MFEM_ASSERT(FET != nullptr,
+                     "FaceElementTransformation must be valid for a boundary element");
          // Evaluate in neighboring element for both continuous and
          // discontinuous fields (the integration point in T1 should have
          // already been set).
@@ -1116,11 +1124,10 @@ int GridFunction::GetFaceVectorValues(
    int i, int side, const IntegrationRule &ir,
    DenseMatrix &vals, DenseMatrix &tr) const
 {
-   int n, di;
+   int di;
    FaceElementTransformations *Transf;
 
-   n = ir.GetNPoints();
-   IntegrationRule eir(n);  // ---
+   IntegrationRule eir(ir.GetNPoints());  // ---
    Transf = fes->GetMesh()->GetFaceElementTransformations(i, 0);
    if (side == 2)
    {
@@ -1142,12 +1149,14 @@ int GridFunction::GetFaceVectorValues(
    if (di == 0)
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 5);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc1.Transform(ir, eir);
       GetVectorValues(*Transf->Elem1, eir, vals, &tr);
    }
    else
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 10);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc2.Transform(ir, eir);
       GetVectorValues(*Transf->Elem2, eir, vals, &tr);
    }
diff --git a/fem/gslib.cpp b/fem/gslib.cpp
index a6428be74..de84388e6 100644
--- a/fem/gslib.cpp
+++ b/fem/gslib.cpp
@@ -184,7 +184,7 @@ void FindPointsGSLIB::FindPoints(const Vector &point_pos,
    gsl_ref.SetSize(points_cnt * dim);
    gsl_dist.SetSize(points_cnt);
 
-   auto xvFill = [&](const double *xv_base[], unsigned xv_stride[], int dim)
+   auto xvFill = [&](const double *xv_base[], unsigned xv_stride[])
    {
       for (int d = 0; d < dim; d++)
       {
@@ -204,7 +204,7 @@ void FindPointsGSLIB::FindPoints(const Vector &point_pos,
    {
       const double *xv_base[2];
       unsigned xv_stride[2];
-      xvFill(xv_base, xv_stride, dim);
+      xvFill(xv_base, xv_stride);
       findpts_2(gsl_code.GetData(), sizeof(unsigned int),
                 gsl_proc.GetData(), sizeof(unsigned int),
                 gsl_elem.GetData(), sizeof(unsigned int),
@@ -216,7 +216,7 @@ void FindPointsGSLIB::FindPoints(const Vector &point_pos,
    {
       const double *xv_base[3];
       unsigned xv_stride[3];
-      xvFill(xv_base, xv_stride, dim);
+      xvFill(xv_base, xv_stride);
       findpts_3(gsl_code.GetData(), sizeof(unsigned int),
                 gsl_proc.GetData(), sizeof(unsigned int),
                 gsl_elem.GetData(), sizeof(unsigned int),
@@ -916,8 +916,9 @@ void FindPointsGSLIB::InterpolateH1(const GridFunction &field_in,
    Vector node_vals;
 
    const int ncomp      = field_in.FESpace()->GetVDim(),
-             points_fld = field_in.Size() / ncomp,
-             points_cnt = gsl_code.Size();
+             points_fld = field_in.Size() / ncomp;
+   MFEM_VERIFY(points_cnt == gsl_code.Size(),
+               "FindPointsGSLIB::InterpolateH1: Inconsistent size of gsl_code");
 
    field_out.SetSize(points_cnt*ncomp);
    field_out = default_interp_value;
diff --git a/fem/bilininteg_br2.cpp b/fem/integ/bilininteg_br2.cpp
similarity index 99%
rename from fem/bilininteg_br2.cpp
rename to fem/integ/bilininteg_br2.cpp
index dba87a8b5..159947029 100644
--- a/fem/bilininteg_br2.cpp
+++ b/fem/integ/bilininteg_br2.cpp
@@ -9,8 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "bilininteg.hpp"
-#include "pfespace.hpp"
+#include "../bilininteg.hpp"
+#include "../pfespace.hpp"
 #include <algorithm>
 
 namespace mfem
diff --git a/fem/bilininteg_convection_ea.cpp b/fem/integ/bilininteg_convection_ea.cpp
similarity index 99%
rename from fem/bilininteg_convection_ea.cpp
rename to fem/integ/bilininteg_convection_ea.cpp
index 52e3b4e81..b2dba388a 100644
--- a/fem/bilininteg_convection_ea.cpp
+++ b/fem/integ/bilininteg_convection_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_convection_mf.cpp b/fem/integ/bilininteg_convection_mf.cpp
similarity index 92%
rename from fem/bilininteg_convection_mf.cpp
rename to fem/integ/bilininteg_convection_mf.cpp
index 61520c135..22ed53c33 100644
--- a/fem/bilininteg_convection_mf.cpp
+++ b/fem/integ/bilininteg_convection_mf.cpp
@@ -9,12 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/convection/convection.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/convection/convection.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
similarity index 99%
rename from fem/bilininteg_convection_pa.cpp
rename to fem/integ/bilininteg_convection_pa.cpp
index 48080ecdf..7bfd65059 100644
--- a/fem/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -9,18 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/convection/convection.hpp"
-#include "quadinterpolator.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/convection/convection.hpp"
 
 namespace mfem
 {
 
-// PA Convection Integrator
-
 // PA Convection Assemble 2D kernel
 static void PAConvectionSetup2D(const int NQ,
                                 const int NE,
@@ -135,6 +132,61 @@ static void PAConvectionSetup(const int dim,
    }
 }
 
+void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &Trans = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
+      }
+      else
+      {
+         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
+      }
+      return;
+   }
+   const int dims = el.GetDim();
+   const int symmDims = dims;
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(symmDims * nq * ne, mt);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
+
+   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
+                     vel, alpha, pa_data);
+}
+
+void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      MFEM_ABORT("AssembleDiagonalPA not yet implemented for"
+                 " ConvectionIntegrator.");
+   }
+}
+
 // PA Convection Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0> static
 void PAConvectionApply2D(const int ne,
@@ -1375,48 +1427,6 @@ void SmemPAConvectionApplyT3D(const int ne,
    });
 }
 
-void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
-      }
-      return;
-   }
-   const int dims = el.GetDim();
-   const int symmDims = dims;
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-   pa_data.SetSize(symmDims * nq * ne, mt);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
-
-   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
-                     vel, alpha, pa_data);
-}
-
 static void PAConvectionApply(const int dim,
                               const int D1D,
                               const int Q1D,
@@ -1521,7 +1531,6 @@ static void PAConvectionApplyT(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Convection Apply kernel
 void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -1536,7 +1545,6 @@ void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
 }
 
-// PA Convection Apply transpose kernel
 void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -1552,17 +1560,4 @@ void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
    }
 }
 
-void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      MFEM_ABORT("AssembleDiagonalPA not yet implemented for"
-                 " ConvectionIntegrator.");
-   }
-}
-
 } // namespace mfem
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
new file mode 100644
index 000000000..68914fe14
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -0,0 +1,205 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../qfunction.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+
+namespace mfem
+{
+
+void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement *fel = fes.GetFE(0);
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
+                                                     *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+   if (Q) { coeff.Project(*Q); }
+   else if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dim*dim);
+   const int sym_dims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int ndata = (dim == 2) ? 1 : (symmetric ? sym_dims : dim*dim);
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   if (el->GetDerivType() != mfem::FiniteElement::CURL)
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+
+   if (dim == 3)
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      internal::PACurlCurlSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                  pa_data);
+   }
+}
+
+void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x34:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x45:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x56:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            default:
+               return internal::SmemPACurlCurlAssembleDiagonal3D(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+         }
+      }
+      else
+      {
+         internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
+                                                mapsO->B, mapsC->B,
+                                                mapsO->G, mapsC->G,
+                                                pa_data, diag);
+      }
+   }
+   else if (dim == 2)
+   {
+      internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                             mapsO->B, mapsC->G, pa_data, diag);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPACurlCurlApply3D<2,3>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x34:
+               return internal::SmemPACurlCurlApply3D<3,4>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x45:
+               return internal::SmemPACurlCurlApply3D<4,5>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x56:
+               return internal::SmemPACurlCurlApply3D<5,6>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            default:
+               return internal::SmemPACurlCurlApply3D(
+                         dofs1D, quad1D, symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
+                                     mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
+                                     pa_data, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
+                                  mapsC->G, mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_dgtrace_ea.cpp b/fem/integ/bilininteg_dgtrace_ea.cpp
similarity index 99%
rename from fem/bilininteg_dgtrace_ea.cpp
rename to fem/integ/bilininteg_dgtrace_ea.cpp
index c40d2ff46..695820489 100644
--- a/fem/bilininteg_dgtrace_ea.cpp
+++ b/fem/integ/bilininteg_dgtrace_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
similarity index 99%
rename from fem/bilininteg_dgtrace_pa.cpp
rename to fem/integ/bilininteg_dgtrace_pa.cpp
index 6987d3455..17dbc3994 100644
--- a/fem/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -9,16 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "restriction.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../restriction.hpp"
 
 namespace mfem
 {
+
 // PA DG Trace Integrator
 static void PADGTraceSetup2D(const int Q1D,
                              const int NF,
diff --git a/fem/bilininteg_diffusion_ea.cpp b/fem/integ/bilininteg_diffusion_ea.cpp
similarity index 99%
rename from fem/bilininteg_diffusion_ea.cpp
rename to fem/integ/bilininteg_diffusion_ea.cpp
index c6b43053c..0e59b33f9 100644
--- a/fem/bilininteg_diffusion_ea.cpp
+++ b/fem/integ/bilininteg_diffusion_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
diff --git a/fem/integ/bilininteg_diffusion_kernels.cpp b/fem/integ/bilininteg_diffusion_kernels.cpp
new file mode 100644
index 000000000..162444bee
--- /dev/null
+++ b/fem/integ/bilininteg_diffusion_kernels.cpp
@@ -0,0 +1,578 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "bilininteg_diffusion_kernels.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+template<>
+void PADiffusionSetup2D<2>(const int Q1D,
+                           const int coeffDim,
+                           const int NE,
+                           const Array<double> &w,
+                           const Vector &j,
+                           const Vector &c,
+                           Vector &d);
+
+template<>
+void PADiffusionSetup2D<3>(const int Q1D,
+                           const int coeffDim,
+                           const int NE,
+                           const Array<double> &w,
+                           const Vector &j,
+                           const Vector &c,
+                           Vector &d);
+
+void PADiffusionSetup(const int dim,
+                      const int sdim,
+                      const int D1D,
+                      const int Q1D,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &W,
+                      const Vector &J,
+                      const Vector &C,
+                      Vector &D)
+{
+   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADiffusionSetup"); }
+   if (dim == 2)
+   {
+#ifdef MFEM_USE_OCCA
+      if (DeviceCanUseOcca())
+      {
+         OccaPADiffusionSetup2D(D1D, Q1D, NE, W, J, C, D);
+         return;
+      }
+#else
+      MFEM_CONTRACT_VAR(D1D);
+#endif // MFEM_USE_OCCA
+      if (sdim == 2) { PADiffusionSetup2D<2>(Q1D, coeffDim, NE, W, J, C, D); }
+      if (sdim == 3) { PADiffusionSetup2D<3>(Q1D, coeffDim, NE, W, J, C, D); }
+   }
+   if (dim == 3)
+   {
+#ifdef MFEM_USE_OCCA
+      if (DeviceCanUseOcca())
+      {
+         OccaPADiffusionSetup3D(D1D, Q1D, NE, W, J, C, D);
+         return;
+      }
+#endif // MFEM_USE_OCCA
+      PADiffusionSetup3D(Q1D, coeffDim, NE, W, J, C, D);
+   }
+}
+
+template<>
+void PADiffusionSetup2D<2>(const int Q1D,
+                           const int coeffDim,
+                           const int NE,
+                           const Array<double> &w,
+                           const Vector &j,
+                           const Vector &c,
+                           Vector &d)
+{
+   const bool symmetric = (coeffDim != 4);
+   const bool const_c = c.Size() == 1;
+   MFEM_VERIFY(coeffDim < 3 ||
+               !const_c, "Constant matrix coefficient not supported");
+   const auto W = Reshape(w.Read(), Q1D,Q1D);
+   const auto J = Reshape(j.Read(), Q1D,Q1D,2,2,NE);
+   const auto C = const_c ? Reshape(c.Read(), 1,1,1,1) :
+                  Reshape(c.Read(), coeffDim,Q1D,Q1D,NE);
+   auto D = Reshape(d.Write(), Q1D,Q1D, symmetric ? 3 : 4, NE);
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            const double J11 = J(qx,qy,0,0,e);
+            const double J21 = J(qx,qy,1,0,e);
+            const double J12 = J(qx,qy,0,1,e);
+            const double J22 = J(qx,qy,1,1,e);
+            const double w_detJ = W(qx,qy) / ((J11*J22)-(J21*J12));
+            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient
+            {
+               // First compute entries of R = MJ^{-T}, without det J factor.
+               const double M11 = C(0,qx,qy,e);
+               const double M12 = C(1,qx,qy,e);
+               const double M21 = symmetric ? M12 : C(2,qx,qy,e);
+               const double M22 = symmetric ? C(2,qx,qy,e) : C(3,qx,qy,e);
+               const double R11 = M11*J22 - M12*J12;
+               const double R21 = M21*J22 - M22*J12;
+               const double R12 = -M11*J21 + M12*J11;
+               const double R22 = -M21*J21 + M22*J11;
+
+               // Now set y to J^{-1}R.
+               D(qx,qy,0,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
+               D(qx,qy,1,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1
+               D(qx,qy,2,e) = w_detJ * (symmetric ? (-J21*R12 + J11*R22) :
+                                        (J22*R12 - J12*R22)); // 2,2 or 1,2
+               if (!symmetric)
+               {
+                  D(qx,qy,3,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
+               }
+            }
+            else // Vector or scalar coefficient
+            {
+               const double C1 = const_c ? C(0,0,0,0) : C(0,qx,qy,e);
+               const double C2 = const_c ? C(0,0,0,0) :
+                                 (coeffDim == 2 ? C(1,qx,qy,e) : C(0,qx,qy,e));
+
+               D(qx,qy,0,e) =  w_detJ * (C2*J12*J12 + C1*J22*J22); // 1,1
+               D(qx,qy,1,e) = -w_detJ * (C2*J12*J11 + C1*J22*J21); // 1,2
+               D(qx,qy,2,e) =  w_detJ * (C2*J11*J11 + C1*J21*J21); // 2,2
+            }
+         }
+      }
+   });
+}
+
+template<>
+void PADiffusionSetup2D<3>(const int Q1D,
+                           const int coeffDim,
+                           const int NE,
+                           const Array<double> &w,
+                           const Vector &j,
+                           const Vector &c,
+                           Vector &d)
+{
+   MFEM_VERIFY(coeffDim == 1, "Matrix and vector coefficients not supported");
+   constexpr int DIM = 2;
+   constexpr int SDIM = 3;
+   const bool const_c = c.Size() == 1;
+   const auto W = Reshape(w.Read(), Q1D,Q1D);
+   const auto J = Reshape(j.Read(), Q1D,Q1D,SDIM,DIM,NE);
+   const auto C = const_c ? Reshape(c.Read(), 1,1,1) :
+                  Reshape(c.Read(), Q1D,Q1D,NE);
+   auto D = Reshape(d.Write(), Q1D,Q1D, 3, NE);
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            const double wq = W(qx,qy);
+            const double J11 = J(qx,qy,0,0,e);
+            const double J21 = J(qx,qy,1,0,e);
+            const double J31 = J(qx,qy,2,0,e);
+            const double J12 = J(qx,qy,0,1,e);
+            const double J22 = J(qx,qy,1,1,e);
+            const double J32 = J(qx,qy,2,1,e);
+            const double E = J11*J11 + J21*J21 + J31*J31;
+            const double G = J12*J12 + J22*J22 + J32*J32;
+            const double F = J11*J12 + J21*J22 + J31*J32;
+            const double iw = 1.0 / sqrt(E*G - F*F);
+            const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+            const double alpha = wq * coeff * iw;
+            D(qx,qy,0,e) =  alpha * G; // 1,1
+            D(qx,qy,1,e) = -alpha * F; // 1,2
+            D(qx,qy,2,e) =  alpha * E; // 2,2
+         }
+      }
+   });
+}
+
+void PADiffusionSetup3D(const int Q1D,
+                        const int coeffDim,
+                        const int NE,
+                        const Array<double> &w,
+                        const Vector &j,
+                        const Vector &c,
+                        Vector &d)
+{
+   const bool symmetric = (coeffDim != 9);
+   const bool const_c = c.Size() == 1;
+   MFEM_VERIFY(coeffDim < 6 ||
+               !const_c, "Constant matrix coefficient not supported");
+   const auto W = Reshape(w.Read(), Q1D,Q1D,Q1D);
+   const auto J = Reshape(j.Read(), Q1D,Q1D,Q1D,3,3,NE);
+   const auto C = const_c ? Reshape(c.Read(), 1,1,1,1,1) :
+                  Reshape(c.Read(), coeffDim,Q1D,Q1D,Q1D,NE);
+   auto D = Reshape(d.Write(), Q1D,Q1D,Q1D, symmetric ? 6 : 9, NE);
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               const double J11 = J(qx,qy,qz,0,0,e);
+               const double J21 = J(qx,qy,qz,1,0,e);
+               const double J31 = J(qx,qy,qz,2,0,e);
+               const double J12 = J(qx,qy,qz,0,1,e);
+               const double J22 = J(qx,qy,qz,1,1,e);
+               const double J32 = J(qx,qy,qz,2,1,e);
+               const double J13 = J(qx,qy,qz,0,2,e);
+               const double J23 = J(qx,qy,qz,1,2,e);
+               const double J33 = J(qx,qy,qz,2,2,e);
+               const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                                   J21 * (J12 * J33 - J32 * J13) +
+                                   J31 * (J12 * J23 - J22 * J13);
+               const double w_detJ = W(qx,qy,qz) / detJ;
+               // adj(J)
+               const double A11 = (J22 * J33) - (J23 * J32);
+               const double A12 = (J32 * J13) - (J12 * J33);
+               const double A13 = (J12 * J23) - (J22 * J13);
+               const double A21 = (J31 * J23) - (J21 * J33);
+               const double A22 = (J11 * J33) - (J13 * J31);
+               const double A23 = (J21 * J13) - (J11 * J23);
+               const double A31 = (J21 * J32) - (J31 * J22);
+               const double A32 = (J31 * J12) - (J11 * J32);
+               const double A33 = (J11 * J22) - (J12 * J21);
+
+               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
+               {
+                  // Compute entries of R = MJ^{-T} = M adj(J)^T, without det J.
+                  const double M11 = C(0, qx,qy,qz, e);
+                  const double M12 = C(1, qx,qy,qz, e);
+                  const double M13 = C(2, qx,qy,qz, e);
+                  const double M21 = (!symmetric) ? C(3, qx,qy,qz, e) : M12;
+                  const double M22 = (!symmetric) ? C(4, qx,qy,qz, e) : C(3, qx,qy,qz, e);
+                  const double M23 = (!symmetric) ? C(5, qx,qy,qz, e) : C(4, qx,qy,qz, e);
+                  const double M31 = (!symmetric) ? C(6, qx,qy,qz, e) : M13;
+                  const double M32 = (!symmetric) ? C(7, qx,qy,qz, e) : M23;
+                  const double M33 = (!symmetric) ? C(8, qx,qy,qz, e) : C(5, qx,qy,qz, e);
+
+                  const double R11 = M11*A11 + M12*A12 + M13*A13;
+                  const double R12 = M11*A21 + M12*A22 + M13*A23;
+                  const double R13 = M11*A31 + M12*A32 + M13*A33;
+                  const double R21 = M21*A11 + M22*A12 + M23*A13;
+                  const double R22 = M21*A21 + M22*A22 + M23*A23;
+                  const double R23 = M21*A31 + M22*A32 + M23*A33;
+                  const double R31 = M31*A11 + M32*A12 + M33*A13;
+                  const double R32 = M31*A21 + M32*A22 + M33*A23;
+                  const double R33 = M31*A31 + M32*A32 + M33*A33;
+
+                  // Now set D to J^{-1} R = adj(J) R
+                  D(qx,qy,qz,0,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
+                  const double D12 = w_detJ * (A11*R12 + A12*R22 + A13*R32);
+                  D(qx,qy,qz,1,e) = D12; // 1,2
+                  D(qx,qy,qz,2,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
+
+                  const double D22 = w_detJ * (A21*R12 + A22*R22 + A23*R32);
+                  const double D23 = w_detJ * (A21*R13 + A22*R23 + A23*R33);
+
+                  const double D33 = w_detJ * (A31*R13 + A32*R23 + A33*R33);
+
+                  D(qx,qy,qz,4,e) = symmetric ? D23 : D22; // 2,3 or 2,2
+                  D(qx,qy,qz,5,e) = symmetric ? D33 : D23; // 3,3 or 2,3
+
+                  if (symmetric)
+                  {
+                     D(qx,qy,qz,3,e) = D22; // 2,2
+                  }
+                  else
+                  {
+                     D(qx,qy,qz,3,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
+                     D(qx,qy,qz,6,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
+                     D(qx,qy,qz,7,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
+                     D(qx,qy,qz,8,e) = D33; // 3,3
+                  }
+               }
+               else  // Vector or scalar coefficient version
+               {
+                  const double C1 = const_c ? C(0,0,0,0,0) : C(0,qx,qy,qz,e);
+                  const double C2 = const_c ? C(0,0,0,0,0) :
+                                    (coeffDim == 3 ? C(1,qx,qy,qz,e) : C(0,qx,qy,qz,e));
+                  const double C3 = const_c ? C(0,0,0,0,0) :
+                                    (coeffDim == 3 ? C(2,qx,qy,qz,e) : C(0,qx,qy,qz,e));
+
+                  // detJ J^{-1} J^{-T} = (1/detJ) adj(J) adj(J)^T
+                  D(qx,qy,qz,0,e) = w_detJ * (C1*A11*A11 + C2*A12*A12 + C3*A13*A13); // 1,1
+                  D(qx,qy,qz,1,e) = w_detJ * (C1*A11*A21 + C2*A12*A22 + C3*A13*A23); // 2,1
+                  D(qx,qy,qz,2,e) = w_detJ * (C1*A11*A31 + C2*A12*A32 + C3*A13*A33); // 3,1
+                  D(qx,qy,qz,3,e) = w_detJ * (C1*A21*A21 + C2*A22*A22 + C3*A23*A23); // 2,2
+                  D(qx,qy,qz,4,e) = w_detJ * (C1*A21*A31 + C2*A22*A32 + C3*A23*A33); // 3,2
+                  D(qx,qy,qz,5,e) = w_detJ * (C1*A31*A31 + C2*A32*A32 + C3*A33*A33); // 3,3
+               }
+            }
+         }
+      }
+   });
+}
+
+#ifdef MFEM_USE_OCCA
+void OccaPADiffusionSetup2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_W = OccaMemoryRead(W.GetMemory(), W.Size());
+   const occa::memory o_J = OccaMemoryRead(J.GetMemory(), J.Size());
+   const occa::memory o_C = OccaMemoryRead(C.GetMemory(), C.Size());
+   occa::memory o_op = OccaMemoryWrite(op.GetMemory(), op.Size());
+   const bool const_c = C.Size() == 1;
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   static occa_kernel_t OccaDiffSetup2D_ker;
+   if (OccaDiffSetup2D_ker.find(id) == OccaDiffSetup2D_ker.end())
+   {
+      const occa::kernel DiffusionSetup2D =
+         mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                     "DiffusionSetup2D", props);
+      OccaDiffSetup2D_ker.emplace(id, DiffusionSetup2D);
+   }
+   OccaDiffSetup2D_ker.at(id)(NE, o_W, o_J, o_C, o_op, const_c);
+}
+
+void OccaPADiffusionSetup3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_W = OccaMemoryRead(W.GetMemory(), W.Size());
+   const occa::memory o_J = OccaMemoryRead(J.GetMemory(), J.Size());
+   const occa::memory o_C = OccaMemoryRead(C.GetMemory(), C.Size());
+   occa::memory o_op = OccaMemoryWrite(op.GetMemory(), op.Size());
+   const bool const_c = C.Size() == 1;
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   static occa_kernel_t OccaDiffSetup3D_ker;
+   if (OccaDiffSetup3D_ker.find(id) == OccaDiffSetup3D_ker.end())
+   {
+      const occa::kernel DiffusionSetup3D =
+         mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                     "DiffusionSetup3D", props);
+      OccaDiffSetup3D_ker.emplace(id, DiffusionSetup3D);
+   }
+   OccaDiffSetup3D_ker.at(id)(NE, o_W, o_J, o_C, o_op, const_c);
+}
+#endif // MFEM_USE_OCCA
+
+void PADiffusionAssembleDiagonal(const int dim,
+                                 const int D1D,
+                                 const int Q1D,
+                                 const int NE,
+                                 const bool symm,
+                                 const Array<double> &B,
+                                 const Array<double> &G,
+                                 const Vector &D,
+                                 Vector &Y)
+{
+   if (dim == 2)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x22: return SmemPADiffusionDiagonal2D<2,2,8>(NE,symm,B,G,D,Y);
+         case 0x33: return SmemPADiffusionDiagonal2D<3,3,8>(NE,symm,B,G,D,Y);
+         case 0x44: return SmemPADiffusionDiagonal2D<4,4,4>(NE,symm,B,G,D,Y);
+         case 0x55: return SmemPADiffusionDiagonal2D<5,5,4>(NE,symm,B,G,D,Y);
+         case 0x66: return SmemPADiffusionDiagonal2D<6,6,2>(NE,symm,B,G,D,Y);
+         case 0x77: return SmemPADiffusionDiagonal2D<7,7,2>(NE,symm,B,G,D,Y);
+         case 0x88: return SmemPADiffusionDiagonal2D<8,8,1>(NE,symm,B,G,D,Y);
+         case 0x99: return SmemPADiffusionDiagonal2D<9,9,1>(NE,symm,B,G,D,Y);
+         default: return PADiffusionDiagonal2D(NE,symm,B,G,D,Y,D1D,Q1D);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x22: return SmemPADiffusionDiagonal3D<2,2>(NE,symm,B,G,D,Y);
+         case 0x23: return SmemPADiffusionDiagonal3D<2,3>(NE,symm,B,G,D,Y);
+         case 0x34: return SmemPADiffusionDiagonal3D<3,4>(NE,symm,B,G,D,Y);
+         case 0x45: return SmemPADiffusionDiagonal3D<4,5>(NE,symm,B,G,D,Y);
+         case 0x46: return SmemPADiffusionDiagonal3D<4,6>(NE,symm,B,G,D,Y);
+         case 0x56: return SmemPADiffusionDiagonal3D<5,6>(NE,symm,B,G,D,Y);
+         case 0x67: return SmemPADiffusionDiagonal3D<6,7>(NE,symm,B,G,D,Y);
+         case 0x78: return SmemPADiffusionDiagonal3D<7,8>(NE,symm,B,G,D,Y);
+         case 0x89: return SmemPADiffusionDiagonal3D<8,9>(NE,symm,B,G,D,Y);
+         case 0x9A: return SmemPADiffusionDiagonal3D<9,10>(NE,symm,B,G,D,Y);
+         default: return PADiffusionDiagonal3D(NE,symm,B,G,D,Y,D1D,Q1D);
+      }
+   }
+   MFEM_ABORT("Unknown kernel.");
+}
+
+void PADiffusionApply(const int dim,
+                      const int D1D,
+                      const int Q1D,
+                      const int NE,
+                      const bool symm,
+                      const Array<double> &B,
+                      const Array<double> &G,
+                      const Array<double> &Bt,
+                      const Array<double> &Gt,
+                      const Vector &D,
+                      const Vector &X,
+                      Vector &Y)
+{
+#ifdef MFEM_USE_OCCA
+   if (DeviceCanUseOcca())
+   {
+      if (dim == 2)
+      {
+         OccaPADiffusionApply2D(D1D,Q1D,NE,B,G,Bt,Gt,D,X,Y);
+         return;
+      }
+      if (dim == 3)
+      {
+         OccaPADiffusionApply3D(D1D,Q1D,NE,B,G,Bt,Gt,D,X,Y);
+         return;
+      }
+      MFEM_ABORT("OCCA PADiffusionApply unknown kernel!");
+   }
+#endif // MFEM_USE_OCCA
+   const int id = (D1D << 4) | Q1D;
+
+   if (dim == 2)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPADiffusionApply2D<2,2,16>(NE,symm,B,G,D,X,Y);
+         case 0x33: return SmemPADiffusionApply2D<3,3,16>(NE,symm,B,G,D,X,Y);
+         case 0x44: return SmemPADiffusionApply2D<4,4,8>(NE,symm,B,G,D,X,Y);
+         case 0x55: return SmemPADiffusionApply2D<5,5,8>(NE,symm,B,G,D,X,Y);
+         case 0x66: return SmemPADiffusionApply2D<6,6,4>(NE,symm,B,G,D,X,Y);
+         case 0x77: return SmemPADiffusionApply2D<7,7,4>(NE,symm,B,G,D,X,Y);
+         case 0x88: return SmemPADiffusionApply2D<8,8,2>(NE,symm,B,G,D,X,Y);
+         case 0x99: return SmemPADiffusionApply2D<9,9,2>(NE,symm,B,G,D,X,Y);
+         default:   return PADiffusionApply2D(NE,symm,B,G,Bt,Gt,D,X,Y,D1D,Q1D);
+      }
+   }
+
+   if (dim == 3)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPADiffusionApply3D<2,2>(NE,symm,B,G,D,X,Y);
+         case 0x23: return SmemPADiffusionApply3D<2,3>(NE,symm,B,G,D,X,Y);
+         case 0x34: return SmemPADiffusionApply3D<3,4>(NE,symm,B,G,D,X,Y);
+         case 0x45: return SmemPADiffusionApply3D<4,5>(NE,symm,B,G,D,X,Y);
+         case 0x46: return SmemPADiffusionApply3D<4,6>(NE,symm,B,G,D,X,Y);
+         case 0x56: return SmemPADiffusionApply3D<5,6>(NE,symm,B,G,D,X,Y);
+         case 0x58: return SmemPADiffusionApply3D<5,8>(NE,symm,B,G,D,X,Y);
+         case 0x67: return SmemPADiffusionApply3D<6,7>(NE,symm,B,G,D,X,Y);
+         case 0x78: return SmemPADiffusionApply3D<7,8>(NE,symm,B,G,D,X,Y);
+         case 0x89: return SmemPADiffusionApply3D<8,9>(NE,symm,B,G,D,X,Y);
+         default:   return PADiffusionApply3D(NE,symm,B,G,Bt,Gt,D,X,Y,D1D,Q1D);
+      }
+   }
+   MFEM_ABORT("Unknown kernel: 0x"<<std::hex << id << std::dec);
+}
+
+#ifdef MFEM_USE_OCCA
+void OccaPADiffusionApply2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_G = OccaMemoryRead(G.GetMemory(), G.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_Gt = OccaMemoryRead(Gt.GetMemory(), Gt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaDiffApply2D_cpu;
+      if (OccaDiffApply2D_cpu.find(id) == OccaDiffApply2D_cpu.end())
+      {
+         const occa::kernel DiffusionApply2D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "DiffusionApply2D_CPU", props);
+         OccaDiffApply2D_cpu.emplace(id, DiffusionApply2D_CPU);
+      }
+      OccaDiffApply2D_cpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaDiffApply2D_gpu;
+      if (OccaDiffApply2D_gpu.find(id) == OccaDiffApply2D_gpu.end())
+      {
+         const occa::kernel DiffusionApply2D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "DiffusionApply2D_GPU", props);
+         OccaDiffApply2D_gpu.emplace(id, DiffusionApply2D_GPU);
+      }
+      OccaDiffApply2D_gpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
+   }
+}
+
+void OccaPADiffusionApply3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_G = OccaMemoryRead(G.GetMemory(), G.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_Gt = OccaMemoryRead(Gt.GetMemory(), Gt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaDiffApply3D_cpu;
+      if (OccaDiffApply3D_cpu.find(id) == OccaDiffApply3D_cpu.end())
+      {
+         const occa::kernel DiffusionApply3D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "DiffusionApply3D_CPU", props);
+         OccaDiffApply3D_cpu.emplace(id, DiffusionApply3D_CPU);
+      }
+      OccaDiffApply3D_cpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaDiffApply3D_gpu;
+      if (OccaDiffApply3D_gpu.find(id) == OccaDiffApply3D_gpu.end())
+      {
+         const occa::kernel DiffusionApply3D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "DiffusionApply3D_GPU", props);
+         OccaDiffApply3D_gpu.emplace(id, DiffusionApply3D_GPU);
+      }
+      OccaDiffApply3D_gpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
+   }
+}
+#endif // MFEM_USE_OCCA
+
+} // namespace internal
+
+} // namespace mfem
diff --git a/fem/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_kernels.hpp
similarity index 59%
rename from fem/bilininteg_diffusion_pa.cpp
rename to fem/integ/bilininteg_diffusion_kernels.hpp
index 2d953952e..4367dc73f 100644
--- a/fem/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_kernels.hpp
@@ -9,189 +9,42 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
+#ifndef MFEM_BILININTEG_DIFFUSION_KERNELS_HPP
+#define MFEM_BILININTEG_DIFFUSION_KERNELS_HPP
 
-using namespace std;
+#include "../../config/config.hpp"
+#include "../../general/array.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+#include "../../linalg/vector.hpp"
+#include "../bilininteg.hpp"
 
 namespace mfem
 {
 
-// PA Diffusion Integrator
-
-// OCCA 2D Assemble kernel
-#ifdef MFEM_USE_OCCA
-static void OccaPADiffusionSetup2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_W = OccaMemoryRead(W.GetMemory(), W.Size());
-   const occa::memory o_J = OccaMemoryRead(J.GetMemory(), J.Size());
-   const occa::memory o_C = OccaMemoryRead(C.GetMemory(), C.Size());
-   occa::memory o_op = OccaMemoryWrite(op.GetMemory(), op.Size());
-   const bool const_c = C.Size() == 1;
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   static occa_kernel_t OccaDiffSetup2D_ker;
-   if (OccaDiffSetup2D_ker.find(id) == OccaDiffSetup2D_ker.end())
-   {
-      const occa::kernel DiffusionSetup2D =
-         mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                     "DiffusionSetup2D", props);
-      OccaDiffSetup2D_ker.emplace(id, DiffusionSetup2D);
-   }
-   OccaDiffSetup2D_ker.at(id)(NE, o_W, o_J, o_C, o_op, const_c);
-}
-
-static void OccaPADiffusionSetup3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
+namespace internal
 {
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_W = OccaMemoryRead(W.GetMemory(), W.Size());
-   const occa::memory o_J = OccaMemoryRead(J.GetMemory(), J.Size());
-   const occa::memory o_C = OccaMemoryRead(C.GetMemory(), C.Size());
-   occa::memory o_op = OccaMemoryWrite(op.GetMemory(), op.Size());
-   const bool const_c = C.Size() == 1;
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   static occa_kernel_t OccaDiffSetup3D_ker;
-   if (OccaDiffSetup3D_ker.find(id) == OccaDiffSetup3D_ker.end())
-   {
-      const occa::kernel DiffusionSetup3D =
-         mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                     "DiffusionSetup3D", props);
-      OccaDiffSetup3D_ker.emplace(id, DiffusionSetup3D);
-   }
-   OccaDiffSetup3D_ker.at(id)(NE, o_W, o_J, o_C, o_op, const_c);
-}
-#endif // MFEM_USE_OCCA
 
-template<>
-void PADiffusionSetup2D<2>(const int Q1D,
-                           const int coeffDim,
-                           const int NE,
-                           const Array<double> &w,
-                           const Vector &j,
-                           const Vector &c,
-                           Vector &d)
-{
-   const bool symmetric = (coeffDim != 4);
-   const bool const_c = c.Size() == 1;
-   MFEM_VERIFY(coeffDim < 3 ||
-               !const_c, "Constant matrix coefficient not supported");
-   const auto W = Reshape(w.Read(), Q1D,Q1D);
-   const auto J = Reshape(j.Read(), Q1D,Q1D,2,2,NE);
-   const auto C = const_c ? Reshape(c.Read(), 1,1,1,1) :
-                  Reshape(c.Read(), coeffDim,Q1D,Q1D,NE);
-   auto D = Reshape(d.Write(), Q1D,Q1D, symmetric ? 3 : 4, NE);
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            const double J11 = J(qx,qy,0,0,e);
-            const double J21 = J(qx,qy,1,0,e);
-            const double J12 = J(qx,qy,0,1,e);
-            const double J22 = J(qx,qy,1,1,e);
-            const double w_detJ = W(qx,qy) / ((J11*J22)-(J21*J12));
-            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient
-            {
-               // First compute entries of R = MJ^{-T}, without det J factor.
-               const double M11 = C(0,qx,qy,e);
-               const double M12 = C(1,qx,qy,e);
-               const double M21 = symmetric ? M12 : C(2,qx,qy,e);
-               const double M22 = symmetric ? C(2,qx,qy,e) : C(3,qx,qy,e);
-               const double R11 = M11*J22 - M12*J12;
-               const double R21 = M21*J22 - M22*J12;
-               const double R12 = -M11*J21 + M12*J11;
-               const double R22 = -M21*J21 + M22*J11;
+void PADiffusionSetup(const int dim,
+                      const int sdim,
+                      const int D1D,
+                      const int Q1D,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &W,
+                      const Vector &J,
+                      const Vector &C,
+                      Vector &D);
 
-               // Now set y to J^{-1}R.
-               D(qx,qy,0,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
-               D(qx,qy,1,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1
-               D(qx,qy,2,e) = w_detJ * (symmetric ? (-J21*R12 + J11*R22) :
-                                        (J22*R12 - J12*R22)); // 2,2 or 1,2
-               if (!symmetric)
-               {
-                  D(qx,qy,3,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
-               }
-            }
-            else // Vector or scalar coefficient
-            {
-               const double C1 = const_c ? C(0,0,0,0) : C(0,qx,qy,e);
-               const double C2 = const_c ? C(0,0,0,0) :
-                                 (coeffDim == 2 ? C(1,qx,qy,e) : C(0,qx,qy,e));
-
-               D(qx,qy,0,e) =  w_detJ * (C2*J12*J12 + C1*J22*J22); // 1,1
-               D(qx,qy,1,e) = -w_detJ * (C2*J12*J11 + C1*J22*J21); // 1,2
-               D(qx,qy,2,e) =  w_detJ * (C2*J11*J11 + C1*J21*J21); // 2,2
-            }
-         }
-      }
-   });
-}
-
-// PA Diffusion Assemble 2D kernel with 3D node coords
-template<>
-void PADiffusionSetup2D<3>(const int Q1D,
-                           const int coeffDim,
-                           const int NE,
-                           const Array<double> &w,
-                           const Vector &j,
-                           const Vector &c,
-                           Vector &d)
-{
-   MFEM_VERIFY(coeffDim == 1, "Matrix and vector coefficients not supported");
-   constexpr int DIM = 2;
-   constexpr int SDIM = 3;
-   const bool const_c = c.Size() == 1;
-   const auto W = Reshape(w.Read(), Q1D,Q1D);
-   const auto J = Reshape(j.Read(), Q1D,Q1D,SDIM,DIM,NE);
-   const auto C = const_c ? Reshape(c.Read(), 1,1,1) :
-                  Reshape(c.Read(), Q1D,Q1D,NE);
-   auto D = Reshape(d.Write(), Q1D,Q1D, 3, NE);
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            const double wq = W(qx,qy);
-            const double J11 = J(qx,qy,0,0,e);
-            const double J21 = J(qx,qy,1,0,e);
-            const double J31 = J(qx,qy,2,0,e);
-            const double J12 = J(qx,qy,0,1,e);
-            const double J22 = J(qx,qy,1,1,e);
-            const double J32 = J(qx,qy,2,1,e);
-            const double E = J11*J11 + J21*J21 + J31*J31;
-            const double G = J12*J12 + J22*J22 + J32*J32;
-            const double F = J11*J12 + J21*J22 + J31*J32;
-            const double iw = 1.0 / sqrt(E*G - F*F);
-            const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-            const double alpha = wq * coeff * iw;
-            D(qx,qy,0,e) =  alpha * G; // 1,1
-            D(qx,qy,1,e) = -alpha * F; // 1,2
-            D(qx,qy,2,e) =  alpha * E; // 2,2
-         }
-      }
-   });
-}
+// PA Diffusion Assemble 2D kernel
+template<int T_SDIM>
+void PADiffusionSetup2D(const int Q1D,
+                        const int coeffDim,
+                        const int NE,
+                        const Array<double> &w,
+                        const Vector &j,
+                        const Vector &c,
+                        Vector &d);
 
 // PA Diffusion Assemble 3D kernel
 void PADiffusionSetup3D(const int Q1D,
@@ -200,217 +53,41 @@ void PADiffusionSetup3D(const int Q1D,
                         const Array<double> &w,
                         const Vector &j,
                         const Vector &c,
-                        Vector &d)
-{
-   const bool symmetric = (coeffDim != 9);
-   const bool const_c = c.Size() == 1;
-   MFEM_VERIFY(coeffDim < 6 ||
-               !const_c, "Constant matrix coefficient not supported");
-   const auto W = Reshape(w.Read(), Q1D,Q1D,Q1D);
-   const auto J = Reshape(j.Read(), Q1D,Q1D,Q1D,3,3,NE);
-   const auto C = const_c ? Reshape(c.Read(), 1,1,1,1,1) :
-                  Reshape(c.Read(), coeffDim,Q1D,Q1D,Q1D,NE);
-   auto D = Reshape(d.Write(), Q1D,Q1D,Q1D, symmetric ? 6 : 9, NE);
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               const double J11 = J(qx,qy,qz,0,0,e);
-               const double J21 = J(qx,qy,qz,1,0,e);
-               const double J31 = J(qx,qy,qz,2,0,e);
-               const double J12 = J(qx,qy,qz,0,1,e);
-               const double J22 = J(qx,qy,qz,1,1,e);
-               const double J32 = J(qx,qy,qz,2,1,e);
-               const double J13 = J(qx,qy,qz,0,2,e);
-               const double J23 = J(qx,qy,qz,1,2,e);
-               const double J33 = J(qx,qy,qz,2,2,e);
-               const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                                   J21 * (J12 * J33 - J32 * J13) +
-                                   J31 * (J12 * J23 - J22 * J13);
-               const double w_detJ = W(qx,qy,qz) / detJ;
-               // adj(J)
-               const double A11 = (J22 * J33) - (J23 * J32);
-               const double A12 = (J32 * J13) - (J12 * J33);
-               const double A13 = (J12 * J23) - (J22 * J13);
-               const double A21 = (J31 * J23) - (J21 * J33);
-               const double A22 = (J11 * J33) - (J13 * J31);
-               const double A23 = (J21 * J13) - (J11 * J23);
-               const double A31 = (J21 * J32) - (J31 * J22);
-               const double A32 = (J31 * J12) - (J11 * J32);
-               const double A33 = (J11 * J22) - (J12 * J21);
-
-               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-               {
-                  // Compute entries of R = MJ^{-T} = M adj(J)^T, without det J.
-                  const double M11 = C(0, qx,qy,qz, e);
-                  const double M12 = C(1, qx,qy,qz, e);
-                  const double M13 = C(2, qx,qy,qz, e);
-                  const double M21 = (!symmetric) ? C(3, qx,qy,qz, e) : M12;
-                  const double M22 = (!symmetric) ? C(4, qx,qy,qz, e) : C(3, qx,qy,qz, e);
-                  const double M23 = (!symmetric) ? C(5, qx,qy,qz, e) : C(4, qx,qy,qz, e);
-                  const double M31 = (!symmetric) ? C(6, qx,qy,qz, e) : M13;
-                  const double M32 = (!symmetric) ? C(7, qx,qy,qz, e) : M23;
-                  const double M33 = (!symmetric) ? C(8, qx,qy,qz, e) : C(5, qx,qy,qz, e);
-
-                  const double R11 = M11*A11 + M12*A12 + M13*A13;
-                  const double R12 = M11*A21 + M12*A22 + M13*A23;
-                  const double R13 = M11*A31 + M12*A32 + M13*A33;
-                  const double R21 = M21*A11 + M22*A12 + M23*A13;
-                  const double R22 = M21*A21 + M22*A22 + M23*A23;
-                  const double R23 = M21*A31 + M22*A32 + M23*A33;
-                  const double R31 = M31*A11 + M32*A12 + M33*A13;
-                  const double R32 = M31*A21 + M32*A22 + M33*A23;
-                  const double R33 = M31*A31 + M32*A32 + M33*A33;
-
-                  // Now set D to J^{-1} R = adj(J) R
-                  D(qx,qy,qz,0,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
-                  const double D12 = w_detJ * (A11*R12 + A12*R22 + A13*R32);
-                  D(qx,qy,qz,1,e) = D12; // 1,2
-                  D(qx,qy,qz,2,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
-
-                  const double D22 = w_detJ * (A21*R12 + A22*R22 + A23*R32);
-                  const double D23 = w_detJ * (A21*R13 + A22*R23 + A23*R33);
-
-                  const double D33 = w_detJ * (A31*R13 + A32*R23 + A33*R33);
-
-                  D(qx,qy,qz,4,e) = symmetric ? D23 : D22; // 2,3 or 2,2
-                  D(qx,qy,qz,5,e) = symmetric ? D33 : D23; // 3,3 or 2,3
+                        Vector &d);
 
-                  if (symmetric)
-                  {
-                     D(qx,qy,qz,3,e) = D22; // 2,2
-                  }
-                  else
-                  {
-                     D(qx,qy,qz,3,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
-                     D(qx,qy,qz,6,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
-                     D(qx,qy,qz,7,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
-                     D(qx,qy,qz,8,e) = D33; // 3,3
-                  }
-               }
-               else  // Vector or scalar coefficient version
-               {
-                  const double C1 = const_c ? C(0,0,0,0,0) : C(0,qx,qy,qz,e);
-                  const double C2 = const_c ? C(0,0,0,0,0) :
-                                    (coeffDim == 3 ? C(1,qx,qy,qz,e) : C(0,qx,qy,qz,e));
-                  const double C3 = const_c ? C(0,0,0,0,0) :
-                                    (coeffDim == 3 ? C(2,qx,qy,qz,e) : C(0,qx,qy,qz,e));
-
-                  // detJ J^{-1} J^{-T} = (1/detJ) adj(J) adj(J)^T
-                  D(qx,qy,qz,0,e) = w_detJ * (C1*A11*A11 + C2*A12*A12 + C3*A13*A13); // 1,1
-                  D(qx,qy,qz,1,e) = w_detJ * (C1*A11*A21 + C2*A12*A22 + C3*A13*A23); // 2,1
-                  D(qx,qy,qz,2,e) = w_detJ * (C1*A11*A31 + C2*A12*A32 + C3*A13*A33); // 3,1
-                  D(qx,qy,qz,3,e) = w_detJ * (C1*A21*A21 + C2*A22*A22 + C3*A23*A23); // 2,2
-                  D(qx,qy,qz,4,e) = w_detJ * (C1*A21*A31 + C2*A22*A32 + C3*A23*A33); // 3,2
-                  D(qx,qy,qz,5,e) = w_detJ * (C1*A31*A31 + C2*A32*A32 + C3*A33*A33); // 3,3
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PADiffusionSetup(const int dim,
-                             const int sdim,
-                             const int D1D,
-                             const int Q1D,
-                             const int coeffDim,
-                             const int NE,
-                             const Array<double> &W,
-                             const Vector &J,
-                             const Vector &C,
-                             Vector &D)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADiffusionSetup"); }
-   if (dim == 2)
-   {
 #ifdef MFEM_USE_OCCA
-      if (DeviceCanUseOcca())
-      {
-         OccaPADiffusionSetup2D(D1D, Q1D, NE, W, J, C, D);
-         return;
-      }
-#else
-      MFEM_CONTRACT_VAR(D1D);
-#endif // MFEM_USE_OCCA
-      if (sdim == 2) { PADiffusionSetup2D<2>(Q1D, coeffDim, NE, W, J, C, D); }
-      if (sdim == 3) { PADiffusionSetup2D<3>(Q1D, coeffDim, NE, W, J, C, D); }
-   }
-   if (dim == 3)
-   {
-#ifdef MFEM_USE_OCCA
-      if (DeviceCanUseOcca())
-      {
-         OccaPADiffusionSetup3D(D1D, Q1D, NE, W, J, C, D);
-         return;
-      }
-#endif // MFEM_USE_OCCA
-      PADiffusionSetup3D(Q1D, coeffDim, NE, W, J, C, D);
-   }
-}
-
-void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-   // Assuming the same element type
-   fespace = &fes;
-   Mesh *mesh = fes.GetMesh();
-   if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
-      return;
-   }
-   const int dims = el.GetDim();
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
-   const int sdim = mesh->SpaceDimension();
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::COMPRESSED);
-
-   if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (VQ) { coeff.Project(*VQ); }
-   else if (Q) { coeff.Project(*Q); }
-   else { coeff.SetConstant(1.0); }
+// OCCA 2D Assemble kernel
+void OccaPADiffusionSetup2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op);
 
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dims*dims);
-   const int pa_size = symmetric ? symmDims : dims*dims;
+// OCCA 3D Assemble kernel
+void OccaPADiffusionSetup3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op);
+#endif // MFEM_USE_OCCA
 
-   pa_data.SetSize(pa_size * nq * ne, mt);
-   PADiffusionSetup(dim, sdim, dofs1D, quad1D, coeff_dim, ne, ir->GetWeights(),
-                    geom->J, coeff, pa_data);
-}
+void PADiffusionAssembleDiagonal(const int dim,
+                                 const int D1D,
+                                 const int Q1D,
+                                 const int NE,
+                                 const bool symm,
+                                 const Array<double> &B,
+                                 const Array<double> &G,
+                                 const Vector &D,
+                                 Vector &Y);
 
+// PA Diffusion Diagonal 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionDiagonal2D(const int NE,
+inline void PADiffusionDiagonal2D(const int NE,
                                   const bool symmetric,
                                   const Array<double> &b,
                                   const Array<double> &g,
@@ -476,7 +153,7 @@ static void PADiffusionDiagonal2D(const int NE,
 
 // Shared memory PA Diffusion Diagonal 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPADiffusionDiagonal2D(const int NE,
+inline void SmemPADiffusionDiagonal2D(const int NE,
                                       const bool symmetric,
                                       const Array<double> &b_,
                                       const Array<double> &g_,
@@ -569,8 +246,9 @@ static void SmemPADiffusionDiagonal2D(const int NE,
    });
 }
 
+// PA Diffusion Diagonal 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionDiagonal3D(const int NE,
+inline void PADiffusionDiagonal3D(const int NE,
                                   const bool symmetric,
                                   const Array<double> &b,
                                   const Array<double> &g,
@@ -671,7 +349,7 @@ static void PADiffusionDiagonal3D(const int NE,
 
 // Shared memory PA Diffusion Diagonal 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPADiffusionDiagonal3D(const int NE,
+inline void SmemPADiffusionDiagonal3D(const int NE,
                                       const bool symmetric,
                                       const Array<double> &b_,
                                       const Array<double> &g_,
@@ -788,169 +466,48 @@ static void SmemPADiffusionDiagonal3D(const int NE,
    });
 }
 
-static void PADiffusionAssembleDiagonal(const int dim,
-                                        const int D1D,
-                                        const int Q1D,
-                                        const int NE,
-                                        const bool symm,
-                                        const Array<double> &B,
-                                        const Array<double> &G,
-                                        const Vector &D,
-                                        Vector &Y)
-{
-   if (dim == 2)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x22: return SmemPADiffusionDiagonal2D<2,2,8>(NE,symm,B,G,D,Y);
-         case 0x33: return SmemPADiffusionDiagonal2D<3,3,8>(NE,symm,B,G,D,Y);
-         case 0x44: return SmemPADiffusionDiagonal2D<4,4,4>(NE,symm,B,G,D,Y);
-         case 0x55: return SmemPADiffusionDiagonal2D<5,5,4>(NE,symm,B,G,D,Y);
-         case 0x66: return SmemPADiffusionDiagonal2D<6,6,2>(NE,symm,B,G,D,Y);
-         case 0x77: return SmemPADiffusionDiagonal2D<7,7,2>(NE,symm,B,G,D,Y);
-         case 0x88: return SmemPADiffusionDiagonal2D<8,8,1>(NE,symm,B,G,D,Y);
-         case 0x99: return SmemPADiffusionDiagonal2D<9,9,1>(NE,symm,B,G,D,Y);
-         default: return PADiffusionDiagonal2D(NE,symm,B,G,D,Y,D1D,Q1D);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x22: return SmemPADiffusionDiagonal3D<2,2>(NE,symm,B,G,D,Y);
-         case 0x23: return SmemPADiffusionDiagonal3D<2,3>(NE,symm,B,G,D,Y);
-         case 0x34: return SmemPADiffusionDiagonal3D<3,4>(NE,symm,B,G,D,Y);
-         case 0x45: return SmemPADiffusionDiagonal3D<4,5>(NE,symm,B,G,D,Y);
-         case 0x46: return SmemPADiffusionDiagonal3D<4,6>(NE,symm,B,G,D,Y);
-         case 0x56: return SmemPADiffusionDiagonal3D<5,6>(NE,symm,B,G,D,Y);
-         case 0x67: return SmemPADiffusionDiagonal3D<6,7>(NE,symm,B,G,D,Y);
-         case 0x78: return SmemPADiffusionDiagonal3D<7,8>(NE,symm,B,G,D,Y);
-         case 0x89: return SmemPADiffusionDiagonal3D<8,9>(NE,symm,B,G,D,Y);
-         case 0x9A: return SmemPADiffusionDiagonal3D<9,10>(NE,symm,B,G,D,Y);
-         default: return PADiffusionDiagonal3D(NE,symm,B,G,D,Y,D1D,Q1D);
-      }
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
-void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      if (pa_data.Size()==0) { AssemblePA(*fespace); }
-      PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
-                                  maps->B, maps->G, pa_data, diag);
-   }
-}
-
+void PADiffusionApply(const int dim,
+                      const int D1D,
+                      const int Q1D,
+                      const int NE,
+                      const bool symm,
+                      const Array<double> &B,
+                      const Array<double> &G,
+                      const Array<double> &Bt,
+                      const Array<double> &Gt,
+                      const Vector &D,
+                      const Vector &X,
+                      Vector &Y);
 
 #ifdef MFEM_USE_OCCA
 // OCCA PA Diffusion Apply 2D kernel
-static void OccaPADiffusionApply2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &B,
-                                   const Array<double> &G,
-                                   const Array<double> &Bt,
-                                   const Array<double> &Gt,
-                                   const Vector &D,
-                                   const Vector &X,
-                                   Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_G = OccaMemoryRead(G.GetMemory(), G.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_Gt = OccaMemoryRead(Gt.GetMemory(), Gt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaDiffApply2D_cpu;
-      if (OccaDiffApply2D_cpu.find(id) == OccaDiffApply2D_cpu.end())
-      {
-         const occa::kernel DiffusionApply2D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "DiffusionApply2D_CPU", props);
-         OccaDiffApply2D_cpu.emplace(id, DiffusionApply2D_CPU);
-      }
-      OccaDiffApply2D_cpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaDiffApply2D_gpu;
-      if (OccaDiffApply2D_gpu.find(id) == OccaDiffApply2D_gpu.end())
-      {
-         const occa::kernel DiffusionApply2D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "DiffusionApply2D_GPU", props);
-         OccaDiffApply2D_gpu.emplace(id, DiffusionApply2D_GPU);
-      }
-      OccaDiffApply2D_gpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
-   }
-}
+void OccaPADiffusionApply2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y);
 
 // OCCA PA Diffusion Apply 3D kernel
-static void OccaPADiffusionApply3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &B,
-                                   const Array<double> &G,
-                                   const Array<double> &Bt,
-                                   const Array<double> &Gt,
-                                   const Vector &D,
-                                   const Vector &X,
-                                   Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_G = OccaMemoryRead(G.GetMemory(), G.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_Gt = OccaMemoryRead(Gt.GetMemory(), Gt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaDiffApply3D_cpu;
-      if (OccaDiffApply3D_cpu.find(id) == OccaDiffApply3D_cpu.end())
-      {
-         const occa::kernel DiffusionApply3D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "DiffusionApply3D_CPU", props);
-         OccaDiffApply3D_cpu.emplace(id, DiffusionApply3D_CPU);
-      }
-      OccaDiffApply3D_cpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaDiffApply3D_gpu;
-      if (OccaDiffApply3D_gpu.find(id) == OccaDiffApply3D_gpu.end())
-      {
-         const occa::kernel DiffusionApply3D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "DiffusionApply3D_GPU", props);
-         OccaDiffApply3D_gpu.emplace(id, DiffusionApply3D_GPU);
-      }
-      OccaDiffApply3D_gpu.at(id)(NE, o_B, o_G, o_Bt, o_Gt, o_D, o_X, o_Y);
-   }
-}
+void OccaPADiffusionApply3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y);
 #endif // MFEM_USE_OCCA
 
 // PA Diffusion Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionApply2D(const int NE,
+inline void PADiffusionApply2D(const int NE,
                                const bool symmetric,
                                const Array<double> &b_,
                                const Array<double> &g_,
@@ -1072,7 +629,7 @@ static void PADiffusionApply2D(const int NE,
 
 // Shared memory PA Diffusion Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPADiffusionApply2D(const int NE,
+inline void SmemPADiffusionApply2D(const int NE,
                                    const bool symmetric,
                                    const Array<double> &b_,
                                    const Array<double> &g_,
@@ -1230,7 +787,7 @@ static void SmemPADiffusionApply2D(const int NE,
 
 // PA Diffusion Apply 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionApply3D(const int NE,
+inline void PADiffusionApply3D(const int NE,
                                const bool symmetric,
                                const Array<double> &b,
                                const Array<double> &g,
@@ -1421,8 +978,9 @@ static void PADiffusionApply3D(const int NE,
    });
 }
 
+// Shared memory PA Diffusion Apply 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPADiffusionApply3D(const int NE,
+inline void SmemPADiffusionApply3D(const int NE,
                                    const bool symmetric,
                                    const Array<double> &b_,
                                    const Array<double> &g_,
@@ -1643,99 +1201,8 @@ static void SmemPADiffusionApply3D(const int NE,
    });
 }
 
-static void PADiffusionApply(const int dim,
-                             const int D1D,
-                             const int Q1D,
-                             const int NE,
-                             const bool symm,
-                             const Array<double> &B,
-                             const Array<double> &G,
-                             const Array<double> &Bt,
-                             const Array<double> &Gt,
-                             const Vector &D,
-                             const Vector &X,
-                             Vector &Y)
-{
-#ifdef MFEM_USE_OCCA
-   if (DeviceCanUseOcca())
-   {
-      if (dim == 2)
-      {
-         OccaPADiffusionApply2D(D1D,Q1D,NE,B,G,Bt,Gt,D,X,Y);
-         return;
-      }
-      if (dim == 3)
-      {
-         OccaPADiffusionApply3D(D1D,Q1D,NE,B,G,Bt,Gt,D,X,Y);
-         return;
-      }
-      MFEM_ABORT("OCCA PADiffusionApply unknown kernel!");
-   }
-#endif // MFEM_USE_OCCA
-   const int id = (D1D << 4) | Q1D;
-
-   if (dim == 2)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPADiffusionApply2D<2,2,16>(NE,symm,B,G,D,X,Y);
-         case 0x33: return SmemPADiffusionApply2D<3,3,16>(NE,symm,B,G,D,X,Y);
-         case 0x44: return SmemPADiffusionApply2D<4,4,8>(NE,symm,B,G,D,X,Y);
-         case 0x55: return SmemPADiffusionApply2D<5,5,8>(NE,symm,B,G,D,X,Y);
-         case 0x66: return SmemPADiffusionApply2D<6,6,4>(NE,symm,B,G,D,X,Y);
-         case 0x77: return SmemPADiffusionApply2D<7,7,4>(NE,symm,B,G,D,X,Y);
-         case 0x88: return SmemPADiffusionApply2D<8,8,2>(NE,symm,B,G,D,X,Y);
-         case 0x99: return SmemPADiffusionApply2D<9,9,2>(NE,symm,B,G,D,X,Y);
-         default:   return PADiffusionApply2D(NE,symm,B,G,Bt,Gt,D,X,Y,D1D,Q1D);
-      }
-   }
-
-   if (dim == 3)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPADiffusionApply3D<2,2>(NE,symm,B,G,D,X,Y);
-         case 0x23: return SmemPADiffusionApply3D<2,3>(NE,symm,B,G,D,X,Y);
-         case 0x34: return SmemPADiffusionApply3D<3,4>(NE,symm,B,G,D,X,Y);
-         case 0x45: return SmemPADiffusionApply3D<4,5>(NE,symm,B,G,D,X,Y);
-         case 0x46: return SmemPADiffusionApply3D<4,6>(NE,symm,B,G,D,X,Y);
-         case 0x56: return SmemPADiffusionApply3D<5,6>(NE,symm,B,G,D,X,Y);
-         case 0x58: return SmemPADiffusionApply3D<5,8>(NE,symm,B,G,D,X,Y);
-         case 0x67: return SmemPADiffusionApply3D<6,7>(NE,symm,B,G,D,X,Y);
-         case 0x78: return SmemPADiffusionApply3D<7,8>(NE,symm,B,G,D,X,Y);
-         case 0x89: return SmemPADiffusionApply3D<8,9>(NE,symm,B,G,D,X,Y);
-         default:   return PADiffusionApply3D(NE,symm,B,G,Bt,Gt,D,X,Y,D1D,Q1D);
-      }
-   }
-   MFEM_ABORT("Unknown kernel: 0x"<<std::hex << id << std::dec);
-}
-
-// PA Diffusion Apply kernel
-void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      PADiffusionApply(dim, dofs1D, quad1D, ne, symmetric,
-                       maps->B, maps->G, maps->Bt, maps->Gt,
-                       pa_data, x, y);
-   }
-}
-
-void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (symmetric)
-   {
-      AddMultPA(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
-                 "the symmetric case.")
-   }
-}
+} // namespace internal
 
 } // namespace mfem
+
+#endif
diff --git a/fem/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
similarity index 92%
rename from fem/bilininteg_diffusion_mf.cpp
rename to fem/integ/bilininteg_diffusion_mf.cpp
index c6bd5c728..449246a02 100644
--- a/fem/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -9,12 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
new file mode 100644
index 000000000..f3ed5952c
--- /dev/null
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -0,0 +1,118 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+
+namespace mfem
+{
+
+void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+   // Assuming the same element type
+   fespace = &fes;
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   const FiniteElement &el = *fes.GetFE(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient supported for DiffusionIntegrator"
+                  " with libCEED");
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
+      }
+      else
+      {
+         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
+      }
+      return;
+   }
+   const int dims = el.GetDim();
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
+   const int sdim = mesh->SpaceDimension();
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::COMPRESSED);
+
+   if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (VQ) { coeff.Project(*VQ); }
+   else if (Q) { coeff.Project(*Q); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dims*dims);
+   const int pa_size = symmetric ? symmDims : dims*dims;
+
+   pa_data.SetSize(pa_size * nq * ne, mt);
+   internal::PADiffusionSetup(dim, sdim, dofs1D, quad1D, coeff_dim, ne,
+                              ir->GetWeights(), geom->J, coeff, pa_data);
+}
+
+void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      if (pa_data.Size()==0) { AssemblePA(*fespace); }
+      internal::PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
+                                            maps->B, maps->G, pa_data, diag);
+   }
+}
+
+void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      internal::PADiffusionApply(dim, dofs1D, quad1D, ne, symmetric,
+                                 maps->B, maps->G, maps->Bt, maps->Gt,
+                                 pa_data, x, y);
+   }
+}
+
+void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (symmetric)
+   {
+      AddMultPA(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
+                 "the symmetric case.")
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
new file mode 100644
index 000000000..aee788e55
--- /dev/null
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -0,0 +1,98 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement *fel = fes.GetFE(0);
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
+                               (*el, *el, *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PADivDivSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                pa_data);
+   }
+   else if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
+   {
+      internal::PADivDivSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
+                                           mapsO->B, mapsC->G, pa_data, diag);
+   }
+   else
+   {
+      internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                           mapsO->B, mapsC->G, pa_data, diag);
+   }
+}
+
+void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+      internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   else if (dim == 2)
+      internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_gradient.cpp b/fem/integ/bilininteg_gradient_pa.cpp
similarity index 99%
rename from fem/bilininteg_gradient.cpp
rename to fem/integ/bilininteg_gradient_pa.cpp
index 73b9d1859..7d6b8c5df 100644
--- a/fem/bilininteg_gradient.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -9,18 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
 
 namespace mfem
 {
 
-// PA Gradient Integrator
-
 /* Description of the *SetupND functions
    Inputs are as follows
    \b Q1D number of quadrature points in one dimension.
diff --git a/fem/integ/bilininteg_hcurl_kernels.cpp b/fem/integ/bilininteg_hcurl_kernels.cpp
new file mode 100644
index 000000000..576faa36b
--- /dev/null
+++ b/fem/integ/bilininteg_hcurl_kernels.cpp
@@ -0,0 +1,1044 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "bilininteg_hcurl_kernels.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+void PAHcurlMassAssembleDiagonal2D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double mass[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+
+                  mass[qx] += wy * wy * ((c == 0) ? op(qx,qy,0,e) :
+                                         op(qx,qy,symmetric ? 2 : 3, e));
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  D(dx + (dy * D1Dx) + osc, e) += mass[qx] * wx * wx;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+void PAHcurlMassAssembleDiagonal3D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                         (symmetric ? 5 : 8));
+
+         double mass[MAX_Q1D];
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+
+                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
+                     }
+                  }
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                     D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += mass[qx] * wx * wx;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+void PAHcurlMassApply2D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O21 = op(qx,qy,1,e);
+            const double O12 = symmetric ? O21 : op(qx,qy,2,e);
+            const double O22 = symmetric ? op(qx,qy,2,e) : op(qx,qy,3,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O21*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double massX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+void PAHcurlMassApply3D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
+               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
+               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
+               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
+               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
+               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MAX_D1D][MAX_D1D];
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+void PACurlCurlSetup2D(const int Q1D,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op)
+{
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
+   auto C = Reshape(coeff.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double detJ = (J11*J22)-(J21*J12);
+         y(q,e) = W[q] * C(q,e) / detJ;
+      }
+   });
+}
+
+void PACurlCurlSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op)
+{
+   const int NQ = Q1D*Q1D*Q1D;
+   const bool symmetric = (coeffDim != 9);
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
+   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
+   auto y = Reshape(op.Write(), NQ, symmetric ? 6 : 9, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J31 = J(q,2,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double J32 = J(q,2,1,e);
+         const double J13 = J(q,0,2,e);
+         const double J23 = J(q,1,2,e);
+         const double J33 = J(q,2,2,e);
+         const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                             J21 * (J12 * J33 - J32 * J13) +
+                             J31 * (J12 * J23 - J22 * J13);
+
+         const double c_detJ = W[q] / detJ;
+
+         if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
+         {
+            // Set y to the 6 or 9 entries of J^T M J / det
+            const double M11 = C(0, q, e);
+            const double M12 = C(1, q, e);
+            const double M13 = C(2, q, e);
+            const double M21 = (!symmetric) ? C(3, q, e) : M12;
+            const double M22 = (!symmetric) ? C(4, q, e) : C(3, q, e);
+            const double M23 = (!symmetric) ? C(5, q, e) : C(4, q, e);
+            const double M31 = (!symmetric) ? C(6, q, e) : M13;
+            const double M32 = (!symmetric) ? C(7, q, e) : M23;
+            const double M33 = (!symmetric) ? C(8, q, e) : C(5, q, e);
+
+            // First compute R = MJ
+            const double R11 = M11*J11 + M12*J21 + M13*J31;
+            const double R12 = M11*J12 + M12*J22 + M13*J32;
+            const double R13 = M11*J13 + M12*J23 + M13*J33;
+            const double R21 = M21*J11 + M22*J21 + M23*J31;
+            const double R22 = M21*J12 + M22*J22 + M23*J32;
+            const double R23 = M21*J13 + M22*J23 + M23*J33;
+            const double R31 = M31*J11 + M32*J21 + M33*J31;
+            const double R32 = M31*J12 + M32*J22 + M33*J32;
+            const double R33 = M31*J13 + M32*J23 + M33*J33;
+
+            // Now set y to J^T R / det
+            y(q,0,e) = c_detJ * (J11*R11 + J21*R21 + J31*R31); // 1,1
+            const double Y12 = c_detJ * (J11*R12 + J21*R22 + J31*R32);
+            y(q,1,e) = Y12; // 1,2
+            y(q,2,e) = c_detJ * (J11*R13 + J21*R23 + J31*R33); // 1,3
+
+            const double Y21 = c_detJ * (J12*R11 + J22*R21 + J32*R31);
+            const double Y22 = c_detJ * (J12*R12 + J22*R22 + J32*R32);
+            const double Y23 = c_detJ * (J12*R13 + J22*R23 + J32*R33);
+
+            const double Y33 = c_detJ * (J13*R13 + J23*R23 + J33*R33);
+
+            y(q,3,e) = symmetric ? Y22 : Y21; // 2,2 or 2,1
+            y(q,4,e) = symmetric ? Y23 : Y22; // 2,3 or 2,2
+            y(q,5,e) = symmetric ? Y33 : Y23; // 3,3 or 2,3
+
+            if (!symmetric)
+            {
+               y(q,6,e) = c_detJ * (J13*R11 + J23*R21 + J33*R31); // 3,1
+               y(q,7,e) = c_detJ * (J13*R12 + J23*R22 + J33*R32); // 3,2
+               y(q,8,e) = Y33; // 3,3
+            }
+         }
+         else  // Vector or scalar coefficient version
+         {
+            // Set y to the 6 entries of J^T D J / det^2
+            const double D1 = C(0, q, e);
+            const double D2 = coeffDim == 3 ? C(1, q, e) : D1;
+            const double D3 = coeffDim == 3 ? C(2, q, e) : D1;
+
+            y(q,0,e) = c_detJ * (D1*J11*J11 + D2*J21*J21 + D3*J31*J31); // 1,1
+            y(q,1,e) = c_detJ * (D1*J11*J12 + D2*J21*J22 + D3*J31*J32); // 1,2
+            y(q,2,e) = c_detJ * (D1*J11*J13 + D2*J21*J23 + D3*J31*J33); // 1,3
+            y(q,3,e) = c_detJ * (D1*J12*J12 + D2*J22*J22 + D3*J32*J32); // 2,2
+            y(q,4,e) = c_detJ * (D1*J12*J13 + D2*J22*J23 + D3*J32*J33); // 2,3
+            y(q,5,e) = c_detJ * (D1*J13*J13 + D2*J23*J23 + D3*J33*J33); // 3,3
+         }
+      }
+   });
+}
+
+void PACurlCurlAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const Array<double> &bo,
+                                  const Array<double> &gc,
+                                  const Vector &pa_data,
+                                  Vector &diag)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double t[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               t[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : -Gc(qy,dy);
+                  t[qx] += wy * wy * op(qx,qy,e);
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+                  D(dx + (dy * D1Dx) + osc, e) += t[qx] * wx * wx;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+void PACurlCurlApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &bo,
+                       const Array<double> &bot,
+                       const Array<double> &gc,
+                       const Array<double> &gct,
+                       const Vector &pa_data,
+                       const Vector &x,
+                       Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D];
+
+      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] = 0.0;
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double gradX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx] = 0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  curl[qy][qx] += gradX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double gradX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               gradX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradX[dx] += curl[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+void PAHcurlL2Setup2D(const int Q1D,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op)
+{
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto C = Reshape(coeff.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * C(q,e);
+      }
+   });
+}
+
+void PAHcurlL2Setup3D(const int NQ,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op)
+{
+   auto W = w.Read();
+   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
+   auto y = Reshape(op.Write(), coeffDim, NQ, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         for (int c=0; c<coeffDim; ++c)
+         {
+            y(c,q,e) = W[q] * C(c,q,e);
+         }
+      }
+   });
+}
+
+void PAHcurlL2Apply2D(const int D1D,
+                      const int D1Dtest,
+                      const int Q1D,
+                      const int NE,
+                      const Array<double> &bo,
+                      const Array<double> &bot,
+                      const Array<double> &bt,
+                      const Array<double> &gc,
+                      const Vector &pa_data,
+                      const Vector &x, // trial = H(curl)
+                      Vector &y)  // test = L2 or H1
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+   const int H1 = (D1Dtest == D1D);
+
+   MFEM_VERIFY(y.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bt = Reshape(bt.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1Dtest, D1Dtest, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D];
+
+      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] = 0.0;
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double gradX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx] = 0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  curl[qy][qx] += gradX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double sol_x[MAX_D1D];
+         for (int dx = 0; dx < D1Dtest; ++dx)
+         {
+            sol_x[dx] = 0.0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double s = curl[qy][qx];
+            for (int dx = 0; dx < D1Dtest; ++dx)
+            {
+               sol_x[dx] += s * ((H1 == 1) ? Bt(dx,qx) : Bot(dx,qx));
+            }
+         }
+         for (int dy = 0; dy < D1Dtest; ++dy)
+         {
+            const double wy = (H1 == 1) ? Bt(dy,qy) : Bot(dy,qy);
+
+            for (int dx = 0; dx < D1Dtest; ++dx)
+            {
+               Y(dx,dy,e) += sol_x[dx] * wy;
+            }
+         }
+      }  // loop qy
+   }); // end of element loop
+}
+
+void PAHcurlL2ApplyTranspose2D(const int D1D,
+                               const int D1Dtest,
+                               const int Q1D,
+                               const int NE,
+                               const Array<double> &bo,
+                               const Array<double> &bot,
+                               const Array<double> &b,
+                               const Array<double> &gct,
+                               const Vector &pa_data,
+                               const Vector &x, // trial = H(curl)
+                               Vector &y)  // test = L2 or H1
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+   const int H1 = (D1Dtest == D1D);
+
+   MFEM_VERIFY(x.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), D1Dtest, D1Dtest, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D];
+
+      // Zero-order term in L2 or H1 test space
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            mass[qy][qx] = 0.0;
+         }
+      }
+
+      for (int dy = 0; dy < D1Dtest; ++dy)
+      {
+         double sol_x[MAX_Q1D];
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            sol_x[qy] = 0.0;
+         }
+         for (int dx = 0; dx < D1Dtest; ++dx)
+         {
+            const double s = X(dx,dy,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               sol_x[qx] += s * ((H1 == 1) ? B(qx,dx) : Bo(qx,dx));
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double d2q = (H1 == 1) ? B(qy,dy) : Bo(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qy][qx] += d2q * sol_x[qx];
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            mass[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double gradX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               gradX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradX[dx] += mass[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+} // namespace internal
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_hcurl_kernels.hpp b/fem/integ/bilininteg_hcurl_kernels.hpp
new file mode 100644
index 000000000..1beabd03d
--- /dev/null
+++ b/fem/integ/bilininteg_hcurl_kernels.hpp
@@ -0,0 +1,3038 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_HCURL_KERNELS_HPP
+#define MFEM_BILININTEG_HCURL_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/array.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+#include "../../linalg/vector.hpp"
+#include "../bilininteg.hpp"
+
+// Piola transformation in H(curl): w = dF^{-T} \hat{w}
+// curl w = (1 / det (dF)) dF \hat{curl} \hat{w}
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA H(curl) Mass Diagonal 2D kernel
+void PAHcurlMassAssembleDiagonal2D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag);
+
+// PA H(curl) Mass Diagonal 3D kernel
+void PAHcurlMassAssembleDiagonal3D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag);
+
+// Shared memory PA H(curl) Mass Diagonal 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHcurlMassAssembleDiagonal3D(const int d1d,
+                                              const int q1d,
+                                              const int NE,
+                                              const bool symmetric,
+                                              const Array<double> &bo,
+                                              const Array<double> &bc,
+                                              const Vector &pa_data,
+                                              Vector &diag)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MQ1D][MD1D];
+      MFEM_SHARED double sBc[MQ1D][MD1D];
+
+      double op3[3];
+      MFEM_SHARED double sop[3][MQ1D][MQ1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               op3[0] = op(qx,qy,qz,0,e);
+               op3[1] = op(qx,qy,qz,symmetric ? 3 : 4,e);
+               op3[2] = op(qx,qy,qz,symmetric ? 5 : 8,e);
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double dxyz = 0.0;
+
+         for (int qz=0; qz < Q1D; ++qz)
+         {
+            if (tidz == qz)
+            {
+               for (int i=0; i<3; ++i)
+               {
+                  sop[i][tidx][tidy] = op3[i];
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
+
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
+                           dxyz += sop[c][qx][qy] * wx * wx * wy * wy * wz * wz;
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+         }  // qz loop
+
+         MFEM_FOREACH_THREAD(dz,z,D1Dz)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1Dy)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1Dx)
+               {
+                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // c loop
+   }); // end of element loop
+}
+
+// PA H(curl) Mass Apply 2D kernel
+void PAHcurlMassApply2D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y);
+
+// PA H(curl) Mass Apply 3D kernel
+void PAHcurlMassApply3D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y);
+
+// Shared memory PA H(curl) Mass Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHcurlMassApply3D(const int d1d,
+                                   const int q1d,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Array<double> &bot,
+                                   const Array<double> &bct,
+                                   const Vector &pa_data,
+                                   const Vector &x,
+                                   Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   const int dataSize = symmetric ? 6 : 9;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, dataSize, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MQ1D][MD1D];
+      MFEM_SHARED double sBc[MQ1D][MD1D];
+
+      double op9[9];
+      MFEM_SHARED double sop[9*MQ1D*MQ1D];
+      MFEM_SHARED double mass[MQ1D][MQ1D][3];
+
+      MFEM_SHARED double sX[MD1D][MD1D][MD1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<dataSize; ++i)
+               {
+                  op9[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               for (int i=0; i<dataSize; ++i)
+               {
+                  sop[i + (dataSize*tidx) + (dataSize*Q1D*tidy)] = op9[i];
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              const double t = sX[dz][dy][dx];
+                              const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
+                              u += t * wx * wy * wz;
+                           }
+                        }
+                     }
+
+                     mass[qy][qx][c] = u;
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         MFEM_SYNC_THREAD;  // Sync mass[qy][qx][d] and sop
+
+         osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double dxyz = 0.0;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const int os = (dataSize*qx) + (dataSize*Q1D*qy);
+                           const int id1 = os + ((c == 0) ? 0 : ((c == 1) ? (symmetric ? 1 : 3) :
+                                                                 (symmetric ? 2 : 6))); // O11, O21, O31
+                           const int id2 = os + ((c == 0) ? 1 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                                                 (symmetric ? 4 : 7))); // O12, O22, O32
+                           const int id3 = os + ((c == 0) ? 2 : ((c == 1) ? (symmetric ? 4 : 5) :
+                                                                 (symmetric ? 5 : 8))); // O13, O23, O33
+
+                           const double m_c = (sop[id1] * mass[qy][qx][0]) + (sop[id2] * mass[qy][qx][1]) +
+                                              (sop[id3] * mass[qy][qx][2]);
+
+                           const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
+                           dxyz += m_c * wx * wy * wz;
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         } // c loop
+      } // qz
+   }); // end of element loop
+}
+
+// PA H(curl) curl-curl Assemble 2D kernel
+void PACurlCurlSetup2D(const int Q1D,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op);
+
+// PA H(curl) curl-curl Assemble 3D kernel
+void PACurlCurlSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op);
+
+// PA H(curl) curl-curl Diagonal 2D kernel
+void PACurlCurlAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const Array<double> &bo,
+                                  const Array<double> &gc,
+                                  const Vector &pa_data,
+                                  Vector &diag);
+
+// PA H(curl) curl-curl Diagonal 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PACurlCurlAssembleDiagonal3D(const int d1d,
+                                         const int q1d,
+                                         const bool symmetric,
+                                         const int NE,
+                                         const Array<double> &bo,
+                                         const Array<double> &bc,
+                                         const Array<double> &go,
+                                         const Array<double> &gc,
+                                         const Vector &pa_data,
+                                         Vector &diag)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Go = Reshape(go.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+   const int i11 = 0;
+   const int i12 = 1;
+   const int i13 = 2;
+   const int i21 = symmetric ? i12 : 3;
+   const int i22 = symmetric ? 3 : 4;
+   const int i23 = symmetric ? 4 : 5;
+   const int i31 = symmetric ? i13 : 6;
+   const int i32 = symmetric ? i23 : 7;
+   const int i33 = symmetric ? 5 : 8;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      // For each c, we will keep 9 arrays for derivatives multiplied by the 9 entries of the 3x3 matrix (dF^T C dF),
+      // which may be non-symmetric depending on a possibly non-symmetric matrix coefficient.
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double zt[MQ1D][MQ1D][MD1D][9][3];
+
+         // z contraction
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     for (int d=0; d<3; ++d)
+                     {
+                        zt[qx][qy][dz][i][d] = 0.0;
+                     }
+                  }
+
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = ((c == 2) ? Bo(qz,dz) : Bc(qz,dz));
+                     const double wDz = ((c == 2) ? Go(qz,dz) : Gc(qz,dz));
+
+                     for (int i=0; i<s; ++i)
+                     {
+                        zt[qx][qy][dz][i][0] += wz * wz * op(qx,qy,qz,i,e);
+                        zt[qx][qy][dz][i][1] += wDz * wz * op(qx,qy,qz,i,e);
+                        zt[qx][qy][dz][i][2] += wDz * wDz * op(qx,qy,qz,i,e);
+                     }
+                  }
+               }
+            }
+         }  // end of z contraction
+
+         double yt[MQ1D][MD1D][MD1D][9][3][3];
+
+         // y contraction
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     for (int d=0; d<3; ++d)
+                        for (int j=0; j<3; ++j)
+                        {
+                           yt[qx][dy][dz][i][d][j] = 0.0;
+                        }
+                  }
+
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = ((c == 1) ? Bo(qy,dy) : Bc(qy,dy));
+                     const double wDy = ((c == 1) ? Go(qy,dy) : Gc(qy,dy));
+
+                     for (int i=0; i<s; ++i)
+                     {
+                        for (int d=0; d<3; ++d)
+                        {
+                           yt[qx][dy][dz][i][d][0] += wy * wy * zt[qx][qy][dz][i][d];
+                           yt[qx][dy][dz][i][d][1] += wDy * wy * zt[qx][qy][dz][i][d];
+                           yt[qx][dy][dz][i][d][2] += wDy * wDy * zt[qx][qy][dz][i][d];
+                        }
+                     }
+                  }
+               }
+            }
+         }  // end of y contraction
+
+         // x contraction
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                     const double wDx = ((c == 0) ? Go(qx,dx) : Gc(qx,dx));
+
+                     // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+                     // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+                     // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                     /*
+                       const double O11 = op(q,0,e);
+                       const double O12 = op(q,1,e);
+                       const double O13 = op(q,2,e);
+                       const double O22 = op(q,3,e);
+                       const double O23 = op(q,4,e);
+                       const double O33 = op(q,5,e);
+                     */
+
+                     if (c == 0)
+                     {
+                        // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
+                        const double sumy = yt[qx][dy][dz][i22][2][0] - yt[qx][dy][dz][i23][1][1]
+                                            - yt[qx][dy][dz][i32][1][1] + yt[qx][dy][dz][i33][0][2];
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += sumy * wx * wx;
+                     }
+                     else if (c == 1)
+                     {
+                        // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
+                        const double d = (yt[qx][dy][dz][i11][2][0] * wx * wx)
+                                         - ((yt[qx][dy][dz][i13][1][0] + yt[qx][dy][dz][i31][1][0]) * wDx * wx)
+                                         + (yt[qx][dy][dz][i33][0][0] * wDx * wDx);
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
+                     }
+                     else
+                     {
+                        // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
+                        const double d = (yt[qx][dy][dz][i11][0][2] * wx * wx)
+                                         - ((yt[qx][dy][dz][i12][0][1] + yt[qx][dy][dz][i21][0][1]) * wDx * wx)
+                                         + (yt[qx][dy][dz][i22][0][0] * wDx * wDx);
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
+                     }
+                  }
+               }
+            }
+         }  // end of x contraction
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+// Shared memory PA H(curl) curl-curl Diagonal 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPACurlCurlAssembleDiagonal3D(const int d1d,
+                                             const int q1d,
+                                             const bool symmetric,
+                                             const int NE,
+                                             const Array<double> &bo,
+                                             const Array<double> &bc,
+                                             const Array<double> &go,
+                                             const Array<double> &gc,
+                                             const Vector &pa_data,
+                                             Vector &diag)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Go = Reshape(go.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+   const int i11 = 0;
+   const int i12 = 1;
+   const int i13 = 2;
+   const int i21 = symmetric ? i12 : 3;
+   const int i22 = symmetric ? 3 : 4;
+   const int i23 = symmetric ? 4 : 5;
+   const int i31 = symmetric ? i13 : 6;
+   const int i32 = symmetric ? i23 : 7;
+   const int i33 = symmetric ? 5 : 8;
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MQ1D][MD1D];
+      MFEM_SHARED double sBc[MQ1D][MD1D];
+      MFEM_SHARED double sGo[MQ1D][MD1D];
+      MFEM_SHARED double sGc[MQ1D][MD1D];
+
+      double ope[9];
+      MFEM_SHARED double sop[9][MQ1D][MQ1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  ope[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               sGc[q][d] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+                  sGo[q][d] = Go(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double dxyz = 0.0;
+
+         for (int qz=0; qz < Q1D; ++qz)
+         {
+            if (tidz == qz)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  sop[i][tidx][tidy] = ope[i];
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
+               const double wDz = ((c == 2) ? sGo[qz][dz] : sGc[qz][dz]);
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
+                        const double wDy = ((c == 1) ? sGo[qy][dy] : sGc[qy][dy]);
+
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
+                           const double wDx = ((c == 0) ? sGo[qx][dx] : sGc[qx][dx]);
+
+                           if (c == 0)
+                           {
+                              // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
+
+                              // (u_0)_{x_2} O22 (u_0)_{x_2}
+                              dxyz += sop[i22][qx][qy] * wx * wx * wy * wy * wDz * wDz;
+
+                              // -(u_0)_{x_2} O23 (u_0)_{x_1} - (u_0)_{x_1} O32 (u_0)_{x_2}
+                              dxyz += -(sop[i23][qx][qy] + sop[i32][qx][qy]) * wx * wx * wDy * wy * wDz * wz;
+
+                              // (u_0)_{x_1} O33 (u_0)_{x_1}
+                              dxyz += sop[i33][qx][qy] * wx * wx * wDy * wDy * wz * wz;
+                           }
+                           else if (c == 1)
+                           {
+                              // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
+
+                              // (u_1)_{x_2} O11 (u_1)_{x_2}
+                              dxyz += sop[i11][qx][qy] * wx * wx * wy * wy * wDz * wDz;
+
+                              // -(u_1)_{x_2} O13 (u_1)_{x_0} - (u_1)_{x_0} O31 (u_1)_{x_2}
+                              dxyz += -(sop[i13][qx][qy] + sop[i31][qx][qy]) * wDx * wx * wy * wy * wDz * wz;
+
+                              // (u_1)_{x_0} O33 (u_1)_{x_0})
+                              dxyz += sop[i33][qx][qy] * wDx * wDx * wy * wy * wz * wz;
+                           }
+                           else
+                           {
+                              // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
+
+                              // (u_2)_{x_1} O11 (u_2)_{x_1}
+                              dxyz += sop[i11][qx][qy] * wx * wx * wDy * wDy * wz * wz;
+
+                              // -(u_2)_{x_1} O12 (u_2)_{x_0} - (u_2)_{x_0} O21 (u_2)_{x_1}
+                              dxyz += -(sop[i12][qx][qy] + sop[i21][qx][qy]) * wDx * wx * wDy * wy * wz * wz;
+
+                              // (u_2)_{x_0} O22 (u_2)_{x_0}
+                              dxyz += sop[i22][qx][qy] * wDx * wDx * wy * wy * wz * wz;
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+         }  // qz loop
+
+         MFEM_FOREACH_THREAD(dz,z,D1Dz)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1Dy)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1Dx)
+               {
+                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // c loop
+   }); // end of element loop
+}
+
+// PA H(curl) curl-curl Apply 2D kernel
+void PACurlCurlApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &bo,
+                       const Array<double> &bot,
+                       const Array<double> &gc,
+                       const Array<double> &gct,
+                       const Vector &pa_data,
+                       const Vector &x,
+                       Vector &y);
+
+// PA H(curl) curl-curl Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PACurlCurlApply3D(const int d1d,
+                              const int q1d,
+                              const bool symmetric,
+                              const int NE,
+                              const Array<double> &bo,
+                              const Array<double> &bc,
+                              const Array<double> &bot,
+                              const Array<double> &bct,
+                              const Array<double> &gc,
+                              const Array<double> &gct,
+                              const Vector &pa_data,
+                              const Vector &x,
+                              Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk),
+      // we get:
+      // (\nabla\times u) \cdot (\nabla\times v)
+      //     = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      double curl[MQ1D][MQ1D][MQ1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MQ1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MQ1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MQ1D][MQ1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MQ1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
+               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
+               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
+               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
+               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
+               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
+
+               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
+                                 (O13 * curl[qz][qy][qx][2]);
+               const double c2 = (O21 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
+                                 (O23 * curl[qz][qy][qx][2]);
+               const double c3 = (O31 * curl[qz][qy][qx][0]) + (O32 * curl[qz][qy][qx][1]) +
+                                 (O33 * curl[qz][qy][qx][2]);
+
+               curl[qz][qy][qx][0] = c1;
+               curl[qz][qy][qx][1] = c2;
+               curl[qz][qy][qx][2] = c3;
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MD1D][MD1D];
+            double gradXY21[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MD1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * curl[qz][qy][qx][1];
+                     massX[dx][1] += wx * curl[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MD1D][MD1D];
+            double gradXY20[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MD1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * curl[qz][qy][qx][2];
+                     massY[dy][1] += wy * curl[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MD1D][MD1D];
+            double gradYZ10[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MD1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * curl[qz][qy][qx][0];
+                     massZ[dz][1] += wz * curl[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   }); // end of element loop
+}
+
+// Shared memory PA H(curl) curl-curl Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPACurlCurlApply3D(const int d1d,
+                                  const int q1d,
+                                  const bool symmetric,
+                                  const int NE,
+                                  const Array<double> &bo,
+                                  const Array<double> &bc,
+                                  const Array<double> &bot,
+                                  const Array<double> &bct,
+                                  const Array<double> &gc,
+                                  const Array<double> &gct,
+                                  const Vector &pa_data,
+                                  const Vector &x,
+                                  Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MD1D][MQ1D];
+      MFEM_SHARED double sBc[MD1D][MQ1D];
+      MFEM_SHARED double sGc[MD1D][MQ1D];
+
+      double ope[9];
+      MFEM_SHARED double sop[9][MQ1D][MQ1D];
+      MFEM_SHARED double curl[MQ1D][MQ1D][3];
+
+      MFEM_SHARED double sX[MD1D][MD1D][MD1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  ope[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     curl[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     sop[i][tidx][tidy] = ope[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+                     double v = 0.0;
+
+                     // We treat x, y, z components separately for optimization specific to each.
+                     if (c == 0) // x component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
+                                 u += wx * wDy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][1] += v; // (u_0)_{x_2}
+                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
+                     }
+                     else if (c == 1)  // y component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBo[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
+                        curl[qy][qx][2] += u; // (u_1)_{x_0}
+                     }
+                     else // z component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBo[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wDy * wz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] += v; // (u_2)_{x_1}
+                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
+                     }
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wcDz = sGc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wcDy = sGc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        const double O12 = sop[1][qx][qy];
+                        const double O13 = sop[2][qx][qy];
+                        const double O21 = symmetric ? O12 : sop[3][qx][qy];
+                        const double O22 = symmetric ? sop[3][qx][qy] : sop[4][qx][qy];
+                        const double O23 = symmetric ? sop[4][qx][qy] : sop[5][qx][qy];
+                        const double O31 = symmetric ? O13 : sop[6][qx][qy];
+                        const double O32 = symmetric ? O23 : sop[7][qx][qy];
+                        const double O33 = symmetric ? sop[5][qx][qy] : sop[8][qx][qy];
+
+                        const double c1 = (O11 * curl[qy][qx][0]) + (O12 * curl[qy][qx][1]) +
+                                          (O13 * curl[qy][qx][2]);
+                        const double c2 = (O21 * curl[qy][qx][0]) + (O22 * curl[qy][qx][1]) +
+                                          (O23 * curl[qy][qx][2]);
+                        const double c3 = (O31 * curl[qy][qx][0]) + (O32 * curl[qy][qx][1]) +
+                                          (O33 * curl[qy][qx][2]);
+
+                        const double wcx = sBc[dx][qx];
+                        const double wDx = sGc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                           // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
+                        }
+
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                        // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
+
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                        // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+// PA H(curl)-L2 Assemble 2D kernel
+void PAHcurlL2Setup2D(const int Q1D,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op);
+
+// PA H(curl)-L2 Assemble 3D kernel
+void PAHcurlL2Setup3D(const int NQ,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op);
+
+// PA H(curl)-L2 Apply 2D kernel
+void PAHcurlL2Apply2D(const int D1D,
+                      const int D1Dtest,
+                      const int Q1D,
+                      const int NE,
+                      const Array<double> &bo,
+                      const Array<double> &bot,
+                      const Array<double> &bt,
+                      const Array<double> &gc,
+                      const Vector &pa_data,
+                      const Vector &x,
+                      Vector &y);
+
+// PA H(curl)-L2 Apply Transpose 2D kernel
+void PAHcurlL2ApplyTranspose2D(const int D1D,
+                               const int D1Dtest,
+                               const int Q1D,
+                               const int NE,
+                               const Array<double> &bo,
+                               const Array<double> &bot,
+                               const Array<double> &b,
+                               const Array<double> &gct,
+                               const Vector &pa_data,
+                               const Vector &x,
+                               Vector &y);
+
+// PA H(curl)-L2 Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAHcurlL2Apply3D(const int d1d,
+                             const int q1d,
+                             const int coeffDim,
+                             const int NE,
+                             const Array<double> &bo,
+                             const Array<double> &bc,
+                             const Array<double> &bot,
+                             const Array<double> &bct,
+                             const Array<double> &gc,
+                             const Vector &pa_data,
+                             const Vector &x,
+                             Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using u = dF^{-T} \hat{u} and (\nabla\times u) F =
+      // 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get:
+      // (\nabla\times u) \cdot v
+      //    = 1/det(dF) \hat{\nabla}\times\hat{u}^T dF^T dF^{-T} \hat{v}
+      //    = 1/det(dF) \hat{\nabla}\times\hat{u}^T \hat{v}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      double curl[MQ1D][MQ1D][MQ1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MQ1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MQ1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MQ1D][MQ1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MQ1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               if (coeffDim == 1)
+               {
+                  for (int c = 0; c < VDIM; ++c)
+                  {
+                     curl[qz][qy][qx][c] *= O11;
+                  }
+               }
+               else
+               {
+                  const double O21 = op(1,qx,qy,qz,e);
+                  const double O31 = op(2,qx,qy,qz,e);
+                  const double O12 = op(3,qx,qy,qz,e);
+                  const double O22 = op(4,qx,qy,qz,e);
+                  const double O32 = op(5,qx,qy,qz,e);
+                  const double O13 = op(6,qx,qy,qz,e);
+                  const double O23 = op(7,qx,qy,qz,e);
+                  const double O33 = op(8,qx,qy,qz,e);
+                  const double curlX = curl[qz][qy][qx][0];
+                  const double curlY = curl[qz][qy][qx][1];
+                  const double curlZ = curl[qz][qy][qx][2];
+                  curl[qz][qy][qx][0] = (O11*curlX)+(O12*curlY)+(O13*curlZ);
+                  curl[qz][qy][qx][1] = (O21*curlX)+(O22*curlY)+(O23*curlZ);
+                  curl[qz][qy][qx][2] = (O31*curlX)+(O32*curlY)+(O33*curlZ);
+               }
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MD1D][MD1D];
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MD1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0.0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += curl[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Shared memory PA H(curl)-L2 Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHcurlL2Apply3D(const int d1d,
+                                 const int q1d,
+                                 const int coeffDim,
+                                 const int NE,
+                                 const Array<double> &bo,
+                                 const Array<double> &bc,
+                                 const Array<double> &gc,
+                                 const Vector &pa_data,
+                                 const Vector &x,
+                                 Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int maxCoeffDim = 9;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MD1D][MQ1D];
+      MFEM_SHARED double sBc[MD1D][MQ1D];
+      MFEM_SHARED double sGc[MD1D][MQ1D];
+
+      double opc[maxCoeffDim];
+      MFEM_SHARED double sop[maxCoeffDim][MQ1D][MQ1D];
+      MFEM_SHARED double curl[MQ1D][MQ1D][3];
+
+      MFEM_SHARED double sX[MD1D][MD1D][MD1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<coeffDim; ++i)
+               {
+                  opc[i] = op(i,qx,qy,qz,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     curl[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<coeffDim; ++i)
+                  {
+                     sop[i][tidx][tidy] = opc[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+                     double v = 0.0;
+
+                     // We treat x, y, z components separately for optimization specific to each.
+                     if (c == 0) // x component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
+                                 u += wx * wDy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][1] += v; // (u_0)_{x_2}
+                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
+                     }
+                     else if (c == 1)  // y component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBo[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
+                        curl[qy][qx][2] += u; // (u_1)_{x_0}
+                     }
+                     else // z component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBo[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wDy * wz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] += v; // (u_2)_{x_1}
+                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
+                     }
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        double c1, c2, c3;
+                        if (coeffDim == 1)
+                        {
+                           c1 = O11 * curl[qy][qx][0];
+                           c2 = O11 * curl[qy][qx][1];
+                           c3 = O11 * curl[qy][qx][2];
+                        }
+                        else
+                        {
+                           const double O21 = sop[1][qx][qy];
+                           const double O31 = sop[2][qx][qy];
+                           const double O12 = sop[3][qx][qy];
+                           const double O22 = sop[4][qx][qy];
+                           const double O32 = sop[5][qx][qy];
+                           const double O13 = sop[6][qx][qy];
+                           const double O23 = sop[7][qx][qy];
+                           const double O33 = sop[8][qx][qy];
+                           c1 = (O11*curl[qy][qx][0])+(O12*curl[qy][qx][1])+(O13*curl[qy][qx][2]);
+                           c2 = (O21*curl[qy][qx][0])+(O22*curl[qy][qx][1])+(O23*curl[qy][qx][2]);
+                           c3 = (O31*curl[qy][qx][0])+(O32*curl[qy][qx][1])+(O33*curl[qy][qx][2]);
+                        }
+
+                        const double wcx = sBc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += c1 * wx * wcy * wcz;
+                        }
+
+                        dxyz2 += c2 * wcx * wy * wcz;
+                        dxyz3 += c3 * wcx * wcy * wz;
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+// PA H(curl)-L2 Apply Transpose 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAHcurlL2ApplyTranspose3D(const int d1d,
+                                      const int q1d,
+                                      const int coeffDim,
+                                      const int NE,
+                                      const Array<double> &bo,
+                                      const Array<double> &bc,
+                                      const Array<double> &bot,
+                                      const Array<double> &bct,
+                                      const Array<double> &gct,
+                                      const Vector &pa_data,
+                                      const Vector &x,
+                                      Vector &y)
+{
+   // See PAHcurlL2Apply3D for comments.
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      double mass[MQ1D][MQ1D][MQ1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MQ1D][MQ1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MQ1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               if (coeffDim == 1)
+               {
+                  for (int c = 0; c < VDIM; ++c)
+                  {
+                     mass[qz][qy][qx][c] *= O11;
+                  }
+               }
+               else
+               {
+                  const double O12 = op(1,qx,qy,qz,e);
+                  const double O13 = op(2,qx,qy,qz,e);
+                  const double O21 = op(3,qx,qy,qz,e);
+                  const double O22 = op(4,qx,qy,qz,e);
+                  const double O23 = op(5,qx,qy,qz,e);
+                  const double O31 = op(6,qx,qy,qz,e);
+                  const double O32 = op(7,qx,qy,qz,e);
+                  const double O33 = op(8,qx,qy,qz,e);
+                  const double massX = mass[qz][qy][qx][0];
+                  const double massY = mass[qz][qy][qx][1];
+                  const double massZ = mass[qz][qy][qx][2];
+                  mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+                  mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+                  mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+               }
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MD1D][MD1D];
+            double gradXY21[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MD1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * mass[qz][qy][qx][1];
+                     massX[dx][1] += wx * mass[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MD1D][MD1D];
+            double gradXY20[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MD1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * mass[qz][qy][qx][2];
+                     massY[dy][1] += wy * mass[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MD1D][MD1D];
+            double gradYZ10[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MD1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
+                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   });
+}
+
+// PA H(curl)-L2 Apply Transpose 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHcurlL2ApplyTranspose3D(const int d1d,
+                                          const int q1d,
+                                          const int coeffDim,
+                                          const int NE,
+                                          const Array<double> &bo,
+                                          const Array<double> &bc,
+                                          const Array<double> &gc,
+                                          const Vector &pa_data,
+                                          const Vector &x,
+                                          Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int maxCoeffDim = 9;
+      constexpr int MD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      MFEM_SHARED double sBo[MD1D][MQ1D];
+      MFEM_SHARED double sBc[MD1D][MQ1D];
+      MFEM_SHARED double sGc[MD1D][MQ1D];
+
+      double opc[maxCoeffDim];
+      MFEM_SHARED double sop[maxCoeffDim][MQ1D][MQ1D];
+      MFEM_SHARED double mass[MQ1D][MQ1D][3];
+
+      MFEM_SHARED double sX[MD1D][MD1D][MD1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<coeffDim; ++i)
+               {
+                  opc[i] = op(i,qx,qy,qz,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     mass[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<coeffDim; ++i)
+                  {
+                     sop[i][tidx][tidy] = opc[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? sBo[dz][qz] : sBc[dz][qz];
+
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? sBo[dy][qy] : sBc[dy][qy];
+
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              const double wx = sX[dz][dy][dx] * ((c == 0) ? sBo[dx][qx] : sBc[dx][qx]);
+                              u += wx * wy * wz;
+                           }
+                        }
+                     }
+
+                     mass[qy][qx][c] += u;
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wcDz = sGc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wcDy = sGc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        double c1, c2, c3;
+                        if (coeffDim == 1)
+                        {
+                           c1 = O11 * mass[qy][qx][0];
+                           c2 = O11 * mass[qy][qx][1];
+                           c3 = O11 * mass[qy][qx][2];
+                        }
+                        else
+                        {
+                           const double O12 = sop[1][qx][qy];
+                           const double O13 = sop[2][qx][qy];
+                           const double O21 = sop[3][qx][qy];
+                           const double O22 = sop[4][qx][qy];
+                           const double O23 = sop[5][qx][qy];
+                           const double O31 = sop[6][qx][qy];
+                           const double O32 = sop[7][qx][qy];
+                           const double O33 = sop[8][qx][qy];
+
+                           c1 = (O11*mass[qy][qx][0])+(O12*mass[qy][qx][1])+(O13*mass[qy][qx][2]);
+                           c2 = (O21*mass[qy][qx][0])+(O22*mass[qy][qx][1])+(O23*mass[qy][qx][2]);
+                           c3 = (O31*mass[qy][qx][0])+(O32*mass[qy][qx][1])+(O33*mass[qy][qx][2]);
+                        }
+
+                        const double wcx = sBc[dx][qx];
+                        const double wDx = sGc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
+                        }
+
+                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
+
+                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/integ/bilininteg_hcurlhdiv_kernels.cpp b/fem/integ/bilininteg_hcurlhdiv_kernels.cpp
new file mode 100644
index 000000000..e8115e659
--- /dev/null
+++ b/fem/integ/bilininteg_hcurlhdiv_kernels.cpp
@@ -0,0 +1,578 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "bilininteg_hcurlhdiv_kernels.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA H(curl) x H(div) mass assemble 2D kernel, with factor
+// dF^{-1} C dF for a vector or matrix coefficient C.
+// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
+void PAHcurlHdivMassSetup2D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op)
+{
+   const bool symmetric = (coeffDim != 4);
+   auto W = Reshape(w_.Read(), Q1D, Q1D);
+   auto J = Reshape(j.Read(), Q1D, Q1D, 2, 2, NE);
+   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, NE);
+   auto y = Reshape(op.Write(), 4, Q1D, Q1D, NE);
+
+   const int i11 = 0;
+   const int i12 = transpose ? 2 : 1;
+   const int i21 = transpose ? 1 : 2;
+   const int i22 = 3;
+
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            const double J11 = J(qx,qy,0,0,e);
+            const double J21 = J(qx,qy,1,0,e);
+            const double J12 = J(qx,qy,0,1,e);
+            const double J22 = J(qx,qy,1,1,e);
+            const double w_detJ = W(qx,qy) / ((J11*J22) - (J21*J12));
+
+            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient version
+            {
+               // First compute entries of R = MJ
+               const double M11 = coeff(i11,qx,qy,e);
+               const double M12 = (!symmetric) ? coeff(i12,qx,qy,e) : coeff(1,qx,qy,e);
+               const double M21 = (!symmetric) ? coeff(i21,qx,qy,e) : M12;
+               const double M22 = (!symmetric) ? coeff(i22,qx,qy,e) : coeff(2,qx,qy,e);
+
+               // J^{-1} M^T
+               const double R11 = ( J22*M11 - J12*M12); // 1,1
+               const double R12 = ( J22*M21 - J12*M22); // 1,2
+               const double R21 = (-J21*M11 + J11*M12); // 2,1
+               const double R22 = (-J21*M21 + J11*M22); // 2,2
+
+               // (RJ)^T
+               y(i11,qx,qy,e) = w_detJ * (R11*J11 + R12*J21); // 1,1
+               y(i21,qx,qy,e) = w_detJ * (R11*J12 + R12*J22); // 1,2 (transpose)
+               y(i12,qx,qy,e) = w_detJ * (R21*J11 + R22*J21); // 2,1 (transpose)
+               y(i22,qx,qy,e) = w_detJ * (R21*J12 + R22*J22); // 2,2
+            }
+            else if (coeffDim == 2) // Vector coefficient version
+            {
+               const double D1 = coeff(0,qx,qy,e);
+               const double D2 = coeff(1,qx,qy,e);
+               const double R11 = D1*J11;
+               const double R12 = D1*J12;
+               const double R21 = D2*J21;
+               const double R22 = D2*J22;
+               y(i11,qx,qy,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
+               y(i21,qx,qy,e) = w_detJ * ( J22*R12 - J12*R22); // 1,2 (transpose)
+               y(i12,qx,qy,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1 (transpose)
+               y(i22,qx,qy,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
+            }
+         }
+      }
+   });
+}
+
+// PA H(curl) x H(div) mass assemble 3D kernel, with factor
+// dF^{-1} C dF for a vector or matrix coefficient C.
+// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
+void PAHcurlHdivMassSetup3D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op)
+{
+   const bool symmetric = (coeffDim != 9);
+   auto W = Reshape(w_.Read(), Q1D, Q1D, Q1D);
+   auto J = Reshape(j.Read(), Q1D, Q1D, Q1D, 3, 3, NE);
+   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto y = Reshape(op.Write(), 9, Q1D, Q1D, Q1D, NE);
+
+   const int i11 = 0;
+   const int i12 = transpose ? 3 : 1;
+   const int i13 = transpose ? 6 : 2;
+   const int i21 = transpose ? 1 : 3;
+   const int i22 = 4;
+   const int i23 = transpose ? 7 : 5;
+   const int i31 = transpose ? 2 : 6;
+   const int i32 = transpose ? 5 : 7;
+   const int i33 = 8;
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               const double J11 = J(qx,qy,qz,0,0,e);
+               const double J21 = J(qx,qy,qz,1,0,e);
+               const double J31 = J(qx,qy,qz,2,0,e);
+               const double J12 = J(qx,qy,qz,0,1,e);
+               const double J22 = J(qx,qy,qz,1,1,e);
+               const double J32 = J(qx,qy,qz,2,1,e);
+               const double J13 = J(qx,qy,qz,0,2,e);
+               const double J23 = J(qx,qy,qz,1,2,e);
+               const double J33 = J(qx,qy,qz,2,2,e);
+               const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                                   J21 * (J12 * J33 - J32 * J13) +
+                                   J31 * (J12 * J23 - J22 * J13);
+               const double w_detJ = W(qx,qy,qz) / detJ;
+               // adj(J)
+               const double A11 = (J22 * J33) - (J23 * J32);
+               const double A12 = (J32 * J13) - (J12 * J33);
+               const double A13 = (J12 * J23) - (J22 * J13);
+               const double A21 = (J31 * J23) - (J21 * J33);
+               const double A22 = (J11 * J33) - (J13 * J31);
+               const double A23 = (J21 * J13) - (J11 * J23);
+               const double A31 = (J21 * J32) - (J31 * J22);
+               const double A32 = (J31 * J12) - (J11 * J32);
+               const double A33 = (J11 * J22) - (J12 * J21);
+
+               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
+               {
+                  // First compute entries of R = M^T J
+                  const double M11 = (!symmetric) ? coeff(i11,qx,qy,qz,e) : coeff(0,qx,qy,qz,e);
+                  const double M12 = (!symmetric) ? coeff(i12,qx,qy,qz,e) : coeff(1,qx,qy,qz,e);
+                  const double M13 = (!symmetric) ? coeff(i13,qx,qy,qz,e) : coeff(2,qx,qy,qz,e);
+                  const double M21 = (!symmetric) ? coeff(i21,qx,qy,qz,e) : M12;
+                  const double M22 = (!symmetric) ? coeff(i22,qx,qy,qz,e) : coeff(3,qx,qy,qz,e);
+                  const double M23 = (!symmetric) ? coeff(i23,qx,qy,qz,e) : coeff(4,qx,qy,qz,e);
+                  const double M31 = (!symmetric) ? coeff(i31,qx,qy,qz,e) : M13;
+                  const double M32 = (!symmetric) ? coeff(i32,qx,qy,qz,e) : M23;
+                  const double M33 = (!symmetric) ? coeff(i33,qx,qy,qz,e) : coeff(5,qx,qy,qz,e);
+
+                  const double R11 = M11*J11 + M21*J21 + M31*J31;
+                  const double R12 = M11*J12 + M21*J22 + M31*J32;
+                  const double R13 = M11*J13 + M21*J23 + M31*J33;
+                  const double R21 = M12*J11 + M22*J21 + M32*J31;
+                  const double R22 = M12*J12 + M22*J22 + M32*J32;
+                  const double R23 = M12*J13 + M22*J23 + M32*J33;
+                  const double R31 = M13*J11 + M23*J21 + M33*J31;
+                  const double R32 = M13*J12 + M23*J22 + M33*J32;
+                  const double R33 = M13*J13 + M23*J23 + M33*J33;
+
+                  // y = (J^{-1} M^T J)^T
+                  y(i11,qx,qy,qz,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
+                  y(i21,qx,qy,qz,e) = w_detJ * (A11*R12 + A12*R22 + A13*R32); // 1,2
+                  y(i31,qx,qy,qz,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
+                  y(i12,qx,qy,qz,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
+                  y(i22,qx,qy,qz,e) = w_detJ * (A21*R12 + A22*R22 + A23*R32); // 2,2
+                  y(i32,qx,qy,qz,e) = w_detJ * (A21*R13 + A22*R23 + A23*R33); // 2,3
+                  y(i13,qx,qy,qz,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
+                  y(i23,qx,qy,qz,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
+                  y(i33,qx,qy,qz,e) = w_detJ * (A31*R13 + A32*R23 + A33*R33); // 3,3
+               }
+               else if (coeffDim == 3)  // Vector coefficient version
+               {
+                  const double D1 = coeff(0,qx,qy,qz,e);
+                  const double D2 = coeff(1,qx,qy,qz,e);
+                  const double D3 = coeff(2,qx,qy,qz,e);
+                  // detJ J^{-1} DJ = adj(J) DJ
+                  // transpose
+                  y(i11,qx,qy,qz,e) = w_detJ * (D1*A11*J11 + D2*A12*J21 + D3*A13*J31); // 1,1
+                  y(i21,qx,qy,qz,e) = w_detJ * (D1*A11*J12 + D2*A12*J22 + D3*A13*J32); // 1,2
+                  y(i31,qx,qy,qz,e) = w_detJ * (D1*A11*J13 + D2*A12*J23 + D3*A13*J33); // 1,3
+                  y(i12,qx,qy,qz,e) = w_detJ * (D1*A21*J11 + D2*A22*J21 + D3*A23*J31); // 2,1
+                  y(i22,qx,qy,qz,e) = w_detJ * (D1*A21*J12 + D2*A22*J22 + D3*A23*J32); // 2,2
+                  y(i32,qx,qy,qz,e) = w_detJ * (D1*A21*J13 + D2*A22*J23 + D3*A23*J33); // 2,3
+                  y(i13,qx,qy,qz,e) = w_detJ * (D1*A31*J11 + D2*A32*J21 + D3*A33*J31); // 3,1
+                  y(i23,qx,qy,qz,e) = w_detJ * (D1*A31*J12 + D2*A32*J22 + D3*A33*J32); // 3,2
+                  y(i33,qx,qy,qz,e) = w_detJ * (D1*A31*J13 + D2*A32*J23 + D3*A33*J33); // 3,3
+               }
+            }
+         }
+      }
+   });
+}
+
+// Mass operator for H(curl) and H(div) functions, using Piola transformations
+// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
+void PAHcurlHdivMassApply2D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 2;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
+   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 4, Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2*(D1Dtest-1)*D1Dtest, NE);
+
+   const int i12 = transpose ? 2 : 1;
+   const int i21 = transpose ? 1 : 2;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y trial components
+      {
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
+                          ((c == 1) ? D1D : D1D - 1);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
+                          ((c == 0) ? D1D : D1D - 1);
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = x(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
+                                    ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
+                                 ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(0,qx,qy,e);
+            const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,e);
+            const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,e);
+            const double O22 = scalarCoeff ? O11 : op(3,qx,qy,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O21*massX)+(O22*massY);
+         }
+      }
+
+      osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y test components
+      {
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
+                          ((c == 1) ? D1Dtest - 1 : D1Dtest);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
+                          ((c == 0) ? D1Dtest - 1 : D1Dtest);
+
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            double massX[HDIV_MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * (trialHcurl ?
+                                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
+                                                  ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
+                                 ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+// Mass operator for H(curl) and H(div) functions, using Piola transformations
+// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
+void PAHcurlHdivMassApply3D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
+   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 9, Q1D, Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), 3*(D1D-1)*D1D*(trialHcurl ? D1D : D1D-1), NE);
+   auto y = Reshape(y_.ReadWrite(), 3*(D1Dtest-1)*D1Dtest*
+                    (trialHcurl ? D1Dtest-1 : D1Dtest), NE);
+
+   const int i12 = transpose ? 3 : 1;
+   const int i13 = transpose ? 6 : 2;
+   const int i21 = transpose ? 1 : 3;
+   const int i23 = transpose ? 7 : 5;
+   const int i31 = transpose ? 2 : 6;
+   const int i32 = transpose ? 5 : 7;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z trial components
+      {
+         const int D1Dz = trialHcurl ? ((c == 2) ? D1D - 1 : D1D) :
+                          ((c == 2) ? D1D : D1D - 1);
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
+                          ((c == 1) ? D1D : D1D - 1);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
+                          ((c == 0) ? D1D : D1D - 1);
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = x(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
+                                       ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
+                                    ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = trialHcurl ? ((c == 2) ? Bo(qz,dz) : Bc(qz,dz)) :
+                                 ((c == 2) ? Bc(qz,dz) : Bo(qz,dz));
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,qz,e);
+               const double O13 = scalarCoeff ? 0.0 : op(i13,qx,qy,qz,e);
+               const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,qz,e);
+               const double O22 = scalarCoeff ? O11 : op(4,qx,qy,qz,e);
+               const double O23 = scalarCoeff ? 0.0 : op(i23,qx,qy,qz,e);
+               const double O31 = scalarCoeff ? 0.0 : op(i31,qx,qy,qz,e);
+               const double O32 = scalarCoeff ? 0.0 : op(i32,qx,qy,qz,e);
+               const double O33 = scalarCoeff ? O11 : op(8,qx,qy,qz,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
+
+         osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z test components
+         {
+            const int D1Dz = trialHcurl ? ((c == 2) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 2) ? D1Dtest - 1 : D1Dtest);
+            const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 1) ? D1Dtest - 1 : D1Dtest);
+            const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 0) ? D1Dtest - 1 : D1Dtest);
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[HDIV_MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0.0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * (trialHcurl ?
+                                                         ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
+                                                         ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
+                                    ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = trialHcurl ? ((c == 2) ? Bct(dz,qz) : Bot(dz,qz)) :
+                                 ((c == 2) ? Bot(dz,qz) : Bct(dz,qz));
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
+                        massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+} // namespace internal
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_hcurlhdiv_kernels.hpp b/fem/integ/bilininteg_hcurlhdiv_kernels.hpp
new file mode 100644
index 000000000..90e88b4ee
--- /dev/null
+++ b/fem/integ/bilininteg_hcurlhdiv_kernels.hpp
@@ -0,0 +1,818 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_HCURLHDIV_KERNELS_HPP
+#define MFEM_BILININTEG_HCURLHDIV_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/array.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+#include "../../linalg/vector.hpp"
+#include "../bilininteg.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA H(curl)-H(div) Mass Apply 2D kernel
+void PAHcurlHdivMassSetup2D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op);
+
+// PA H(curl)-H(div) Mass Assemble 3D kernel
+void PAHcurlHdivMassSetup3D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op);
+
+// PA H(curl)-H(div) Mass Apply 2D kernel
+void PAHcurlHdivMassApply2D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_);
+
+// PA H(curl)-H(div) Mass Apply 3D kernel
+void PAHcurlHdivMassApply3D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_);
+
+// PA H(curl)-H(div) Curl Apply 3D kernel
+template<int T_D1D = 0, int T_D1D_TEST = 0, int T_Q1D = 0>
+inline void PAHcurlHdivApply3D(const int d1d,
+                               const int d1dtest,
+                               const int q1d,
+                               const int NE,
+                               const Array<double> &bo,
+                               const Array<double> &bc,
+                               const Array<double> &bot,
+                               const Array<double> &bct,
+                               const Array<double> &gc,
+                               const Vector &pa_data,
+                               const Vector &x,
+                               Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_D1D_TEST ||
+               d1dtest <= HCURL_MAX_D1D, "Error: d1dtest > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int D1Dtest = T_D1D_TEST ? T_D1D_TEST : d1dtest;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1Dtest-1)*(D1Dtest-1)*D1Dtest, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
+      // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
+      // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D :
+                           HCURL_MAX_D1D;  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int D1Dtest = T_D1D_TEST ? T_D1D_TEST : d1dtest;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      double curl[MQ1D][MQ1D][MQ1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MQ1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MQ1D][MQ1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MQ1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MQ1D][MQ1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MQ1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+
+               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
+                                 (O13 * curl[qz][qy][qx][2]);
+               const double c2 = (O12 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
+                                 (O23 * curl[qz][qy][qx][2]);
+               const double c3 = (O13 * curl[qz][qy][qx][0]) + (O23 * curl[qz][qy][qx][1]) +
+                                 (O33 * curl[qz][qy][qx][2]);
+
+               curl[qz][qy][qx][0] = c1;
+               curl[qz][qy][qx][1] = c2;
+               curl[qz][qy][qx][2] = c3;
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MD1D][MD1D];
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1Dtest : D1Dtest - 1;
+            const int D1Dy = (c == 1) ? D1Dtest : D1Dtest - 1;
+            const int D1Dx = (c == 0) ? D1Dtest : D1Dtest - 1;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MD1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += curl[qz][qy][qx][c] *
+                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bct(dy,qy) : Bot(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bct(dz,qz) : Bot(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
+                        massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// PA H(curl)-H(div) Curl Apply Transpose 3D kernel
+template<int T_D1D = 0, int T_D1D_TEST = 0, int T_Q1D = 0>
+inline void PAHcurlHdivApplyTranspose3D(const int d1d,
+                                        const int d1dtest,
+                                        const int q1d,
+                                        const int NE,
+                                        const Array<double> &bo,
+                                        const Array<double> &bc,
+                                        const Array<double> &bot,
+                                        const Array<double> &bct,
+                                        const Array<double> &gct,
+                                        const Vector &pa_data,
+                                        const Vector &x,
+                                        Vector &y)
+{
+   MFEM_VERIFY(T_D1D || d1d <= HCURL_MAX_D1D, "Error: d1d > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_D1D_TEST ||
+               d1dtest <= HCURL_MAX_D1D, "Error: d1dtest > HCURL_MAX_D1D");
+   MFEM_VERIFY(T_Q1D || q1d <= HCURL_MAX_Q1D, "Error: q1d > HCURL_MAX_Q1D");
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int D1Dtest = T_D1D_TEST ? T_D1D_TEST : d1dtest;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1Dtest-1)*(D1Dtest-1)*D1Dtest, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
+      // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
+      // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+      constexpr int MD1D = T_D1D ? T_D1D :
+                           HCURL_MAX_D1D;  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
+      constexpr int MQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int D1Dtest = T_D1D_TEST ? T_D1D_TEST : d1dtest;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      double mass[MQ1D][MQ1D][MQ1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1Dtest : D1Dtest - 1;
+         const int D1Dy = (c == 1) ? D1Dtest : D1Dtest - 1;
+         const int D1Dx = (c == 0) ? D1Dtest : D1Dtest - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MQ1D][MQ1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MQ1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bc(qx,dx) : Bo(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MD1D][MD1D];
+            double gradXY21[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MD1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * mass[qz][qy][qx][1];
+                     massX[dx][1] += wx * mass[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MD1D][MD1D];
+            double gradXY20[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MD1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * mass[qz][qy][qx][2];
+                     massY[dy][1] += wy * mass[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MD1D][MD1D];
+            double gradYZ10[MD1D][MD1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MD1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
+                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   }); // end of element loop
+}
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/bilininteg_hdiv.cpp b/fem/integ/bilininteg_hdiv_kernels.cpp
similarity index 66%
rename from fem/bilininteg_hdiv.cpp
rename to fem/integ/bilininteg_hdiv_kernels.cpp
index 26e0ed973..30f2615ff 100644
--- a/fem/bilininteg_hdiv.cpp
+++ b/fem/integ/bilininteg_hdiv_kernels.cpp
@@ -6,31 +6,24 @@
 // availability visit https://mfem.org.
 //
 // MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qspace.hpp"
-
-using namespace std;
-
-
-// Piola transformation in H(div): w = (1 / det (dF)) dF \hat{w}
-// div w = (1 / det (dF)) \hat{div} \hat{w}
+#include "bilininteg_hdiv_kernels.hpp"
 
 namespace mfem
 {
 
-// PA H(div) Mass Assemble 2D kernel
-void PAHdivSetup2D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op)
+namespace internal
+{
+
+void PAHdivMassSetup2D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op)
 {
    const bool symmetric = (coeffDim != 4);
    const int NQ = Q1D*Q1D;
@@ -87,14 +80,13 @@ void PAHdivSetup2D(const int Q1D,
    });
 }
 
-// PA H(div) Mass Assemble 3D kernel
-void PAHdivSetup3D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op)
+void PAHdivMassSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op)
 {
    const bool symmetric = (coeffDim != 9);
    const int NQ = Q1D*Q1D*Q1D;
@@ -175,6 +167,174 @@ void PAHdivSetup3D(const int Q1D,
    });
 }
 
+void PAHdivMassAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double mass[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                  mass[qx] += wy*wy*((c == 0) ? op(qx,qy,0,e) : op(qx,qy,symmetric ? 2 : 3,e));
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double val = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
+                  val += mass[qx] * wx * wx;
+               }
+               diag(dx + (dy * D1Dx) + osc, e) += val;
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+   }); // end of element loop
+}
+
+void PAHdivMassAssembleDiagonal3D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_)
+{
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                         (symmetric ? 5 : 8));
+
+         double mass[HDIV_MAX_Q1D];
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
+                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
+                     }
+                  }
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  double val = 0.0;
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
+                     val += mass[qx] * wx * wx;
+                  }
+                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+void PAHdivMassApply(const int dim,
+                     const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const bool symmetric,
+                     const Array<double> &Bo,
+                     const Array<double> &Bc,
+                     const Array<double> &Bot,
+                     const Array<double> &Bct,
+                     const Vector &op,
+                     const Vector &x,
+                     Vector &y)
+{
+   const int id = (D1D << 4) | Q1D;
+
+   if (dim == 2)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPAHdivMassApply2D<2,2>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x33: return SmemPAHdivMassApply2D<3,3>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x44: return SmemPAHdivMassApply2D<4,4>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x55: return SmemPAHdivMassApply2D<5,5>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         default: // fallback
+            return PAHdivMassApply2D(D1D,Q1D,NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch (id)
+      {
+         case 0x23: return SmemPAHdivMassApply3D<2,3>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x34: return SmemPAHdivMassApply3D<3,4>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x45: return SmemPAHdivMassApply3D<4,5>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x56: return SmemPAHdivMassApply3D<5,6>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x67: return SmemPAHdivMassApply3D<6,7>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         case 0x78: return SmemPAHdivMassApply3D<7,8>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+         default: // fallback
+            return PAHdivMassApply3D(D1D,Q1D,NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
+      }
+   }
+}
+
 void PAHdivMassApply2D(const int D1D,
                        const int Q1D,
                        const int NE,
@@ -306,367 +466,73 @@ void PAHdivMassApply2D(const int D1D,
    }); // end of element loop
 }
 
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHdivMassApply2D(const int NE,
-                           const bool symmetric,
-                           const Array<double> &Bo_,
-                           const Array<double> &Bc_,
-                           const Array<double> &Bot_,
-                           const Array<double> &Bct_,
-                           const Vector &op_,
-                           const Vector &x_,
-                           Vector &y_,
-                           const int d1d = 0,
-                           const int q1d = 0)
+void PAHdivMassApply3D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const bool symmetric,
+                       const Array<double> &Bo_,
+                       const Array<double> &Bc_,
+                       const Array<double> &Bot_,
+                       const Array<double> &Bct_,
+                       const Vector &op_,
+                       const Vector &x_,
+                       Vector &y_)
 {
-   MFEM_CONTRACT_VAR(Bot_);
-   MFEM_CONTRACT_VAR(Bct_);
-
-   static constexpr int VDIM = 2;
-
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
 
-   const auto bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   const auto bc = Reshape(Bc_.Read(), Q1D, D1D);
-   const auto D = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   const auto x = Reshape(x_.Read(), D1D*(D1D-1), VDIM, NE);
-   auto y = y_.ReadWrite();
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(Bct_.Read(), D1D, Q1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto x = Reshape(x_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
 
-   mfem::forall_3D(NE, Q1D, Q1D, VDIM, [=] MFEM_HOST_DEVICE (int e)
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      const int tidz = MFEM_THREAD_ID(z);
-
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-
-      constexpr int MQ1 = T_Q1D ? T_Q1D : HDIV_MAX_Q1D;
-      constexpr int MD1 = T_D1D ? T_D1D : HDIV_MAX_D1D;
-      constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
-
-      MFEM_SHARED double smo[MQ1*(MD1-1)];
-      DeviceMatrix Bo(smo, D1D-1, Q1D);
-
-      MFEM_SHARED double smc[MQ1*MD1];
-      DeviceMatrix Bc(smc, D1D, Q1D);
-
-      MFEM_SHARED double sm0[VDIM*MDQ*MDQ];
-      MFEM_SHARED double sm1[VDIM*MDQ*MDQ];
-      DeviceMatrix X(sm0, D1D*(D1D-1), VDIM);
-      DeviceCube QD(sm1, Q1D, D1D, VDIM);
-      DeviceCube QQ(sm0, Q1D, Q1D, VDIM);
+      double mass[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D][VDIM];
 
-      // Load X, Bo and Bc into shared memory
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         MFEM_FOREACH_THREAD(dy,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               if (qx < D1D && dy < (D1D-1)) { X(qx + dy*D1D,vd) = x(qx+dy*D1D,vd,e); }
-               if (tidz == 0)
-               {
-                  if (dy < (D1D-1)) { Bo(dy,qx) = bo(qx,dy); }
-                  Bc(dy,qx) = bc(qx,dy);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      // Apply B operator
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         DeviceCube Xxy(X, nx, ny, VDIM);
-         DeviceMatrix Bx = (vd == 0) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(dy,y,ny)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               double dq = 0.0;
-               for (int dx = 0; dx < nx; ++dx)
-               {
-                  dq += Xxy(dx,dy,vd) * Bx(dx,qx);
-               }
-               QD(qx,dy,vd) = dq;
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      for (int qz = 0; qz < Q1D; ++qz)
       {
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         DeviceMatrix By = (vd == 1) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         for (int qy = 0; qy < Q1D; ++qy)
          {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            for (int qx = 0; qx < Q1D; ++qx)
             {
-               double qq = 0.0;
-               for (int dy = 0; dy < ny; ++dy)
+               for (int c = 0; c < VDIM; ++c)
                {
-                  qq += QD(qx,dy,vd) * By(dy,qy);
+                  mass[qz][qy][qx][c] = 0.0;
                }
-               QQ(qx,qy,vd) = qq;
             }
          }
       }
-      MFEM_SYNC_THREAD;
-      // Apply D operator
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               const double Qx = QQ(qx,qy,0);
-               const double Qy = QQ(qx,qy,1);
 
-               const double D11 = D(qx,qy,0,e);
-               const double D12 = D(qx,qy,1,e);
-               const double D21 = symmetric ? D12 : D(qx,qy,2,e);
-               const double D22 = symmetric ? D(qx,qy,2,e) : D(qx,qy,3,e);
+      int osc = 0;
 
-               QQ(qx,qy,0) = D11*Qx + D12*Qy;
-               QQ(qx,qy,1) = D21*Qx + D22*Qy;
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      // Apply Bt operator
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
       {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         DeviceMatrix Btx = (vd == 0) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
          {
-            MFEM_FOREACH_THREAD(dx,x,nx)
+            double massXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
             {
-               double qd = 0.0;
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  qd += QQ(qx,qy,vd) * Btx(dx,qx);
+                  massXY[qy][qx] = 0.0;
                }
-               QD(dx,qy,vd) = qd;
             }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         DeviceMatrix Bty = (vd == 1) ? Bc : Bo;
-         DeviceTensor<4> Yxy(y, nx, ny, VDIM, NE);
-         MFEM_FOREACH_THREAD(dy,y,ny)
-         {
-            MFEM_FOREACH_THREAD(dx,x,nx)
+
+            for (int dy = 0; dy < D1Dy; ++dy)
             {
-               double dd = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
+               double massX[HDIV_MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
                {
-                  dd += QD(dx,qy,vd) * Bty(dy,qy);
-               }
-               Yxy(dx,dy,vd,e) += dd;
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-   });
-}
-
-void PAHdivMassAssembleDiagonal2D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double mass[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                  mass[qx] += wy*wy*((c == 0) ? op(qx,qy,0,e) : op(qx,qy,symmetric ? 2 : 3,e));
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double val = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
-                  val += mass[qx] * wx * wx;
-               }
-               diag(dx + (dy * D1Dx) + osc, e) += val;
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-   }); // end of element loop
-}
-
-void PAHdivMassAssembleDiagonal3D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                         (symmetric ? 5 : 8));
-
-         double mass[HDIV_MAX_Q1D];
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qx] = 0.0;
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
-                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
-                     }
-                  }
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  double val = 0.0;
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
-                     val += mass[qx] * wx * wx;
-                  }
-                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-void PAHdivMassApply3D(const int D1D,
-                       const int Q1D,
-                       const int NE,
-                       const bool symmetric,
-                       const Array<double> &Bo_,
-                       const Array<double> &Bc_,
-                       const Array<double> &Bot_,
-                       const Array<double> &Bct_,
-                       const Vector &op_,
-                       const Vector &x_,
-                       Vector &y_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(Bct_.Read(), D1D, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto x = Reshape(x_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[HDIV_MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
+                  massX[qx] = 0.0;
                }
 
                for (int dx = 0; dx < D1Dx; ++dx)
@@ -795,409 +661,199 @@ void PAHdivMassApply3D(const int D1D,
    }); // end of element loop
 }
 
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHdivMassApply3D(const int NE,
-                           const bool symmetric,
-                           const Array<double> &Bo_,
-                           const Array<double> &Bc_,
-                           const Array<double> &Bot_,
-                           const Array<double> &Bct_,
-                           const Vector &op_,
-                           const Vector &x_,
-                           Vector &y_,
-                           const int d1d = 0,
-                           const int q1d = 0)
+// NOTE: this is identical to PACurlCurlSetup2D
+void PADivDivSetup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op)
 {
-   MFEM_CONTRACT_VAR(Bot_);
-   MFEM_CONTRACT_VAR(Bct_);
-
-   static constexpr int VDIM = 3;
-
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-
-   const auto bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   const auto bc = Reshape(Bc_.Read(), Q1D, D1D);
-   const auto D = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   const auto x = Reshape(x_.Read(), D1D*(D1D-1)*(D1D-1), VDIM, NE);
-   auto y = y_.ReadWrite();
-
-   mfem::forall_3D(NE, Q1D, Q1D, VDIM, [=] MFEM_HOST_DEVICE (int e)
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      const int tidz = MFEM_THREAD_ID(z);
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double detJ = (J11*J22)-(J21*J12);
+         y(q,e) = W[q] * coeff(q,e) / detJ;
+      }
+   });
+}
 
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
+void PADivDivSetup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op)
+{
+   const int NQ = Q1D*Q1D*Q1D;
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
 
-      constexpr int MQ1 = T_Q1D ? T_Q1D : HDIV_MAX_Q1D;
-      constexpr int MD1 = T_D1D ? T_D1D : HDIV_MAX_D1D;
-      constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J31 = J(q,2,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double J32 = J(q,2,1,e);
+         const double J13 = J(q,0,2,e);
+         const double J23 = J(q,1,2,e);
+         const double J33 = J(q,2,2,e);
+         const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                             J21 * (J12 * J33 - J32 * J13) +
+                             J31 * (J12 * J23 - J22 * J13);
+         y(q,e) = W[q] * coeff(q, e) / detJ;
+      }
+   });
+}
 
-      MFEM_SHARED double smo[MQ1*(MD1-1)];
-      DeviceMatrix Bo(smo, D1D-1, Q1D);
+void PADivDivAssembleDiagonal2D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
 
-      MFEM_SHARED double smc[MQ1*MD1];
-      DeviceMatrix Bc(smc, D1D, Q1D);
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
 
-      MFEM_SHARED double sm0[VDIM*MDQ*MDQ*MDQ];
-      MFEM_SHARED double sm1[VDIM*MDQ*MDQ*MDQ];
-      DeviceMatrix X(sm0, D1D*(D1D-1)*(D1D-1), VDIM);
-      DeviceTensor<4> QDD(sm1, Q1D, D1D, D1D, VDIM);
-      DeviceTensor<4> QQD(sm0, Q1D, Q1D, D1D, VDIM);
-      DeviceTensor<4> QQQ(sm1, Q1D, Q1D, Q1D, VDIM);
-      DeviceTensor<4> DQQ(sm0, D1D, Q1D, Q1D, VDIM);
-      DeviceTensor<4> DDQ(sm1, D1D, D1D, Q1D, VDIM);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
 
-      // Load X into shared memory
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
       {
-         MFEM_FOREACH_THREAD(dz,y,D1D-1)
-         {
-            MFEM_FOREACH_THREAD(dy,x,D1D-1)
-            {
-               MFEM_UNROLL(MD1)
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  X(dx+(dy+dz*(D1D-1))*D1D,vd) = x(dx+(dy+dz*(D1D-1))*D1D,vd,e);
-               }
-            }
-         }
-      }
-      // Load Bo and Bc into shared memory
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D-1)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               Bo(d,q) = bo(q,d);
-            }
-         }
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               Bc(d,q) = bc(q,d);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      // Apply B operator
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         const int nz = (vd == 2) ? D1D : D1D-1;
-         DeviceTensor<4> Xxyz(X, nx, ny, nz, VDIM);
-         DeviceMatrix Bx = (vd == 0) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(dy,y,ny)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               double u[D1D];
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
-               MFEM_UNROLL(MD1)
-               for (int dx = 0; dx < nx; ++dx)
-               {
-                  MFEM_UNROLL(MD1)
-                  for (int dz = 0; dz < nz; ++dz)
-                  {
-                     u[dz] += Xxyz(dx,dy,dz,vd) * Bx(dx,qx);
-                  }
-               }
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { QDD(qx,dy,dz,vd) = u[dz]; }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         const int nz = (vd == 2) ? D1D : D1D-1;
-         DeviceMatrix By = (vd == 1) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               double u[D1D];
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
-               MFEM_UNROLL(MD1)
-               for (int dy = 0; dy < ny; ++dy)
-               {
-                  MFEM_UNROLL(MD1)
-                  for (int dz = 0; dz < nz; ++dz)
-                  {
-                     u[dz] += QDD(qx,dy,dz,vd) * By(dy,qy);
-                  }
-               }
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { QQD(qx,qy,dz,vd) = u[dz]; }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nz = (vd == 2) ? D1D : D1D-1;
-         DeviceMatrix Bz = (vd == 2) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
-            {
-               double u[Q1D];
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz)
-               {
-                  MFEM_UNROLL(MQ1)
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     u[qz] += QQD(qx,qy,dz,vd) * Bz(dz,qz);
-                  }
-               }
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { QQQ(qx,qy,qz,vd) = u[qz]; }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      // Apply D operator
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+
+         double div[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
          {
-            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            for (int qx = 0; qx < Q1D; ++qx)
             {
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz)
+               div[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
                {
-                  const double Qx = QQQ(qx,qy,qz,0);
-                  const double Qy = QQQ(qx,qy,qz,1);
-                  const double Qz = QQQ(qx,qy,qz,2);
-
-                  const double D11 = D(qx,qy,qz,0,e);
-                  const double D12 = D(qx,qy,qz,1,e);
-                  const double D13 = D(qx,qy,qz,2,e);
-                  const double D21 = symmetric ? D12 : D(qx,qy,qz,3,e);
-                  const double D22 = symmetric ? D(qx,qy,qz,3,e) : D(qx,qy,qz,4,e);
-                  const double D23 = symmetric ? D(qx,qy,qz,4,e) : D(qx,qy,qz,5,e);
-                  const double D31 = symmetric ? D13 : D(qx,qy,qz,6,e);
-                  const double D32 = symmetric ? D23 : D(qx,qy,qz,7,e);
-                  const double D33 = symmetric ? D(qx,qy,qz,5,e) : D(qx,qy,qz,8,e);
-
-                  QQQ(qx,qy,qz,0) = D11*Qx + D12*Qy + D13*Qz;
-                  QQQ(qx,qy,qz,1) = D21*Qx + D22*Qy + D23*Qz;
-                  QQQ(qx,qy,qz,2) = D31*Qx + D32*Qy + D33*Qz;
+                  const double wy = (c == 0) ? Bo(qy,dy) : Gc(qy,dy);
+                  div[qx] += wy * wy * op(qx,qy,e);
                }
             }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      // Apply Bt operator
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         DeviceMatrix Btx = (vd == 0) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(dx,x,nx)
+
+            for (int dx = 0; dx < D1Dx; ++dx)
             {
-               double u[Q1D];
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
-               MFEM_UNROLL(MQ1)
+               double val = 0.0;
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  MFEM_UNROLL(MQ1)
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     u[qz] += QQQ(qx,qy,qz,vd) * Btx(dx,qx);
-                  }
+                  const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
+                  val += div[qx] * wx * wx;
                }
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { DQQ(dx,qy,qz,vd) = u[qz]; }
+               diag(dx + (dy * D1Dx) + osc, e) += val;
             }
          }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   });
+}
+
+void PADivDivAssembleDiagonal3D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_)
+{
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
       {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         DeviceMatrix Bty = (vd == 1) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(dy,y,ny)
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
          {
-            MFEM_FOREACH_THREAD(dx,x,nx)
+            for (int dy = 0; dy < D1Dy; ++dy)
             {
-               double u[Q1D];
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
-               MFEM_UNROLL(MQ1)
-               for (int qy = 0; qy < Q1D; ++qy)
+               double a[HDIV_MAX_Q1D];
+
+               for (int qx = 0; qx < Q1D; ++qx)
                {
-                  MFEM_UNROLL(MQ1)
-                  for (int qz = 0; qz < Q1D; ++qz)
+                  a[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
                   {
-                     u[qz] += DQQ(dx,qy,qz,vd) * Bty(dy,qy);
+                     const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
+
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Gc(qz,dz) : Bo(qz,dz);
+                        a[qx] += wy * wy * wz * wz * op(qx,qy,qz,e);
+                     }
                   }
                }
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz) { DDQ(dx,dy,qz,vd) = u[qz]; }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(vd,z,VDIM)
-      {
-         const int nx = (vd == 0) ? D1D : D1D-1;
-         const int ny = (vd == 1) ? D1D : D1D-1;
-         const int nz = (vd == 2) ? D1D : D1D-1;
-         DeviceTensor<5> Yxyz(y, nx, ny, nz, VDIM, NE);
-         DeviceMatrix Btz = (vd == 2) ? Bc : Bo;
-         MFEM_FOREACH_THREAD(dy,y,ny)
-         {
-            MFEM_FOREACH_THREAD(dx,x,nx)
-            {
-               double u[D1D];
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
-               MFEM_UNROLL(MQ1)
-               for (int qz = 0; qz < Q1D; ++qz)
+
+               for (int dx = 0; dx < D1Dx; ++dx)
                {
-                  MFEM_UNROLL(MD1)
-                  for (int dz = 0; dz < nz; ++dz)
+                  double val = 0.0;
+                  for (int qx = 0; qx < Q1D; ++qx)
                   {
-                     u[dz] += DDQ(dx,dy,qz,vd) * Btz(dz,qz);
+                     const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
+                     val += a[qx] * wx * wx;
                   }
+                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
                }
-               MFEM_UNROLL(MD1)
-               for (int dz = 0; dz < nz; ++dz) { Yxyz(dx,dy,dz,vd,e) += u[dz]; }
             }
          }
-      }
-      MFEM_SYNC_THREAD;
-   });
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
 }
 
-void PAHdivMassApply(const int dim,
-                     const int D1D,
+void PADivDivApply2D(const int D1D,
                      const int Q1D,
                      const int NE,
-                     const bool symmetric,
-                     const Array<double> &Bo,
-                     const Array<double> &Bc,
-                     const Array<double> &Bot,
-                     const Array<double> &Bct,
-                     const Vector &op,
-                     const Vector &x,
-                     Vector &y)
-{
-   const int id = (D1D << 4) | Q1D;
-
-   if (dim == 2)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPAHdivMassApply2D<2,2>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x33: return SmemPAHdivMassApply2D<3,3>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x44: return SmemPAHdivMassApply2D<4,4>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x55: return SmemPAHdivMassApply2D<5,5>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         default: // fallback
-            return PAHdivMassApply2D(D1D,Q1D,NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch (id)
-      {
-         case 0x23: return SmemPAHdivMassApply3D<2,3>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x34: return SmemPAHdivMassApply3D<3,4>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x45: return SmemPAHdivMassApply3D<4,5>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x56: return SmemPAHdivMassApply3D<5,6>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x67: return SmemPAHdivMassApply3D<6,7>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         case 0x78: return SmemPAHdivMassApply3D<7,8>(NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-         default: // fallback
-            return PAHdivMassApply3D(D1D,Q1D,NE,symmetric,Bo,Bc,Bot,Bct,op,x,y);
-      }
-   }
-}
-
-// PA H(div) div-div assemble 2D kernel
-// NOTE: this is identical to PACurlCurlSetup3D
-static void PADivDivSetup2D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            const Vector &j,
-                            Vector &coeff_,
-                            Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double detJ = (J11*J22)-(J21*J12);
-         y(q,e) = W[q] * coeff(q,e) / detJ;
-      }
-   });
-}
-
-static void PADivDivSetup3D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            const Vector &j,
-                            Vector &coeff_,
-                            Vector &op)
-{
-   const int NQ = Q1D*Q1D*Q1D;
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J31 = J(q,2,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double J32 = J(q,2,1,e);
-         const double J13 = J(q,0,2,e);
-         const double J23 = J(q,1,2,e);
-         const double J33 = J(q,2,2,e);
-         const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                             J21 * (J12 * J33 - J32 * J13) +
-                             J31 * (J12 * J23 - J22 * J13);
-         y(q,e) = W[q] * coeff(q, e) / detJ;
-      }
-   });
-}
-
-static void PADivDivApply2D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Gct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    constexpr static int VDIM = 2;
    constexpr static int MAX_D1D = HDIV_MAX_D1D;
@@ -1307,16 +963,16 @@ static void PADivDivApply2D(const int D1D,
    }); // end of element loop
 }
 
-static void PADivDivApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Gct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+void PADivDivApply3D(const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
@@ -1483,332 +1139,488 @@ static void PADivDivApply3D(const int D1D,
    }); // end of element loop
 }
 
-void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
+void PAHdivL2Setup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op)
 {
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
-                               (*el, *el, *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PADivDivSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-   else if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
-   {
-      PADivDivSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-   else
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      MFEM_ABORT("Unknown kernel.");
-   }
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * coeff(q,e);
+      }
+   });
 }
 
-void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
+void PAHdivL2Setup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op)
 {
-   if (dim == 3)
-      PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                      mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                      mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
+   const int NQ = Q1D*Q1D*Q1D;
+   auto W = w.Read();
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
 
-static void PADivDivAssembleDiagonal2D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const Array<double> &Bo_,
-                                       const Array<double> &Gc_,
-                                       const Vector &op_,
-                                       Vector &diag_)
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * coeff(q, e);
+      }
+   });
+}
+
+void PAHdivL2AssembleDiagonal_ADAt_2D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_)
 {
    constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
 
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
    auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
+   auto D = Reshape(D_.Read(), 2*(D1D-1)*D1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, NE);
 
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      for (int ry = 0; ry < L2D1D; ++ry)
       {
-         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+         for (int rx = 0; rx < L2D1D; ++rx)
+         {
+            // Compute row (rx,ry), assuming all contributions are from
+            // a single element.
 
-         double div[MAX_Q1D];
+            double row[2*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)];
+            double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
 
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
+            for (int i=0; i<2*D1D*(D1D - 1); ++i)
             {
-               div[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 0) ? Bo(qy,dy) : Gc(qy,dy);
-                  div[qx] += wy * wy * op(qx,qy,e);
-               }
+               row[i] = 0;
             }
 
-            for (int dx = 0; dx < D1Dx; ++dx)
+            for (int qy = 0; qy < Q1D; ++qy)
             {
-               double val = 0.0;
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
-                  val += div[qx] * wx * wx;
+                  div[qy][qx] = op(qx,qy,e) * L2Bo(qx,rx) * L2Bo(qy,ry);
                }
-               diag(dx + (dy * D1Dx) + osc, e) += val;
             }
-         }
 
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   });
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               int osc = 0;
+               for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+               {
+                  const int D1Dy = (c == 1) ? D1D : D1D - 1;
+                  const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+                  double aX[HDIV_MAX_D1D];
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     aX[dx] = 0;
+                  }
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     for (int dx = 0; dx < D1Dx; ++dx)
+                     {
+                        aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) :
+                                                 Bot(dx,qx));
+                     }
+                  }
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
+
+                     for (int dx = 0; dx < D1Dx; ++dx)
+                     {
+                        row[dx + (dy * D1Dx) + osc] += aX[dx] * wy;
+                     }
+                  }
+
+                  osc += D1Dx * D1Dy;
+               }  // loop c
+            }  // loop qy
+
+            double val = 0.0;
+            for (int i=0; i<2*D1D*(D1D - 1); ++i)
+            {
+               val += row[i] * row[i] * D(i,e);
+            }
+            diag(rx,ry,e) += val;
+         }  // loop rx
+      }  // loop ry
+   }); // end of element loop
 }
 
-static void PADivDivAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const Array<double> &Bo_,
-                                       const Array<double> &Gc_,
-                                       const Vector &op_,
-                                       Vector &diag_)
+void PAHdivL2AssembleDiagonal_ADAt_3D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
    constexpr static int VDIM = 3;
 
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
    auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+   auto D = Reshape(D_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, L2D1D, NE);
 
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      for (int rz = 0; rz < L2D1D; ++rz)
       {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
+         for (int ry = 0; ry < L2D1D; ++ry)
          {
-            for (int dy = 0; dy < D1Dy; ++dy)
+            for (int rx = 0; rx < L2D1D; ++rx)
             {
-               double a[HDIV_MAX_Q1D];
+               // Compute row (rx,ry,rz), assuming all contributions are from
+               // a single element.
 
-               for (int qx = 0; qx < Q1D; ++qx)
+               double row[3*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)*(HDIV_MAX_D1D-1)];
+               double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
+
+               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
+               {
+                  row[i] = 0;
+               }
+
+               for (int qz = 0; qz < Q1D; ++qz)
                {
-                  a[qx] = 0.0;
                   for (int qy = 0; qy < Q1D; ++qy)
                   {
-                     const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
-
-                     for (int qz = 0; qz < Q1D; ++qz)
+                     for (int qx = 0; qx < Q1D; ++qx)
                      {
-                        const double wz = (c == 2) ? Gc(qz,dz) : Bo(qz,dz);
-                        a[qx] += wy * wy * wz * wz * op(qx,qy,qz,e);
+                        div[qz][qy][qx] = op(qx,qy,qz,e) * L2Bo(qx,rx) *
+                                          L2Bo(qy,ry) * L2Bo(qz,rz);
                      }
                   }
                }
 
-               for (int dx = 0; dx < D1Dx; ++dx)
+               for (int qz = 0; qz < Q1D; ++qz)
                {
-                  double val = 0.0;
-                  for (int qx = 0; qx < Q1D; ++qx)
+                  double aXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
+
+                  int osc = 0;
+                  for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
                   {
-                     const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
-                     val += a[qx] * wx * wx;
-                  }
-                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
-               }
-            }
-         }
+                     const int D1Dz = (c == 2) ? D1D : D1D - 1;
+                     const int D1Dy = (c == 1) ? D1D : D1D - 1;
+                     const int D1Dx = (c == 0) ? D1D : D1D - 1;
 
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
+                     for (int dy = 0; dy < D1Dy; ++dy)
+                     {
+                        for (int dx = 0; dx < D1Dx; ++dx)
+                        {
+                           aXY[dy][dx] = 0;
+                        }
+                     }
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        double aX[HDIV_MAX_D1D];
+                        for (int dx = 0; dx < D1Dx; ++dx)
+                        {
+                           aX[dx] = 0;
+                        }
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              aX[dx] += div[qz][qy][qx] * ((c == 0) ? Gct(dx,qx)
+                                                           : Bot(dx,qx));
+                           }
+                        }
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              aXY[dy][dx] += aX[dx] * wy;
+                           }
+                        }
+                     }
+
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? Gct(dz,qz) : Bot(dz,qz);
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              row[dx + ((dy + (dz * D1Dy)) * D1Dx) + osc] +=
+                                 aXY[dy][dx] * wz;
+                           }
+                        }
+                     }
+
+                     osc += D1Dx * D1Dy * D1Dz;
+                  }  // loop c
+               }  // loop qz
+
+               double val = 0.0;
+               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
+               {
+                  val += row[i] * row[i] * D(i,e);
+               }
+               diag(rx,ry,rz,e) += val;
+            }  // loop rx
+         }  // loop ry
+      }  // loop rz
    }); // end of element loop
 }
 
-void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+// Apply to x corresponding to DOFs in H(div) (trial), whose divergence is
+// integrated against L_2 test functions corresponding to y.
+void PAHdivL2Apply2D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
-   if (dim == 3)
-   {
-      PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
-                                 mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                 mapsO->B, mapsC->G, pa_data, diag);
-   }
-}
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HDIV_MAX_D1D;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto L2Bot = Reshape(L2Bot_.Read(), L2D1D, Q1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), L2D1D, L2D1D, NE);
 
-// PA H(div)-L2 (div u, p) assemble 2D kernel
-static void PADivL2Setup2D(const int Q1D,
-                           const int NE,
-                           const Array<double> &w,
-                           Vector &coeff_,
-                           Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      for (int q = 0; q < NQ; ++q)
+      double div[MAX_Q1D][MAX_Q1D];
+
+      for (int qy = 0; qy < Q1D; ++qy)
       {
-         y(q,e) = W[q] * coeff(q,e);
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            div[qy][qx] = 0.0;
+         }
       }
-   });
-}
 
-static void PADivL2Setup3D(const int Q1D,
-                           const int NE,
-                           const Array<double> &w,
-                           Vector &coeff_,
-                           Vector &op)
-{
-   const int NQ = Q1D*Q1D*Q1D;
-   auto W = w.Read();
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
+      int osc = 0;
 
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
       {
-         y(q,e) = W[q] * coeff(q, e);
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double aX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               aX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = x(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  aX[qx] += t * ((c == 0) ? Gc(qx,dx) : Bo(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  div[qy][qx] += aX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            div[qy][qx] *= op(qx,qy,e);
+         }
       }
-   });
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double aX[MAX_D1D];
+         for (int dx = 0; dx < L2D1D; ++dx)
+         {
+            aX[dx] = 0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int dx = 0; dx < L2D1D; ++dx)
+            {
+               aX[dx] += div[qy][qx] * L2Bot(dx,qx);
+            }
+         }
+         for (int dy = 0; dy < L2D1D; ++dy)
+         {
+            const double wy = L2Bot(dy,qy);
+            for (int dx = 0; dx < L2D1D; ++dx)
+            {
+               y(dx,dy,e) += aX[dx] * wy;
+            }
+         }
+      }
+   }); // end of element loop
 }
 
-void
-VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                         const FiniteElementSpace &test_fes)
+void PAHdivL2ApplyTranspose2D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_)
 {
-   // Assumes tensor-product elements, with a vector test space and
-   // scalar trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const NodalTensorFiniteElement *test_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HDIV_MAX_D1D;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
 
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
-                                  *trial_el, *trial_el,
-                                  *mesh->GetElementTransformation(0));
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), L2D1D, L2D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2*(D1D-1)*D1D, NE);
 
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double div[MAX_Q1D][MAX_Q1D];
 
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            div[qy][qx] = 0.0;
+         }
+      }
 
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder() + 1, "");
+      for (int dy = 0; dy < L2D1D; ++dy)
+      {
+         double aX[MAX_Q1D];
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            aX[qx] = 0.0;
+         }
 
-   ne = trial_fes.GetNE();
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
+         for (int dx = 0; dx < L2D1D; ++dx)
+         {
+            const double t = x(dx,dy,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               aX[qx] += t * L2Bo(qx,dx);
+            }
+         }
 
-   L2mapsO = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   L2dofs1D = L2mapsO->ndof;
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double wy = L2Bo(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               div[qy][qx] += aX[qx] * wy;
+            }
+         }
+      }
 
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-   if (dim == 2)
-   {
-      MFEM_VERIFY(nq == quad1D * quad1D, "");
-   }
-   else
-   {
-      MFEM_VERIFY(nq == quad1D * quad1D * quad1D, "");
-   }
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            div[qy][qx] *= op(qx,qy,e);
+         }
+      }
 
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double aX[MAX_D1D];
 
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D : D1D - 1;
+            const int D1Dx = (c == 0) ? D1D : D1D - 1;
 
-   if (test_el->GetMapType() == FiniteElement::INTEGRAL)
-   {
-      const GeometricFactors *geom =
-         mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS);
-      coeff /= geom->detJ;
-   }
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               aX[dx] = 0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) : Bot(dx,qx));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 0) ? Bot(dy,qy) : Gct(dy,qy);
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  y(dx + (dy * D1Dx) + osc, e) += aX[dx] * wy;
+               }
+            }
 
-   if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PADivL2Setup3D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
-   {
-      PADivL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
 }
 
 // Apply to x corresponding to DOFs in H(div) (trial), whose divergence is
 // integrated against L_2 test functions corresponding to y.
-static void PAHdivL2Apply3D(const int D1D,
-                            const int Q1D,
-                            const int L2D1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &L2Bot_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+void PAHdivL2Apply3D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
@@ -1960,211 +1772,103 @@ static void PAHdivL2Apply3D(const int D1D,
    }); // end of element loop
 }
 
-// Apply to x corresponding to DOFs in H(div) (trial), whose divergence is
-// integrated against L_2 test functions corresponding to y.
-static void PAHdivL2Apply2D(const int D1D,
-                            const int Q1D,
-                            const int L2D1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &L2Bot_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+void PAHdivL2ApplyTranspose3D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_)
 {
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HDIV_MAX_D1D;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
 
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
-   auto L2Bot = Reshape(L2Bot_.Read(), L2D1D, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), L2D1D, L2D1D, NE);
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), L2D1D, L2D1D, L2D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
 
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      double div[MAX_Q1D][MAX_Q1D];
+      double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
 
-      for (int qy = 0; qy < Q1D; ++qy)
+      for (int qz = 0; qz < Q1D; ++qz)
       {
-         for (int qx = 0; qx < Q1D; ++qx)
+         for (int qy = 0; qy < Q1D; ++qy)
          {
-            div[qy][qx] = 0.0;
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               div[qz][qy][qx] = 0.0;
+            }
          }
       }
 
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      for (int dz = 0; dz < L2D1D; ++dz)
       {
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+         double aXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               aXY[qy][qx] = 0.0;
+            }
+         }
 
-         for (int dy = 0; dy < D1Dy; ++dy)
+         for (int dy = 0; dy < L2D1D; ++dy)
          {
-            double aX[MAX_Q1D];
+            double aX[HDIV_MAX_Q1D];
             for (int qx = 0; qx < Q1D; ++qx)
             {
                aX[qx] = 0.0;
             }
 
-            for (int dx = 0; dx < D1Dx; ++dx)
+            for (int dx = 0; dx < L2D1D; ++dx)
             {
-               const double t = x(dx + (dy * D1Dx) + osc, e);
+               const double t = x(dx,dy,dz,e);
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  aX[qx] += t * ((c == 0) ? Gc(qx,dx) : Bo(qx,dx));
+                  aX[qx] += t * L2Bo(qx,dx);
                }
             }
 
             for (int qy = 0; qy < Q1D; ++qy)
             {
-               const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
+               const double wy = L2Bo(qy,dy);
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  div[qy][qx] += aX[qx] * wy;
+                  aXY[qy][qx] += aX[qx] * wy;
                }
             }
          }
 
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            const double wz = L2Bo(qz,dz);
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  div[qz][qy][qx] += aXY[qy][qx] * wz;
+               }
+            }
+         }
+      }
 
       // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
+      for (int qz = 0; qz < Q1D; ++qz)
       {
-         for (int qx = 0; qx < Q1D; ++qx)
+         for (int qy = 0; qy < Q1D; ++qy)
          {
-            div[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double aX[MAX_D1D];
-         for (int dx = 0; dx < L2D1D; ++dx)
-         {
-            aX[dx] = 0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int dx = 0; dx < L2D1D; ++dx)
-            {
-               aX[dx] += div[qy][qx] * L2Bot(dx,qx);
-            }
-         }
-         for (int dy = 0; dy < L2D1D; ++dy)
-         {
-            const double wy = L2Bot(dy,qy);
-            for (int dx = 0; dx < L2D1D; ++dx)
-            {
-               y(dx,dy,e) += aX[dx] * wy;
-            }
-         }
-      }
-   }); // end of element loop
-}
-
-static void PAHdivL2ApplyTranspose3D(const int D1D,
-                                     const int Q1D,
-                                     const int L2D1D,
-                                     const int NE,
-                                     const Array<double> &L2Bo_,
-                                     const Array<double> &Gct_,
-                                     const Array<double> &Bot_,
-                                     const Vector &op_,
-                                     const Vector &x_,
-                                     Vector &y_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), L2D1D, L2D1D, L2D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               div[qz][qy][qx] = 0.0;
-            }
-         }
-      }
-
-      for (int dz = 0; dz < L2D1D; ++dz)
-      {
-         double aXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               aXY[qy][qx] = 0.0;
-            }
-         }
-
-         for (int dy = 0; dy < L2D1D; ++dy)
-         {
-            double aX[HDIV_MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               aX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < L2D1D; ++dx)
-            {
-               const double t = x(dx,dy,dz,e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  aX[qx] += t * L2Bo(qx,dx);
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = L2Bo(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  aXY[qy][qx] += aX[qx] * wy;
-               }
-            }
-         }
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            const double wz = L2Bo(qz,dz);
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  div[qz][qy][qx] += aXY[qy][qx] * wz;
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               div[qz][qy][qx] *= op(qx,qy,qz,e);
-            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               div[qz][qy][qx] *= op(qx,qy,qz,e);
+            }
          }
       }
 
@@ -2230,371 +1934,6 @@ static void PAHdivL2ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-static void PAHdivL2ApplyTranspose2D(const int D1D,
-                                     const int Q1D,
-                                     const int L2D1D,
-                                     const int NE,
-                                     const Array<double> &L2Bo_,
-                                     const Array<double> &Gct_,
-                                     const Array<double> &Bot_,
-                                     const Vector &op_,
-                                     const Vector &x_,
-                                     Vector &y_)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HDIV_MAX_D1D;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), L2D1D, L2D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double div[MAX_Q1D][MAX_Q1D];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            div[qy][qx] = 0.0;
-         }
-      }
-
-      for (int dy = 0; dy < L2D1D; ++dy)
-      {
-         double aX[MAX_Q1D];
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            aX[qx] = 0.0;
-         }
-
-         for (int dx = 0; dx < L2D1D; ++dx)
-         {
-            const double t = x(dx,dy,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               aX[qx] += t * L2Bo(qx,dx);
-            }
-         }
-
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double wy = L2Bo(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               div[qy][qx] += aX[qx] * wy;
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            div[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double aX[MAX_D1D];
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D : D1D - 1;
-            const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               aX[dx] = 0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) : Bot(dx,qx));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 0) ? Bot(dy,qy) : Gct(dy,qy);
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  y(dx + (dy * D1Dx) + osc, e) += aX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-void VectorFEDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-      PAHdivL2Apply3D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
-                      L2mapsO->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHdivL2Apply2D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
-                      L2mapsO->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void VectorFEDivergenceIntegrator::AddMultTransposePA(const Vector &x,
-                                                      Vector &y) const
-{
-   if (dim == 3)
-      PAHdivL2ApplyTranspose3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                               mapsC->Gt, mapsO->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHdivL2ApplyTranspose2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                               mapsC->Gt, mapsO->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-static void PAHdivL2AssembleDiagonal_ADAt_3D(const int D1D,
-                                             const int Q1D,
-                                             const int L2D1D,
-                                             const int NE,
-                                             const Array<double> &L2Bo_,
-                                             const Array<double> &Gct_,
-                                             const Array<double> &Bot_,
-                                             const Vector &op_,
-                                             const Vector &D_,
-                                             Vector &diag_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto D = Reshape(D_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, L2D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int rz = 0; rz < L2D1D; ++rz)
-      {
-         for (int ry = 0; ry < L2D1D; ++ry)
-         {
-            for (int rx = 0; rx < L2D1D; ++rx)
-            {
-               // Compute row (rx,ry,rz), assuming all contributions are from
-               // a single element.
-
-               double row[3*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)*(HDIV_MAX_D1D-1)];
-               double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-
-               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
-               {
-                  row[i] = 0;
-               }
-
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        div[qz][qy][qx] = op(qx,qy,qz,e) * L2Bo(qx,rx) *
-                                          L2Bo(qy,ry) * L2Bo(qz,rz);
-                     }
-                  }
-               }
-
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  double aXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
-
-                  int osc = 0;
-                  for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-                  {
-                     const int D1Dz = (c == 2) ? D1D : D1D - 1;
-                     const int D1Dy = (c == 1) ? D1D : D1D - 1;
-                     const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-                     for (int dy = 0; dy < D1Dy; ++dy)
-                     {
-                        for (int dx = 0; dx < D1Dx; ++dx)
-                        {
-                           aXY[dy][dx] = 0;
-                        }
-                     }
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        double aX[HDIV_MAX_D1D];
-                        for (int dx = 0; dx < D1Dx; ++dx)
-                        {
-                           aX[dx] = 0;
-                        }
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              aX[dx] += div[qz][qy][qx] * ((c == 0) ? Gct(dx,qx)
-                                                           : Bot(dx,qx));
-                           }
-                        }
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              aXY[dy][dx] += aX[dx] * wy;
-                           }
-                        }
-                     }
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? Gct(dz,qz) : Bot(dz,qz);
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              row[dx + ((dy + (dz * D1Dy)) * D1Dx) + osc] +=
-                                 aXY[dy][dx] * wz;
-                           }
-                        }
-                     }
-
-                     osc += D1Dx * D1Dy * D1Dz;
-                  }  // loop c
-               }  // loop qz
-
-               double val = 0.0;
-               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
-               {
-                  val += row[i] * row[i] * D(i,e);
-               }
-               diag(rx,ry,rz,e) += val;
-            }  // loop rx
-         }  // loop ry
-      }  // loop rz
-   }); // end of element loop
-}
-
-static void PAHdivL2AssembleDiagonal_ADAt_2D(const int D1D,
-                                             const int Q1D,
-                                             const int L2D1D,
-                                             const int NE,
-                                             const Array<double> &L2Bo_,
-                                             const Array<double> &Gct_,
-                                             const Array<double> &Bot_,
-                                             const Vector &op_,
-                                             const Vector &D_,
-                                             Vector &diag_)
-{
-   constexpr static int VDIM = 2;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto D = Reshape(D_.Read(), 2*(D1D-1)*D1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int ry = 0; ry < L2D1D; ++ry)
-      {
-         for (int rx = 0; rx < L2D1D; ++rx)
-         {
-            // Compute row (rx,ry), assuming all contributions are from
-            // a single element.
-
-            double row[2*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)];
-            double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-
-            for (int i=0; i<2*D1D*(D1D - 1); ++i)
-            {
-               row[i] = 0;
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  div[qy][qx] = op(qx,qy,e) * L2Bo(qx,rx) * L2Bo(qy,ry);
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               int osc = 0;
-               for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-               {
-                  const int D1Dy = (c == 1) ? D1D : D1D - 1;
-                  const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-                  double aX[HDIV_MAX_D1D];
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     aX[dx] = 0;
-                  }
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     for (int dx = 0; dx < D1Dx; ++dx)
-                     {
-                        aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) :
-                                                 Bot(dx,qx));
-                     }
-                  }
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
-
-                     for (int dx = 0; dx < D1Dx; ++dx)
-                     {
-                        row[dx + (dy * D1Dx) + osc] += aX[dx] * wy;
-                     }
-                  }
-
-                  osc += D1Dx * D1Dy;
-               }  // loop c
-            }  // loop qy
-
-            double val = 0.0;
-            for (int i=0; i<2*D1D*(D1D - 1); ++i)
-            {
-               val += row[i] * row[i] * D(i,e);
-            }
-            diag(rx,ry,e) += val;
-         }  // loop rx
-      }  // loop ry
-   }); // end of element loop
-}
-
-void VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const Vector &D,
-                                                           Vector &diag)
-{
-   if (dim == 3)
-      PAHdivL2AssembleDiagonal_ADAt_3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                                       mapsC->Gt, mapsO->Bt, pa_data, D, diag);
-   else if (dim == 2)
-      PAHdivL2AssembleDiagonal_ADAt_2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                                       mapsC->Gt, mapsO->Bt, pa_data, D, diag);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
+} // namespace internal
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_hdiv_kernels.hpp b/fem/integ/bilininteg_hdiv_kernels.hpp
new file mode 100644
index 000000000..db414809e
--- /dev/null
+++ b/fem/integ/bilininteg_hdiv_kernels.hpp
@@ -0,0 +1,715 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_HDIV_KERNELS_HPP
+#define MFEM_BILININTEG_HDIV_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/array.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+#include "../../linalg/vector.hpp"
+#include "../bilininteg.hpp"
+
+// Piola transformation in H(div): w = (1 / det (dF)) dF \hat{w}
+// div w = (1 / det (dF)) \hat{div} \hat{w}
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA H(div) Mass Assemble 2D kernel
+void PAHdivMassSetup2D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op);
+
+// PA H(div) Mass Assemble 3D kernel
+void PAHdivMassSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op);
+
+// PA H(div) Mass Diagonal 2D kernel
+void PAHdivMassAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_);
+
+// PA H(div) Mass Diagonal 3D kernel
+void PAHdivMassAssembleDiagonal3D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_);
+
+void PAHdivMassApply(const int dim,
+                     const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const bool symmetric,
+                     const Array<double> &Bo,
+                     const Array<double> &Bc,
+                     const Array<double> &Bot,
+                     const Array<double> &Bct,
+                     const Vector &op,
+                     const Vector &x,
+                     Vector &y);
+
+// PA H(div) Mass Apply 2D kernel
+void PAHdivMassApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const bool symmetric,
+                       const Array<double> &Bo_,
+                       const Array<double> &Bc_,
+                       const Array<double> &Bot_,
+                       const Array<double> &Bct_,
+                       const Vector &op_,
+                       const Vector &x_,
+                       Vector &y_);
+
+// PA H(div) Mass Apply 3D kernel
+void PAHdivMassApply3D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const bool symmetric,
+                       const Array<double> &Bo_,
+                       const Array<double> &Bc_,
+                       const Array<double> &Bot_,
+                       const Array<double> &Bct_,
+                       const Vector &op_,
+                       const Vector &x_,
+                       Vector &y_);
+
+// Shared memory PA H(div) Mass Apply 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHdivMassApply2D(const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Array<double> &Bot_,
+                                  const Array<double> &Bct_,
+                                  const Vector &op_,
+                                  const Vector &x_,
+                                  Vector &y_,
+                                  const int d1d = 0,
+                                  const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(Bot_);
+   MFEM_CONTRACT_VAR(Bct_);
+
+   static constexpr int VDIM = 2;
+
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   const auto bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   const auto bc = Reshape(Bc_.Read(), Q1D, D1D);
+   const auto D = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   const auto x = Reshape(x_.Read(), D1D*(D1D-1), VDIM, NE);
+   auto y = y_.ReadWrite();
+
+   mfem::forall_3D(NE, Q1D, Q1D, VDIM, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      constexpr int MQ1 = T_Q1D ? T_Q1D : HDIV_MAX_Q1D;
+      constexpr int MD1 = T_D1D ? T_D1D : HDIV_MAX_D1D;
+      constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
+
+      MFEM_SHARED double smo[MQ1*(MD1-1)];
+      DeviceMatrix Bo(smo, D1D-1, Q1D);
+
+      MFEM_SHARED double smc[MQ1*MD1];
+      DeviceMatrix Bc(smc, D1D, Q1D);
+
+      MFEM_SHARED double sm0[VDIM*MDQ*MDQ];
+      MFEM_SHARED double sm1[VDIM*MDQ*MDQ];
+      DeviceMatrix X(sm0, D1D*(D1D-1), VDIM);
+      DeviceCube QD(sm1, Q1D, D1D, VDIM);
+      DeviceCube QQ(sm0, Q1D, Q1D, VDIM);
+
+      // Load X, Bo and Bc into shared memory
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         MFEM_FOREACH_THREAD(dy,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               if (qx < D1D && dy < (D1D-1)) { X(qx + dy*D1D,vd) = x(qx+dy*D1D,vd,e); }
+               if (tidz == 0)
+               {
+                  if (dy < (D1D-1)) { Bo(dy,qx) = bo(qx,dy); }
+                  Bc(dy,qx) = bc(qx,dy);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply B operator
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         DeviceCube Xxy(X, nx, ny, VDIM);
+         DeviceMatrix Bx = (vd == 0) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(dy,y,ny)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               double dq = 0.0;
+               for (int dx = 0; dx < nx; ++dx)
+               {
+                  dq += Xxy(dx,dy,vd) * Bx(dx,qx);
+               }
+               QD(qx,dy,vd) = dq;
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         DeviceMatrix By = (vd == 1) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               double qq = 0.0;
+               for (int dy = 0; dy < ny; ++dy)
+               {
+                  qq += QD(qx,dy,vd) * By(dy,qy);
+               }
+               QQ(qx,qy,vd) = qq;
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply D operator
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               const double Qx = QQ(qx,qy,0);
+               const double Qy = QQ(qx,qy,1);
+
+               const double D11 = D(qx,qy,0,e);
+               const double D12 = D(qx,qy,1,e);
+               const double D21 = symmetric ? D12 : D(qx,qy,2,e);
+               const double D22 = symmetric ? D(qx,qy,2,e) : D(qx,qy,3,e);
+
+               QQ(qx,qy,0) = D11*Qx + D12*Qy;
+               QQ(qx,qy,1) = D21*Qx + D22*Qy;
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply Bt operator
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         DeviceMatrix Btx = (vd == 0) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(dx,x,nx)
+            {
+               double qd = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  qd += QQ(qx,qy,vd) * Btx(dx,qx);
+               }
+               QD(dx,qy,vd) = qd;
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         DeviceMatrix Bty = (vd == 1) ? Bc : Bo;
+         DeviceTensor<4> Yxy(y, nx, ny, VDIM, NE);
+         MFEM_FOREACH_THREAD(dy,y,ny)
+         {
+            MFEM_FOREACH_THREAD(dx,x,nx)
+            {
+               double dd = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  dd += QD(dx,qy,vd) * Bty(dy,qy);
+               }
+               Yxy(dx,dy,vd,e) += dd;
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+   });
+}
+
+// Shared memory PA H(div) Mass Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAHdivMassApply3D(const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Array<double> &Bot_,
+                                  const Array<double> &Bct_,
+                                  const Vector &op_,
+                                  const Vector &x_,
+                                  Vector &y_,
+                                  const int d1d = 0,
+                                  const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(Bot_);
+   MFEM_CONTRACT_VAR(Bct_);
+
+   static constexpr int VDIM = 3;
+
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+   const auto bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   const auto bc = Reshape(Bc_.Read(), Q1D, D1D);
+   const auto D = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   const auto x = Reshape(x_.Read(), D1D*(D1D-1)*(D1D-1), VDIM, NE);
+   auto y = y_.ReadWrite();
+
+   mfem::forall_3D(NE, Q1D, Q1D, VDIM, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+
+      constexpr int MQ1 = T_Q1D ? T_Q1D : HDIV_MAX_Q1D;
+      constexpr int MD1 = T_D1D ? T_D1D : HDIV_MAX_D1D;
+      constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
+
+      MFEM_SHARED double smo[MQ1*(MD1-1)];
+      DeviceMatrix Bo(smo, D1D-1, Q1D);
+
+      MFEM_SHARED double smc[MQ1*MD1];
+      DeviceMatrix Bc(smc, D1D, Q1D);
+
+      MFEM_SHARED double sm0[VDIM*MDQ*MDQ*MDQ];
+      MFEM_SHARED double sm1[VDIM*MDQ*MDQ*MDQ];
+      DeviceMatrix X(sm0, D1D*(D1D-1)*(D1D-1), VDIM);
+      DeviceTensor<4> QDD(sm1, Q1D, D1D, D1D, VDIM);
+      DeviceTensor<4> QQD(sm0, Q1D, Q1D, D1D, VDIM);
+      DeviceTensor<4> QQQ(sm1, Q1D, Q1D, Q1D, VDIM);
+      DeviceTensor<4> DQQ(sm0, D1D, Q1D, Q1D, VDIM);
+      DeviceTensor<4> DDQ(sm1, D1D, D1D, Q1D, VDIM);
+
+      // Load X into shared memory
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         MFEM_FOREACH_THREAD(dz,y,D1D-1)
+         {
+            MFEM_FOREACH_THREAD(dy,x,D1D-1)
+            {
+               MFEM_UNROLL(MD1)
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  X(dx+(dy+dz*(D1D-1))*D1D,vd) = x(dx+(dy+dz*(D1D-1))*D1D,vd,e);
+               }
+            }
+         }
+      }
+      // Load Bo and Bc into shared memory
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D-1)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               Bo(d,q) = bo(q,d);
+            }
+         }
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               Bc(d,q) = bc(q,d);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply B operator
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         const int nz = (vd == 2) ? D1D : D1D-1;
+         DeviceTensor<4> Xxyz(X, nx, ny, nz, VDIM);
+         DeviceMatrix Bx = (vd == 0) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(dy,y,ny)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               double u[D1D];
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
+               MFEM_UNROLL(MD1)
+               for (int dx = 0; dx < nx; ++dx)
+               {
+                  MFEM_UNROLL(MD1)
+                  for (int dz = 0; dz < nz; ++dz)
+                  {
+                     u[dz] += Xxyz(dx,dy,dz,vd) * Bx(dx,qx);
+                  }
+               }
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { QDD(qx,dy,dz,vd) = u[dz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         const int nz = (vd == 2) ? D1D : D1D-1;
+         DeviceMatrix By = (vd == 1) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               double u[D1D];
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
+               MFEM_UNROLL(MD1)
+               for (int dy = 0; dy < ny; ++dy)
+               {
+                  MFEM_UNROLL(MD1)
+                  for (int dz = 0; dz < nz; ++dz)
+                  {
+                     u[dz] += QDD(qx,dy,dz,vd) * By(dy,qy);
+                  }
+               }
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { QQD(qx,qy,dz,vd) = u[dz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nz = (vd == 2) ? D1D : D1D-1;
+         DeviceMatrix Bz = (vd == 2) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               double u[Q1D];
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz)
+               {
+                  MFEM_UNROLL(MQ1)
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     u[qz] += QQD(qx,qy,dz,vd) * Bz(dz,qz);
+                  }
+               }
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { QQQ(qx,qy,qz,vd) = u[qz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply D operator
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qx,x,Q1D)
+            {
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  const double Qx = QQQ(qx,qy,qz,0);
+                  const double Qy = QQQ(qx,qy,qz,1);
+                  const double Qz = QQQ(qx,qy,qz,2);
+
+                  const double D11 = D(qx,qy,qz,0,e);
+                  const double D12 = D(qx,qy,qz,1,e);
+                  const double D13 = D(qx,qy,qz,2,e);
+                  const double D21 = symmetric ? D12 : D(qx,qy,qz,3,e);
+                  const double D22 = symmetric ? D(qx,qy,qz,3,e) : D(qx,qy,qz,4,e);
+                  const double D23 = symmetric ? D(qx,qy,qz,4,e) : D(qx,qy,qz,5,e);
+                  const double D31 = symmetric ? D13 : D(qx,qy,qz,6,e);
+                  const double D32 = symmetric ? D23 : D(qx,qy,qz,7,e);
+                  const double D33 = symmetric ? D(qx,qy,qz,5,e) : D(qx,qy,qz,8,e);
+
+                  QQQ(qx,qy,qz,0) = D11*Qx + D12*Qy + D13*Qz;
+                  QQQ(qx,qy,qz,1) = D21*Qx + D22*Qy + D23*Qz;
+                  QQQ(qx,qy,qz,2) = D31*Qx + D32*Qy + D33*Qz;
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      // Apply Bt operator
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         DeviceMatrix Btx = (vd == 0) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(dx,x,nx)
+            {
+               double u[Q1D];
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
+               MFEM_UNROLL(MQ1)
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  MFEM_UNROLL(MQ1)
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     u[qz] += QQQ(qx,qy,qz,vd) * Btx(dx,qx);
+                  }
+               }
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { DQQ(dx,qy,qz,vd) = u[qz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         DeviceMatrix Bty = (vd == 1) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(dy,y,ny)
+         {
+            MFEM_FOREACH_THREAD(dx,x,nx)
+            {
+               double u[Q1D];
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { u[qz] = 0.0; }
+               MFEM_UNROLL(MQ1)
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  MFEM_UNROLL(MQ1)
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     u[qz] += DQQ(dx,qy,qz,vd) * Bty(dy,qy);
+                  }
+               }
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz) { DDQ(dx,dy,qz,vd) = u[qz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(vd,z,VDIM)
+      {
+         const int nx = (vd == 0) ? D1D : D1D-1;
+         const int ny = (vd == 1) ? D1D : D1D-1;
+         const int nz = (vd == 2) ? D1D : D1D-1;
+         DeviceTensor<5> Yxyz(y, nx, ny, nz, VDIM, NE);
+         DeviceMatrix Btz = (vd == 2) ? Bc : Bo;
+         MFEM_FOREACH_THREAD(dy,y,ny)
+         {
+            MFEM_FOREACH_THREAD(dx,x,nx)
+            {
+               double u[D1D];
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { u[dz] = 0.0; }
+               MFEM_UNROLL(MQ1)
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  MFEM_UNROLL(MD1)
+                  for (int dz = 0; dz < nz; ++dz)
+                  {
+                     u[dz] += DDQ(dx,dy,qz,vd) * Btz(dz,qz);
+                  }
+               }
+               MFEM_UNROLL(MD1)
+               for (int dz = 0; dz < nz; ++dz) { Yxyz(dx,dy,dz,vd,e) += u[dz]; }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+   });
+}
+
+// PA H(div) div-div Assemble 2D kernel
+void PADivDivSetup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op);
+
+// PA H(div) div-div Assemble 3D kernel
+void PADivDivSetup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op);
+
+// PA H(div) div-div Diagonal 2D kernel
+void PADivDivAssembleDiagonal2D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_);
+
+// PA H(div) div-div Diagonal 3D kernel
+void PADivDivAssembleDiagonal3D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_);
+
+// PA H(div) div-div Apply 2D kernel
+void PADivDivApply2D(const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_);
+
+// PA H(div) div-div Apply 3D kernel
+void PADivDivApply3D(const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_);
+
+// PA H(div)-L2 Assemble 2D kernel
+void PAHdivL2Setup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op);
+
+// PA H(div)-L2 Assemble 3D kernel
+void PAHdivL2Setup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op);
+
+// PA H(div)-L2 Diagonal 2D kernel
+void PAHdivL2AssembleDiagonal_ADAt_2D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_);
+
+// PA H(div)-L2 Diagonal 3D kernel
+void PAHdivL2AssembleDiagonal_ADAt_3D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_);
+
+// PA H(div)-L2 Apply 2D kernel
+void PAHdivL2Apply2D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_);
+
+// PA H(div)-L2 Apply Transpose 2D kernel
+void PAHdivL2ApplyTranspose2D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_);
+
+// PA H(div)-L2 Apply 3D kernel
+void PAHdivL2Apply3D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_);
+
+// PA H(div)-L2 Apply Transpose 3D kernel
+void PAHdivL2ApplyTranspose3D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_);
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/integ/bilininteg_interp_pa.cpp b/fem/integ/bilininteg_interp_pa.cpp
new file mode 100644
index 000000000..0ec03faec
--- /dev/null
+++ b/fem/integ/bilininteg_interp_pa.cpp
@@ -0,0 +1,1938 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+
+namespace mfem
+{
+
+// Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
+// to get a dof in H(curl) (range). You can think of the range as the "test" space
+// and the domain as the "trial" space, but there's no integration.
+static void PAHcurlApplyGradient2D(const int c_dofs1D,
+                                   const int o_dofs1D,
+                                   const int NE,
+                                   const Array<double> &B_,
+                                   const Array<double> &G_,
+                                   const Vector &x_,
+                                   Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += B(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += G(ex, dx) * w[dx][ey];
+            }
+            const int local_index = ey*o_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+
+      // vertical part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += B(ex, dx) * w[dx][ey];
+            }
+            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradient2D to the case where B is identity
+static void PAHcurlApplyGradient2DBId(const int c_dofs1D,
+                                      const int o_dofs1D,
+                                      const int NE,
+                                      const Array<double> &G_,
+                                      const Vector &x_,
+                                      Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            const int dy = ey;
+            w[dx][ey] = x(dx, dy, e);
+         }
+      }
+
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += G(ex, dx) * w[dx][ey];
+            }
+            const int local_index = ey*o_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+
+      // vertical part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int dx = ex;
+            const double s = w[dx][ey];
+            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradientTranspose2D(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &B_, const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part (open x, closed y)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               const int local_index = ey*o_dofs1D + ex;
+               w[dy][ex] += B(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               s += G(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+
+      // vertical part (open y, closed x)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+               w[dy][ex] += G(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               s += B(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradientTranspose2D to the case where
+// B is identity
+static void PAHcurlApplyGradientTranspose2DBId(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part (open x, closed y)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int ey = dy;
+            const int local_index = ey*o_dofs1D + ex;
+            w[dy][ex] = x(local_index, e);
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               s += G(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+
+      // vertical part (open y, closed x)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+               w[dy][ex] += G(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            const int ex = dx;
+            const double s = w[dy][ex];
+            y(dx, dy, e) += s;
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradient3D(const int c_dofs1D,
+                                   const int o_dofs1D,
+                                   const int NE,
+                                   const Array<double> &B_,
+                                   const Array<double> &G_,
+                                   const Vector &x_,
+                                   Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += G(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += B(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += B(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradient3D to the case where B is identity
+static void PAHcurlApplyGradient3DBId(const int c_dofs1D,
+                                      const int o_dofs1D,
+                                      const int NE,
+                                      const Array<double> &G_,
+                                      const Vector &x_,
+                                      Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               const int dz = ez;
+               w1[dx][dy][ez] = x(dx, dy, dz, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int dy = ey;
+               w2[dx][ey][ez] = w1[dx][dy][ez];
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += G(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               const int dz = ez;
+               w1[dx][dy][ez] = x(dx, dy, dz, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int dx = ex;
+               const double s = w2[dx][ey][ez];
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int dy = ey;
+               w2[dx][ey][ez] = w1[dx][dy][ez];
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int dx = ex;
+               const double s = w2[dx][ey][ez];
+               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradientTranspose3D(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &B_, const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < c_dofs1D; ++ez)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  s += G(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < c_dofs1D; ++ez)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  s += B(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < o_dofs1D; ++ez)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  s += B(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradientTranspose3D to the case where
+// B is identity
+static void PAHcurlApplyGradientTranspose3DBId(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               const int ez = dz;
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               w1[ex][ey][dz] = x(local_index, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               const int ey = dy;
+               w2[ex][dy][dz] = w1[ex][ey][dz];
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  s += G(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int ez = dz;
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               w1[ex][ey][dz] = x(local_index, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int ex = dx;
+               double s = w2[ex][dy][dz];
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < o_dofs1D; ++ez)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int ey = dy;
+               w2[ex][dy][dz] = w1[ex][ey][dz];
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int ex = dx;
+               double s = w2[ex][dy][dz];
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+   });
+}
+
+void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
+               "Orders do not match!");
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+   o_dofs1D = maps_O_C->nqpt;
+   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   {
+      B_id = true;
+      c_dofs1D = maps_O_C->ndof;
+   }
+   else
+   {
+      B_id = false;
+      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+      c_dofs1D = maps_C_C->nqpt;
+   }
+}
+
+void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+                                   maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                maps_O_C->G, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
+                                   maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
+                                x, y);
+      }
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
+                                            maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                         maps_O_C->G, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
+                                            maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                         maps_O_C->G, x, y);
+      }
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
+   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in y
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bo(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = ey*o_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in y
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bc(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int local_index = ey*o_dofs1D + ex;
+            const double xd = x(local_index, e);
+
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bc(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+            const double xd = x(local_index, e);
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bo(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < o_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < o_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+   });
+}
+
+void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order);
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+
+   o_dofs1D = maps_O_C->nqpt;
+   c_dofs1D = maps_C_C->nqpt;
+   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
+               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
+
+   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
+                         : 2 * c_dofs1D * o_dofs1D;
+
+   const IntegrationRule & Nodes = test_el->GetNodes();
+
+   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
+   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
+
+   const Array<int> &dofmap = test_el->GetDofMap();
+
+   if (dim == 3)
+   {
+      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
+      // the last 3 having negative signs. Here the signs are all positive, as
+      // signs are applied in ElementRestriction.
+
+      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
+
+      for (int c=0; c<3; ++c)
+      {
+         for (int i=0; i<ndof_test/3; ++i)
+         {
+            const int d = (c*ndof_test/3) + i;
+            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[3];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<3; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+   else // 2D case
+   {
+      const double tk[4] = { 1.,0.,  0.,1. };
+      for (int c=0; c<2; ++c)
+      {
+         for (int i=0; i<ndof_test/2; ++i)
+         {
+            const int d = (c*ndof_test/2) + i;
+            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[2];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<2; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+}
+
+void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                  pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                  pa_data, x, y);
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                           maps_O_C->B, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                           maps_O_C->B, pa_data, x, y);
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_mass_ea.cpp b/fem/integ/bilininteg_mass_ea.cpp
similarity index 99%
rename from fem/bilininteg_mass_ea.cpp
rename to fem/integ/bilininteg_mass_ea.cpp
index cb1e7e064..4cafa68f3 100644
--- a/fem/bilininteg_mass_ea.cpp
+++ b/fem/integ/bilininteg_mass_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
diff --git a/fem/integ/bilininteg_mass_kernels.cpp b/fem/integ/bilininteg_mass_kernels.cpp
new file mode 100644
index 000000000..4f39c9ec8
--- /dev/null
+++ b/fem/integ/bilininteg_mass_kernels.cpp
@@ -0,0 +1,333 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "bilininteg_mass_kernels.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA Mass Diagonal 1D kernel
+static void PAMassAssembleDiagonal1D(const int NE,
+                                     const Array<double> &b,
+                                     const Vector &d,
+                                     Vector &y,
+                                     const int D1D,
+                                     const int Q1D)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx, e) = 0.0;
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            Y(dx, e) += B(qx, dx) * B(qx, dx) * D(qx, e);
+         }
+      }
+   });
+}
+
+void PAMassAssembleDiagonal(const int dim, const int D1D,
+                            const int Q1D, const int NE,
+                            const Array<double> &B,
+                            const Vector &D,
+                            Vector &Y)
+{
+   if (dim == 1)
+   {
+      return PAMassAssembleDiagonal1D(NE,B,D,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x22: return SmemPAMassAssembleDiagonal2D<2,2,16>(NE,B,D,Y);
+         case 0x33: return SmemPAMassAssembleDiagonal2D<3,3,16>(NE,B,D,Y);
+         case 0x44: return SmemPAMassAssembleDiagonal2D<4,4,8>(NE,B,D,Y);
+         case 0x55: return SmemPAMassAssembleDiagonal2D<5,5,8>(NE,B,D,Y);
+         case 0x66: return SmemPAMassAssembleDiagonal2D<6,6,4>(NE,B,D,Y);
+         case 0x77: return SmemPAMassAssembleDiagonal2D<7,7,4>(NE,B,D,Y);
+         case 0x88: return SmemPAMassAssembleDiagonal2D<8,8,2>(NE,B,D,Y);
+         case 0x99: return SmemPAMassAssembleDiagonal2D<9,9,2>(NE,B,D,Y);
+         default:   return PAMassAssembleDiagonal2D(NE,B,D,Y,D1D,Q1D);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x23: return SmemPAMassAssembleDiagonal3D<2,3>(NE,B,D,Y);
+         case 0x24: return SmemPAMassAssembleDiagonal3D<2,4>(NE,B,D,Y);
+         case 0x26: return SmemPAMassAssembleDiagonal3D<2,6>(NE,B,D,Y);
+         case 0x34: return SmemPAMassAssembleDiagonal3D<3,4>(NE,B,D,Y);
+         case 0x35: return SmemPAMassAssembleDiagonal3D<3,5>(NE,B,D,Y);
+         case 0x45: return SmemPAMassAssembleDiagonal3D<4,5>(NE,B,D,Y);
+         case 0x48: return SmemPAMassAssembleDiagonal3D<4,8>(NE,B,D,Y);
+         case 0x56: return SmemPAMassAssembleDiagonal3D<5,6>(NE,B,D,Y);
+         case 0x67: return SmemPAMassAssembleDiagonal3D<6,7>(NE,B,D,Y);
+         case 0x78: return SmemPAMassAssembleDiagonal3D<7,8>(NE,B,D,Y);
+         case 0x89: return SmemPAMassAssembleDiagonal3D<8,9>(NE,B,D,Y);
+         default:   return PAMassAssembleDiagonal3D(NE,B,D,Y,D1D,Q1D);
+      }
+   }
+   MFEM_ABORT("Unknown kernel.");
+}
+
+#ifdef MFEM_USE_OCCA
+void OccaPAMassApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaMassApply2D_cpu;
+      if (OccaMassApply2D_cpu.find(id) == OccaMassApply2D_cpu.end())
+      {
+         const occa::kernel MassApply2D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply2D_CPU", props);
+         OccaMassApply2D_cpu.emplace(id, MassApply2D_CPU);
+      }
+      OccaMassApply2D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaMassApply2D_gpu;
+      if (OccaMassApply2D_gpu.find(id) == OccaMassApply2D_gpu.end())
+      {
+         const occa::kernel MassApply2D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply2D_GPU", props);
+         OccaMassApply2D_gpu.emplace(id, MassApply2D_GPU);
+      }
+      OccaMassApply2D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+}
+
+void OccaPAMassApply3D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaMassApply3D_cpu;
+      if (OccaMassApply3D_cpu.find(id) == OccaMassApply3D_cpu.end())
+      {
+         const occa::kernel MassApply3D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply3D_CPU", props);
+         OccaMassApply3D_cpu.emplace(id, MassApply3D_CPU);
+      }
+      OccaMassApply3D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaMassApply3D_gpu;
+      if (OccaMassApply3D_gpu.find(id) == OccaMassApply3D_gpu.end())
+      {
+         const occa::kernel MassApply3D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply3D_GPU", props);
+         OccaMassApply3D_gpu.emplace(id, MassApply3D_GPU);
+      }
+      OccaMassApply3D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+}
+#endif // MFEM_USE_OCCA
+
+MFEM_HOST_DEVICE inline
+void PAMassApply1D_Element(const int e,
+                           const int NE,
+                           const double *b_,
+                           const double *bt_,
+                           const double *d_,
+                           const double *x_,
+                           double *y_,
+                           const int d1d = 0,
+                           const int q1d = 0)
+{
+   const int D1D = d1d;
+   const int Q1D = q1d;
+   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
+   auto D = ConstDeviceMatrix(d_, Q1D, NE);
+   auto X = ConstDeviceMatrix(x_, D1D, NE);
+   auto Y = DeviceMatrix(y_, D1D, NE);
+
+   constexpr int max_Q1D = MAX_Q1D;
+   double XQ[max_Q1D];
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      XQ[qx] = 0.0;
+   }
+   for (int dx = 0; dx < D1D; ++dx)
+   {
+      const double s = X(dx,e);
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         XQ[qx] += B(qx,dx)*s;
+      }
+   }
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      const double q = XQ[qx]*D(qx,e);
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx,e) += Bt(dx,qx) * q;
+      }
+   }
+}
+
+// PA Mass Apply 1D kernel
+static void PAMassApply1D(const int NE,
+                          const Array<double> &b_,
+                          const Array<double> &bt_,
+                          const Vector &d_,
+                          const Vector &x_,
+                          Vector &y_,
+                          const int d1d = 0,
+                          const int q1d = 0)
+{
+   MFEM_VERIFY(d1d <= MAX_D1D, "");
+   MFEM_VERIFY(q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply1D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+void PAMassApply(const int dim,
+                 const int D1D,
+                 const int Q1D,
+                 const int NE,
+                 const Array<double> &B,
+                 const Array<double> &Bt,
+                 const Vector &D,
+                 const Vector &X,
+                 Vector &Y)
+{
+#ifdef MFEM_USE_OCCA
+   if (DeviceCanUseOcca())
+   {
+      if (dim == 2)
+      {
+         return OccaPAMassApply2D(D1D,Q1D,NE,B,Bt,D,X,Y);
+      }
+      if (dim == 3)
+      {
+         return OccaPAMassApply3D(D1D,Q1D,NE,B,Bt,D,X,Y);
+      }
+      MFEM_ABORT("OCCA PA Mass Apply unknown kernel!");
+   }
+#endif // MFEM_USE_OCCA
+   const int id = (D1D << 4) | Q1D;
+
+   if (dim == 1)
+   {
+      return PAMassApply1D(NE,B,Bt,D,X,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPAMassApply2D<2,2,16>(NE,B,Bt,D,X,Y);
+         case 0x24: return SmemPAMassApply2D<2,4,16>(NE,B,Bt,D,X,Y);
+         case 0x33: return SmemPAMassApply2D<3,3,16>(NE,B,Bt,D,X,Y);
+         case 0x34: return SmemPAMassApply2D<3,4,16>(NE,B,Bt,D,X,Y);
+         case 0x35: return SmemPAMassApply2D<3,5,16>(NE,B,Bt,D,X,Y);
+         case 0x36: return SmemPAMassApply2D<3,6,16>(NE,B,Bt,D,X,Y);
+         case 0x44: return SmemPAMassApply2D<4,4,8>(NE,B,Bt,D,X,Y);
+         case 0x46: return SmemPAMassApply2D<4,6,8>(NE,B,Bt,D,X,Y);
+         case 0x48: return SmemPAMassApply2D<4,8,4>(NE,B,Bt,D,X,Y);
+         case 0x55: return SmemPAMassApply2D<5,5,8>(NE,B,Bt,D,X,Y);
+         case 0x57: return SmemPAMassApply2D<5,7,8>(NE,B,Bt,D,X,Y);
+         case 0x58: return SmemPAMassApply2D<5,8,2>(NE,B,Bt,D,X,Y);
+         case 0x66: return SmemPAMassApply2D<6,6,4>(NE,B,Bt,D,X,Y);
+         case 0x77: return SmemPAMassApply2D<7,7,4>(NE,B,Bt,D,X,Y);
+         case 0x88: return SmemPAMassApply2D<8,8,2>(NE,B,Bt,D,X,Y);
+         case 0x99: return SmemPAMassApply2D<9,9,2>(NE,B,Bt,D,X,Y);
+         default:   return PAMassApply2D(NE,B,Bt,D,X,Y,D1D,Q1D);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPAMassApply3D<2,2>(NE,B,Bt,D,X,Y);
+         case 0x23: return SmemPAMassApply3D<2,3>(NE,B,Bt,D,X,Y);
+         case 0x24: return SmemPAMassApply3D<2,4>(NE,B,Bt,D,X,Y);
+         case 0x26: return SmemPAMassApply3D<2,6>(NE,B,Bt,D,X,Y);
+         case 0x34: return SmemPAMassApply3D<3,4>(NE,B,Bt,D,X,Y);
+         case 0x35: return SmemPAMassApply3D<3,5>(NE,B,Bt,D,X,Y);
+         case 0x36: return SmemPAMassApply3D<3,6>(NE,B,Bt,D,X,Y);
+         case 0x37: return SmemPAMassApply3D<3,7>(NE,B,Bt,D,X,Y);
+         case 0x45: return SmemPAMassApply3D<4,5>(NE,B,Bt,D,X,Y);
+         case 0x46: return SmemPAMassApply3D<4,6>(NE,B,Bt,D,X,Y);
+         case 0x48: return SmemPAMassApply3D<4,8>(NE,B,Bt,D,X,Y);
+         case 0x56: return SmemPAMassApply3D<5,6>(NE,B,Bt,D,X,Y);
+         case 0x58: return SmemPAMassApply3D<5,8>(NE,B,Bt,D,X,Y);
+         case 0x67: return SmemPAMassApply3D<6,7>(NE,B,Bt,D,X,Y);
+         case 0x78: return SmemPAMassApply3D<7,8>(NE,B,Bt,D,X,Y);
+         case 0x89: return SmemPAMassApply3D<8,9>(NE,B,Bt,D,X,Y);
+         case 0x9A: return SmemPAMassApply3D<9,10>(NE,B,Bt,D,X,Y);
+         default:   return PAMassApply3D(NE,B,Bt,D,X,Y,D1D,Q1D);
+      }
+   }
+   mfem::out << "Unknown kernel 0x" << std::hex << id << std::endl;
+   MFEM_ABORT("Unknown kernel.");
+}
+
+} // namespace internal
+
+} // namespace mfem
diff --git a/fem/bilininteg_mass_pa.hpp b/fem/integ/bilininteg_mass_kernels.hpp
similarity index 53%
rename from fem/bilininteg_mass_pa.hpp
rename to fem/integ/bilininteg_mass_kernels.hpp
index 73c8892e1..991a5ff99 100644
--- a/fem/bilininteg_mass_pa.hpp
+++ b/fem/integ/bilininteg_mass_kernels.hpp
@@ -9,12 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_BILININTEG_MASS_PA_HPP
-#define MFEM_BILININTEG_MASS_PA_HPP
+#ifndef MFEM_BILININTEG_MASS_KERNELS_HPP
+#define MFEM_BILININTEG_MASS_KERNELS_HPP
 
-#include "../config/config.hpp"
-#include "../general/forall.hpp"
-#include "../linalg/dtensor.hpp"
+#include "../../config/config.hpp"
+#include "../../general/array.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+#include "../../linalg/vector.hpp"
+#include "../bilininteg.hpp"
 
 namespace mfem
 {
@@ -22,6 +25,315 @@ namespace mfem
 namespace internal
 {
 
+void PAMassAssembleDiagonal(const int dim, const int D1D,
+                            const int Q1D, const int NE,
+                            const Array<double> &B,
+                            const Vector &D,
+                            Vector &Y);
+
+// PA Mass Diagonal 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAMassAssembleDiagonal2D(const int NE,
+                                     const Array<double> &b,
+                                     const Vector &d,
+                                     Vector &y,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QD[MQ1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            QD[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               QD[qx][dy] += B(qy, dy) * B(qy, dy) * D(qx, qy, e);
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               Y(dx,dy,e) += B(qx, dx) * B(qx, dx) * QD[qx][dy];
+            }
+         }
+      }
+   });
+}
+
+// Shared memory PA Mass Diagonal 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+inline void SmemPAMassAssembleDiagonal2D(const int NE,
+                                         const Array<double> &b_,
+                                         const Vector &d_,
+                                         Vector &y_,
+                                         const int d1d = 0,
+                                         const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto b = Reshape(b_.Read(), Q1D, D1D);
+   auto D = Reshape(d_.Read(), Q1D, Q1D, NE);
+   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, NE);
+   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      MFEM_SHARED double B[MQ1][MD1];
+      MFEM_SHARED double QDZ[NBZ][MQ1][MD1];
+      double (*QD)[MD1] = (double (*)[MD1])(QDZ + tidz);
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               B[q][d] = b(q,d);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(dy,y,D1D)
+         {
+            QD[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               QD[qx][dy] += B[qy][dy] * B[qy][dy] * D(qx, qy, e);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(dy,y,D1D)
+      {
+         MFEM_FOREACH_THREAD(dx,x,D1D)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               // might need absolute values on next line
+               Y(dx,dy,e) += B[qx][dx] * B[qx][dx] * QD[qx][dy];
+            }
+         }
+      }
+   });
+}
+
+// PA Mass Diagonal 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAMassAssembleDiagonal3D(const int NE,
+                                     const Array<double> &b,
+                                     const Vector &d,
+                                     Vector &y,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, Q1D, Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QQD[MQ1][MQ1][MD1];
+      double QDD[MQ1][MD1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               QQD[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  QQD[qx][qy][dz] += B(qz, dz) * B(qz, dz) * D(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               QDD[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  QDD[qx][dy][dz] += B(qy, dy) * B(qy, dy) * QQD[qx][qy][dz];
+               }
+            }
+         }
+      }
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               double t = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  t += B(qx, dx) * B(qx, dx) * QDD[qx][dy][dz];
+               }
+               Y(dx, dy, dz, e) += t;
+            }
+         }
+      }
+   });
+}
+
+// Shared memory PA Mass Diagonal 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAMassAssembleDiagonal3D(const int NE,
+                                         const Array<double> &b_,
+                                         const Vector &d_,
+                                         Vector &y_,
+                                         const int d1d = 0,
+                                         const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto b = Reshape(b_.Read(), Q1D, D1D);
+   auto D = Reshape(d_.Read(), Q1D, Q1D, Q1D, NE);
+   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, D1D, NE);
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      MFEM_SHARED double B[MQ1][MD1];
+      MFEM_SHARED double QQD[MQ1][MQ1][MD1];
+      MFEM_SHARED double QDD[MQ1][MD1][MD1];
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               B[q][d] = b(q,d);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(dz,z,D1D)
+            {
+               QQD[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  QQD[qx][qy][dz] += B[qz][dz] * B[qz][dz] * D(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               QDD[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  QDD[qx][dy][dz] += B[qy][dy] * B[qy][dy] * QQD[qx][qy][dz];
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(dz,z,D1D)
+      {
+         MFEM_FOREACH_THREAD(dy,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(dx,x,D1D)
+            {
+               double t = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  t += B[qx][dx] * B[qx][dx] * QDD[qx][dy][dz];
+               }
+               Y(dx, dy, dz, e) += t;
+            }
+         }
+      }
+   });
+}
+
+void PAMassApply(const int dim,
+                 const int D1D,
+                 const int Q1D,
+                 const int NE,
+                 const Array<double> &B,
+                 const Array<double> &Bt,
+                 const Vector &D,
+                 const Vector &X,
+                 Vector &Y);
+
+#ifdef MFEM_USE_OCCA
+// OCCA PA Mass Apply 2D kernel
+void OccaPAMassApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y);
+
+// OCCA PA Mass Apply 3D kernel
+void OccaPAMassApply3D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y);
+#endif // MFEM_USE_OCCA
+
 template <bool ACCUMULATE = true>
 MFEM_HOST_DEVICE inline
 void PAMassApply2D_Element(const int e,
@@ -625,6 +937,116 @@ void SmemPAMassApply3D_Element(const int e,
    MFEM_SYNC_THREAD;
 }
 
+// PA Mass Apply 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAMassApply2D(const int NE,
+                          const Array<double> &b_,
+                          const Array<double> &bt_,
+                          const Vector &d_,
+                          const Vector &x_,
+                          Vector &y_,
+                          const int d1d = 0,
+                          const int q1d = 0)
+{
+   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
+   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply2D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+// Shared memory PA Mass Apply 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+inline void SmemPAMassApply2D(const int NE,
+                              const Array<double> &b_,
+                              const Array<double> &bt_,
+                              const Vector &d_,
+                              const Vector &x_,
+                              Vector &y_,
+                              const int d1d = 0,
+                              const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(bt_);
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   const auto b = b_.Read();
+   const auto D = d_.Read();
+   const auto x = x_.Read();
+   auto Y = y_.ReadWrite();
+   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::SmemPAMassApply2D_Element<T_D1D,T_Q1D,T_NBZ>(e, NE, b, D, x, Y, d1d,
+                                                             q1d);
+   });
+}
+
+// PA Mass Apply 3D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void PAMassApply3D(const int NE,
+                          const Array<double> &b_,
+                          const Array<double> &bt_,
+                          const Vector &d_,
+                          const Vector &x_,
+                          Vector &y_,
+                          const int d1d = 0,
+                          const int q1d = 0)
+{
+   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
+   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply3D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+// Shared memory PA Mass Apply 2D kernel
+template<int T_D1D = 0, int T_Q1D = 0>
+inline void SmemPAMassApply3D(const int NE,
+                              const Array<double> &b_,
+                              const Array<double> &bt_,
+                              const Vector &d_,
+                              const Vector &x_,
+                              Vector &y_,
+                              const int d1d = 0,
+                              const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(bt_);
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int M1Q = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int M1D = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= M1D, "");
+   MFEM_VERIFY(Q1D <= M1Q, "");
+   auto b = b_.Read();
+   auto d = d_.Read();
+   auto x = x_.Read();
+   auto y = y_.ReadWrite();
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::SmemPAMassApply3D_Element<T_D1D,T_Q1D>(e, NE, b, d, x, y, d1d, q1d);
+   });
+}
+
 } // namespace internal
 
 } // namespace mfem
diff --git a/fem/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
similarity index 92%
rename from fem/bilininteg_mass_mf.cpp
rename to fem/integ/bilininteg_mass_mf.cpp
index 2a89c0ce6..18a0edfca 100644
--- a/fem/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -9,12 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
new file mode 100644
index 000000000..7695403e7
--- /dev/null
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -0,0 +1,222 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
+#include "bilininteg_mass_kernels.hpp"
+
+namespace mfem
+{
+
+void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+
+   // Assuming the same element type
+   fespace = &fes;
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation *T0 = mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
+      }
+      return;
+   }
+   int map_type = el.GetMapType();
+   dim = mesh->Dimension();
+   ne = fes.GetMesh()->GetNE();
+   nq = ir->GetNPoints();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(ne*nq, mt);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
+
+   if (dim==1) { MFEM_ABORT("Not supported yet... stay tuned!"); }
+   if (dim==2)
+   {
+      const int NE = ne;
+      const int Q1D = quad1D;
+      const bool const_c = coeff.Size() == 1;
+      const bool by_val = map_type == FiniteElement::VALUE;
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
+      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
+      mfem::forall_2D(NE,Q1D,Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               const double detJ = J(qx,qy,e);
+               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+            }
+         }
+      });
+   }
+   if (dim==3)
+   {
+      const int NE = ne;
+      const int Q1D = quad1D;
+      const bool const_c = coeff.Size() == 1;
+      const bool by_val = map_type == FiniteElement::VALUE;
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D,Q1D);
+      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D,Q1D,NE);
+      mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qz,z,Q1D)
+               {
+                  const double detJ = J(qx,qy,qz,e);
+                  const double coeff = const_c ? C(0,0,0,0) : C(qx,qy,qz,e);
+                  v(qx,qy,qz,e) = W(qx,qy,qz) * coeff * (by_val ? detJ : 1.0/detJ);
+               }
+            }
+         }
+      });
+   }
+}
+
+void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+
+   // Assuming the same element type
+   fespace = &fes;
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   const FiniteElement &el = *fes.GetBE(0);
+   ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+
+   int map_type = el.GetMapType();
+   dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
+   ne = fes.GetMesh()->GetNBE();
+   nq = ir->GetNPoints();
+   face_geom = mesh->GetFaceGeometricFactors(*ir, GeometricFactors::DETERMINANTS,
+                                             FaceType::Boundary, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(ne*nq, mt);
+
+   FaceQuadratureSpace qs(*mesh, *ir, FaceType::Boundary);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
+
+   const int NE = ne;
+   const int Q1D = quad1D;
+   const bool const_c = coeff.Size() == 1;
+   const bool by_val = map_type == FiniteElement::VALUE;
+   if (dim==1)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D, NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1, 1) :
+                     Reshape(coeff.Read(), Q1D, NE);
+      auto v = Reshape(pa_data.Write(), Q1D, NE);
+      mfem::forall_2D(NE, Q1D, 1, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            const double detJ = J(qx,e);
+            const double coeff = const_c ? C(0,0) : C(qx,e);
+            v(qx,e) =  W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
+         }
+      });
+   }
+   else if (dim==2)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
+      mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               const double detJ = J(qx,qy,e);
+               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+            }
+         }
+      });
+   }
+   else
+   {
+      MFEM_ABORT("Not supported.");
+   }
+}
+
+void MassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      internal::PAMassAssembleDiagonal(dim, dofs1D, quad1D, ne, maps->B, pa_data,
+                                       diag);
+   }
+}
+
+void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      internal::PAMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x,
+                            y);
+   }
+}
+
+void MassIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   // Mass integrator is symmetric
+   AddMultPA(x, y);
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
new file mode 100644
index 000000000..8be2134dd
--- /dev/null
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -0,0 +1,423 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+#include "bilininteg_hcurlhdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *fel = trial_fes.GetFE(0); // In H(curl)
+   const FiniteElement *eltest = test_fes.GetFE(0); // In scalar space
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   if (el->GetDerivType() != mfem::FiniteElement::CURL)
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
+                                                     *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2, "");
+
+   ne = test_fes.GetNE();
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   if (el->GetOrder() == eltest->GetOrder())
+   {
+      dofs1Dtest = dofs1D;
+   }
+   else
+   {
+      dofs1Dtest = dofs1D - 1;
+   }
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (dim == 2)
+   {
+      internal::PAHcurlL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedScalarCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 2)
+   {
+      internal::PAHcurlL2Apply2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                 mapsO->Bt, mapsC->Bt, mapsC->G, pa_data,
+                                 x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                   Vector &y) const
+{
+   if (dim == 2)
+   {
+      internal::PAHcurlL2ApplyTranspose2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                          mapsO->Bt, mapsC->B, mapsC->Gt, pa_data,
+                                          x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with vector test and trial spaces.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+   dofs1Dtest = mapsCtest->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   testType = test_el->GetDerivType();
+   trialType = trial_el->GetDerivType();
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   coeffDim = (DQ ? 3 : 1);
+
+   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
+                            trialType == mfem::FiniteElement::CURL);
+
+   const int ndata = curlSpaces ? (coeffDim == 1 ? 1 : 9) : symmDims;
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::FULL);
+   if (Q) { coeff.Project(*Q); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      if (coeffDim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         internal::PAHcurlHdivMassSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
+                                          geom->J, coeff, pa_data);
+      }
+   }
+   else if (testType == mfem::FiniteElement::DIV &&
+            trialType == mfem::FiniteElement::CURL && dim == 3 &&
+            test_fel->GetOrder() == trial_fel->GetOrder())
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      const int ndata = coeffDim == 1 ? 1 : 9;
+
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPAHcurlL2Apply3D<2,3>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x34:
+               return internal::SmemPAHcurlL2Apply3D<3,4>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x45:
+               return internal::SmemPAHcurlL2Apply3D<4,5>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x56:
+               return internal::SmemPAHcurlL2Apply3D<5,6>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            default:
+               return internal::SmemPAHcurlL2Apply3D(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
+                                    mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
+      }
+   }
+   else if (testType == mfem::FiniteElement::DIV &&
+            trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                   mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
+                                   pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                   Vector &y) const
+{
+   if (testType == mfem::FiniteElement::DIV &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                            mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
+                                            mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
+                                               &trial_fes,
+                                               const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with vector test and trial spaces.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   testType = test_el->GetDerivType();
+   trialType = trial_el->GetDerivType();
+
+   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
+                            trialType == mfem::FiniteElement::CURL);
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+
+   coeffDim = DQ ? 3 : 1;
+   const int ndata = curlSpaces ? (DQ ? 9 : 1) : symmDims;
+
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::FULL);
+   if (Q) { coeff.Project(*Q); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   if (trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      if (coeffDim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         internal::PAHcurlHdivMassSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
+                                          geom->J, coeff, pa_data);
+      }
+   }
+   else if (trialType == mfem::FiniteElement::DIV && dim == 3 &&
+            test_el->GetOrder() == trial_el->GetOrder())
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      const int ndata = coeffDim == 1 ? 1 : 9;
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPAHcurlL2ApplyTranspose3D<2,3>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x34:
+               return internal::SmemPAHcurlL2ApplyTranspose3D<3,4>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x45:
+               return internal::SmemPAHcurlL2ApplyTranspose3D<4,5>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x56:
+               return internal::SmemPAHcurlL2ApplyTranspose3D<5,6>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            default:
+               return internal::SmemPAHcurlL2ApplyTranspose3D(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PAHcurlL2ApplyTranspose3D(dofs1D, quad1D, ndata, ne, mapsO->B,
+                                             mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
+                                             pa_data, x, y);
+      }
+   }
+   else if (testType == mfem::FiniteElement::CURL &&
+            trialType == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                            mapsC->B, mapsO->Bt, mapsC->Bt,
+                                            mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
+                                   pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
new file mode 100644
index 000000000..4f50dcc92
--- /dev/null
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -0,0 +1,757 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+
+namespace mfem
+{
+
+// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
+// integrated against H(curl) test functions corresponding to y.
+static void PAHcurlH1Apply2D(const int D1D,
+                             const int Q1D,
+                             const int NE,
+                             const Array<double> &bc,
+                             const Array<double> &gc,
+                             const Array<double> &bot,
+                             const Array<double> &bct,
+                             const Vector &pa_data,
+                             const Vector &x,
+                             Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
+   auto X = Reshape(x.Read(), D1D, D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         double gradX[MAX_Q1D][2];
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            gradX[qx][0] = 0.0;
+            gradX[qx][1] = 0.0;
+         }
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            const double s = X(dx,dy,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx][0] += s * Bc(qx,dx);
+               gradX[qx][1] += s * Gc(qx,dx);
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double wy  = Bc(qy,dy);
+            const double wDy = Gc(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx  = gradX[qx][0];
+               const double wDx = gradX[qx][1];
+               mass[qy][qx][0] += wDx * wy;
+               mass[qy][qx][1] += wx * wDy;
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O12 = op(qx,qy,1,e);
+            const double O22 = op(qx,qy,2,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O12*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double massX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl), integrated
+// against gradients of H^1 functions corresponding to y.
+static void PAHcurlH1ApplyTranspose2D(const int D1D,
+                                      const int Q1D,
+                                      const int NE,
+                                      const Array<double> &bc,
+                                      const Array<double> &bo,
+                                      const Array<double> &bct,
+                                      const Array<double> &gct,
+                                      const Vector &pa_data,
+                                      const Vector &x,
+                                      Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bt = Reshape(bct.Read(), D1D, Q1D);
+   auto Gt = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O12 = op(qx,qy,1,e);
+            const double O22 = op(qx,qy,2,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O12*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double gradX[MAX_D1D][2];
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            gradX[dx][0] = 0;
+            gradX[dx][1] = 0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double gX = mass[qy][qx][0];
+            const double gY = mass[qy][qx][1];
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               const double wx  = Bt(dx,qx);
+               const double wDx = Gt(dx,qx);
+               gradX[dx][0] += gX * wDx;
+               gradX[dx][1] += gY * wx;
+            }
+         }
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            const double wy  = Bt(dy,qy);
+            const double wDy = Gt(dy,qy);
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               Y(dx,dy,e) += ((gradX[dx][0] * wy) + (gradX[dx][1] * wDy));
+            }
+         }
+      }
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
+// integrated against H(curl) test functions corresponding to y.
+static void PAHcurlH1Apply3D(const int D1D,
+                             const int Q1D,
+                             const int NE,
+                             const Array<double> &bc,
+                             const Array<double> &gc,
+                             const Array<double> &bot,
+                             const Array<double> &bct,
+                             const Vector &pa_data,
+                             const Vector &x,
+                             Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   constexpr static int VDIM = 3;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), D1D, D1D, D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         double gradXY[MAX_Q1D][MAX_Q1D][3];
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradXY[qy][qx][0] = 0.0;
+               gradXY[qy][qx][1] = 0.0;
+               gradXY[qy][qx][2] = 0.0;
+            }
+         }
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            double gradX[MAX_Q1D][2];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx][0] = 0.0;
+               gradX[qx][1] = 0.0;
+            }
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               const double s = X(dx,dy,dz,e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx][0] += s * Bc(qx,dx);
+                  gradX[qx][1] += s * Gc(qx,dx);
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy  = Bc(qy,dy);
+               const double wDy = Gc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx  = gradX[qx][0];
+                  const double wDx = gradX[qx][1];
+                  gradXY[qy][qx][0] += wDx * wy;
+                  gradXY[qy][qx][1] += wx * wDy;
+                  gradXY[qy][qx][2] += wx * wy;
+               }
+            }
+         }
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            const double wz  = Bc(qz,dz);
+            const double wDz = Gc(qz,dz);
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
+                  mass[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
+                  mass[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MAX_D1D][MAX_D1D];
+
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl), integrated
+// against gradients of H^1 functions corresponding to y.
+static void PAHcurlH1ApplyTranspose3D(const int D1D,
+                                      const int Q1D,
+                                      const int NE,
+                                      const Array<double> &bc,
+                                      const Array<double> &bo,
+                                      const Array<double> &bct,
+                                      const Array<double> &gct,
+                                      const Vector &pa_data,
+                                      const Vector &x,
+                                      Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   constexpr static int VDIM = 3;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bt = Reshape(bct.Read(), D1D, Q1D);
+   auto Gt = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double gradXY[MAX_D1D][MAX_D1D][3];
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               gradXY[dy][dx][0] = 0;
+               gradXY[dy][dx][1] = 0;
+               gradXY[dy][dx][2] = 0;
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            double gradX[MAX_D1D][3];
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               gradX[dx][0] = 0;
+               gradX[dx][1] = 0;
+               gradX[dx][2] = 0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double gX = mass[qz][qy][qx][0];
+               const double gY = mass[qz][qy][qx][1];
+               const double gZ = mass[qz][qy][qx][2];
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  const double wx  = Bt(dx,qx);
+                  const double wDx = Gt(dx,qx);
+                  gradX[dx][0] += gX * wDx;
+                  gradX[dx][1] += gY * wx;
+                  gradX[dx][2] += gZ * wx;
+               }
+            }
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               const double wy  = Bt(dy,qy);
+               const double wDy = Gt(dy,qy);
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  gradXY[dy][dx][0] += gradX[dx][0] * wy;
+                  gradXY[dy][dx][1] += gradX[dx][1] * wDy;
+                  gradXY[dy][dx][2] += gradX[dx][2] * wy;
+               }
+            }
+         }
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            const double wz  = Bt(dz,qz);
+            const double wDz = Gt(dz,qz);
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  Y(dx,dy,dz,e) +=
+                     ((gradXY[dy][dx][0] * wz) +
+                      (gradXY[dy][dx][1] * wz) +
+                      (gradXY[dy][dx][2] * wDz));
+               }
+            }
+         }
+      }  // loop qz
+   }); // end of element loop
+}
+
+void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
+                                               &trial_fes,
+                                               const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   // Use the same setup functions as VectorFEMassIntegrator.
+   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                      coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_transpose_ea.cpp b/fem/integ/bilininteg_transpose_ea.cpp
similarity index 99%
rename from fem/bilininteg_transpose_ea.cpp
rename to fem/integ/bilininteg_transpose_ea.cpp
index bea53f1b3..4ff8be04b 100644
--- a/fem/bilininteg_transpose_ea.cpp
+++ b/fem/integ/bilininteg_transpose_ea.cpp
@@ -9,8 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
similarity index 93%
rename from fem/bilininteg_vecdiffusion_mf.cpp
rename to fem/integ/bilininteg_vecdiffusion_mf.cpp
index dae344544..150b662f1 100644
--- a/fem/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -9,12 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_vecdiffusion.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
similarity index 97%
rename from fem/bilininteg_vecdiffusion.cpp
rename to fem/integ/bilininteg_vecdiffusion_pa.cpp
index 1915fca37..88d0b136f 100644
--- a/fem/bilininteg_vecdiffusion.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -9,19 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
 
-// PA Vector Diffusion Integrator
-
 // PA Diffusion Assemble 2D kernel
 static void PAVectorDiffusionSetup2D(const int Q1D,
                                      const int NE,
@@ -226,6 +222,209 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAVectorDiffusionDiagonal2D(const int NE,
+                                        const Array<double> &b,
+                                        const Array<double> &g,
+                                        const Vector &d,
+                                        Vector &y,
+                                        const int d1d = 0,
+                                        const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto G = Reshape(g.Read(), Q1D, D1D);
+   // note the different shape for D, this is a (symmetric) matrix so we only
+   // store necessary entries
+   auto D = Reshape(d.Read(), Q1D*Q1D, 3, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, 2, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      // gradphi \cdot Q \gradphi has four terms
+      double QD0[MQ1][MD1];
+      double QD1[MQ1][MD1];
+      double QD2[MQ1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            QD0[qx][dy] = 0.0;
+            QD1[qx][dy] = 0.0;
+            QD2[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const int q = qx + qy * Q1D;
+               const double D0 = D(q,0,e);
+               const double D1 = D(q,1,e);
+               const double D2 = D(q,2,e);
+               QD0[qx][dy] += B(qy, dy) * B(qy, dy) * D0;
+               QD1[qx][dy] += B(qy, dy) * G(qy, dy) * D1;
+               QD2[qx][dy] += G(qy, dy) * G(qy, dy) * D2;
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            double temp = 0.0;
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               temp += G(qx, dx) * G(qx, dx) * QD0[qx][dy];
+               temp += G(qx, dx) * B(qx, dx) * QD1[qx][dy];
+               temp += B(qx, dx) * G(qx, dx) * QD1[qx][dy];
+               temp += B(qx, dx) * B(qx, dx) * QD2[qx][dy];
+            }
+            Y(dx,dy,0,e) += temp;
+            Y(dx,dy,1,e) += temp;
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAVectorDiffusionDiagonal3D(const int NE,
+                                        const Array<double> &b,
+                                        const Array<double> &g,
+                                        const Vector &d,
+                                        Vector &y,
+                                        const int d1d = 0,
+                                        const int q1d = 0)
+{
+   constexpr int DIM = 3;
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto G = Reshape(g.Read(), Q1D, D1D);
+   auto Q = Reshape(d.Read(), Q1D*Q1D*Q1D, 6, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, 3, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QQD[MQ1][MQ1][MD1];
+      double QDD[MQ1][MD1][MD1];
+      for (int i = 0; i < DIM; ++i)
+      {
+         for (int j = 0; j < DIM; ++j)
+         {
+            // first tensor contraction, along z direction
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dz = 0; dz < D1D; ++dz)
+                  {
+                     QQD[qx][qy][dz] = 0.0;
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const int q = qx + (qy + qz * Q1D) * Q1D;
+                        const int k = j >= i ?
+                                      3 - (3-i)*(2-i)/2 + j:
+                                      3 - (3-j)*(2-j)/2 + i;
+                        const double O = Q(q,k,e);
+                        const double Bz = B(qz,dz);
+                        const double Gz = G(qz,dz);
+                        const double L = i==2 ? Gz : Bz;
+                        const double R = j==2 ? Gz : Bz;
+                        QQD[qx][qy][dz] += L * O * R;
+                     }
+                  }
+               }
+            }
+            // second tensor contraction, along y direction
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dz = 0; dz < D1D; ++dz)
+               {
+                  for (int dy = 0; dy < D1D; ++dy)
+                  {
+                     QDD[qx][dy][dz] = 0.0;
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double By = B(qy,dy);
+                        const double Gy = G(qy,dy);
+                        const double L = i==1 ? Gy : By;
+                        const double R = j==1 ? Gy : By;
+                        QDD[qx][dy][dz] += L * QQD[qx][qy][dz] * R;
+                     }
+                  }
+               }
+            }
+            // third tensor contraction, along x direction
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               for (int dy = 0; dy < D1D; ++dy)
+               {
+                  for (int dx = 0; dx < D1D; ++dx)
+                  {
+                     double temp = 0.0;
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double Bx = B(qx,dx);
+                        const double Gx = G(qx,dx);
+                        const double L = i==0 ? Gx : Bx;
+                        const double R = j==0 ? Gx : Bx;
+                        temp += L * QDD[qx][dy][dz] * R;
+                     }
+                     Y(dx, dy, dz, 0, e) += temp;
+                     Y(dx, dy, dz, 1, e) += temp;
+                     Y(dx, dy, dz, 2, e) += temp;
+                  }
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAVectorDiffusionAssembleDiagonal(const int dim,
+                                              const int D1D,
+                                              const int Q1D,
+                                              const int NE,
+                                              const Array<double> &B,
+                                              const Array<double> &G,
+                                              const Vector &op,
+                                              Vector &y)
+{
+   if (dim == 2)
+   {
+      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
+   }
+   else if (dim == 3)
+   {
+      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
+   }
+   MFEM_ABORT("Dimension not implemented.");
+}
+
+void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      PAVectorDiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne,
+                                        maps->B, maps->G,
+                                        pa_data, diag);
+   }
+}
+
 // PA Diffusion Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0> static
 void PAVectorDiffusionApply2D(const int NE,
@@ -581,212 +780,4 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
 }
 
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAVectorDiffusionDiagonal2D(const int NE,
-                                        const Array<double> &b,
-                                        const Array<double> &g,
-                                        const Vector &d,
-                                        Vector &y,
-                                        const int d1d = 0,
-                                        const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto G = Reshape(g.Read(), Q1D, D1D);
-   // note the different shape for D, this is a (symmetric) matrix so we only
-   // store necessary entries
-   auto D = Reshape(d.Read(), Q1D*Q1D, 3, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, 2, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      // gradphi \cdot Q \gradphi has four terms
-      double QD0[MQ1][MD1];
-      double QD1[MQ1][MD1];
-      double QD2[MQ1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            QD0[qx][dy] = 0.0;
-            QD1[qx][dy] = 0.0;
-            QD2[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const int q = qx + qy * Q1D;
-               const double D0 = D(q,0,e);
-               const double D1 = D(q,1,e);
-               const double D2 = D(q,2,e);
-               QD0[qx][dy] += B(qy, dy) * B(qy, dy) * D0;
-               QD1[qx][dy] += B(qy, dy) * G(qy, dy) * D1;
-               QD2[qx][dy] += G(qy, dy) * G(qy, dy) * D2;
-            }
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            double temp = 0.0;
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               temp += G(qx, dx) * G(qx, dx) * QD0[qx][dy];
-               temp += G(qx, dx) * B(qx, dx) * QD1[qx][dy];
-               temp += B(qx, dx) * G(qx, dx) * QD1[qx][dy];
-               temp += B(qx, dx) * B(qx, dx) * QD2[qx][dy];
-            }
-            Y(dx,dy,0,e) += temp;
-            Y(dx,dy,1,e) += temp;
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAVectorDiffusionDiagonal3D(const int NE,
-                                        const Array<double> &b,
-                                        const Array<double> &g,
-                                        const Vector &d,
-                                        Vector &y,
-                                        const int d1d = 0,
-                                        const int q1d = 0)
-{
-   constexpr int DIM = 3;
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto G = Reshape(g.Read(), Q1D, D1D);
-   auto Q = Reshape(d.Read(), Q1D*Q1D*Q1D, 6, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, 3, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QQD[MQ1][MQ1][MD1];
-      double QDD[MQ1][MD1][MD1];
-      for (int i = 0; i < DIM; ++i)
-      {
-         for (int j = 0; j < DIM; ++j)
-         {
-            // first tensor contraction, along z direction
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dz = 0; dz < D1D; ++dz)
-                  {
-                     QQD[qx][qy][dz] = 0.0;
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const int q = qx + (qy + qz * Q1D) * Q1D;
-                        const int k = j >= i ?
-                                      3 - (3-i)*(2-i)/2 + j:
-                                      3 - (3-j)*(2-j)/2 + i;
-                        const double O = Q(q,k,e);
-                        const double Bz = B(qz,dz);
-                        const double Gz = G(qz,dz);
-                        const double L = i==2 ? Gz : Bz;
-                        const double R = j==2 ? Gz : Bz;
-                        QQD[qx][qy][dz] += L * O * R;
-                     }
-                  }
-               }
-            }
-            // second tensor contraction, along y direction
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dz = 0; dz < D1D; ++dz)
-               {
-                  for (int dy = 0; dy < D1D; ++dy)
-                  {
-                     QDD[qx][dy][dz] = 0.0;
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double By = B(qy,dy);
-                        const double Gy = G(qy,dy);
-                        const double L = i==1 ? Gy : By;
-                        const double R = j==1 ? Gy : By;
-                        QDD[qx][dy][dz] += L * QQD[qx][qy][dz] * R;
-                     }
-                  }
-               }
-            }
-            // third tensor contraction, along x direction
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               for (int dy = 0; dy < D1D; ++dy)
-               {
-                  for (int dx = 0; dx < D1D; ++dx)
-                  {
-                     double temp = 0.0;
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double Bx = B(qx,dx);
-                        const double Gx = G(qx,dx);
-                        const double L = i==0 ? Gx : Bx;
-                        const double R = j==0 ? Gx : Bx;
-                        temp += L * QDD[qx][dy][dz] * R;
-                     }
-                     Y(dx, dy, dz, 0, e) += temp;
-                     Y(dx, dy, dz, 1, e) += temp;
-                     Y(dx, dy, dz, 2, e) += temp;
-                  }
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAVectorDiffusionAssembleDiagonal(const int dim,
-                                              const int D1D,
-                                              const int Q1D,
-                                              const int NE,
-                                              const Array<double> &B,
-                                              const Array<double> &G,
-                                              const Vector &op,
-                                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
-void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAVectorDiffusionAssembleDiagonal(dim,
-                                        dofs1D,
-                                        quad1D,
-                                        ne,
-                                        maps->B,
-                                        maps->G,
-                                        pa_data,
-                                        diag);
-   }
-}
-
 } // namespace mfem
diff --git a/fem/bilininteg_divergence.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
similarity index 99%
rename from fem/bilininteg_divergence.cpp
rename to fem/integ/bilininteg_vecdiv_pa.cpp
index b83acd75c..cc282a49a 100644
--- a/fem/bilininteg_divergence.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -9,17 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
 
-// PA Divergence Integrator
-
 // PA Divergence Assemble 2D kernel
 static void PADivergenceSetup2D(const int Q1D,
                                 const int NE,
diff --git a/fem/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
similarity index 90%
rename from fem/bilininteg_vecmass_mf.cpp
rename to fem/integ/bilininteg_vecmass_mf.cpp
index 2e8d74491..d71f05808 100644
--- a/fem/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -9,19 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
 
-// MF Mass Integrator
-
-// MF Mass Assemble kernel
 void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
diff --git a/fem/bilininteg_vecmass.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
similarity index 96%
rename from fem/bilininteg_vecmass.cpp
rename to fem/integ/bilininteg_vecmass_pa.cpp
index 512cd42d5..faafdf14d 100644
--- a/fem/bilininteg_vecmass.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -9,19 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
 
-// PA Mass Integrator
-
-// PA Mass Assemble kernel
 void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
@@ -111,8 +106,169 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-template<const int T_D1D = 0,
-         const int T_Q1D = 0>
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorMassAssembleDiagonal2D(const int NE,
+                                           const Array<double> &B_,
+                                           const Array<double> &Bt_,
+                                           const Vector &op_,
+                                           Vector &diag_,
+                                           const int d1d = 0,
+                                           const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int VDIM = 2;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(B_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, VDIM, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
+
+      double temp[max_Q1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            temp[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               temp[qx][dy] += B(qy, dy) * B(qy, dy) * op(qx, qy, e);
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            double temp1 = 0.0;
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               temp1 += B(qx, dx) * B(qx, dx) * temp[qx][dy];
+            }
+            y(dx, dy, 0, e) = temp1;
+            y(dx, dy, 1, e) = temp1;
+         }
+      }
+   });
+}
+
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorMassAssembleDiagonal3D(const int NE,
+                                           const Array<double> &B_,
+                                           const Array<double> &Bt_,
+                                           const Vector &op_,
+                                           Vector &diag_,
+                                           const int d1d = 0,
+                                           const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int VDIM = 3;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(B_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
+   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, D1D, VDIM, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d; // nvcc workaround
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      // the following variables are evaluated at compile time
+      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
+
+      double temp[max_Q1D][max_Q1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               temp[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  temp[qx][qy][dz] += B(qz, dz) * B(qz, dz) * op(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      double temp2[max_Q1D][max_D1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               temp2[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  temp2[qx][dy][dz] += B(qy, dy) * B(qy, dy) * temp[qx][qy][dz];
+               }
+            }
+         }
+      }
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               double temp3 = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  temp3 += B(qx, dx) * B(qx, dx)
+                           * temp2[qx][dy][dz];
+               }
+               y(dx, dy, dz, 0, e) = temp3;
+               y(dx, dy, dz, 1, e) = temp3;
+               y(dx, dy, dz, 2, e) = temp3;
+            }
+         }
+      }
+   });
+}
+
+static void PAVectorMassAssembleDiagonal(const int dim,
+                                         const int D1D,
+                                         const int Q1D,
+                                         const int NE,
+                                         const Array<double> &B,
+                                         const Array<double> &Bt,
+                                         const Vector &op,
+                                         Vector &y)
+{
+   if (dim == 2)
+   {
+      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
+   }
+   else if (dim == 3)
+   {
+      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
+   }
+   MFEM_ABORT("Dimension not implemented.");
+}
+
+void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      PAVectorMassAssembleDiagonal(dim, dofs1D, quad1D, ne,
+                                   maps->B, maps->Bt,
+                                   pa_data, diag);
+   }
+}
+
+template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassApply2D(const int NE,
                                 const Array<double> &B_,
                                 const Array<double> &Bt_,
@@ -208,8 +364,7 @@ static void PAVectorMassApply2D(const int NE,
    });
 }
 
-template<const int T_D1D = 0,
-         const int T_Q1D = 0>
+template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassApply3D(const int NE,
                                 const Array<double> &B_,
                                 const Array<double> &Bt_,
@@ -387,171 +542,4 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
 }
 
-template<const int T_D1D = 0, const int T_Q1D = 0>
-static void PAVectorMassAssembleDiagonal2D(const int NE,
-                                           const Array<double> &B_,
-                                           const Array<double> &Bt_,
-                                           const Vector &op_,
-                                           Vector &diag_,
-                                           const int d1d = 0,
-                                           const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int VDIM = 2;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(B_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, VDIM, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
-
-      double temp[max_Q1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            temp[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               temp[qx][dy] += B(qy, dy) * B(qy, dy) * op(qx, qy, e);
-            }
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            double temp1 = 0.0;
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               temp1 += B(qx, dx) * B(qx, dx) * temp[qx][dy];
-            }
-            y(dx, dy, 0, e) = temp1;
-            y(dx, dy, 1, e) = temp1;
-         }
-      }
-   });
-}
-
-template<const int T_D1D = 0, const int T_Q1D = 0>
-static void PAVectorMassAssembleDiagonal3D(const int NE,
-                                           const Array<double> &B_,
-                                           const Array<double> &Bt_,
-                                           const Vector &op_,
-                                           Vector &diag_,
-                                           const int d1d = 0,
-                                           const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int VDIM = 3;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(B_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, D1D, VDIM, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d; // nvcc workaround
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      // the following variables are evaluated at compile time
-      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
-
-      double temp[max_Q1D][max_Q1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               temp[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  temp[qx][qy][dz] += B(qz, dz) * B(qz, dz) * op(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      double temp2[max_Q1D][max_D1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               temp2[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  temp2[qx][dy][dz] += B(qy, dy) * B(qy, dy) * temp[qx][qy][dz];
-               }
-            }
-         }
-      }
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               double temp3 = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  temp3 += B(qx, dx) * B(qx, dx)
-                           * temp2[qx][dy][dz];
-               }
-               y(dx, dy, dz, 0, e) = temp3;
-               y(dx, dy, dz, 1, e) = temp3;
-               y(dx, dy, dz, 2, e) = temp3;
-            }
-         }
-      }
-   });
-}
-
-static void PAVectorMassAssembleDiagonal(const int dim,
-                                         const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &B,
-                                         const Array<double> &Bt,
-                                         const Vector &op,
-                                         Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
-void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAVectorMassAssembleDiagonal(dim,
-                                   dofs1D,
-                                   quad1D,
-                                   ne,
-                                   maps->B,
-                                   maps->Bt,
-                                   pa_data,
-                                   diag);
-   }
-}
-
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vectorfediv_pa.cpp b/fem/integ/bilininteg_vectorfediv_pa.cpp
new file mode 100644
index 000000000..97843a576
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfediv_pa.cpp
@@ -0,0 +1,154 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void
+VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                         const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and
+   // scalar trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const NodalTensorFiniteElement *test_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
+                                  *trial_el, *trial_el,
+                                  *mesh->GetElementTransformation(0));
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder() + 1, "");
+
+   ne = trial_fes.GetNE();
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   L2mapsO = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   L2dofs1D = L2mapsO->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+   if (dim == 2)
+   {
+      MFEM_VERIFY(nq == quad1D * quad1D, "");
+   }
+   else
+   {
+      MFEM_VERIFY(nq == quad1D * quad1D * quad1D, "");
+   }
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (test_el->GetMapType() == FiniteElement::INTEGRAL)
+   {
+      const GeometricFactors *geom =
+         mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS);
+      coeff /= geom->detJ;
+   }
+
+   if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHdivL2Setup3D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
+   {
+      internal::PAHdivL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const Vector &D,
+                                                           Vector &diag)
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2AssembleDiagonal_ADAt_3D(dofs1D, quad1D, L2dofs1D, ne,
+                                                 L2mapsO->B,
+                                                 mapsC->Gt, mapsO->Bt, pa_data, D, diag);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2AssembleDiagonal_ADAt_2D(dofs1D, quad1D, L2dofs1D, ne,
+                                                 L2mapsO->B,
+                                                 mapsC->Gt, mapsO->Bt, pa_data, D, diag);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2Apply3D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
+                                L2mapsO->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2Apply2D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
+                                L2mapsO->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AddMultTransposePA(const Vector &x,
+                                                      Vector &y) const
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2ApplyTranspose3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
+                                         mapsC->Gt, mapsO->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2ApplyTranspose2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
+                                         mapsC->Gt, mapsO->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
new file mode 100644
index 000000000..f8d6f63d4
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -0,0 +1,351 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+#include "bilininteg_hcurlhdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   AssemblePA(fes, fes);
+}
+
+void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                        const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = trial_fes.GetMesh();
+
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = trial_fes.GetNE();
+   MFEM_VERIFY(ne == test_fes.GetNE(),
+               "Different meshes for test and trial spaces");
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1Dtest = mapsCtest->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   trial_fetype = trial_el->GetDerivType();
+   test_fetype = test_el->GetDerivType();
+
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+   if (Q) { coeff.Project(*Q); }
+   else if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dim*dim);
+
+   if ((trial_curl && test_div) || (trial_div && test_curl))
+   {
+      pa_data.SetSize((coeff_dim == 1 ? 1 : dim*dim) * nq * ne,
+                      Device::GetMemoryType());
+   }
+   else
+   {
+      pa_data.SetSize((symmetric ? symmDims : dims*dims) * nq * ne,
+                      Device::GetMemoryType());
+   }
+   if (trial_curl && test_curl && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (trial_curl && test_curl && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, coeff_dim, ne, ir->GetWeights(),
+                                      geom->J, coeff, pa_data);
+   }
+   else if (trial_div && test_div && dim == 3)
+   {
+      internal::PAHdivMassSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else if (trial_div && test_div && dim == 2)
+   {
+      internal::PAHdivMassSetup2D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else if (((trial_curl && test_div) || (trial_div && test_curl)) &&
+            test_fel->GetOrder() == trial_fel->GetOrder())
+   {
+      if (coeff_dim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeff_dim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         const bool tr = (trial_div && test_curl);
+         if (dim == 3)
+         {
+            internal::PAHcurlHdivMassSetup3D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
+                                             geom->J, coeff, pa_data);
+         }
+         else
+         {
+            internal::PAHcurlHdivMassSetup2D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
+                                             geom->J, coeff, pa_data);
+         }
+      }
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      {
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x34:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x45:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x56:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               default:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+            }
+         }
+         else
+         {
+            internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                    mapsO->B, mapsC->B, pa_data, diag);
+         }
+      }
+      else if (trial_fetype == mfem::FiniteElement::DIV &&
+               test_fetype == trial_fetype)
+      {
+         internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+   else // 2D
+   {
+      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      {
+         internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                 mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else if (trial_fetype == mfem::FiniteElement::DIV &&
+               test_fetype == trial_fetype)
+      {
+         internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+}
+
+void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   if (dim == 3)
+   {
+      if (trial_curl && test_curl)
+      {
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlMassApply3D<2,3>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlMassApply3D<3,4>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlMassApply3D<4,5>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlMassApply3D<5,6>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlMassApply3D(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+      }
+      else if (trial_div && test_div)
+      {
+         internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                   mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (trial_curl && test_div)
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                          mapsCtest->Bt, pa_data, x, y);
+      }
+      else if (trial_div && test_curl)
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                          mapsCtest->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+   else // 2D
+   {
+      if (trial_curl && test_curl)
+      {
+         internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                      mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (trial_div && test_div)
+      {
+         internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                   mapsO->Bt,
+                                   mapsC->Bt, pa_data, x, y);
+      }
+      else if ((trial_curl && test_div) || (trial_div && test_curl))
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          trial_curl, false, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+}
+
+void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
+                                                Vector &y) const
+{
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   bool symmetricSpaces = true;
+   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
+   {
+      const bool scalarCoeff = !(DQ || MQ);
+      internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                       trial_div, true, mapsO->B, mapsC->B,
+                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      symmetricSpaces = false;
+   }
+   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
+   {
+      const bool scalarCoeff = !(DQ || MQ);
+      internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                       !trial_curl, true, mapsO->B, mapsC->B,
+                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      symmetricSpaces = false;
+   }
+   if (symmetricSpaces)
+   {
+      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+      {
+         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+      }
+      AddMultPA(x, y);
+   }
+}
+
+} // namespace mfem
diff --git a/fem/lininteg_boundary.cpp b/fem/integ/lininteg_boundary.cpp
similarity index 89%
rename from fem/lininteg_boundary.cpp
rename to fem/integ/lininteg_boundary.cpp
index 68e54dd1b..9b785335c 100644
--- a/fem/lininteg_boundary.cpp
+++ b/fem/integ/lininteg_boundary.cpp
@@ -9,18 +9,19 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BLFEvalAssemble2D(const int vdim, const int nbe, const int d, const int q,
-                       const bool normals, const int *markers, const double *b,
-                       const double *detj, const double *n, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BLFEvalAssemble2D(const int vdim, const int nbe, const int d,
+                              const int q,
+                              const bool normals, const int *markers, const double *b,
+                              const double *detj, const double *n, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -69,11 +70,12 @@ void BLFEvalAssemble2D(const int vdim, const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BLFEvalAssemble3D(const int vdim, const int nbe, const int d, const int q,
-                       const bool normals, const int *markers, const double *b,
-                       const double *detj, const double *n, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BLFEvalAssemble3D(const int vdim, const int nbe, const int d,
+                              const int q,
+                              const bool normals, const int *markers, const double *b,
+                              const double *detj, const double *n, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
similarity index 98%
rename from fem/lininteg_boundary_flux.cpp
rename to fem/integ/lininteg_boundary_flux.cpp
index 411ba0314..98cee62a6 100644
--- a/fem/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
diff --git a/fem/lininteg_domain.cpp b/fem/integ/lininteg_domain.cpp
similarity index 91%
rename from fem/lininteg_domain.cpp
rename to fem/integ/lininteg_domain.cpp
index 6fa0ec82b..6ff7b090d 100644
--- a/fem/lininteg_domain.cpp
+++ b/fem/integ/lininteg_domain.cpp
@@ -9,18 +9,19 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFEvalAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int map_type, const int *markers, const double *b,
-                       const double *detj, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFEvalAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int map_type, const int *markers, const double *b,
+                              const double *detj, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -85,11 +86,12 @@ void DLFEvalAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFEvalAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int map_type, const int *markers, const double *b,
-                       const double *detj, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFEvalAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int map_type, const int *markers, const double *b,
+                              const double *detj, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
similarity index 99%
rename from fem/lininteg_domain_grad.cpp
rename to fem/integ/lininteg_domain_grad.cpp
index 16131e11c..9bf3af218 100644
--- a/fem/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
diff --git a/fem/lininteg_vectorfe_domain.cpp b/fem/integ/lininteg_domain_vectorfe.cpp
similarity index 99%
rename from fem/lininteg_vectorfe_domain.cpp
rename to fem/integ/lininteg_domain_vectorfe.cpp
index 55a3dda7e..16d9e866c 100644
--- a/fem/lininteg_vectorfe_domain.cpp
+++ b/fem/integ/lininteg_domain_vectorfe.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
diff --git a/fem/nonlininteg_vectorconvection_mf.cpp b/fem/integ/nonlininteg_vecconvection_mf.cpp
similarity index 92%
rename from fem/nonlininteg_vectorconvection_mf.cpp
rename to fem/integ/nonlininteg_vecconvection_mf.cpp
index c29f4e920..edcf7d20f 100644
--- a/fem/nonlininteg_vectorconvection_mf.cpp
+++ b/fem/integ/nonlininteg_vecconvection_mf.cpp
@@ -9,14 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "nonlininteg.hpp"
-#include "ceed/integrators/nlconvection/nlconvection.hpp"
-
-using namespace std;
+#include "../nonlininteg.hpp"
+#include "../ceed/integrators/nlconvection/nlconvection.hpp"
 
 namespace mfem
 {
+
 void VectorConvectionNLFIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
diff --git a/fem/nonlininteg_vectorconvection.cpp b/fem/integ/nonlininteg_vecconvection_pa.cpp
similarity index 99%
rename from fem/nonlininteg_vectorconvection.cpp
rename to fem/integ/nonlininteg_vecconvection_pa.cpp
index efa7a10a3..f2f9e242b 100644
--- a/fem/nonlininteg_vectorconvection.cpp
+++ b/fem/integ/nonlininteg_vecconvection_pa.cpp
@@ -9,14 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "nonlininteg.hpp"
-#include "ceed/integrators/nlconvection/nlconvection.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../nonlininteg.hpp"
+#include "../ceed/integrators/nlconvection/nlconvection.hpp"
 
 namespace mfem
 {
+
 void VectorConvectionNLFIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
@@ -566,7 +565,7 @@ static void PAConvectionNLApply3D(const int NE,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0, int T_MAX_D1D =0, int T_MAX_Q1D =0>
+template<int T_D1D = 0, int T_Q1D = 0, int T_MAX_D1D = 0, int T_MAX_Q1D = 0>
 static void SmemPAConvectionNLApply3D(const int NE,
                                       const Array<double> &b_,
                                       const Array<double> &g_,
diff --git a/fem/lininteg.cpp b/fem/lininteg.cpp
index 52abc3cad..c9b6b4699 100644
--- a/fem/lininteg.cpp
+++ b/fem/lininteg.cpp
@@ -9,7 +9,6 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
 #include "fem.hpp"
 #include <cmath>
 
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 6f0af11c6..ba47b8070 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -90,20 +90,20 @@ ParNURBSExtension *ParFiniteElementSpace::MakeLocalNURBSext(
 void ParFiniteElementSpace::ParInit(ParMesh *pm)
 {
    pmesh = pm;
-   pncmesh = NULL;
+   pncmesh = nullptr;
 
    MyComm = pmesh->GetComm();
    NRanks = pmesh->GetNRanks();
    MyRank = pmesh->GetMyRank();
 
-   gcomm = NULL;
+   gcomm = nullptr;
 
-   P = NULL;
-   Pconf = NULL;
+   P = nullptr;
+   Pconf = nullptr;
    nonconf_P = false;
-   Rconf = NULL;
-   R_transpose = NULL;
-   R = NULL;
+   Rconf = nullptr;
+   R_transpose = nullptr;
+   R = nullptr;
 
    num_face_nbr_dofs = -1;
 
@@ -163,18 +163,18 @@ void ParFiniteElementSpace::Construct()
 
       // calculate number of ghost DOFs
       ngvdofs = pncmesh->GetNGhostVertices()
-                * fec->DofForGeometry(Geometry::POINT);
+                * fec->DofForGeometry(Geometry::Type::POINT);
 
       if (pmesh->Dimension() > 1)
       {
          ngedofs = pncmesh->GetNGhostEdges()
-                   * fec->DofForGeometry(Geometry::SEGMENT);
+                   * fec->DofForGeometry(Geometry::Type::SEGMENT);
       }
 
       if (pmesh->Dimension() > 2)
       {
-         int stride = fec->DofForGeometry(Geometry::SQUARE);
-         ngfdofs = pncmesh->GetNGhostFaces() * stride;
+         ngfdofs = pncmesh->GetNGhostFaces()
+                   * fec->DofForGeometry(Geometry::Type::SQUARE);
       }
 
       // total number of ghost DOFs. Ghost DOFs start at index 'ndofs', i.e.,
@@ -519,12 +519,14 @@ ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs) const
 int ParFiniteElementSpace::GetFaceDofs(int i, Array<int> &dofs,
                                        int variant) const
 {
-   if (face_dof && variant == 0)
+   if (face_dof != nullptr && variant == 0)
    {
       face_dof->GetRow(i, dofs);
       return fec->GetOrder();
    }
+
    int p = FiniteElementSpace::GetFaceDofs(i, dofs, variant);
+
    if (Conforming())
    {
       ApplyLDofSigns(dofs);
@@ -1024,6 +1026,38 @@ void ParFiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
 {
    FiniteElementSpace::GetEssentialVDofs(bdr_attr_is_ess, ess_dofs, component);
 
+   if (mesh->Nonconforming())
+   {
+      // In a nonconforming mesh, there can be internal boundary elements that
+      // can only be marked from ghost child faces. These are constructed during the
+      // ExchangeFaceNbrData phase
+
+      Array<int> dofs;
+      for (const auto &kv : pncmesh->GetGhostBoundaryElements())
+      {
+         if (bdr_attr_is_ess[kv.first - 1])
+         {
+            if (component < 0)
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityVDofs(mesh->Dimension() - 1, f, dofs);
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+            else
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityDofs(mesh->Dimension() - 1, f, dofs);
+                  for (auto &d : dofs) { d = DofToVDof(d, component); }
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+         }
+      }
+   }
+
    // Make sure that processors without boundary elements mark
    // their boundary dofs (if they have any).
    Synchronize(ess_dofs);
@@ -1042,18 +1076,28 @@ void ParFiniteElementSpace::GetEssentialTrueDofs(const Array<int>
 #ifdef MFEM_DEBUG
    // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs.
    Array<int> true_ess_dofs2(true_ess_dofs.Size());
-   HypreParMatrix *Pt = Dof_TrueDof_Matrix()->Transpose();
+   auto Pt = std::unique_ptr<HypreParMatrix>(Dof_TrueDof_Matrix()->Transpose());
+
    const int *ess_dofs_data = ess_dofs.HostRead();
    Pt->BooleanMult(1, ess_dofs_data, 0, true_ess_dofs2);
-   delete Pt;
    int counter = 0;
    const int *ted = true_ess_dofs.HostRead();
+   std::string error_msg = "failed dof: ";
    for (int i = 0; i < true_ess_dofs.Size(); i++)
    {
-      if (bool(ted[i]) != bool(true_ess_dofs2[i])) { counter++; }
+      if (bool(ted[i]) != bool(true_ess_dofs2[i]))
+      {
+         error_msg += std::to_string(i) += "(R ";
+         error_msg += std::to_string(bool(ted[i])) += " P^T ";
+         error_msg += std::to_string(bool(true_ess_dofs2[i])) += ") ";
+         ++counter;
+      }
    }
+   MFEM_ASSERT(R->Height() == P->Width(), "!");
+   MFEM_ASSERT(R->Width() == P->Height(), "!");
+   MFEM_ASSERT(R->Width() == ess_dofs.Size(), "!");
    MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter
-               << ", rank = " << MyRank);
+               << ", rank = " << MyRank << ", " << error_msg);
 #endif
 
    MarkerToList(true_ess_dofs, ess_tdof_list);
@@ -1173,6 +1217,7 @@ const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
             Pconf = new DeviceConformingProlongationOperator(*this);
          }
       }
+
       return Pconf;
    }
    else
@@ -1293,6 +1338,7 @@ void ParFiniteElementSpace::ExchangeFaceNbrData()
    // element)
    face_nbr_element_dof.MakeI(recv_el_off[num_face_nbrs]);
 
+
    int *send_I = send_nbr_elem_dof.GetI();
    int *recv_I = face_nbr_element_dof.GetI();
    for (int fn = 0; fn < num_face_nbrs; fn++)
@@ -1842,9 +1888,13 @@ int ParFiniteElementSpace::PackDof(int entity, int index, int edof) const
 static int bisect(const int* array, int size, int value)
 {
    const int* end = array + size;
-   const int* pos = std::lower_bound(array, end, value);
-   MFEM_VERIFY(pos != end, "value not found");
-   return pos - array;
+   const int* pos = std::upper_bound(array, end, value);
+   MFEM_VERIFY(pos != array, "value not found");
+   if (pos == end)
+   {
+      MFEM_VERIFY(*(array+size - 1) == value, "Last entry must be exact")
+   }
+   return pos - array - 1;
 }
 
 /** Dissect a DOF number to obtain the entity type (0=vertex, 1=edge, 2=face),
@@ -1880,7 +1930,8 @@ void ParFiniteElementSpace::UnpackDof(int dof,
          else // mixed faces or var-order space
          {
             const Table &table = var_face_dofs;
-            MFEM_ASSERT(table.Size(), "");
+
+            MFEM_ASSERT(table.Size() > 0, "");
             int jpos = bisect(table.GetJ(), table.Size_of_connections(), dof);
             index = bisect(table.GetI(), table.Size(), jpos);
             edof = dof - table.GetRow(index)[0];
@@ -1948,9 +1999,8 @@ struct PMatrixRow
    void AddRow(const PMatrixRow &other, double coef)
    {
       elems.reserve(elems.size() + other.elems.size());
-      for (unsigned i = 0; i < other.elems.size(); i++)
+      for (const PMatrixElement &oei : other.elems)
       {
-         const PMatrixElement &oei = other.elems[i];
          elems.push_back(
             PMatrixElement(oei.column, oei.stride, coef * oei.value));
       }
@@ -2010,7 +2060,6 @@ class NeighborRowMessage : public VarMessage<314>
 public:
    typedef NCMesh::MeshId MeshId;
    typedef ParNCMesh::GroupId GroupId;
-
    struct RowInfo
    {
       int entity, index, edof;
@@ -2022,8 +2071,6 @@ public:
 
       RowInfo(int ent, int idx, int edof, GroupId grp)
          : entity(ent), index(idx), edof(edof), group(grp) {}
-
-      typedef std::vector<RowInfo> List;
    };
 
    NeighborRowMessage() : pncmesh(NULL) {}
@@ -2034,7 +2081,7 @@ public:
       rows.push_back(RowInfo(entity, index, edof, group, row));
    }
 
-   const RowInfo::List& GetRows() const { return rows; }
+   const std::vector<RowInfo>& GetRows() const { return rows; }
 
    void SetNCMesh(ParNCMesh* pnc) { pncmesh = pnc; }
    void SetFEC(const FiniteElementCollection* fec_) { this->fec = fec_; }
@@ -2042,7 +2089,7 @@ public:
    typedef std::map<int, NeighborRowMessage> Map;
 
 protected:
-   RowInfo::List rows;
+   std::vector<RowInfo> rows;
 
    ParNCMesh *pncmesh;
    const FiniteElementCollection* fec;
@@ -2051,7 +2098,6 @@ protected:
    virtual void Decode(int);
 };
 
-
 void NeighborRowMessage::Encode(int rank)
 {
    std::ostringstream stream;
@@ -2088,6 +2134,7 @@ void NeighborRowMessage::Encode(int rank)
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+
          const RowInfo &ri = rows[row_idx[ent][i]];
          MFEM_ASSERT(ent == ri.entity, "");
 
@@ -2139,35 +2186,58 @@ void NeighborRowMessage::Decode(int rank)
    rows.reserve(nrows);
 
    // read rows
+   // ent = {0,1,2} means vertex, edge and face entity
    for (int ent = 0, gi = 0; ent < 3; ent++)
    {
+      // extract the vertex list, edge list or face list.
       const Array<MeshId> &ids = ent_ids[ent];
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+         // read the particular element dof value off the stream.
          int edof = bin_io::read<int>(stream);
 
-         // handle orientation and sign change
-         const int *ind = NULL;
+         // Handle orientation and sign change.
+         // This flips the sign on dofs where necessary, and for edges and faces
+         // also reorders if flipped, i.e. an edge with
+         //    1 -> 2 -> 3 -> 4
+         // might become
+         //    -4 -> -3 -> -2 -> -1
+         // This cannot treat all face dofs, as they can have rotations and
+         // reflections.
+         const int *ind = nullptr;
+         Geometry::Type geom = Geometry::Type::INVALID;
          if (ent == 1)
          {
+            // edge NC orientation is element defined.
             int eo = pncmesh->GetEdgeNCOrientation(id);
             ind = fec->DofOrderForOrientation(Geometry::SEGMENT, eo);
          }
          else if (ent == 2)
          {
-            Geometry::Type geom = pncmesh->GetFaceGeometry(id.index);
+            geom = pncmesh->GetFaceGeometry(id.index);
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
 
-         double s = 1.0;
+#ifdef MFEM_DEBUG_PMATRIX
+         mfem::out << "Rank " << pncmesh->MyRank << " receiving from " << rank
+                   << ": ent " << ent << ", index " << id.index
+                   << ", edof " << edof << " (id " << id.element << "/"
+                   << int(id.local) << ")" << std::endl;
+#endif
+
+         // If edof arrived with a negative index, flip it, and the scaling.
+         double s = (edof < 0) ? -1.0 : 1.0;
+         edof = (edof < 0) ? -1 - edof : edof;
+
          if (ind && (edof = ind[edof]) < 0)
          {
             edof = -1 - edof;
-            s = -1.0;
+            s *= -1.0;
          }
 
+         // Create a row for this entity, recording the index of the mesh element
          rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
          rows.back().row.read(stream, s);
 
@@ -2177,6 +2247,65 @@ void NeighborRowMessage::Decode(int rank)
                    << rows.back().index << ", edof " << rows.back().edof
                    << std::endl;
 #endif
+
+         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
+             && !Geometry::IsTensorProduct(geom))
+         {
+            // ND face dofs need to be processed together, as the transformation
+            // is given by a 2x2 matrix, so we manually apply an extra increment
+            // to the loop counter and add in a new row. Once these rows are placed, they
+            // represent the Identity transformation. To map across the
+            // processor boundary, we also need to apply a Primal Transformation
+            // (see doftrans.hpp) to a notional "global dof" orientation.
+            // For simplicity we perform the action of these 2x2 matrices
+            // manually using the AddRow capability, followed by a Collapse.
+
+            // To perform the operations, we add and subtract initial versions
+            // of the rows, that represent [1 0; 0 1] in row major notation.
+            // The first row represents the 1 at (0,0) in [1 0; 0 1]
+            // The second row represents the 1 at (1,1) in [1 0; 0 1]
+
+            // We can safely bind this reference as rows was reserved above so
+            // there is no hidden copying that could result in a dangling reference.
+            auto &first_row = rows.back().row;
+            // This is the first "fundamental unit" used in the transformation.
+            const auto initial_first_row = first_row;
+            // Extract the next dof too, and apply any dof order transformation expected.
+            const MeshId &next_id = ids[++i];
+            int fo = pncmesh->GetFaceOrientation(next_id.index);
+            ind = fec->DofOrderForOrientation(geom, fo);
+
+            s = 1.0;
+            edof = bin_io::read<int>(stream);
+            if (ind && (edof = ind[edof]) < 0)
+            {
+               edof = -1 - edof;
+               s = -1.0;
+            }
+            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+            rows.back().row.read(stream, s);
+
+            auto &second_row = rows.back().row;
+
+            // This is the second "fundamental unit" used in the transformation.
+            const auto initial_second_row = second_row;
+
+            const auto T = [&fo]()
+            {
+               auto T = ND_DofTransformation::GetFaceTransform(fo);
+               T(0,0) -= 1;
+               T(1,1) -= 1;
+               return T;
+            }();
+
+            first_row.AddRow(initial_first_row, T(0,0));
+            first_row.AddRow(initial_second_row, T(0,1));
+            second_row.AddRow(initial_first_row, T(1,0));
+            second_row.AddRow(initial_second_row, T(1,1));
+
+            first_row.Collapse();
+            second_row.Collapse();
+         }
       }
    }
 }
@@ -2189,10 +2318,8 @@ ParFiniteElementSpace::ScheduleSendRow(const PMatrixRow &row, int dof,
    int ent, idx, edof;
    UnpackDof(dof, ent, idx, edof);
 
-   const ParNCMesh::CommGroup &group = pncmesh->GetGroup(group_id);
-   for (unsigned i = 0; i < group.size(); i++)
+   for (const auto &rank : pncmesh->GetGroup(group_id))
    {
-      int rank = group[i];
       if (rank != MyRank)
       {
          NeighborRowMessage &msg = send_msg[rank];
@@ -2306,13 +2433,7 @@ int ParFiniteElementSpace
                                        Array<int> *dof_tdof,
                                        bool partial) const
 {
-   // TODO: general face DOF transformations in NeighborRowMessage::Decode()
-   MFEM_VERIFY(!(fec->GetOrder() >= 2
-                 && pmesh->HasGeometry(Geometry::TETRAHEDRON)
-                 && fec->GetContType() == FiniteElementCollection::TANGENTIAL),
-               "Nedelec NC tets of order >= 2 are not supported yet.");
-
-   bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
+   const bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
 
 #ifdef MFEM_PMATRIX_STATS
    n_msgs_sent = n_msgs_recv = 0;
@@ -2321,7 +2442,7 @@ int ParFiniteElementSpace
 
    // *** STEP 1: build master-slave dependency lists ***
 
-   int total_dofs = ndofs + ngdofs;
+   const int total_dofs = ndofs + ngdofs;
    SparseMatrix deps(ndofs, total_dofs);
 
    if (!dg && !partial)
@@ -2332,16 +2453,14 @@ int ParFiniteElementSpace
       for (int entity = 0; entity <= 2; entity++)
       {
          const NCMesh::NCList &list = pncmesh->GetNCList(entity);
-         if (!list.masters.Size()) { continue; }
+         if (list.masters.Size() == 0) { continue; }
 
          IsoparametricTransformation T;
          DenseMatrix I;
 
          // process masters that we own or that affect our edges/faces
-         for (int mi = 0; mi < list.masters.Size(); mi++)
+         for (const auto &mf : list.masters)
          {
-            const NCMesh::Master &mf = list.masters[mi];
-
             // get master DOFs
             if (pncmesh->IsGhost(entity, mf.index))
             {
@@ -2352,10 +2471,10 @@ int ParFiniteElementSpace
                GetEntityDofs(entity, mf.index, master_dofs, mf.Geom());
             }
 
-            if (!master_dofs.Size()) { continue; }
+            if (master_dofs.Size() == 0) { continue; }
 
-            const FiniteElement* fe = fec->FiniteElementForGeometry(mf.Geom());
-            if (!fe) { continue; }
+            const FiniteElement * const fe = fec->FiniteElementForGeometry(mf.Geom());
+            if (fe == nullptr) { continue; }
 
             switch (mf.Geom())
             {
@@ -2371,7 +2490,7 @@ int ParFiniteElementSpace
                const NCMesh::Slave &sf = list.slaves[si];
                if (pncmesh->IsGhost(entity, sf.index)) { continue; }
 
-               const int variant = 0; // TODO parallel var-order
+               constexpr int variant = 0; // TODO parallel var-order
                GetEntityDofs(entity, sf.index, slave_dofs, mf.Geom(), variant);
                if (!slave_dofs.Size()) { continue; }
 
@@ -2398,37 +2517,37 @@ int ParFiniteElementSpace
    {
       Array<int> dofs;
 
-      // initialize dof_group[], dof_owner[]
-      for (int entity = 0; entity <= 2; entity++)
+      auto initialize_group_and_owner = [&dof_group, &dof_owner, &dofs,
+                                                     this](int entity, const MeshId &id)
       {
-         const NCMesh::NCList &list = pncmesh->GetNCList(entity);
+         if (id.index < 0) { return; }
 
-         int lsize[3] =
-         { list.conforming.Size(), list.masters.Size(), list.slaves.Size() };
+         GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
+         GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
 
-         for (int l = 0; l < 3; l++)
-         {
-            for (int i = 0; i < lsize[l]; i++)
-            {
-               const MeshId &id =
-                  (l == 0) ? list.conforming[i] :
-                  (l == 1) ? (const MeshId&) list.masters[i]
-                  /*    */ : (const MeshId&) list.slaves[i];
-
-               if (id.index < 0) { continue; }
+         GetBareDofs(entity, id.index, dofs);
 
-               GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
-               GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
-
-               GetBareDofs(entity, id.index, dofs);
+         for (auto dof : dofs)
+         {
+            dof_owner[dof] = owner;
+            dof_group[dof] = group;
+         }
+      };
 
-               for (int j = 0; j < dofs.Size(); j++)
-               {
-                  int dof = dofs[j];
-                  dof_owner[dof] = owner;
-                  dof_group[dof] = group;
-               }
-            }
+      // initialize dof_group[], dof_owner[] in sequence
+      for (int entity : {0,1,2})
+      {
+         for (const auto &id : pncmesh->GetNCList(entity).conforming)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).masters)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).slaves)
+         {
+            initialize_group_and_owner(entity, id);
          }
       }
    }
@@ -2440,15 +2559,50 @@ int ParFiniteElementSpace
 
    // DOFs that stayed independent and are ours are true DOFs
    int num_true_dofs = 0;
-   for (int i = 0; i < ndofs; i++)
+   for (int i = 0; i < ndofs; ++i)
    {
       if (dof_owner[i] == 0 && deps.RowSize(i) == 0)
       {
-         num_true_dofs++;
+         ++num_true_dofs;
          finalized[i] = true;
       }
    }
 
+#ifdef MFEM_DEBUG_PMATRIX
+   // Helper for dumping diagnostics on one dof
+   auto dof_diagnostics = [&](int dof, bool print_diagnostic)
+   {
+      const auto &comm_group = pncmesh->GetGroup(dof_group[dof]);
+      std::stringstream msg;
+      msg << std::boolalpha;
+      msg << "R" << Mpi::WorldRank() << " dof " << dof
+          << " owner_rank " << pncmesh->GetGroup(dof_owner[dof])[0] << " CommGroup {";
+      for (const auto &x : comm_group)
+      {
+         msg << x << ' ';
+      }
+      msg << "} finalized " << finalized[dof];
+
+      Array<int> cols;
+      if (dof < ndofs)
+      {
+         Vector row;
+         deps.GetRow(dof, cols, row);
+         msg << " deps cols {";
+         for (const auto &x : cols)
+         {
+            msg << x << ' ';
+         }
+         msg << '}';
+      }
+
+      int entity, index, edof;
+      UnpackDof(dof, entity, index, edof);
+      msg << " entity " << entity << " index " << index << " edof " << edof;
+      return msg.str();
+   };
+#endif
+
    // calculate global offsets
    HYPRE_BigInt loc_sizes[2] = { ndofs*vdim, num_true_dofs*vdim };
    Array<HYPRE_BigInt>* offsets[2] = { &dof_offs, &tdof_offs };
@@ -2468,12 +2622,14 @@ int ParFiniteElementSpace
       *dof_tdof = -1;
    }
 
+
+
    std::vector<PMatrixRow> pmatrix(total_dofs);
 
-   bool bynodes = (ordering == Ordering::byNODES);
-   int vdim_factor = bynodes ? 1 : vdim;
-   int dof_stride = bynodes ? ndofs : 1;
-   int tdof_stride = bynodes ? num_true_dofs : 1;
+   const bool bynodes = (ordering == Ordering::byNODES);
+   const int vdim_factor = bynodes ? 1 : vdim;
+   const int dof_stride = bynodes ? ndofs : 1;
+   const int tdof_stride = bynodes ? num_true_dofs : 1;
 
    // big container for all messages we send (the list is for iterations)
    std::list<NeighborRowMessage::Map> send_msg;
@@ -2495,13 +2651,13 @@ int ParFiniteElementSpace
 
          for (int vd = 0; vd < vdim; vd++)
          {
-            int vdof = dof*vdim_factor + vd*dof_stride;
-            int vtdof = tdof*vdim_factor + vd*tdof_stride;
+            const int vdof = dof*vdim_factor + vd*dof_stride;
+            const int vtdof = tdof*vdim_factor + vd*tdof_stride;
 
             if (R_) { (*R_)->Add(vtdof, vdof, 1.0); }
             if (dof_tdof) { (*dof_tdof)[vdof] = vtdof; }
          }
-         tdof++;
+         ++tdof;
       }
    }
 
@@ -2542,14 +2698,12 @@ int ParFiniteElementSpace
          n_rows_recv += recv_msg.GetRows().size();
 #endif
 
-         const NeighborRowMessage::RowInfo::List &rows = recv_msg.GetRows();
-         for (unsigned i = 0; i < rows.size(); i++)
+         for (const auto &ri : recv_msg.GetRows())
          {
-            const NeighborRowMessage::RowInfo &ri = rows[i];
-            int dof = PackDof(ri.entity, ri.index, ri.edof);
+            const int dof = PackDof(ri.entity, ri.index, ri.edof);
             pmatrix[dof] = ri.row;
 
-            if (dof < ndofs && !finalized[dof]) { num_finalized++; }
+            if (dof < ndofs && !finalized[dof]) { ++num_finalized; }
             finalized[dof] = true;
 
             if (ri.group >= 0 && dof_group[dof] != ri.group)
@@ -2567,13 +2721,14 @@ int ParFiniteElementSpace
          done = true;
          for (int dof = 0; dof < ndofs; dof++)
          {
-            if (finalized[dof]) { continue; }
-
-            bool owned = (dof_owner[dof] == 0);
-            bool shared = (dof_group[dof] != 0);
-
-            if (owned && DofFinalizable(dof, finalized, deps))
+            const bool owned = (dof_owner[dof] == 0);
+            if (!finalized[dof]
+                && owned
+                && DofFinalizable(dof, finalized, deps))
             {
+               int ent, idx, edof;
+               UnpackDof(dof, ent, idx, edof);
+
                const int* dep_col = deps.GetRowColumns(dof);
                const double* dep_coef = deps.GetRowEntries(dof);
                int num_dep = deps.RowSize(dof);
@@ -2588,10 +2743,11 @@ int ParFiniteElementSpace
                pmatrix[dof] = buffer;
 
                finalized[dof] = true;
-               num_finalized++;
+               ++num_finalized;
                done = false;
 
                // send row to neighbors who need it
+               const bool shared = (dof_group[dof] != 0);
                if (shared)
                {
                   ScheduleSendRow(pmatrix[dof], dof, dof_group[dof],
@@ -2602,7 +2758,7 @@ int ParFiniteElementSpace
       }
 
 #ifdef MFEM_DEBUG_PMATRIX
-      /*static int dump = 0;
+      static int dump = 0;
       if (dump < 10)
       {
          char fname[100];
@@ -2610,7 +2766,7 @@ int ParFiniteElementSpace
          std::ofstream f(fname);
          DebugDumpDOFs(f, deps, dof_group, dof_owner, finalized);
          dump++;
-      }*/
+      }
 #endif
 
       // send current batch of messages
@@ -2635,10 +2791,9 @@ int ParFiniteElementSpace
    }
 
    // make sure we can discard all send buffers
-   for (std::list<NeighborRowMessage::Map>::iterator
-        it = send_msg.begin(); it != send_msg.end(); ++it)
+   for (auto &msg : send_msg)
    {
-      NeighborRowMessage::WaitAllSent(*it);
+      NeighborRowMessage::WaitAllSent(msg);
    }
 
 #ifdef MFEM_PMATRIX_STATS
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 8f574670b..70f1e6301 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -128,8 +128,8 @@ private:
    void GetGhostVertexDofs(const MeshId &id, Array<int> &dofs) const;
    void GetGhostEdgeDofs(const MeshId &edge_id, Array<int> &dofs) const;
    void GetGhostFaceDofs(const MeshId &face_id, Array<int> &dofs) const;
-
    void GetGhostDofs(int entity, const MeshId &id, Array<int> &dofs) const;
+
    /// Return the dofs associated with the interior of the given mesh entity.
    void GetBareDofs(int entity, int index, Array<int> &dofs) const;
 
@@ -194,15 +194,15 @@ private:
    /// Updates the internal mesh pointer. @warning @a new_mesh must be
    /// <b>topologically identical</b> to the existing mesh. Used if the address
    /// of the Mesh object has changed, e.g. in @a Mesh::Swap.
-   virtual void UpdateMeshPointer(Mesh *new_mesh);
+   void UpdateMeshPointer(Mesh *new_mesh) override;
 
    /// Copies the prolongation and restriction matrices from @a fes.
    ///
    /// Used for low order preconditioning on non-conforming meshes. If the DOFs
    /// require a permutation, it will be supplied by non-NULL @a perm. NULL @a
    /// perm indicates that no permutation is required.
-   virtual void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
-                                               const Array<int> *perm);
+   void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
+                                       const Array<int> *perm) override;
 
 public:
    // Face-neighbor data
@@ -286,32 +286,32 @@ public:
    { return Dof_TrueDof_Matrix()->GetGlobalNumCols(); }
 
    /// Return the number of local vector true dofs.
-   virtual int GetTrueVSize() const { return ltdof_size; }
+   int GetTrueVSize() const override { return ltdof_size; }
 
    /// Returns indexes of degrees of freedom in array dofs for i'th element.
-   virtual DofTransformation *GetElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetElementDofs(int i, Array<int> &dofs) const override;
 
    /// Returns indexes of degrees of freedom for i'th boundary element.
-   virtual DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const override;
 
    /** Returns the indexes of the degrees of freedom for i'th face
        including the dofs for the edges and the vertices of the face. */
-   virtual int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const;
+   int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const override;
 
    /** Returns pointer to the FiniteElement in the FiniteElementCollection
        associated with i'th element in the mesh object. If @a i is greater than
        or equal to the number of local mesh elements, @a i will be interpreted
        as a shifted index of a face neighbor element. */
-   virtual const FiniteElement *GetFE(int i) const;
+   const FiniteElement *GetFE(int i) const override;
 
    /** Returns an Operator that converts L-vectors to E-vectors on each face.
        The parallel version is different from the serial one because of the
        presence of shared faces. Shared faces are treated as interior faces,
        the returned operator handles the communication needed to get the
        shared face values from other MPI ranks */
-   virtual const FaceRestriction *GetFaceRestriction(
+   const FaceRestriction *GetFaceRestriction(
       ElementDofOrdering f_ordering, FaceType type,
-      L2FaceValues mul = L2FaceValues::DoubleValued) const;
+      L2FaceValues mul = L2FaceValues::DoubleValued) const override;
 
    void GetSharedEdgeDofs(int group, int ei, Array<int> &dofs) const;
    void GetSharedTriangleDofs(int group, int fi, Array<int> &dofs) const;
@@ -351,15 +351,15 @@ public:
    void Synchronize(Array<int> &ldof_marker) const;
 
    /// Determine the boundary degrees of freedom
-   virtual void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
-                                  Array<int> &ess_dofs,
-                                  int component = -1) const;
+   void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
+                          Array<int> &ess_dofs,
+                          int component = -1) const override;
 
    /** Get a list of essential true dofs, ess_tdof_list, corresponding to the
        boundary attributes marked in the array bdr_attr_is_ess. */
-   virtual void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
-                                     Array<int> &ess_tdof_list,
-                                     int component = -1);
+   void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
+                             Array<int> &ess_tdof_list,
+                             int component = -1) override;
 
    /** If the given ldof is owned by the current processor, return its local
        tdof number, otherwise return -1 */
@@ -374,19 +374,19 @@ public:
    HYPRE_BigInt GetMyDofOffset() const;
    HYPRE_BigInt GetMyTDofOffset() const;
 
-   virtual const Operator *GetProlongationMatrix() const;
+   const Operator *GetProlongationMatrix() const override;
    /** @brief Return logical transpose of restriction matrix, but in
        non-assembled optimized matrix-free form.
 
        The implementation is like GetProlongationMatrix, but it sets local
        DOFs to the true DOF values if owned locally, otherwise zero. */
-   virtual const Operator *GetRestrictionTransposeOperator() const;
+   const Operator *GetRestrictionTransposeOperator() const override;
    /** Get an Operator that performs the action of GetRestrictionMatrix(),
        but potentially with a non-assembled optimized matrix-free
        implementation. */
-   virtual const Operator *GetRestrictionOperator() const;
+   const Operator *GetRestrictionOperator() const override;
    /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
+   const SparseMatrix *GetRestrictionMatrix() const override
    { Dof_TrueDof_Matrix(); return R; }
 
    // Face-neighbor functions
@@ -412,15 +412,15 @@ public:
    // Transfer parallel true-dof data from coarse_fes, defined on a coarse mesh,
    // to this FE space, defined on a refined mesh. See full documentation in the
    // base class, FiniteElementSpace::GetTrueTransferOperator.
-   virtual void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
-                                        OperatorHandle &T) const;
+   void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
+                                OperatorHandle &T) const override;
 
    /** Reflect changes in the mesh. Calculate one of the refinement/derefinement
        /rebalance matrices, unless want_transform is false. */
-   virtual void Update(bool want_transform = true);
+   void Update(bool want_transform = true) override;
 
    /// Free ParGridFunction transformation matrix (if any), to save memory.
-   virtual void UpdatesFinished()
+   void UpdatesFinished() override
    {
       FiniteElementSpace::UpdatesFinished();
       old_dof_offsets.DeleteAll();
@@ -452,9 +452,9 @@ public:
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
@@ -503,9 +503,9 @@ public:
 
    virtual ~DeviceConformingProlongationOperator();
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 }
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index 182f1b12a..9970fddee 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -469,17 +469,17 @@ void ParGridFunction::GetVectorValue(ElementTransformation &T,
    }
 
    Array<int> vdofs;
-   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no,
-                                                               vdofs);
-   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
-
-   int dof = fe->GetDof();
+   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no, vdofs);
    Vector loc_data;
    face_nbr_data.GetSubVector(vdofs, loc_data);
    if (doftrans)
    {
       doftrans->InvTransformPrimal(loc_data);
    }
+
+   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
+   int dof = fe->GetDof();
+
    if (fe->GetRangeType() == FiniteElement::SCALAR)
    {
       Vector shape(dof);
@@ -944,6 +944,103 @@ void ParGridFunction::SaveAsOne(const char *fname, int precision) const
    SaveAsOne(ofs);
 }
 
+void ParGridFunction::SaveAsSerial(const char *fname, int precision,
+                                   int save_rank) const
+{
+   ParMesh *pmesh = ParFESpace()->GetParMesh();
+   Mesh serial_mesh = pmesh->GetSerialMesh(save_rank);
+   GridFunction serialgf = GetSerialGridFunction(save_rank, serial_mesh);
+
+   if (pmesh->GetMyRank() == save_rank)
+   {
+      serialgf.Save(fname, precision);
+   }
+   MPI_Barrier(pmesh->GetComm());
+}
+
+GridFunction ParGridFunction::GetSerialGridFunction(int save_rank,
+                                                    Mesh &serial_mesh) const
+{
+   ParFiniteElementSpace *pfespace = ParFESpace();
+   ParMesh *pmesh = pfespace->GetParMesh();
+
+   int vdim = pfespace->GetVDim();
+   auto *fec_serial = FiniteElementCollection::New(pfespace->FEColl()->Name());
+   auto *fespace_serial = new FiniteElementSpace(&serial_mesh,
+                                                 fec_serial,
+                                                 vdim,
+                                                 pfespace->GetOrdering());
+
+   GridFunction gf_serial(fespace_serial);
+   gf_serial.MakeOwner(fec_serial);
+   Array<double> vals;
+   Array<int> dofs;
+   MPI_Status status;
+   int n_send_recv;
+
+   int my_rank = pmesh->GetMyRank(),
+       nranks = pmesh->GetNRanks();
+   MPI_Comm my_comm = pmesh->GetComm();
+
+   int elem_count = 0; // To keep track of element count in serial mesh
+
+   if (my_rank == save_rank)
+   {
+      Vector nodeval;
+      for (int e = 0; e < pmesh->GetNE(); e++)
+      {
+         GetElementDofValues(e, nodeval);
+         fespace_serial->GetElementVDofs(elem_count++, dofs);
+         gf_serial.SetSubVector(dofs, nodeval);
+      }
+
+      for (int p = 0; p < nranks; p++)
+      {
+         if (p == save_rank) { continue; }
+         MPI_Recv(&n_send_recv, 1, MPI_INT, p, 448, my_comm, &status);
+         vals.SetSize(n_send_recv);
+         if (n_send_recv)
+         {
+            MPI_Recv(&vals[0], n_send_recv, MPI_DOUBLE, p, 449, my_comm, &status);
+         }
+         for (int i = 0; i < n_send_recv; )
+         {
+            fespace_serial->GetElementVDofs(elem_count++, dofs);
+            gf_serial.SetSubVector(dofs, &vals[i]);
+            i += dofs.Size();
+         }
+      }
+   } // my_rank == save_rank
+   else
+   {
+      n_send_recv = 0;
+      Vector nodeval;
+      for (int e = 0; e < pmesh->GetNE(); e++)
+      {
+         const FiniteElement *fe = pfespace->GetFE(e);
+         n_send_recv += vdim*fe->GetDof();
+      }
+      MPI_Send(&n_send_recv, 1, MPI_INT, save_rank, 448, my_comm);
+      vals.Reserve(n_send_recv);
+      vals.SetSize(0);
+      for (int e = 0; e < pmesh->GetNE(); e++)
+      {
+         GetElementDofValues(e, nodeval);
+         for (int j = 0; j < nodeval.Size(); j++)
+         {
+            vals.Append(nodeval(j));
+         }
+      }
+      if (n_send_recv)
+      {
+         MPI_Send(&vals[0], n_send_recv, MPI_DOUBLE, save_rank, 449, my_comm);
+      }
+   }
+
+   MPI_Barrier(my_comm);
+   return gf_serial;
+}
+
 #ifdef MFEM_USE_ADIOS2
 void ParGridFunction::Save(adios2stream &os,
                            const std::string& variable_name,
diff --git a/fem/pgridfunc.hpp b/fem/pgridfunc.hpp
index 7c7348437..e582f29d1 100644
--- a/fem/pgridfunc.hpp
+++ b/fem/pgridfunc.hpp
@@ -437,6 +437,17 @@ public:
    /// be used for ASCII output.
    virtual void Save(const char *fname, int precision=16) const;
 
+   /// Returns a GridFunction on MPI rank @a save_rank that does not have any
+   /// duplication of vertices/nodes at processor boundaries.
+   /// serial_mesh is obtained using ParMesh::GetSerialMesh(save_rank).
+   /// Note that the @ save_rank argument must match for the
+   /// ParMesh::GetSerialMesh and GetSerialGridFunction method.
+   GridFunction GetSerialGridFunction(int save_rank, Mesh &serial_mesh) const;
+
+   /// Write the serial GridFunction a single file (written using MPI rank 0).
+   /// The given @a precision will be used for ASCII output.
+   void SaveAsSerial(const char *fname, int precision=16, int save_rank=0) const;
+
 #ifdef MFEM_USE_ADIOS2
    /** Save the local portion of the ParGridFunction. This differs from the
        serial GridFunction::Save in that it takes into account the signs of
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index 37dee3c8d..b383af103 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -311,7 +311,13 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
    ParGridFunction x_gf;
    x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(&pfes),
                 const_cast<Vector&>(x), 0);
-   x_gf.ExchangeFaceNbrData();
+   // Face-neighbor information is only needed for interior faces. For boundary
+   // faces, no communication is required.
+   if (type == FaceType::Interior) { x_gf.ExchangeFaceNbrData(); }
+
+   // Early return only after calling ParGridFunction::ExchangeFaceNbrData,
+   // otherwise MPI communication can hang.
+   if (nf == 0) { return; }
 
    // Assumes all elements have the same number of dofs
    const int nface_dofs = face_dofs;
@@ -356,7 +362,6 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
 
 void ParL2FaceRestriction::Mult(const Vector& x, Vector& y) const
 {
-   if (nf==0) { return; }
    if (m==L2FaceValues::DoubleValued)
    {
       DoubleValuedConformingMult(x, y);
@@ -670,6 +675,7 @@ ParNCL2FaceRestriction::ParNCL2FaceRestriction(const ParFiniteElementSpace &fes,
 void ParNCL2FaceRestriction::SingleValuedNonconformingMult(
    const Vector& x, Vector& y) const
 {
+   if (nf == 0) { return; }
    MFEM_ASSERT(
       m == L2FaceValues::SingleValued,
       "This method should be called when m == L2FaceValues::SingleValued.");
@@ -758,7 +764,6 @@ void ParNCL2FaceRestriction::DoubleValuedNonconformingMult(
 
 void ParNCL2FaceRestriction::Mult(const Vector& x, Vector& y) const
 {
-   if (nf==0) { return; }
    if ( type==FaceType::Interior && m==L2FaceValues::DoubleValued )
    {
       DoubleValuedNonconformingMult(x, y);
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index 0765a61c7..da4eab5fa 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -675,38 +675,61 @@ void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void ConformingFaceRestriction::AddMultTranspose(
-   const Vector& x, Vector& y, const double a) const
+static void ConformingFaceRestriction_AddMultTranspose(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &gather_offsets,
+   const Array<int> &gather_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs,
+   const double a)
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
-   auto d_x = Reshape(x.Read(), nface_dofs, vd, nf);
-   auto d_y = Reshape(y.ReadWrite(), t?vd:ndofs, t?ndofs:vd);
+   auto d_x = Reshape(x.Read(), face_dofs, vdim, nf);
+   auto d_y = Reshape(y.ReadWrite(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
       const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
-      for (int c = 0; c < vd; ++c)
+      for (int c = 0; c < vdim; ++c)
       {
          double dof_value = 0;
          for (int j = offset; j < next_offset; ++j)
          {
             const int s_idx_j = d_indices[j];
-            const int sgn = (s_idx_j >= 0) ? 1 : -1;
+            const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
             const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
-            dof_value += sgn*d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += sgn*d_x(idx_j % face_dofs, c, idx_j / face_dofs);
          }
-         d_y(t?c:i,t?i:c) += dof_value;
+         d_y(by_vdim?c:i,by_vdim?i:c) += dof_value;
       }
    });
 }
 
+void ConformingFaceRestriction::AddMultTranspose(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      true, a);
+}
+
+void ConformingFaceRestriction::AddMultTransposeUnsigned(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      false, a);
+}
+
 void ConformingFaceRestriction::CheckFESpace(const ElementDofOrdering
                                              f_ordering)
 {
@@ -1050,6 +1073,7 @@ L2FaceRestriction::L2FaceRestriction(const FiniteElementSpace &fes,
 void L2FaceRestriction::SingleValuedConformingMult(const Vector& x,
                                                    Vector& y) const
 {
+   if (nf == 0) { return; }
    MFEM_ASSERT(
       m == L2FaceValues::SingleValued,
       "This method should be called when m == L2FaceValues::SingleValued.");
@@ -1771,6 +1795,7 @@ void NCL2FaceRestriction::DoubleValuedNonconformingMult(
 void NCL2FaceRestriction::DoubleValuedNonconformingInterpolation(
    Vector& y) const
 {
+   if (nf == 0) { return; }
    // Assumes all elements have the same number of dofs
    const int nface_dofs = face_dofs;
    const int vd = vdim;
@@ -1817,7 +1842,6 @@ void NCL2FaceRestriction::DoubleValuedNonconformingInterpolation(
 
 void NCL2FaceRestriction::Mult(const Vector& x, Vector& y) const
 {
-   if (nf==0) { return; }
    if ( type==FaceType::Interior && m==L2FaceValues::DoubleValued )
    {
       DoubleValuedNonconformingMult(x, y);
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index 3f9ed3fbd..6ee367cde 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -184,6 +184,14 @@ public:
    virtual void AddMultTranspose(const Vector &x, Vector &y,
                                  const double a = 1.0) const override = 0;
 
+   /** @brief Add the face degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                         const double a = 1.0) const
+   {
+      AddMultTranspose(x, y, a);
+   }
+
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y. Perform the same computation as AddMultTranspose, but
        @a x is invalid after calling this method.
@@ -286,6 +294,13 @@ public:
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
+   /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
+       L-Vector @b not taking into account signs from DOF orientations.
+
+       @sa AddMultTranspose(). */
+   void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                 const double a = 1.0) const override;
+
 private:
    /** @brief Compute the scatter indices: L-vector to E-vector, and the offsets
        for the gathering: E-vector to L-vector.
diff --git a/fem/tmop.cpp b/fem/tmop.cpp
index 198a9a085..10f96f4af 100644
--- a/fem/tmop.cpp
+++ b/fem/tmop.cpp
@@ -3160,10 +3160,10 @@ double TMOP_Integrator::GetElementEnergy(const FiniteElement &el,
    {
       const IntegrationPoint &ip = ir.IntPoint(i);
 
-      const DenseMatrix &Jtr_i = Jtr(i);
-      metric->SetTargetJacobian(Jtr_i);
-      CalcInverse(Jtr_i, Jrt);
-      const double weight = ip.weight * Jtr_i.Det();
+      metric->SetTargetJacobian(Jtr(i));
+      CalcInverse(Jtr(i), Jrt);
+      const double weight =
+         (integ_over_target) ? ip.weight * Jtr(i).Det() : ip.weight;
 
       el.CalcDShape(ip, DSh);
       MultAtB(PMatI, DSh, Jpr);
@@ -3279,10 +3279,10 @@ double TMOP_Integrator::GetRefinementElementEnergy(const FiniteElement &el,
       for (int i = 0; i < ir.GetNPoints(); i++)
       {
          const IntegrationPoint &ip = ir.IntPoint(i);
-         const DenseMatrix &Jtr_i = Jtr(i);
-         h_metric->SetTargetJacobian(Jtr_i);
-         CalcInverse(Jtr_i, Jrt);
-         const double weight = ip.weight * Jtr_i.Det();
+         h_metric->SetTargetJacobian(Jtr(i));
+         CalcInverse(Jtr(i), Jrt);
+         const double weight =
+            (integ_over_target) ? ip.weight * Jtr(i).Det() : ip.weight;
 
          el.CalcDShape(ip, DSh);
          MultAtB(PMatI, DSh, Jpr);
@@ -3338,10 +3338,10 @@ double TMOP_Integrator::GetDerefinementElementEnergy(const FiniteElement &el,
    for (int i = 0; i < ir.GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir.IntPoint(i);
-      const DenseMatrix &Jtr_i = Jtr(i);
-      h_metric->SetTargetJacobian(Jtr_i);
-      CalcInverse(Jtr_i, Jrt);
-      const double weight = ip.weight * Jtr_i.Det();
+      h_metric->SetTargetJacobian(Jtr(i));
+      CalcInverse(Jtr(i), Jrt);
+      const double weight =
+         (integ_over_target) ? ip.weight * Jtr(i).Det() : ip.weight;
 
       el.CalcDShape(ip, DSh);
       MultAtB(PMatI, DSh, Jpr);
@@ -3458,10 +3458,9 @@ void TMOP_Integrator::AssembleElementVectorExact(const FiniteElement &el,
    for (int q = 0; q < nqp; q++)
    {
       const IntegrationPoint &ip = ir.IntPoint(q);
-      const DenseMatrix &Jtr_q = Jtr(q);
-      metric->SetTargetJacobian(Jtr_q);
-      CalcInverse(Jtr_q, Jrt);
-      weights(q) = ip.weight * Jtr_q.Det();
+      metric->SetTargetJacobian(Jtr(q));
+      CalcInverse(Jtr(q), Jrt);
+      weights(q) = (integ_over_target) ? ip.weight * Jtr(q).Det() : ip.weight;
       double weight_m = weights(q) * metric_normal;
 
       el.CalcDShape(ip, DSh);
@@ -3589,7 +3588,7 @@ void TMOP_Integrator::AssembleElementGradExact(const FiniteElement &el,
       const DenseMatrix &Jtr_q = Jtr(q);
       metric->SetTargetJacobian(Jtr_q);
       CalcInverse(Jtr_q, Jrt);
-      weights(q) = ip.weight * Jtr_q.Det();
+      weights(q) = (integ_over_target) ? ip.weight * Jtr_q.Det() : ip.weight;
       double weight_m = weights(q) * metric_normal;
 
       el.CalcDShape(ip, DSh);
@@ -3949,7 +3948,9 @@ void TMOP_Integrator::AssembleElementVectorFD(const FiniteElement &el,
       Vector weights(nqp);
       for (int q = 0; q < nqp; q++)
       {
-         weights(q) = ir.IntPoint(q).weight * Jtr(q).Det();
+         weights(q) = (integ_over_target) ?
+                      ir.IntPoint(q).weight * Jtr(q).Det() :
+                      ir.IntPoint(q).weight;
       }
 
       PMatO.UseExternalData(elvect.GetData(), dof, dim);
@@ -4047,7 +4048,9 @@ void TMOP_Integrator::AssembleElementGradFD(const FiniteElement &el,
       Vector weights(nqp);
       for (int q = 0; q < nqp; q++)
       {
-         weights(q) = ir.IntPoint(q).weight * Jtr(q).Det();
+         weights(q) = (integ_over_target) ?
+                      ir.IntPoint(q).weight * Jtr(q).Det() :
+                      ir.IntPoint(q).weight;
       }
 
       if (adapt_lim_gf) { AssembleElemGradAdaptLim(el, Tpr, ir, weights, elmat); }
@@ -4138,7 +4141,8 @@ void TMOP_Integrator::ComputeNormalizationEnergies(const GridFunction &x,
          const IntegrationPoint &ip = ir.IntPoint(q);
          metric->SetTargetJacobian(Jtr(q));
          CalcInverse(Jtr(q), Jrt);
-         const double weight = ip.weight * Jtr(q).Det();
+         const double weight =
+            (integ_over_target) ? ip.weight * Jtr(q).Det() : ip.weight;
 
          fe->CalcDShape(ip, DSh);
          MultAtB(PMatI, DSh, Jpr);
@@ -4165,9 +4169,10 @@ void TMOP_Integrator::ComputeNormalizationEnergies(const GridFunction &x,
       }
    }
 
-   if (targetC->ContainsVolumeInfo() == false)
+   // Cases when integration is not over the target element, or when the
+   // targets don't contain volumetric iniformation.
+   if (integ_over_target == false || targetC->ContainsVolumeInfo() == false)
    {
-      // Special case when the targets don't contain volumetric information.
       lim_energy = fes->GetNE();
    }
 }
diff --git a/fem/tmop.hpp b/fem/tmop.hpp
index a259a9f09..0b017fb8d 100644
--- a/fem/tmop.hpp
+++ b/fem/tmop.hpp
@@ -1743,6 +1743,7 @@ protected:
    // Custom integration rules.
    IntegrationRules *IntegRules;
    int integ_order;
+   bool integ_over_target = true;
 
    // Weight Coefficient multiplying the quality metric term.
    Coefficient *metric_coeff; // not owned, if NULL -> metric_coeff is 1.
@@ -1771,7 +1772,7 @@ protected:
    AdaptivityEvaluator *adapt_lim_eval;  // Not owned.
 
    // Surface fitting.
-   GridFunction *surf_fit_gf;       // Owned, Updated by surf_fit_eval.
+   GridFunction *surf_fit_gf;           // Owned, Updated by surf_fit_eval.
    const Array<bool> *surf_fit_marker;  // Not owned.
    Coefficient *surf_fit_coeff;         // Not owned.
    AdaptivityEvaluator *surf_fit_eval;  // Not owned.
@@ -2001,6 +2002,18 @@ public:
       integ_order = order;
    }
 
+   /// The TMOP integrals can be computed over the reference element or the
+   /// target elements. This function is used to switch between the two options.
+   /// By default integratioin is performed over the target elements.
+   void IntegrateOverTarget(bool integ_over_target_)
+   {
+      MFEM_VERIFY(metric_normal == 1.0 && lim_normal == 1.0,
+                  "This function must be called before EnableNormalization, as "
+                  "the normalization computations must know how to integrate.");
+
+      integ_over_target = integ_over_target_;
+   }
+
    /// Sets a scaling Coefficient for the quality metric term of the integrator.
    /** With this addition, the integrator becomes
           @f$ \int w1 W(Jpt) dx @f$.
diff --git a/general/array.hpp b/general/array.hpp
index c4f7a26b4..552fc34a2 100644
--- a/general/array.hpp
+++ b/general/array.hpp
@@ -77,8 +77,8 @@ public:
    /** @brief Creates array using an existing c-array of asize elements;
        allocsize is set to -asize to indicate that the data will not
        be deleted. */
-   inline Array(T *data_, int asize)
-   { data.Wrap(data_, asize, false); size = asize; }
+   inline Array(T *data_, int asize, bool own_data = false)
+   { data.Wrap(data_, asize, own_data); size = asize; }
 
    /// Copy constructor: deep copy from @a src
    /** This method supports source arrays using any MemoryType. */
@@ -206,7 +206,7 @@ public:
    inline void Copy(Array &copy) const;
 
    /// Make this Array a reference to a pointer.
-   inline void MakeRef(T *, int);
+   inline void MakeRef(T *data_, int size_, bool own_data = false);
 
    /// Make this Array a reference to 'master'.
    inline void MakeRef(const Array &master);
@@ -866,11 +866,11 @@ inline void Array<T>::Copy(Array &copy) const
 }
 
 template <class T>
-inline void Array<T>::MakeRef(T *p, int s)
+inline void Array<T>::MakeRef(T *data_, int size_, bool own_data)
 {
    data.Delete();
-   data.Wrap(p, s, false);
-   size = s;
+   data.Wrap(data_, size_, own_data);
+   size = size_;
 }
 
 template <class T>
diff --git a/general/communication.cpp b/general/communication.cpp
index 10fa6988c..95235edd3 100644
--- a/general/communication.cpp
+++ b/general/communication.cpp
@@ -263,7 +263,7 @@ void GroupTopology::Save(ostream &os) const
    os << "\ncommunication_groups\n";
    os << "number_of_groups " << NGroups() << "\n\n";
 
-   os << "# number of entities in each group, followed by group ids in group\n";
+   os << "# number of entities in each group, followed by ranks in group\n";
    for (int group_id = 0; group_id < NGroups(); ++group_id)
    {
       int group_size = GetGroupSize(group_id);
diff --git a/general/hash.hpp b/general/hash.hpp
index 288d51288..b517172aa 100644
--- a/general/hash.hpp
+++ b/general/hash.hpp
@@ -335,6 +335,8 @@ public:
 
    iterator begin() { return iterator(Base::begin()); }
    iterator end() { return iterator(); }
+   const_iterator begin() const { return const_iterator(Base::cbegin()); }
+   const_iterator end() const { return const_iterator(); }
 
    const_iterator cbegin() const { return const_iterator(Base::cbegin()); }
    const_iterator cend() const { return const_iterator(); }
diff --git a/general/mem_manager.cpp b/general/mem_manager.cpp
index 3f9300de5..acb54d208 100644
--- a/general/mem_manager.cpp
+++ b/general/mem_manager.cpp
@@ -851,7 +851,8 @@ void *MemoryManager::Register_(void *ptr, void *h_tmp, size_t bytes,
 
 void MemoryManager::Register2_(void *h_ptr, void *d_ptr, size_t bytes,
                                MemoryType h_mt, MemoryType d_mt,
-                               bool own, bool alias, unsigned &flags)
+                               bool own, bool alias, unsigned &flags,
+                               unsigned valid_flags)
 {
    MFEM_CONTRACT_VAR(alias);
    MFEM_ASSERT(exists, "Internal error!");
@@ -871,7 +872,7 @@ void MemoryManager::Register2_(void *h_ptr, void *d_ptr, size_t bytes,
    mm.InsertDevice(d_ptr, h_ptr, bytes, h_mt, d_mt);
    flags = (own ? flags | (Mem::OWNS_HOST | Mem::OWNS_DEVICE) :
             flags & ~(Mem::OWNS_HOST | Mem::OWNS_DEVICE)) |
-           Mem::VALID_HOST;
+           valid_flags;
 
    CheckHostMemoryType_(h_mt, h_ptr, alias);
 }
diff --git a/general/mem_manager.hpp b/general/mem_manager.hpp
index 223b7b935..c7c1a23d2 100644
--- a/general/mem_manager.hpp
+++ b/general/mem_manager.hpp
@@ -367,7 +367,8 @@ public:
 
    /** Wrap an externally pair of allocated pointers, @a h_ptr and @a d_ptr,
        of the given host MemoryType @a h_mt. */
-   /** The new memory object will have the device MemoryType set as valid.
+   /** The new memory object will have the device MemoryType set as valid unless
+       specified otherwise by the parameters @a valid_host and @a valid_device.
 
        The given @a h_ptr and @a d_ptr must be allocated appropriately for the
        given host MemoryType and its dual device MemoryType as defined by
@@ -376,13 +377,18 @@ public:
        The parameter @a own determines whether both @a h_ptr and @a d_ptr will
        be deleted when the method Delete() is called.
 
+       The parameters @a valid_host and @a valid_device determine which
+       pointers, host and/or device, will be marked as valid; at least one of
+       the two parameters must be set to true.
+
        @note Ownership can also be controlled by using the following methods:
          - ClearOwnerFlags,
          - SetHostPtrOwner,
          - SetDevicePtrOwner.
 
        @note The current memory is NOT deleted by this method. */
-   inline void Wrap(T *h_ptr, T *d_ptr, int size, MemoryType h_mt, bool own);
+   inline void Wrap(T *h_ptr, T *d_ptr, int size, MemoryType h_mt, bool own,
+                    bool valid_host = false, bool valid_device = true);
 
    /// Create a memory object that points inside the memory object @a base.
    /** The new Memory object uses the same MemoryType(s) as @a base.
@@ -645,7 +651,8 @@ private: // Static methods used by the Memory<T> class
    /// Register a pair of external host and device pointers
    static void Register2_(void *h_ptr, void *d_ptr, size_t bytes,
                           MemoryType h_mt, MemoryType d_mt,
-                          bool own, bool alias, unsigned &flags);
+                          bool own, bool alias, unsigned &flags,
+                          unsigned valid_flags);
 
    /// Register an alias. Note: base_h_ptr may be an alias.
    static void Alias_(void *base_h_ptr, size_t offset, size_t bytes,
@@ -958,17 +965,20 @@ inline void Memory<T>::Wrap(T *ptr, int size, MemoryType mt, bool own)
 }
 
 template <typename T>
-inline void Memory<T>::Wrap(T *ptr, T *d_ptr, int size, MemoryType mt, bool own)
+inline void Memory<T>::Wrap(T *h_ptr_, T *d_ptr, int size, MemoryType h_mt_,
+                            bool own, bool valid_host, bool valid_device)
 {
-   h_mt = mt;
+   h_mt = h_mt_;
    flags = 0;
-   h_ptr = ptr;
+   h_ptr = h_ptr_;
    capacity = size;
    MFEM_ASSERT(IsHostMemory(h_mt),"");
+   MFEM_ASSERT(valid_host || valid_device,"");
    const size_t bytes = size*sizeof(T);
    const MemoryType d_mt = MemoryManager::GetDualMemoryType(h_mt);
    MemoryManager::Register2_(h_ptr, d_ptr, bytes, h_mt, d_mt,
-                             own, false, flags);
+                             own, false, flags,
+                             valid_host*VALID_HOST|valid_device*VALID_DEVICE);
 }
 
 template <typename T>
diff --git a/general/table.cpp b/general/table.cpp
index 4c0bb68ee..da4c0187b 100644
--- a/general/table.cpp
+++ b/general/table.cpp
@@ -218,7 +218,8 @@ void Table::SetIJ(int *newI, int *newJ, int newsize)
 
 int Table::Push(int i, int j)
 {
-   MFEM_ASSERT( i >=0 && i<size, "Index out of bounds.  i = "<<i);
+   MFEM_ASSERT( i >=0 &&
+                i<size, "Index out of bounds.  i = " << i << " size " << size);
 
    for (int k = I[i], end = I[i+1]; k < end; k++)
    {
diff --git a/general/table.hpp b/general/table.hpp
index 2ed9f4a1b..96373b2d1 100644
--- a/general/table.hpp
+++ b/general/table.hpp
@@ -208,6 +208,7 @@ void Transpose (const Table &A, Table &At, int ncols_A_ = -1);
 Table * Transpose (const Table &A);
 
 ///  Transpose an Array<int>
+/** @note The column (TYPE II) indices in each row of @a At will be sorted. */
 void Transpose(const Array<int> &A, Table &At, int ncols_A_ = -1);
 
 ///  C = A * B  (as boolean matrices)
diff --git a/linalg/CMakeLists.txt b/linalg/CMakeLists.txt
index 64778ffdb..c257e5133 100644
--- a/linalg/CMakeLists.txt
+++ b/linalg/CMakeLists.txt
@@ -124,6 +124,11 @@ if (MFEM_USE_MKL_CPARDISO)
   list(APPEND HDRS cpardiso.hpp)
 endif()
 
+if (MFEM_USE_MKL_PARDISO)
+  list(APPEND SRCS pardiso.cpp)
+  list(APPEND HDRS pardiso.hpp)
+endif()
+
 convert_filenames_to_full_paths(SRCS)
 convert_filenames_to_full_paths(HDRS)
 
diff --git a/linalg/linalg.hpp b/linalg/linalg.hpp
index 4192f857d..320a1b88c 100644
--- a/linalg/linalg.hpp
+++ b/linalg/linalg.hpp
@@ -49,6 +49,10 @@
 #include "ginkgo.hpp"
 #endif
 
+#ifdef MFEM_USE_MKL_PARDISO
+#include "pardiso.hpp"
+#endif
+
 #ifdef MFEM_USE_MPI
 #include "hypre_parcsr.hpp"
 #include "hypre.hpp"
diff --git a/linalg/pardiso.cpp b/linalg/pardiso.cpp
new file mode 100644
index 000000000..6053da722
--- /dev/null
+++ b/linalg/pardiso.cpp
@@ -0,0 +1,145 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "pardiso.hpp"
+
+#ifdef MFEM_USE_MKL_PARDISO
+
+#include "sparsemat.hpp"
+
+namespace mfem
+{
+
+PardisoSolver::PardisoSolver()
+{
+   // Indicate that default parameters are changed
+   iparm[0] = 1;
+   // Use METIS for fill-in reordering
+   iparm[1] = 2;
+   // Write the solution into the x vector data
+   iparm[5] = 0;
+   // Maximum number of iterative refinement steps
+   iparm[7] = 2;
+   // Perturb the pivot elements with 1E-13
+   iparm[9] = 13;
+   // Use nonsymmetric permutation
+   iparm[10] = 1;
+   // Perform a check on the input data
+   iparm[26] = 1;
+   // 0-based indexing in CSR data structure
+   iparm[34] = 1;
+   // Maximum number of numerical factorizations
+   maxfct = 1;
+   // Which factorization to use. This parameter is ignored and always assumed
+   // to be equal to 1. See MKL documentation.
+   mnum = 1;
+   // Print statistical information in file
+   msglvl = 0;
+   // Initialize error flag
+   error = 0;
+   // Real nonsymmetric matrix
+   mtype = MatType::REAL_NONSYMMETRIC;
+   // Number of right hand sides
+   nrhs = 1;
+}
+
+void PardisoSolver::SetOperator(const Operator &op)
+{
+   auto mat = const_cast<SparseMatrix *>(dynamic_cast<const SparseMatrix *>(&op));
+
+   MFEM_ASSERT(mat, "Must pass SparseMatrix as Operator");
+
+   height = op.Height();
+
+   width = op.Width();
+
+   m = mat->Size();
+
+   nnz = mat->NumNonZeroElems();
+
+   const int *Ap = mat->HostReadI();
+   const int *Ai = mat->HostReadJ();
+   const double *Ax = mat->HostReadData();
+
+   csr_rowptr = new int[m + 1];
+   reordered_csr_colind = new int[nnz];
+   reordered_csr_nzval = new double[nnz];
+
+   for (int i = 0; i <= m; i++)
+   {
+      csr_rowptr[i] = Ap[i];
+   }
+
+   // Pardiso expects the column indices to be sorted for each row
+   mat->SortColumnIndices();
+
+   for (int i = 0; i < nnz; i++)
+   {
+      reordered_csr_colind[i] = Ai[i];
+      reordered_csr_nzval[i] = Ax[i];
+   }
+
+   // Analyze inputs
+   phase = 11;
+   PARDISO(pt, &maxfct, &mnum, &mtype, &phase, &m, reordered_csr_nzval, csr_rowptr,
+           reordered_csr_colind, &idum, &nrhs,
+           iparm, &msglvl, &ddum, &ddum, &error);
+
+   MFEM_ASSERT(error == 0, "Pardiso symbolic factorization error");
+
+   // Numerical factorization
+   phase = 22;
+   PARDISO(pt, &maxfct, &mnum, &mtype, &phase, &m, reordered_csr_nzval, csr_rowptr,
+           reordered_csr_colind, &idum, &nrhs,
+           iparm, &msglvl, &ddum, &ddum, &error);
+
+   MFEM_ASSERT(error == 0, "Pardiso numerical factorization error");
+}
+
+void PardisoSolver::Mult(const Vector &b, Vector &x) const
+{
+   // Solve
+   phase = 33;
+   PARDISO(pt, &maxfct, &mnum, &mtype, &phase, &m, reordered_csr_nzval, csr_rowptr,
+           reordered_csr_colind, &idum, &nrhs,
+           iparm, &msglvl, b.GetData(), x.GetData(), &error);
+
+   MFEM_ASSERT(error == 0, "Pardiso solve error");
+}
+
+void PardisoSolver::SetPrintLevel(int print_level)
+{
+   msglvl = print_level;
+}
+
+void PardisoSolver::SetMatrixType(MatType mat_type)
+{
+   mtype = mat_type;
+}
+
+PardisoSolver::~PardisoSolver()
+{
+   // Release all internal memory
+   phase = -1;
+   PARDISO(pt, &maxfct, &mnum, &mtype, &phase, &m, reordered_csr_nzval, csr_rowptr,
+           reordered_csr_colind, &idum, &nrhs,
+           iparm, &msglvl, &ddum, &ddum, &error);
+
+   MFEM_ASSERT(error == 0, "Pardiso free error");
+
+   delete[] csr_rowptr;
+   delete[] reordered_csr_colind;
+   delete[] reordered_csr_nzval;
+}
+
+} // namespace mfem
+
+#endif // MFEM_USE_MKL_PARDISO
diff --git a/linalg/pardiso.hpp b/linalg/pardiso.hpp
new file mode 100644
index 000000000..0f1871f44
--- /dev/null
+++ b/linalg/pardiso.hpp
@@ -0,0 +1,116 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_PARDISO
+#define MFEM_PARDISO
+
+#include "../config/config.hpp"
+
+#ifdef MFEM_USE_MKL_PARDISO
+
+#include "mkl_pardiso.h"
+#include "operator.hpp"
+
+namespace mfem
+{
+/**
+ * @brief MKL Parallel Direct Sparse Solver PARDISO
+ *
+ * Interface to MKL PARDISO: the direct sparse solver based on PARDISO
+ */
+class PardisoSolver : public mfem::Solver
+{
+public:
+   enum MatType
+   {
+      REAL_STRUCTURE_SYMMETRIC = 1,
+      REAL_SYMMETRIC_POSITIVE_DEFINITE = 2,
+      REAL_SYMMETRIC_INDEFINITE = -2,
+      REAL_NONSYMMETRIC = 11
+   };
+
+   /**
+    * @brief Construct a new PardisoSolver object
+    *
+    */
+   PardisoSolver();
+
+   /**
+    * @brief Set the Operator object and perform factorization
+    *
+    * @a op needs to be of type SparseMatrix.
+    *
+    * @param op Operator to use in factorization and solve
+    */
+   void SetOperator(const Operator &op) override;
+
+   /**
+    * @brief Solve
+    *
+    * @param b RHS vector
+    * @param x Solution vector
+    */
+   void Mult(const Vector &b, Vector &x) const override;
+
+   /**
+    * @brief Set the print level for MKL Pardiso
+    *
+    * Prints statistics after the factorization and after each solve.
+    *
+    * @param print_lvl Print level
+    */
+   void SetPrintLevel(int print_lvl);
+
+   /**
+    * @brief Set the matrix type
+    *
+    * The matrix type supported is either real and symmetric or real and
+    * non-symmetric.
+    *
+    * @param mat_type Matrix type
+    */
+   void SetMatrixType(MatType mat_type);
+
+   ~PardisoSolver();
+
+private:
+   // Global number of rows
+   int m;
+
+   // Number of nonzero entries
+   int nnz;
+
+   // CSR data structure for the copy data of the local CSR matrix
+   int *csr_rowptr = nullptr;
+   double *reordered_csr_nzval = nullptr;
+   int *reordered_csr_colind = nullptr;
+
+   // Internal solver memory pointer pt,
+   // 32-bit: int pt[64]
+   // 64-bit: long int pt[64] or void *pt[64] should be OK on both architectures
+   mutable void *pt[64] = {0};
+
+   // Solver control parameters, detailed description can be found in the
+   // constructor.
+   mutable int iparm[64] = {0};
+   mutable int maxfct, mnum, msglvl, phase, error;
+   int mtype;
+   int nrhs;
+
+   // Dummy variables
+   mutable int idum;
+   mutable double ddum;
+};
+} // namespace mfem
+
+#endif // MFEM_USE_MKL_PARDISO
+
+#endif
diff --git a/linalg/sundials.cpp b/linalg/sundials.cpp
index fc8d89533..2f1b7aaa6 100644
--- a/linalg/sundials.cpp
+++ b/linalg/sundials.cpp
@@ -20,8 +20,10 @@
 
 // SUNDIALS vectors
 #include <nvector/nvector_serial.h>
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA)
 #include <nvector/nvector_cuda.h>
+#elif defined(MFEM_USE_HIP)
+#include <nvector/nvector_hip.h>
 #endif
 #ifdef MFEM_USE_MPI
 #include <nvector/nvector_mpiplusx.h>
@@ -35,6 +37,14 @@
 // Access SUNDIALS object's content pointer
 #define GET_CONTENT(X) ( X->content )
 
+#if defined(MFEM_USE_CUDA)
+#define SUN_Hip_OR_Cuda(X) X##_Cuda
+#define SUN_HIP_OR_CUDA(X) X##_CUDA
+#elif defined(MFEM_USE_HIP)
+#define SUN_Hip_OR_Cuda(X) X##_Hip
+#define SUN_HIP_OR_CUDA(X) X##_HIP
+#endif
+
 using namespace std;
 
 #if (SUNDIALS_VERSION_MAJOR < 6)
@@ -112,16 +122,16 @@ MFEM_DEPRECATED N_Vector N_VNewEmpty_Parallel(MPI_Comm comm,
 
 #endif // MFEM_USE_MPI
 
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
 
 /// (DEPRECATED) Wrapper function for backwards compatibility with SUNDIALS
 /// version < 6
-MFEM_DEPRECATED N_Vector N_VNewWithMemHelp_Cuda(sunindextype length,
-                                                booleantype use_managed_mem,
-                                                SUNMemoryHelper helper,
-                                                SUNContext)
+MFEM_DEPRECATED N_Vector SUN_Hip_OR_Cuda(N_VNewWithMemHelp)(sunindextype length,
+                                                            booleantype use_managed_mem,
+                                                            SUNMemoryHelper helper,
+                                                            SUNContext)
 {
-   return N_VNewWithMemHelp_Cuda(length, use_managed_mem, helper);
+   return SUN_Hip_OR_Cuda(N_VNewWithMemHelp)(length, use_managed_mem, helper);
 }
 
 /// (DEPRECATED) Wrapper function for backwards compatibility with SUNDIALS
@@ -131,9 +141,9 @@ MFEM_DEPRECATED SUNMemoryHelper SUNMemoryHelper_NewEmpty(SUNContext)
    return SUNMemoryHelper_NewEmpty();
 }
 
-#endif // MFEM_USE_CUDA
+#endif // MFEM_USE_CUDA || MFEM_USE_HIP
 
-#if defined(MFEM_USE_MPI) && defined(MFEM_USE_CUDA)
+#if defined(MFEM_USE_MPI) && (defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP))
 
 /// (DEPRECATED) Wrapper function for backwards compatibility with SUNDIALS
 /// version < 6
@@ -143,7 +153,7 @@ MFEM_DEPRECATED N_Vector N_VMake_MPIPlusX(MPI_Comm comm, N_Vector local_vector,
    return N_VMake_MPIPlusX(comm, local_vector);
 }
 
-#endif // MFEM_USE_MPI && MFEM_USE_CUDA
+#endif // MFEM_USE_MPI && (MFEM_USE_CUDA || MFEM_USE_HIP)
 
 #endif // SUNDIALS_VERSION_MAJOR < 6
 
@@ -206,7 +216,7 @@ Sundials::~Sundials()
 
 #endif // SUNDIALS_VERSION_MAJOR >= 6
 
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
 SundialsMemHelper::SundialsMemHelper(SUNContext context)
 {
    /* Allocate helper */
@@ -215,8 +225,8 @@ SundialsMemHelper::SundialsMemHelper(SUNContext context)
    /* Set the ops */
    h->ops->alloc     = SundialsMemHelper_Alloc;
    h->ops->dealloc   = SundialsMemHelper_Dealloc;
-   h->ops->copy      = SUNMemoryHelper_Copy_Cuda;
-   h->ops->copyasync = SUNMemoryHelper_CopyAsync_Cuda;
+   h->ops->copy      = SUN_Hip_OR_Cuda(SUNMemoryHelper_Copy);
+   h->ops->copyasync = SUN_Hip_OR_Cuda(SUNMemoryHelper_CopyAsync);
 }
 
 SundialsMemHelper::SundialsMemHelper(SundialsMemHelper&& that_helper)
@@ -240,25 +250,25 @@ int SundialsMemHelper::SundialsMemHelper_Alloc(SUNMemoryHelper helper,
 #endif
                                               )
 {
-   int length = memsize/sizeof(double);
    SUNMemory sunmem = SUNMemoryNewEmpty();
 
    sunmem->ptr = NULL;
    sunmem->own = SUNTRUE;
 
+   // memsize is the number of bytes to allocate, so we use Memory<char>
    if (mem_type == SUNMEMTYPE_HOST)
    {
-      Memory<double> mem(length, Device::GetHostMemoryType());
+      Memory<char> mem(memsize, Device::GetHostMemoryType());
       mem.SetHostPtrOwner(false);
-      sunmem->ptr  = mfem::HostReadWrite(mem, length);
+      sunmem->ptr  = mfem::HostReadWrite(mem, memsize);
       sunmem->type = SUNMEMTYPE_HOST;
       mem.Delete();
    }
    else if (mem_type == SUNMEMTYPE_DEVICE || mem_type == SUNMEMTYPE_UVM)
    {
-      Memory<double> mem(length, Device::GetDeviceMemoryType());
+      Memory<char> mem(memsize, Device::GetDeviceMemoryType());
       mem.SetDevicePtrOwner(false);
-      sunmem->ptr  = mfem::ReadWrite(mem, length);
+      sunmem->ptr  = mfem::ReadWrite(mem, memsize);
       sunmem->type = mem_type;
       mem.Delete();
    }
@@ -283,14 +293,14 @@ int SundialsMemHelper::SundialsMemHelper_Dealloc(SUNMemoryHelper helper,
    {
       if (sunmem->type == SUNMEMTYPE_HOST)
       {
-         Memory<double> mem(static_cast<double*>(sunmem->ptr), 1,
-                            Device::GetHostMemoryType(), true);
+         Memory<char> mem(static_cast<char*>(sunmem->ptr), 1,
+                          Device::GetHostMemoryType(), true);
          mem.Delete();
       }
       else if (sunmem->type == SUNMEMTYPE_DEVICE || sunmem->type == SUNMEMTYPE_UVM)
       {
-         Memory<double> mem(static_cast<double*>(sunmem->ptr), 1,
-                            Device::GetDeviceMemoryType(), true);
+         Memory<char> mem(static_cast<char*>(sunmem->ptr), 1,
+                          Device::GetDeviceMemoryType(), true);
          mem.Delete();
       }
       else
@@ -303,7 +313,7 @@ int SundialsMemHelper::SundialsMemHelper_Dealloc(SUNMemoryHelper helper,
    return 0;
 }
 
-#endif // MFEM_USE_CUDA
+#endif // MFEM_USE_CUDA || MFEM_USE_HIP
 
 
 // ---------------------------------------------------------------------------
@@ -329,12 +339,13 @@ void SundialsNVector::_SetNvecDataAndSize_(long glob_size)
          NV_LENGTH_S(local_x) = size;
          break;
       }
-#ifdef MFEM_USE_CUDA
-      case SUNDIALS_NVEC_CUDA:
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
+      case SUN_HIP_OR_CUDA(SUNDIALS_NVEC):
       {
-         N_VSetHostArrayPointer_Cuda(HostReadWrite(), local_x);
-         N_VSetDeviceArrayPointer_Cuda(ReadWrite(), local_x);
-         static_cast<N_VectorContent_Cuda>(GET_CONTENT(local_x))->length = size;
+         SUN_Hip_OR_Cuda(N_VSetHostArrayPointer)(HostReadWrite(), local_x);
+         SUN_Hip_OR_Cuda(N_VSetDeviceArrayPointer)(ReadWrite(), local_x);
+         static_cast<SUN_Hip_OR_Cuda(N_VectorContent)>(GET_CONTENT(
+                                                          local_x))->length = size;
          break;
       }
 #endif
@@ -403,14 +414,14 @@ void SundialsNVector::_SetDataAndSize_()
          if (known) { data.ClearOwnerFlags(); }
          break;
       }
-#ifdef MFEM_USE_CUDA
-      case SUNDIALS_NVEC_CUDA:
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
+      case SUN_HIP_OR_CUDA(SUNDIALS_NVEC):
       {
-         double *h_ptr = N_VGetHostArrayPointer_Cuda(local_x);
-         double *d_ptr = N_VGetDeviceArrayPointer_Cuda(local_x);
+         double *h_ptr = SUN_Hip_OR_Cuda(N_VGetHostArrayPointer)(local_x);
+         double *d_ptr = SUN_Hip_OR_Cuda(N_VGetDeviceArrayPointer)(local_x);
          const bool known = mm.IsKnown(h_ptr);
-         size = N_VGetLength_Cuda(local_x);
-         data.Wrap(h_ptr, d_ptr, size, Device::GetHostMemoryType(), false);
+         size = SUN_Hip_OR_Cuda(N_VGetLength)(local_x);
+         data.Wrap(h_ptr, d_ptr, size, Device::GetHostMemoryType(), false, false, true);
          if (known) { data.ClearOwnerFlags(); }
          UseDevice(true);
          break;
@@ -525,11 +536,12 @@ void SundialsNVector::SetDataAndSize(double *d, int s, long glob_size)
 N_Vector SundialsNVector::MakeNVector(bool use_device)
 {
    N_Vector x;
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
    if (use_device)
    {
-      x = N_VNewWithMemHelp_Cuda(0, UseManagedMemory(), Sundials::GetMemHelper(),
-                                 Sundials::GetContext());
+      x = SUN_Hip_OR_Cuda(N_VNewWithMemHelp)(0, UseManagedMemory(),
+                                             Sundials::GetMemHelper(),
+                                             Sundials::GetContext());
    }
    else
    {
@@ -555,12 +567,13 @@ N_Vector SundialsNVector::MakeNVector(MPI_Comm comm, bool use_device)
    }
    else
    {
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
       if (use_device)
       {
-         x = N_VMake_MPIPlusX(comm, N_VNewWithMemHelp_Cuda(0, UseManagedMemory(),
-                                                           Sundials::GetMemHelper(),
-                                                           Sundials::GetContext()),
+         x = N_VMake_MPIPlusX(comm, SUN_Hip_OR_Cuda(N_VNewWithMemHelp)(0,
+                                                                       UseManagedMemory(),
+                                                                       Sundials::GetMemHelper(),
+                                                                       Sundials::GetContext()),
                               Sundials::GetContext());
       }
       else
@@ -569,7 +582,7 @@ N_Vector SundialsNVector::MakeNVector(MPI_Comm comm, bool use_device)
       }
 #else
       x = N_VNewEmpty_Parallel(comm, 0, 0, Sundials::GetContext());
-#endif // MFEM_USE_CUDA
+#endif // MFEM_USE_CUDA || MFEM_USE_HIP
    }
 
    MFEM_VERIFY(x, "Error in SundialsNVector::MakeNVector.");
diff --git a/linalg/sundials.hpp b/linalg/sundials.hpp
index 2d54374fe..451c12b02 100644
--- a/linalg/sundials.hpp
+++ b/linalg/sundials.hpp
@@ -32,13 +32,24 @@
 #if defined(MFEM_USE_CUDA) && ((SUNDIALS_VERSION_MAJOR == 5) && (SUNDIALS_VERSION_MINOR < 4))
 #error MFEM requires SUNDIALS version 5.4.0 or newer when MFEM_USE_CUDA=TRUE!
 #endif
+#if defined(MFEM_USE_HIP) && ((SUNDIALS_VERSION_MAJOR == 5) && (SUNDIALS_VERSION_MINOR < 7))
+#error MFEM requires SUNDIALS version 5.7.0 or newer when MFEM_USE_HIP=TRUE!
+#endif
+#if defined(MFEM_USE_CUDA) && !defined(SUNDIALS_NVECTOR_CUDA)
+#error MFEM_USE_CUDA=TRUE requires SUNDIALS to be built with CUDA support
+#endif
+#if defined(MFEM_USE_HIP) && !defined(SUNDIALS_NVECTOR_HIP)
+#error MFEM_USE_HIP=TRUE requires SUNDIALS to be built with HIP support
+#endif
 #include <sundials/sundials_matrix.h>
 #include <sundials/sundials_linearsolver.h>
 #include <arkode/arkode_arkstep.h>
 #include <cvodes/cvodes.h>
 #include <kinsol/kinsol.h>
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA)
 #include <sunmemory/sunmemory_cuda.h>
+#elif defined(MFEM_USE_HIP)
+#include <sunmemory/sunmemory_hip.h>
 #endif
 
 #include <functional>
@@ -62,10 +73,10 @@ using SUNContext = void*;
 namespace mfem
 {
 
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
 
 // ---------------------------------------------------------------------------
-// SUNMemory interface class (used when CUDA is enabled)
+// SUNMemory interface class (used when CUDA or HIP is enabled)
 // ---------------------------------------------------------------------------
 class SundialsMemHelper
 {
@@ -113,10 +124,10 @@ public:
 
 };
 
-#else // MFEM_USE_CUDA
+#else // MFEM_USE_CUDA || MFEM_USE_HIP
 
 // ---------------------------------------------------------------------------
-// Dummy SUNMemory interface class (used when CUDA is not enabled)
+// Dummy SUNMemory interface class (used when CUDA or HIP is not enabled)
 // ---------------------------------------------------------------------------
 class SundialsMemHelper
 {
@@ -130,7 +141,7 @@ public:
    }
 };
 
-#endif // MFEM_USE_CUDA
+#endif // MFEM_USE_CUDA || MFEM_USE_HIP
 
 
 /// Singleton class for SUNContext and SundialsMemHelper objects
@@ -290,17 +301,17 @@ public:
 #endif
 
    /// Create a N_Vector.
-   /** @param[in] use_device  If true, use the SUNDIALS CUDA N_Vector. */
+   /** @param[in] use_device  If true, use the SUNDIALS CUDA or HIP N_Vector. */
    static N_Vector MakeNVector(bool use_device);
 
 #ifdef MFEM_USE_MPI
    /// Create a parallel N_Vector.
    /** @param[in] comm  The MPI communicator to use.
-       @param[in] use_device  If true, use the SUNDIALS CUDA N_Vector. */
+       @param[in] use_device  If true, use the SUNDIALS CUDA or HIP N_Vector. */
    static N_Vector MakeNVector(MPI_Comm comm, bool use_device);
 #endif
 
-#ifdef MFEM_USE_CUDA
+#if defined(MFEM_USE_CUDA) || defined(MFEM_USE_HIP)
    static bool UseManagedMemory()
    {
       return Device::GetDeviceMemoryType() == MemoryType::MANAGED;
diff --git a/linalg/vector.cpp b/linalg/vector.cpp
index d6456b60a..a51d6ac9c 100644
--- a/linalg/vector.cpp
+++ b/linalg/vector.cpp
@@ -15,13 +15,6 @@
 #include "vector.hpp"
 #include "../general/forall.hpp"
 
-#if defined(MFEM_USE_SUNDIALS)
-#include "sundials.hpp"
-#if defined(MFEM_USE_MPI)
-#include <nvector/nvector_parallel.h>
-#endif
-#endif
-
 #ifdef MFEM_USE_OPENMP
 #include <omp.h>
 #endif
@@ -313,6 +306,14 @@ void Vector::Neg()
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = -y[i]; });
 }
 
+void Vector::Reciprocal()
+{
+   const bool use_dev = UseDevice();
+   const int N = size;
+   auto y = ReadWrite(use_dev);
+   mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = 1.0/y[i]; });
+}
+
 void add(const Vector &v1, const Vector &v2, Vector &v)
 {
    MFEM_ASSERT(v.size == v1.size && v.size == v2.size,
diff --git a/linalg/vector.hpp b/linalg/vector.hpp
index 13f6a748c..6037a5fa8 100644
--- a/linalg/vector.hpp
+++ b/linalg/vector.hpp
@@ -19,9 +19,7 @@
 #include "../general/globals.hpp"
 #include "../general/mem_manager.hpp"
 #include "../general/device.hpp"
-#ifdef MFEM_USE_SUNDIALS
-#include <nvector/nvector_serial.h>
-#endif
+
 #include <cmath>
 #include <iostream>
 #include <limits>
@@ -323,6 +321,9 @@ public:
    /// (*this) = -(*this)
    void Neg();
 
+   /// (*this)(i) = 1.0 / (*this)(i)
+   void Reciprocal();
+
    /// Swap the contents of two Vectors
    inline void Swap(Vector &other);
 
diff --git a/makefile b/makefile
index f45eee1db..6f71bd0fd 100644
--- a/makefile
+++ b/makefile
@@ -278,7 +278,7 @@ endif
 # List of MFEM dependencies, that require the *_LIB variable to be non-empty
 MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS\
  SUITESPARSE STRUMPACK GINKGO GNUTLS NETCDF PETSC SLEPC MPFR PUMI HIOP\
- GSLIB OCCA CEED RAJA UMPIRE MKL_CPARDISO AMGX CALIPER PARELAG BENCHMARK\
+ GSLIB OCCA CEED RAJA UMPIRE MKL_CPARDISO MKL_PARDISO AMGX CALIPER PARELAG BENCHMARK\
  MOONOLITH ALGOIM
 
 
@@ -345,7 +345,7 @@ MFEM_DEFINES = MFEM_VERSION MFEM_VERSION_STRING MFEM_GIT_STRING MFEM_USE_MPI\
  MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT\
  MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP\
  MFEM_USE_OCCA MFEM_USE_MOONOLITH MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE\
- MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_AMGX\
+ MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_MKL_PARDISO MFEM_USE_AMGX\
  MFEM_USE_MUMPS MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER\
  MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME\
  MFEM_SOURCE_DIR MFEM_INSTALL_DIR MFEM_SHARED_BUILD
@@ -419,7 +419,7 @@ endif
 DIRS = general linalg linalg/simd mesh mesh/submesh fem fem/ceed/interface \
        fem/ceed/integrators/mass fem/ceed/integrators/convection \
        fem/ceed/integrators/diffusion fem/ceed/integrators/nlconvection \
-       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/tmop
+       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/integ fem/tmop
 
 ifeq ($(MFEM_USE_MOONOLITH),YES)
    MFEM_CXXFLAGS += $(MOONOLITH_CXX_FLAGS)
@@ -705,6 +705,7 @@ status info:
 	$(info MFEM_USE_SIMD          = $(MFEM_USE_SIMD))
 	$(info MFEM_USE_ADIOS2        = $(MFEM_USE_ADIOS2))
 	$(info MFEM_USE_MKL_CPARDISO  = $(MFEM_USE_MKL_CPARDISO))
+	$(info MFEM_USE_MKL_PARDISO   = $(MFEM_USE_MKL_PARDISO))
 	$(info MFEM_USE_MOONOLITH     = $(MFEM_USE_MOONOLITH))
 	$(info MFEM_USE_ADFORWARD     = $(MFEM_USE_ADFORWARD))
 	$(info MFEM_USE_CODIPACK      = $(MFEM_USE_CODIPACK))
diff --git a/mesh/element.hpp b/mesh/element.hpp
index c37205eb1..a4e45250f 100644
--- a/mesh/element.hpp
+++ b/mesh/element.hpp
@@ -62,6 +62,7 @@ public:
 
    /// Returns element's vertices.
    virtual void GetVertices(Array<int> &v) const = 0;
+   virtual void SetVertices(const Array<int> &v) = 0;
 
    /// @note The returned array should NOT be deleted by the caller.
    virtual int *GetVertices() = 0;
diff --git a/mesh/hexahedron.cpp b/mesh/hexahedron.cpp
index beeab3b6a..30a8b192e 100644
--- a/mesh/hexahedron.cpp
+++ b/mesh/hexahedron.cpp
@@ -43,10 +43,13 @@ Hexahedron::Hexahedron(int ind1, int ind2, int ind3, int ind4,
 void Hexahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(8);
-   for (int i = 0; i < 8; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 8, v.begin());
+}
+
+void Hexahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 8, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/hexahedron.hpp b/mesh/hexahedron.hpp
index a8186c0c8..40c5d2995 100644
--- a/mesh/hexahedron.hpp
+++ b/mesh/hexahedron.hpp
@@ -37,35 +37,36 @@ public:
               int ind5, int ind6, int ind7, int ind8, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::HEXAHEDRON; }
+   Type GetType() const override { return Element::HEXAHEDRON; }
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Access the indices of the element's vertices.
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 8; }
+   int GetNVertices() const override { return 8; }
 
-   virtual int GetNEdges() const { return 12; }
+   int GetNEdges() const override { return 12; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 4; return 6; }
 
-   virtual int GetNFaces() const { return 6; }
+   int GetNFaces() const override { return 6; }
 
-   virtual int GetNFaceVertices(int) const { return 4; }
+   int GetNFaceVertices(int) const override { return 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Hexahedron(indices, attribute); }
 
-   virtual ~Hexahedron() { }
+   virtual ~Hexahedron() = default;
 };
 
 extern MFEM_EXPORT class TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 87e606510..e243ebb95 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -19,6 +19,7 @@
 #include "../general/device.hpp"
 #include "../general/tic_toc.hpp"
 #include "../general/gecko.hpp"
+#include "../general/sets.hpp"
 #include "../fem/quadinterpolator.hpp"
 
 #include <iostream>
@@ -31,6 +32,7 @@
 #include <functional>
 #include <map>
 #include <set>
+#include <unordered_set>
 
 // Include the METIS header, if using version 5. If using METIS 4, the needed
 // declarations are inlined below, i.e. no header is needed.
@@ -1109,6 +1111,7 @@ FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
    {
       return NULL;
    }
+
    tr = GetFaceElementTransformations(fn, 21);
    tr->Attribute = boundary[BdrElemNo]->GetAttribute();
    tr->ElementNo = BdrElemNo;
@@ -1431,6 +1434,7 @@ Geometry::Type Mesh::GetFaceGeometry(int Face) const
          }
          // ghost face
          const int nc_face_id = faces_info[Face].NCFace;
+
          MFEM_ASSERT(nc_face_id >= 0, "parent ghost faces are not supported");
          return faces[nc_faces_info[nc_face_id].MasterFace]->GetGeometryType();
    }
@@ -1906,14 +1910,11 @@ int Mesh::AddBdrPoint(int v, int attr)
 
 void Mesh::GenerateBoundaryElements()
 {
-   int i, j;
    Array<int> &be2face = (Dim == 2) ? be_to_edge : be_to_face;
 
-   // GenerateFaces();
-
-   for (i = 0; i < boundary.Size(); i++)
+   for (auto &b : boundary)
    {
-      FreeElement(boundary[i]);
+      FreeElement(b);
    }
 
    if (Dim == 3)
@@ -1924,14 +1925,14 @@ void Mesh::GenerateBoundaryElements()
 
    // count the 'NumOfBdrElements'
    NumOfBdrElements = 0;
-   for (i = 0; i < faces_info.Size(); i++)
+   for (const auto &fi : faces_info)
    {
-      if (faces_info[i].Elem2No < 0) { NumOfBdrElements++; }
+      if (fi.Elem2No < 0) { ++NumOfBdrElements; }
    }
 
    boundary.SetSize(NumOfBdrElements);
    be2face.SetSize(NumOfBdrElements);
-   for (j = i = 0; i < faces_info.Size(); i++)
+   for (int j = 0, i = 0; i < faces_info.Size(); ++i)
    {
       if (faces_info[i].Elem2No < 0)
       {
@@ -2986,7 +2987,7 @@ void Mesh::FinalizeTopology(bool generate_bdr)
    {
       GetElementToFaceTable();
       GenerateFaces();
-      if (NumOfBdrElements == 0 && generate_bdr)
+      if (ReduceInt(NumOfBdrElements) == 0 && generate_bdr)
       {
          GenerateBoundaryElements();
          GetElementToFaceTable(); // update be_to_face
@@ -3006,7 +3007,7 @@ void Mesh::FinalizeTopology(bool generate_bdr)
       if (Dim == 2)
       {
          GenerateFaces(); // 'Faces' in 2D refers to the edges
-         if (NumOfBdrElements == 0 && generate_bdr)
+         if (ReduceInt(NumOfBdrElements) == 0 && generate_bdr)
          {
             GenerateBoundaryElements();
          }
@@ -4386,7 +4387,7 @@ Mesh::Mesh(Mesh *orig_mesh, int ref_factor, int ref_type)
    MakeRefined_(*orig_mesh, ref_factors, ref_type);
 }
 
-void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                         int ref_type)
 {
    SetEmpty();
@@ -5394,6 +5395,12 @@ const FiniteElementSpace *Mesh::GetNodalFESpace() const
 
 void Mesh::SetCurvature(int order, bool discont, int space_dim, int ordering)
 {
+   if (order <= 0)
+   {
+      delete Nodes;
+      Nodes = nullptr;
+      return;
+   }
    space_dim = (space_dim == -1) ? spaceDim : space_dim;
    FiniteElementCollection* nfec;
    if (discont)
@@ -5923,22 +5930,22 @@ int Mesh::CheckBdrElementOrientation(bool fix_it)
             {
                // swap vertices 0 and 1 so that we don't change the marked edge:
                // (0,1,2) -> (1,0,2)
-               mfem::Swap<int>(bv[0], bv[1]);
+               std::swap(bv[0], bv[1]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[1], be[2]);
+                  std::swap(be[1], be[2]);
                }
                break;
             }
             case Element::QUADRILATERAL:
             {
-               mfem::Swap<int>(bv[0], bv[2]);
+               std::swap(bv[0], bv[2]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[0], be[1]);
-                  mfem::Swap<int>(be[2], be[3]);
+                  std::swap(be[0], be[1]);
+                  std::swap(be[2], be[3]);
                }
                break;
             }
@@ -6654,9 +6661,9 @@ void Mesh::AddQuadFaceElement(int lf, int gf, int el,
 
 void Mesh::GenerateFaces()
 {
-   int i, nfaces = GetNumFaces();
+   int nfaces = GetNumFaces();
 
-   for (i = 0; i < faces.Size(); i++)
+   for (int i = 0; i < faces.Size(); ++i)
    {
       FreeElement(faces[i]);
    }
@@ -6664,16 +6671,17 @@ void Mesh::GenerateFaces()
    // (re)generate the interior faces and the info for them
    faces.SetSize(nfaces);
    faces_info.SetSize(nfaces);
-   for (i = 0; i < nfaces; i++)
+   for (int i = 0; i < nfaces; ++i)
    {
       faces[i] = NULL;
       faces_info[i].Elem1No = -1;
       faces_info[i].NCFace = -1;
    }
-   for (i = 0; i < NumOfElements; i++)
+
+   Array<int> v;
+   for (int i = 0; i < NumOfElements; ++i)
    {
-      const int *v = elements[i]->GetVertices();
-      const int *ef;
+      elements[i]->GetVertices(v);
       if (Dim == 1)
       {
          AddPointFaceElement(0, v[0], i);
@@ -6681,7 +6689,7 @@ void Mesh::GenerateFaces()
       }
       else if (Dim == 2)
       {
-         ef = el_to_edge->GetRow(i);
+         const int * const ef = el_to_edge->GetRow(i);
          const int ne = elements[i]->GetNEdges();
          for (int j = 0; j < ne; j++)
          {
@@ -6691,7 +6699,7 @@ void Mesh::GenerateFaces()
       }
       else
       {
-         ef = el_to_face->GetRow(i);
+         const int * const ef = el_to_face->GetRow(i);
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
@@ -6757,9 +6765,9 @@ void Mesh::GenerateNCFaceInfo()
 {
    MFEM_VERIFY(ncmesh, "missing NCMesh.");
 
-   for (int i = 0; i < faces_info.Size(); i++)
+   for (auto &x : faces_info)
    {
-      faces_info[i].NCFace = -1;
+      x.NCFace = -1;
    }
 
    const NCMesh::NCList &list =
@@ -6771,9 +6779,8 @@ void Mesh::GenerateNCFaceInfo()
    int nfaces = GetNumFaces();
 
    // add records for master faces
-   for (int i = 0; i < list.masters.Size(); i++)
+   for (const NCMesh::Master &master : list.masters)
    {
-      const NCMesh::Master &master = list.masters[i];
       if (master.index >= nfaces) { continue; }
 
       FaceInfo &master_fi = faces_info[master.index];
@@ -6785,10 +6792,8 @@ void Mesh::GenerateNCFaceInfo()
    }
 
    // add records for slave faces
-   for (int i = 0; i < list.slaves.Size(); i++)
+   for (const NCMesh::Slave &slave : list.slaves)
    {
-      const NCMesh::Slave &slave = list.slaves[i];
-
       if (slave.index < 0 || // degenerate slave face
           slave.index >= nfaces || // ghost slave
           slave.master >= nfaces) // has ghost master
@@ -6871,7 +6876,7 @@ STable3D *Mesh::GetFacesTable()
             break;
          }
          default:
-            MFEM_ABORT("Unexpected type of Element.");
+            MFEM_ABORT("Unexpected type of Element: " << GetElementType(i));
       }
    }
    return faces_tbl;
@@ -6879,7 +6884,7 @@ STable3D *Mesh::GetFacesTable()
 
 STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
 {
-   int i, *v;
+   Array<int> v;
    STable3D *faces_tbl;
 
    if (el_to_face != NULL)
@@ -6888,9 +6893,9 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    }
    el_to_face = new Table(NumOfElements, 6);  // must be 6 for hexahedra
    faces_tbl = new STable3D(NumOfVertices);
-   for (i = 0; i < NumOfElements; i++)
+   for (int i = 0; i < NumOfElements; i++)
    {
-      v = elements[i]->GetVertices();
+      elements[i]->GetVertices(v);
       switch (GetElementType(i))
       {
          case Element::TETRAHEDRON:
@@ -6954,9 +6959,10 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    el_to_face->Finalize();
    NumOfFaces = faces_tbl->NumberOfElements();
    be_to_face.SetSize(NumOfBdrElements);
-   for (i = 0; i < NumOfBdrElements; i++)
+
+   for (int i = 0; i < NumOfBdrElements; i++)
    {
-      v = boundary[i]->GetVertices();
+      boundary[i]->GetVertices(v);
       switch (GetBdrElementType(i))
       {
          case Element::TRIANGLE:
@@ -7943,7 +7949,7 @@ void Mesh::GetNode(int i, double *coord) const
       FiniteElementSpace *fes = Nodes->FESpace();
       for (int j = 0; j < spaceDim; j++)
       {
-         coord[j] = (*Nodes)(fes->DofToVDof(i, j));
+         coord[j] = AsConst(*Nodes)(fes->DofToVDof(i, j));
       }
    }
    else
@@ -10574,7 +10580,8 @@ void Mesh::PrintVTU(std::string fname,
                     VTKFormat format,
                     bool high_order_output,
                     int compression_level,
-                    bool bdr)
+                    bool bdr_elements,
+                    double scale_factor)
 {
    int ref = (high_order_output && Nodes)
              ? Nodes->FESpace()->GetMaxElementOrder() : 1;
@@ -10588,7 +10595,8 @@ void Mesh::PrintVTU(std::string fname,
    }
    os << " byte_order=\"" << VTKByteOrder() << "\">\n";
    os << "<UnstructuredGrid>\n";
-   PrintVTU(os, ref, format, high_order_output, compression_level, bdr);
+   PrintVTU(os, ref, format, high_order_output, compression_level, bdr_elements,
+            scale_factor);
    os << "</Piece>\n"; // need to close the piece open in the PrintVTU method
    os << "</UnstructuredGrid>\n";
    os << "</VTKFile>" << std::endl;
@@ -10599,14 +10607,16 @@ void Mesh::PrintVTU(std::string fname,
 void Mesh::PrintBdrVTU(std::string fname,
                        VTKFormat format,
                        bool high_order_output,
-                       int compression_level)
+                       int compression_level,
+                       double scale_factor)
 {
-   PrintVTU(fname, format, high_order_output, compression_level, true);
+   PrintVTU(fname, format, high_order_output, compression_level, true,
+            scale_factor);
 }
 
 void Mesh::PrintVTU(std::ostream &os, int ref, VTKFormat format,
                     bool high_order_output, int compression_level,
-                    bool bdr_elements)
+                    bool bdr_elements, double scale_factor)
 {
    RefinedGeometry *RefG;
    DenseMatrix pmat;
@@ -10653,6 +10663,11 @@ void Mesh::PrintVTU(std::ostream &os, int ref, VTKFormat format,
          GetElementTransformation(i)->Transform(RefG->RefPts, pmat);
       }
 
+      if (scale_factor != 1.0)
+      {
+         pmat *= scale_factor;
+      }
+
       for (int j = 0; j < pmat.Width(); j++)
       {
          WriteBinaryOrASCII(os, buf, pmat(0,j), " ", format);
@@ -12230,6 +12245,879 @@ void Mesh::GetGeometricParametersFromJacobian(const DenseMatrix &J,
 }
 
 
+MeshPart::EntityHelper::EntityHelper(
+   int dim_, const Array<int> (&entity_to_vertex_)[Geometry::NumGeom])
+   : dim(dim_),
+     entity_to_vertex(entity_to_vertex_)
+{
+   int geom_offset = 0;
+   for (int g = Geometry::DimStart[dim]; g < Geometry::DimStart[dim+1]; g++)
+   {
+      geom_offsets[g] = geom_offset;
+      geom_offset += entity_to_vertex[g].Size()/Geometry::NumVerts[g];
+   }
+   geom_offsets[Geometry::DimStart[dim+1]] = geom_offset;
+   num_entities = geom_offset;
+}
+
+MeshPart::Entity MeshPart::EntityHelper::FindEntity(int bytype_entity_id)
+{
+   // Find the 'geom' that corresponds to 'bytype_entity_id'
+   int geom = Geometry::DimStart[dim];
+   while (geom_offsets[geom+1] <= bytype_entity_id) { geom++; }
+   MFEM_ASSERT(geom < Geometry::NumGeom, "internal error");
+   MFEM_ASSERT(Geometry::Dimension[geom] == dim, "internal error");
+   const int nv = Geometry::NumVerts[geom];
+   const int geom_elem_id = bytype_entity_id - geom_offsets[geom];
+   const int *v = &entity_to_vertex[geom][nv*geom_elem_id];
+   return { geom, nv, v };
+}
+
+void MeshPart::Print(std::ostream &os) const
+{
+   os << "MFEM mesh v1.2\n";
+
+   // optional
+   os <<
+      "\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n"
+      "# POINT       = 0\n"
+      "# SEGMENT     = 1\n"
+      "# TRIANGLE    = 2\n"
+      "# SQUARE      = 3\n"
+      "# TETRAHEDRON = 4\n"
+      "# CUBE        = 5\n"
+      "# PRISM       = 6\n"
+      "# PYRAMID     = 7\n"
+      "#\n";
+
+   const int dim = dimension;
+   os << "\ndimension\n" << dim;
+
+   os << "\n\nelements\n" << num_elements << '\n';
+   {
+      const bool have_element_map = (element_map.Size() == num_elements);
+      MFEM_ASSERT(have_element_map || element_map.Size() == 0,
+                  "invalid MeshPart state");
+      EntityHelper elem_helper(dim, entity_to_vertex);
+      MFEM_ASSERT(elem_helper.num_entities == num_elements,
+                  "invalid MeshPart state");
+      for (int nat_elem_id = 0; nat_elem_id < num_elements; nat_elem_id++)
+      {
+         const int bytype_elem_id = have_element_map ?
+                                    element_map[nat_elem_id] : nat_elem_id;
+         const Entity ent = elem_helper.FindEntity(bytype_elem_id);
+         // Print the element
+         os << attributes[nat_elem_id] << ' ' << ent.geom;
+         for (int i = 0; i < ent.num_verts; i++)
+         {
+            os << ' ' << ent.verts[i];
+         }
+         os << '\n';
+      }
+   }
+
+   os << "\nboundary\n" << num_bdr_elements << '\n';
+   {
+      const bool have_boundary_map = (boundary_map.Size() == num_bdr_elements);
+      MFEM_ASSERT(have_boundary_map || boundary_map.Size() == 0,
+                  "invalid MeshPart state");
+      EntityHelper bdr_helper(dim-1, entity_to_vertex);
+      MFEM_ASSERT(bdr_helper.num_entities == num_bdr_elements,
+                  "invalid MeshPart state");
+      for (int nat_bdr_id = 0; nat_bdr_id < num_bdr_elements; nat_bdr_id++)
+      {
+         const int bytype_bdr_id = have_boundary_map ?
+                                   boundary_map[nat_bdr_id] : nat_bdr_id;
+         const Entity ent = bdr_helper.FindEntity(bytype_bdr_id);
+         // Print the boundary element
+         os << bdr_attributes[nat_bdr_id] << ' ' << ent.geom;
+         for (int i = 0; i < ent.num_verts; i++)
+         {
+            os << ' ' << ent.verts[i];
+         }
+         os << '\n';
+      }
+   }
+
+   os << "\nvertices\n" << num_vertices << '\n';
+   if (!nodes)
+   {
+      const int sdim = space_dimension;
+      os << sdim << '\n';
+      for (int i = 0; i < num_vertices; i++)
+      {
+         os << vertex_coordinates[i*sdim];
+         for (int d = 1; d < sdim; d++)
+         {
+            os << ' ' << vertex_coordinates[i*sdim+d];
+         }
+         os << '\n';
+      }
+   }
+   else
+   {
+      os << "\nnodes\n";
+      nodes->Save(os);
+   }
+
+   os << "\nmfem_serial_mesh_end\n";
+
+   // Start: GroupTopology::Save
+   const int num_groups = my_groups.Size();
+   os << "\ncommunication_groups\n";
+   os << "number_of_groups " << num_groups << "\n\n";
+
+   os << "# number of entities in each group, followed by ranks in group\n";
+   for (int group_id = 0; group_id < num_groups; ++group_id)
+   {
+      const int group_size = my_groups.RowSize(group_id);
+      const int *group_ptr = my_groups.GetRow(group_id);
+      os << group_size;
+      for (int group_member_index = 0; group_member_index < group_size;
+           ++group_member_index)
+      {
+         os << ' ' << group_ptr[group_member_index];
+      }
+      os << '\n';
+   }
+   // End: GroupTopology::Save
+
+   const Table &g2v  = group__shared_entity_to_vertex[Geometry::POINT];
+   const Table &g2ev = group__shared_entity_to_vertex[Geometry::SEGMENT];
+   const Table &g2tv = group__shared_entity_to_vertex[Geometry::TRIANGLE];
+   const Table &g2qv = group__shared_entity_to_vertex[Geometry::SQUARE];
+
+   MFEM_VERIFY(g2v.RowSize(0) == 0, "internal erroor");
+   os << "\ntotal_shared_vertices " << g2v.Size_of_connections() << '\n';
+   if (dimension >= 2)
+   {
+      MFEM_VERIFY(g2ev.RowSize(0) == 0, "internal erroor");
+      os << "total_shared_edges " << g2ev.Size_of_connections()/2 << '\n';
+   }
+   if (dimension >= 3)
+   {
+      MFEM_VERIFY(g2tv.RowSize(0) == 0, "internal erroor");
+      MFEM_VERIFY(g2qv.RowSize(0) == 0, "internal erroor");
+      const int total_shared_faces =
+         g2tv.Size_of_connections()/3 + g2qv.Size_of_connections()/4;
+      os << "total_shared_faces " << total_shared_faces << '\n';
+   }
+   os << "\n# group 0 has no shared entities\n";
+   for (int gr = 1; gr < num_groups; gr++)
+   {
+      {
+         const int  nv = g2v.RowSize(gr);
+         const int *sv = g2v.GetRow(gr);
+         os << "\n# group " << gr << "\nshared_vertices " << nv << '\n';
+         for (int i = 0; i < nv; i++)
+         {
+            os << sv[i] << '\n';
+         }
+      }
+      if (dimension >= 2)
+      {
+         const int  ne = g2ev.RowSize(gr)/2;
+         const int *se = g2ev.GetRow(gr);
+         os << "\nshared_edges " << ne << '\n';
+         for (int i = 0; i < ne; i++)
+         {
+            const int *v = se + 2*i;
+            os << v[0] << ' ' << v[1] << '\n';
+         }
+      }
+      if (dimension >= 3)
+      {
+         const int  nt = g2tv.RowSize(gr)/3;
+         const int *st = g2tv.GetRow(gr);
+         const int  nq = g2qv.RowSize(gr)/4;
+         const int *sq = g2qv.GetRow(gr);
+         os << "\nshared_faces " << nt+nq << '\n';
+         for (int i = 0; i < nt; i++)
+         {
+            os << Geometry::TRIANGLE;
+            const int *v = st + 3*i;
+            for (int j = 0; j < 3; j++) { os << ' ' << v[j]; }
+            os << '\n';
+         }
+         for (int i = 0; i < nq; i++)
+         {
+            os << Geometry::SQUARE;
+            const int *v = sq + 4*i;
+            for (int j = 0; j < 4; j++) { os << ' ' << v[j]; }
+            os << '\n';
+         }
+      }
+   }
+
+   // Write out section end tag for mesh.
+   os << "\nmfem_mesh_end" << endl;
+}
+
+Mesh &MeshPart::GetMesh()
+{
+   if (mesh) { return *mesh; }
+
+   mesh.reset(new Mesh(dimension,
+                       num_vertices,
+                       num_elements,
+                       num_bdr_elements,
+                       space_dimension));
+
+   // Add elements
+   {
+      const bool have_element_map = (element_map.Size() == num_elements);
+      MFEM_ASSERT(have_element_map || element_map.Size() == 0,
+                  "invalid MeshPart state");
+      EntityHelper elem_helper(dimension, entity_to_vertex);
+      MFEM_ASSERT(elem_helper.num_entities == num_elements,
+                  "invalid MeshPart state");
+      const bool have_tet_refine_flags = (tet_refine_flags.Size() > 0);
+      for (int nat_elem_id = 0; nat_elem_id < num_elements; nat_elem_id++)
+      {
+         const int bytype_elem_id = have_element_map ?
+                                    element_map[nat_elem_id] : nat_elem_id;
+         const Entity ent = elem_helper.FindEntity(bytype_elem_id);
+         Element *el = mesh->NewElement(ent.geom);
+         el->SetVertices(ent.verts);
+         el->SetAttribute(attributes[nat_elem_id]);
+         if (ent.geom == Geometry::TETRAHEDRON && have_tet_refine_flags)
+         {
+            constexpr int geom_tet = Geometry::TETRAHEDRON;
+            const int tet_id = (ent.verts - entity_to_vertex[geom_tet])/4;
+            const int ref_flag = tet_refine_flags[tet_id];
+            static_cast<Tetrahedron*>(el)->SetRefinementFlag(ref_flag);
+         }
+         mesh->AddElement(el);
+      }
+   }
+
+   // Add boundary elements
+   {
+      const bool have_boundary_map = (boundary_map.Size() == num_bdr_elements);
+      MFEM_ASSERT(have_boundary_map || boundary_map.Size() == 0,
+                  "invalid MeshPart state");
+      EntityHelper bdr_helper(dimension-1, entity_to_vertex);
+      MFEM_ASSERT(bdr_helper.num_entities == num_bdr_elements,
+                  "invalid MeshPart state");
+      for (int nat_bdr_id = 0; nat_bdr_id < num_bdr_elements; nat_bdr_id++)
+      {
+         const int bytype_bdr_id = have_boundary_map ?
+                                   boundary_map[nat_bdr_id] : nat_bdr_id;
+         const Entity ent = bdr_helper.FindEntity(bytype_bdr_id);
+         Element *bdr = mesh->NewElement(ent.geom);
+         bdr->SetVertices(ent.verts);
+         bdr->SetAttribute(bdr_attributes[nat_bdr_id]);
+         mesh->AddBdrElement(bdr);
+      }
+   }
+
+   // Add vertices
+   if (vertex_coordinates.Size() == space_dimension*num_vertices)
+   {
+      MFEM_ASSERT(!nodes, "invalid MeshPart state");
+      for (int vert_id = 0; vert_id < num_vertices; vert_id++)
+      {
+         mesh->AddVertex(vertex_coordinates + space_dimension*vert_id);
+      }
+   }
+   else
+   {
+      MFEM_ASSERT(vertex_coordinates.Size() == 0, "invalid MeshPart state");
+      for (int vert_id = 0; vert_id < num_vertices; vert_id++)
+      {
+         mesh->AddVertex(0., 0., 0.);
+      }
+      // 'mesh.Nodes' cannot be set here -- they can be set later, if needed
+   }
+
+   mesh->FinalizeTopology(/* generate_bdr: */ false);
+
+   return *mesh;
+}
+
+
+MeshPartitioner::MeshPartitioner(Mesh &mesh_,
+                                 int num_parts_,
+                                 int *partitioning_,
+                                 int part_method)
+   : mesh(mesh_),
+     partitioning(partitioning_),
+     own_partitioning(false)
+{
+   if (partitioning == nullptr)
+   {
+      partitioning = mesh.GeneratePartitioning(num_parts_, part_method);
+      own_partitioning = true;
+   }
+
+   Transpose(Array<int>(partitioning, mesh.GetNE()),
+             part_to_element, num_parts_);
+   // Note: the element ids in each row of 'part_to_element' are sorted.
+
+   const int dim = mesh.Dimension();
+   if (dim >= 2)
+   {
+      Transpose(mesh.ElementToEdgeTable(), edge_to_element, mesh.GetNEdges());
+   }
+
+   Array<int> boundary_to_part(mesh.GetNBE());
+   // Same logic as in ParMesh::BuildLocalBoundary
+   if (dim >= 3)
+   {
+      for (int i = 0; i < boundary_to_part.Size(); i++)
+      {
+         int face, o, el1, el2;
+         mesh.GetBdrElementFace(i, &face, &o);
+         mesh.GetFaceElements(face, &el1, &el2);
+         boundary_to_part[i] =
+            partitioning[(o % 2 == 0 || el2 < 0) ? el1 : el2];
+      }
+   }
+   else if (dim == 2)
+   {
+      for (int i = 0; i < boundary_to_part.Size(); i++)
+      {
+         int edge = mesh.GetBdrElementEdgeIndex(i);
+         int el1 = edge_to_element.GetRow(edge)[0];
+         boundary_to_part[i] = partitioning[el1];
+      }
+   }
+   else if (dim == 1)
+   {
+      for (int i = 0; i < boundary_to_part.Size(); i++)
+      {
+         int vert = mesh.GetBdrElementEdgeIndex(i);
+         int el1, el2;
+         mesh.GetFaceElements(vert, &el1, &el2);
+         boundary_to_part[i] = partitioning[el1];
+      }
+   }
+   Transpose(boundary_to_part, part_to_boundary, num_parts_);
+   // Note: the boundary element ids in each row of 'part_to_boundary' are
+   // sorted.
+   boundary_to_part.DeleteAll();
+
+   Table *vert_element = mesh.GetVertexToElementTable(); // we must delete this
+   vertex_to_element.Swap(*vert_element);
+   delete vert_element;
+}
+
+void MeshPartitioner::ExtractPart(int part_id, MeshPart &mesh_part) const
+{
+   const int num_parts = part_to_element.Size();
+
+   MFEM_VERIFY(0 <= part_id && part_id < num_parts,
+               "invalid part_id = " << part_id
+               << ", num_parts = " << num_parts);
+
+   const int dim = mesh.Dimension();
+   const int sdim = mesh.SpaceDimension();
+   const int num_elems = part_to_element.RowSize(part_id);
+   const int *elem_list = part_to_element.GetRow(part_id); // sorted
+   const int num_bdr_elems = part_to_boundary.RowSize(part_id);
+   const int *bdr_elem_list = part_to_boundary.GetRow(part_id); // sorted
+
+   // Initialize 'mesh_part'
+   mesh_part.dimension = dim;
+   mesh_part.space_dimension = sdim;
+   mesh_part.num_vertices = 0;
+   mesh_part.num_elements = num_elems;
+   mesh_part.num_bdr_elements = num_bdr_elems;
+   for (int g = 0; g < Geometry::NumGeom; g++)
+   {
+      mesh_part.entity_to_vertex[g].SetSize(0); // can reuse Array allocation
+   }
+   mesh_part.tet_refine_flags.SetSize(0);
+   mesh_part.element_map.SetSize(0); // 0 or 'num_elements', if needed
+   mesh_part.boundary_map.SetSize(0); // 0 or 'num_bdr_elements', if needed
+   mesh_part.attributes.SetSize(num_elems);
+   mesh_part.bdr_attributes.SetSize(num_bdr_elems);
+   mesh_part.vertex_coordinates.SetSize(0);
+
+   mesh_part.num_parts = num_parts;
+   mesh_part.my_part_id = part_id;
+   mesh_part.my_groups.Clear();
+   for (int g = 0; g < Geometry::NumGeom; g++)
+   {
+      mesh_part.group__shared_entity_to_vertex[g].Clear();
+   }
+   mesh_part.nodes.reset(nullptr);
+   mesh_part.nodal_fes.reset(nullptr);
+   mesh_part.mesh.reset(nullptr);
+
+   // Initialize:
+   // - 'mesh_part.entity_to_vertex' for the elements (boundary elements are
+   //   set later); vertex ids are global at this point - they will be mapped to
+   //   local ids later
+   // - 'mesh_part.attributes'
+   // - 'mesh_part.tet_refine_flags' if needed
+   int geom_marker = 0, num_geom = 0;
+   for (int i = 0; i < num_elems; i++)
+   {
+      const Element *elem = mesh.GetElement(elem_list[i]);
+      const int geom = elem->GetGeometryType();
+      const int nv = Geometry::NumVerts[geom];
+      const int *v = elem->GetVertices();
+      MFEM_VERIFY(numeric_limits<int>::max() - nv >=
+                  mesh_part.entity_to_vertex[geom].Size(),
+                  "overflow in 'entity_to_vertex[geom]', geom: "
+                  << Geometry::Name[geom]);
+      mesh_part.entity_to_vertex[geom].Append(v, nv);
+      mesh_part.attributes[i] = elem->GetAttribute();
+      if (geom == Geometry::TETRAHEDRON)
+      {
+         // Create 'mesh_part.tet_refine_flags' but only if we find at least one
+         // non-zero flag in a tetrahedron.
+         const Tetrahedron *tet = static_cast<const Tetrahedron*>(elem);
+         const int ref_flag = tet->GetRefinementFlag();
+         if (mesh_part.tet_refine_flags.Size() == 0)
+         {
+            if (ref_flag)
+            {
+               // This is the first time we encounter non-zero 'ref_flag'
+               const int num_tets = mesh_part.entity_to_vertex[geom].Size()/nv;
+               mesh_part.tet_refine_flags.SetSize(num_tets, 0);
+               mesh_part.tet_refine_flags.Last() = ref_flag;
+            }
+         }
+         else
+         {
+            mesh_part.tet_refine_flags.Append(ref_flag);
+         }
+      }
+      if ((geom_marker & (1 << geom)) == 0)
+      {
+         geom_marker |= (1 << geom);
+         num_geom++;
+      }
+   }
+   MFEM_ASSERT(mesh_part.tet_refine_flags.Size() == 0 ||
+               mesh_part.tet_refine_flags.Size() ==
+               mesh_part.entity_to_vertex[Geometry::TETRAHEDRON].Size()/4,
+               "internal error");
+   // Initialize 'mesh_part.element_map' if needed
+   if (num_geom > 1)
+   {
+      int offsets[Geometry::NumGeom];
+      int offset = 0;
+      for (int g = Geometry::DimStart[dim]; g < Geometry::DimStart[dim+1]; g++)
+      {
+         offsets[g] = offset;
+         offset += mesh_part.entity_to_vertex[g].Size()/Geometry::NumVerts[g];
+      }
+      mesh_part.element_map.SetSize(num_elems);
+      for (int i = 0; i < num_elems; i++)
+      {
+         const int geom = mesh.GetElementGeometry(elem_list[i]);
+         mesh_part.element_map[i] = offsets[geom]++;
+      }
+   }
+
+   // Initialize:
+   // - 'mesh_part.entity_to_vertex' for the boundary elements; vertex ids are
+   //   global at this point - they will be mapped to local ids later
+   // - 'mesh_part.bdr_attributes'
+   geom_marker = 0; num_geom = 0;
+   for (int i = 0; i < num_bdr_elems; i++)
+   {
+      const Element *bdr_elem = mesh.GetBdrElement(bdr_elem_list[i]);
+      const int geom = bdr_elem->GetGeometryType();
+      const int nv = Geometry::NumVerts[geom];
+      const int *v = bdr_elem->GetVertices();
+      MFEM_VERIFY(numeric_limits<int>::max() - nv >=
+                  mesh_part.entity_to_vertex[geom].Size(),
+                  "overflow in 'entity_to_vertex[geom]', geom: "
+                  << Geometry::Name[geom]);
+      mesh_part.entity_to_vertex[geom].Append(v, nv);
+      mesh_part.bdr_attributes[i] = bdr_elem->GetAttribute();
+      if ((geom_marker & (1 << geom)) == 0)
+      {
+         geom_marker |= (1 << geom);
+         num_geom++;
+      }
+   }
+   // Initialize 'mesh_part.boundary_map' if needed
+   if (num_geom > 1)
+   {
+      int offsets[Geometry::NumGeom];
+      int offset = 0;
+      for (int g = Geometry::DimStart[dim-1]; g < Geometry::DimStart[dim]; g++)
+      {
+         offsets[g] = offset;
+         offset += mesh_part.entity_to_vertex[g].Size()/Geometry::NumVerts[g];
+      }
+      mesh_part.boundary_map.SetSize(num_bdr_elems);
+      for (int i = 0; i < num_bdr_elems; i++)
+      {
+         const int geom = mesh.GetBdrElementGeometry(bdr_elem_list[i]);
+         mesh_part.boundary_map[i] = offsets[geom]++;
+      }
+   }
+
+   // Create the vertex id map, 'vertex_loc_to_glob', which maps local ids to
+   // global ones; the map is sorted, preserving the global ordering.
+   Array<int> vertex_loc_to_glob;
+   {
+      Array<int> v;
+      std::unordered_set<int> vertex_set;
+      for (int i = 0; i < num_elems; i++)
+      {
+         const Element *elem = mesh.GetElement(elem_list[i]);
+         const int geom = elem->GetGeometryType();
+         const int nv = Geometry::NumVerts[geom];
+         elem->GetVertices(v);
+         vertex_set.insert(v.begin(), v.end());
+      }
+      vertex_loc_to_glob.SetSize(vertex_set.size());
+      std::copy(vertex_set.begin(), vertex_set.end(), // src
+                vertex_loc_to_glob.begin());          // dest
+   }
+   vertex_loc_to_glob.Sort();
+
+   // Initialize 'mesh_part.num_vertices'
+   mesh_part.num_vertices = vertex_loc_to_glob.Size();
+
+   // Update the vertex ids in the arrays 'mesh_part.entity_to_vertex' from
+   // global to local.
+   for (int g = 0; g < Geometry::NumGeom; g++)
+   {
+      Array<int> &vert_array = mesh_part.entity_to_vertex[g];
+      for (int i = 0; i < vert_array.Size(); i++)
+      {
+         const int glob_id = vert_array[i];
+         const int loc_id = vertex_loc_to_glob.FindSorted(glob_id);
+         MFEM_ASSERT(loc_id >= 0, "internal error: global vertex id not found");
+         vert_array[i] = loc_id;
+      }
+   }
+
+   // Initialize one of 'mesh_part.vertex_coordinates' or 'mesh_part.nodes'
+   if (!mesh.GetNodes())
+   {
+      MFEM_VERIFY(numeric_limits<int>::max()/sdim >= vertex_loc_to_glob.Size(),
+                  "overflow in 'vertex_coordinates', num_vertices = "
+                  << vertex_loc_to_glob.Size() << ", sdim = " << sdim);
+      mesh_part.vertex_coordinates.SetSize(sdim*vertex_loc_to_glob.Size());
+      for (int i = 0; i < vertex_loc_to_glob.Size(); i++)
+      {
+         const double *coord = mesh.GetVertex(vertex_loc_to_glob[i]);
+         for (int d = 0; d < sdim; d++)
+         {
+            mesh_part.vertex_coordinates[i*sdim+d] = coord[d];
+         }
+      }
+   }
+   else
+   {
+      const GridFunction &glob_nodes = *mesh.GetNodes();
+      mesh_part.nodal_fes = ExtractFESpace(mesh_part, *glob_nodes.FESpace());
+      // Initialized 'mesh_part.mesh'.
+      // Note: the nodes of 'mesh_part.mesh' are not set.
+
+      mesh_part.nodes = ExtractGridFunction(mesh_part, glob_nodes,
+                                            *mesh_part.nodal_fes);
+
+      // Attach the 'mesh_part.nodes' to the 'mesh_part.mesh'.
+      mesh_part.mesh->NewNodes(*mesh_part.nodes, /* make_owner: */ false);
+      // Note: the vertices of 'mesh_part.mesh' are not set.
+   }
+
+   // Begin constructing the "neighbor" groups, i.e. the groups that contain
+   // 'part_id'.
+   ListOfIntegerSets groups;
+   {
+      // the first group is the local one
+      IntegerSet group;
+      group.Recreate(1, &part_id);
+      groups.Insert(group);
+   }
+
+   // 'shared_faces' : shared face id -> (global_face_id, group_id)
+   // Note: 'shared_faces' will be sorted by 'global_face_id'.
+   Array<Pair<int,int>> shared_faces;
+
+   // Add "neighbor" groups defined by faces
+   // Construct 'shared_faces'.
+   if (dim >= 3)
+   {
+      std::unordered_set<int> face_set;
+      // Construct 'face_set'
+      const Table &elem_to_face = mesh.ElementToFaceTable();
+      for (int loc_elem_id = 0; loc_elem_id < num_elems; loc_elem_id++)
+      {
+         const int glob_elem_id = elem_list[loc_elem_id];
+         const int nfaces = elem_to_face.RowSize(glob_elem_id);
+         const int *faces = elem_to_face.GetRow(glob_elem_id);
+         face_set.insert(faces, faces + nfaces);
+      }
+      // Construct 'shared_faces'; add "neighbor" groups defined by faces.
+      IntegerSet group;
+      for (int glob_face_id : face_set)
+      {
+         int el[2];
+         mesh.GetFaceElements(glob_face_id, &el[0], &el[1]);
+         if (el[1] < 0) { continue; }
+         el[0] = partitioning[el[0]];
+         el[1] = partitioning[el[1]];
+         MFEM_ASSERT(el[0] == part_id || el[1] == part_id, "internal error");
+         if (el[0] != part_id || el[1] != part_id)
+         {
+            group.Recreate(2, el);
+            const int group_id = groups.Insert(group);
+            shared_faces.Append(Pair<int,int>(glob_face_id, group_id));
+         }
+      }
+      shared_faces.Sort(); // sort the shared faces by 'glob_face_id'
+   }
+
+   // 'shared_edges' : shared edge id -> (global_edge_id, group_id)
+   // Note: 'shared_edges' will be sorted by 'global_edge_id'.
+   Array<Pair<int,int>> shared_edges;
+
+   // Add "neighbor" groups defined by edges.
+   // Construct 'shared_edges'.
+   if (dim >= 2)
+   {
+      std::unordered_set<int> edge_set;
+      // Construct 'edge_set'
+      const Table &elem_to_edge = mesh.ElementToEdgeTable();
+      for (int loc_elem_id = 0; loc_elem_id < num_elems; loc_elem_id++)
+      {
+         const int glob_elem_id = elem_list[loc_elem_id];
+         const int nedges = elem_to_edge.RowSize(glob_elem_id);
+         const int *edges = elem_to_edge.GetRow(glob_elem_id);
+         edge_set.insert(edges, edges + nedges);
+      }
+      // Construct 'shared_edges'; add "neighbor" groups defined by edges.
+      IntegerSet group;
+      for (int glob_edge_id : edge_set)
+      {
+         const int nelem = edge_to_element.RowSize(glob_edge_id);
+         const int *elem = edge_to_element.GetRow(glob_edge_id);
+         Array<int> &gr = group; // reference to the 'group' internal Array
+         gr.SetSize(nelem);
+         for (int j = 0; j < nelem; j++)
+         {
+            gr[j] = partitioning[elem[j]];
+         }
+         gr.Sort();
+         gr.Unique();
+         MFEM_ASSERT(gr.FindSorted(part_id) >= 0, "internal error");
+         if (group.Size() > 1)
+         {
+            const int group_id = groups.Insert(group);
+            shared_edges.Append(Pair<int,int>(glob_edge_id, group_id));
+         }
+      }
+      shared_edges.Sort(); // sort the shared edges by 'glob_edge_id'
+   }
+
+   // 'shared_verts' : shared vertex id -> (global_vertex_id, group_id)
+   // Note: 'shared_verts' will be sorted by 'global_vertex_id'.
+   Array<Pair<int,int>> shared_verts;
+
+   // Add "neighbor" groups defined by vertices.
+   // Construct 'shared_verts'.
+   {
+      IntegerSet group;
+      for (int i = 0; i < vertex_loc_to_glob.Size(); i++)
+      {
+         // 'vertex_to_element' maps global vertex ids to global element ids
+         const int glob_vertex_id = vertex_loc_to_glob[i];
+         const int nelem = vertex_to_element.RowSize(glob_vertex_id);
+         const int *elem = vertex_to_element.GetRow(glob_vertex_id);
+         Array<int> &gr = group; // reference to the 'group' internal Array
+         gr.SetSize(nelem);
+         for (int j = 0; j < nelem; j++)
+         {
+            gr[j] = partitioning[elem[j]];
+         }
+         gr.Sort();
+         gr.Unique();
+         MFEM_ASSERT(gr.FindSorted(part_id) >= 0, "internal error");
+         if (group.Size() > 1)
+         {
+            const int group_id = groups.Insert(group);
+            shared_verts.Append(Pair<int,int>(glob_vertex_id, group_id));
+         }
+      }
+   }
+
+   // Done constructing the "neighbor" groups in 'groups'.
+   const int num_groups = groups.Size();
+
+   // Define 'mesh_part.my_groups'
+   groups.AsTable(mesh_part.my_groups);
+
+   // Construct 'mesh_part.group__shared_entity_to_vertex[Geometry::POINT]'
+   Table &group__shared_vertex_to_vertex =
+      mesh_part.group__shared_entity_to_vertex[Geometry::POINT];
+   group__shared_vertex_to_vertex.MakeI(num_groups);
+   for (int sv = 0; sv < shared_verts.Size(); sv++)
+   {
+      const int group_id = shared_verts[sv].two;
+      group__shared_vertex_to_vertex.AddAColumnInRow(group_id);
+   }
+   group__shared_vertex_to_vertex.MakeJ();
+   for (int sv = 0; sv < shared_verts.Size(); sv++)
+   {
+      const int glob_vertex_id = shared_verts[sv].one;
+      const int group_id       = shared_verts[sv].two;
+      const int loc_vertex_id = vertex_loc_to_glob.FindSorted(glob_vertex_id);
+      MFEM_ASSERT(loc_vertex_id >= 0, "internal error");
+      group__shared_vertex_to_vertex.AddConnection(group_id, loc_vertex_id);
+   }
+   group__shared_vertex_to_vertex.ShiftUpI();
+
+   // Construct 'mesh_part.group__shared_entity_to_vertex[Geometry::SEGMENT]'
+   if (dim >= 2)
+   {
+      Table &group__shared_edge_to_vertex =
+         mesh_part.group__shared_entity_to_vertex[Geometry::SEGMENT];
+      group__shared_edge_to_vertex.MakeI(num_groups);
+      for (int se = 0; se < shared_edges.Size(); se++)
+      {
+         const int group_id = shared_edges[se].two;
+         group__shared_edge_to_vertex.AddColumnsInRow(group_id, 2);
+      }
+      group__shared_edge_to_vertex.MakeJ();
+      const Table &edge_to_vertex = *mesh.GetEdgeVertexTable();
+      for (int se = 0; se < shared_edges.Size(); se++)
+      {
+         const int glob_edge_id = shared_edges[se].one;
+         const int group_id     = shared_edges[se].two;
+         const int *v = edge_to_vertex.GetRow(glob_edge_id);
+         for (int i = 0; i < 2; i++)
+         {
+            const int loc_vertex_id = vertex_loc_to_glob.FindSorted(v[i]);
+            MFEM_ASSERT(loc_vertex_id >= 0, "internal error");
+            group__shared_edge_to_vertex.AddConnection(group_id, loc_vertex_id);
+         }
+      }
+      group__shared_edge_to_vertex.ShiftUpI();
+   }
+
+   // Construct 'mesh_part.group__shared_entity_to_vertex[Geometry::TRIANGLE]'
+   // and 'mesh_part.group__shared_entity_to_vertex[Geometry::SQUARE]'.
+   if (dim >= 3)
+   {
+      Table &group__shared_tria_to_vertex =
+         mesh_part.group__shared_entity_to_vertex[Geometry::TRIANGLE];
+      Table &group__shared_quad_to_vertex =
+         mesh_part.group__shared_entity_to_vertex[Geometry::SQUARE];
+      Array<int> vertex_ids;
+      group__shared_tria_to_vertex.MakeI(num_groups);
+      group__shared_quad_to_vertex.MakeI(num_groups);
+      for (int sf = 0; sf < shared_faces.Size(); sf++)
+      {
+         const int glob_face_id = shared_faces[sf].one;
+         const int group_id     = shared_faces[sf].two;
+         const int geom         = mesh.GetFaceGeometry(glob_face_id);
+         mesh_part.group__shared_entity_to_vertex[geom].
+         AddColumnsInRow(group_id, Geometry::NumVerts[geom]);
+      }
+      group__shared_tria_to_vertex.MakeJ();
+      group__shared_quad_to_vertex.MakeJ();
+      for (int sf = 0; sf < shared_faces.Size(); sf++)
+      {
+         const int glob_face_id = shared_faces[sf].one;
+         const int group_id     = shared_faces[sf].two;
+         const int geom         = mesh.GetFaceGeometry(glob_face_id);
+         mesh.GetFaceVertices(glob_face_id, vertex_ids);
+         // Rotate shared triangles that have an adjacent tetrahedron with a
+         // nonzero refinement flag.
+         // See also ParMesh::BuildSharedFaceElems.
+         if (geom == Geometry::TRIANGLE)
+         {
+            int glob_el_id[2];
+            mesh.GetFaceElements(glob_face_id, &glob_el_id[0], &glob_el_id[1]);
+            int side = 0;
+            const Element *el = mesh.GetElement(glob_el_id[0]);
+            const Tetrahedron *tet = nullptr;
+            if (el->GetGeometryType() == Geometry::TETRAHEDRON)
+            {
+               tet = static_cast<const Tetrahedron*>(el);
+            }
+            else
+            {
+               side = 1;
+               el = mesh.GetElement(glob_el_id[1]);
+               if (el->GetGeometryType() == Geometry::TETRAHEDRON)
+               {
+                  tet = static_cast<const Tetrahedron*>(el);
+               }
+            }
+            if (tet && tet->GetRefinementFlag())
+            {
+               // mark the shared face for refinement by reorienting
+               // it according to the refinement flag in the tetrahedron
+               // to which this shared face belongs to.
+               int info[2];
+               mesh.GetFaceInfos(glob_face_id, &info[0], &info[1]);
+               tet->GetMarkedFace(info[side]/64, &vertex_ids[0]);
+            }
+         }
+         for (int i = 0; i < vertex_ids.Size(); i++)
+         {
+            const int glob_id = vertex_ids[i];
+            const int loc_id = vertex_loc_to_glob.FindSorted(glob_id);
+            MFEM_ASSERT(loc_id >= 0, "internal error");
+            vertex_ids[i] = loc_id;
+         }
+         mesh_part.group__shared_entity_to_vertex[geom].
+         AddConnections(group_id, vertex_ids, vertex_ids.Size());
+      }
+      group__shared_tria_to_vertex.ShiftUpI();
+      group__shared_quad_to_vertex.ShiftUpI();
+   }
+}
+
+std::unique_ptr<FiniteElementSpace>
+MeshPartitioner::ExtractFESpace(MeshPart &mesh_part,
+                                const FiniteElementSpace &global_fespace) const
+{
+   mesh_part.GetMesh(); // initialize 'mesh_part.mesh'
+   // Note: the nodes of 'mesh_part.mesh' are not set.
+
+   return std::unique_ptr<FiniteElementSpace>(
+             new FiniteElementSpace(mesh_part.mesh.get(),
+                                    global_fespace.FEColl(),
+                                    global_fespace.GetVDim(),
+                                    global_fespace.GetOrdering()));
+}
+
+std::unique_ptr<GridFunction>
+MeshPartitioner::ExtractGridFunction(MeshPart &mesh_part,
+                                     const GridFunction &global_gf,
+                                     FiniteElementSpace &local_fespace) const
+{
+   std::unique_ptr<GridFunction> local_gf(new GridFunction(&local_fespace));
+
+   // Transfer data from 'global_gf' to 'local_gf'.
+   Array<int> gvdofs, lvdofs;
+   Vector loc_vals;
+   const int part_id = mesh_part.my_part_id;
+   const int num_elems = part_to_element.RowSize(part_id);
+   const int *elem_list = part_to_element.GetRow(part_id); // sorted
+   for (int loc_elem_id = 0; loc_elem_id < num_elems; loc_elem_id++)
+   {
+      const int glob_elem_id = elem_list[loc_elem_id];
+      auto glob_dt = global_gf.FESpace()->GetElementVDofs(glob_elem_id, gvdofs);
+      global_gf.GetSubVector(gvdofs, loc_vals);
+      if (glob_dt) { glob_dt->InvTransformPrimal(loc_vals); }
+      auto local_dt = local_fespace.GetElementVDofs(loc_elem_id, lvdofs);
+      if (local_dt) { local_dt->TransformPrimal(loc_vals); }
+      local_gf->SetSubVector(lvdofs, loc_vals);
+   }
+   return local_gf;
+}
+
+MeshPartitioner::~MeshPartitioner()
+{
+   if (own_partitioning) { delete [] partitioning; }
+}
+
+
 GeometricFactors::GeometricFactors(const Mesh *mesh, const IntegrationRule &ir,
                                    int flags, MemoryType d_mt)
 {
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index 64cf55ae4..157f43606 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -27,6 +27,7 @@
 #include "../general/adios2stream.hpp"
 #endif
 #include <iostream>
+#include <memory>
 
 namespace mfem
 {
@@ -74,8 +75,10 @@ protected:
        visualization purpose in GLVis. */
    mutable int nbInteriorFaces, nbBoundaryFaces;
 
-   int meshgen; // see MeshGenerator()
-   int mesh_geoms; // sum of (1 << geom) for all geom of all dimensions
+   // see MeshGenerator(); global in parallel
+   int meshgen;
+   // sum of (1 << geom) for all geom of all dimensions; local in parallel
+   int mesh_geoms;
 
    // Counter for Mesh transformations: refinement, derefinement, rebalancing.
    // Used for checking during Update operations on objects depending on the
@@ -543,7 +546,7 @@ protected:
    void Make1D(int n, double sx = 1.0);
 
    /// Internal function used in Mesh::MakeRefined
-   void MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+   void MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                      int ref_type);
 
    /// Initialize vertices/elements/boundary/tables from a nonconforming mesh.
@@ -563,6 +566,13 @@ protected:
 
 public:
 
+   /// @anchor mfem_Mesh_ctors
+   /// @name Standard Mesh constructors and related methods
+   ///
+   /// These constructors and assignment operators accept mesh information in
+   /// a variety of common forms. For more specialized constructors see
+   /// @ref mfem_Mesh_named_ctors "Named mesh constructors".
+   /// @{
    Mesh() { SetEmpty(); }
 
    /** Copy constructor. Performs a deep copy of (almost) all data, so that the
@@ -574,16 +584,91 @@ public:
    /// Move constructor, useful for using a Mesh as a function return value.
    Mesh(Mesh &&mesh);
 
-   /// Move assignment operstor.
+   /// Move assignment operator.
    Mesh& operator=(Mesh &&mesh);
 
    /// Explicitly delete the copy assignment operator.
    Mesh& operator=(const Mesh &mesh) = delete;
 
-   /** @name Named mesh constructors.
+   /// Construct a Mesh from the given primary data.
+   /** The array @a vertices is used as external data, i.e. the Mesh does not
+       copy the data and will not delete the pointer.
+
+       The data from the other arrays is copied into the internal Mesh data
+       structures.
+
+       This method calls the method FinalizeTopology(). The method Finalize()
+       may be called after this constructor and after optionally setting the
+       Mesh nodes. */
+   Mesh(double *vertices, int num_vertices,
+        int *element_indices, Geometry::Type element_type,
+        int *element_attributes, int num_elements,
+        int *boundary_indices, Geometry::Type boundary_type,
+        int *boundary_attributes, int num_boundary_elements,
+        int dimension, int space_dimension = -1);
+
+   /** @anchor mfem_Mesh_init_ctor
+       @brief _Init_ constructor: begin the construction of a Mesh object.
+
+       Construct a shell of a mesh object allocating space to store pointers to
+       the vertices, elements, and boundary elements. The vertices and elements
+       themselves can later be added using methods from the
+       @ref mfem_Mesh_construction "Mesh construction" group.
+   */
+   Mesh(int Dim_, int NVert, int NElem, int NBdrElem = 0, int spaceDim_ = -1)
+   {
+      if (spaceDim_ == -1) { spaceDim_ = Dim_; }
+      InitMesh(Dim_, spaceDim_, NVert, NElem, NBdrElem);
+   }
+
+   /** Creates mesh by reading a file in MFEM, Netgen, or VTK format. If
+       generate_edges = 0 (default) edges are not generated, if 1 edges are
+       generated. See also @a Mesh::LoadFromFile. */
+   explicit Mesh(const char *filename, int generate_edges = 0, int refine = 1,
+                 bool fix_orientation = true);
+
+   /** Creates mesh by reading data stream in MFEM, Netgen, or VTK format. If
+       generate_edges = 0 (default) edges are not generated, if 1 edges are
+       generated. */
+   explicit Mesh(std::istream &input, int generate_edges = 0, int refine = 1,
+                 bool fix_orientation = true);
+
+   /// Create a disjoint mesh from the given mesh array
+   ///
+   /// @note Data is copied from the meshes in @a mesh_array.
+   Mesh(Mesh *mesh_array[], int num_pieces);
+
+   /** This is similar to the mesh constructor with the same arguments, but here
+       the current mesh is destroyed and another one created based on the data
+       stream again given in MFEM, Netgen, or VTK format. If generate_edges = 0
+       (default) edges are not generated, if 1 edges are generated. */
+   /// \see mfem::ifgzstream() for on-the-fly decompression of compressed ascii
+   /// inputs.
+   virtual void Load(std::istream &input, int generate_edges = 0,
+                     int refine = 1, bool fix_orientation = true)
+   {
+      Loader(input, generate_edges);
+      Finalize(refine, fix_orientation);
+   }
+
+   /// Swaps internal data with another mesh. By default, non-geometry members
+   /// like 'ncmesh' and 'NURBSExt' are only swapped when 'non_geometry' is set.
+   void Swap(Mesh& other, bool non_geometry);
+
+   /// Clear the contents of the Mesh.
+   void Clear() { Destroy(); SetEmpty(); }
+
+   /// Destroys Mesh.
+   virtual ~Mesh() { DestroyPointers(); }
+
+   /// @}
+
+   /** @anchor mfem_Mesh_named_ctors @name Named mesh constructors.
 
-       Each of these constructors uses the move constructor, and can be used as
-       the right-hand side of an assignment when creating new meshes. */
+        Each of these constructors uses the move constructor, and can be used as
+        the right-hand side of an assignment when creating new meshes. For more
+        general mesh constructors see
+        @ref mfem_Mesh_ctors "Standard mesh constructors".*/
    ///@{
 
    /** Creates mesh by reading a file in MFEM, Netgen, or VTK format. If
@@ -670,44 +755,8 @@ public:
 
    ///@}
 
-   /// @brief Creates a mapping @a v2v from the vertex indices of the mesh such
-   /// that coincident vertices under the given @a translations are identified.
-   /** Each Vector in @a translations should be of size @a sdim (the spatial
-       dimension of the mesh). Two vertices are considered coincident if the
-       translated coordinates of one vertex are within the given tolerance (@a
-       tol, relative to the mesh diameter) of the coordinates of the other
-       vertex.
-       @warning This algorithm does not scale well with the number of boundary
-       vertices in the mesh, and may run slowly on very large meshes. */
-   std::vector<int> CreatePeriodicVertexMapping(
-      const std::vector<Vector> &translations, double tol = 1e-8) const;
-
-   /// Construct a Mesh from the given primary data.
-   /** The array @a vertices is used as external data, i.e. the Mesh does not
-       copy the data and will not delete the pointer.
-
-       The data from the other arrays is copied into the internal Mesh data
-       structures.
-
-       This method calls the method FinalizeTopology(). The method Finalize()
-       may be called after this constructor and after optionally setting the
-       Mesh nodes. */
-   Mesh(double *vertices, int num_vertices,
-        int *element_indices, Geometry::Type element_type,
-        int *element_attributes, int num_elements,
-        int *boundary_indices, Geometry::Type boundary_type,
-        int *boundary_attributes, int num_boundary_elements,
-        int dimension, int space_dimension = -1);
-
-   /** @anchor mfem_Mesh_init_ctor
-       @brief _Init_ constructor: begin the construction of a Mesh object. */
-   Mesh(int Dim_, int NVert, int NElem, int NBdrElem = 0, int spaceDim_ = -1)
-   {
-      if (spaceDim_ == -1) { spaceDim_ = Dim_; }
-      InitMesh(Dim_, spaceDim_, NVert, NElem, NBdrElem);
-   }
-
-   /** @name Methods for Mesh construction.
+   /** @anchor mfem_Mesh_construction
+       @name Methods for piecewise Mesh construction.
 
        These methods are intended to be used with the @ref mfem_Mesh_init_ctor
        "init constructor". */
@@ -767,7 +816,7 @@ public:
 
    int AddBdrPoint(int v, int attr = 1);
 
-   void GenerateBoundaryElements();
+   virtual void GenerateBoundaryElements();
    /// Finalize the construction of a triangular Mesh.
    void FinalizeTriMesh(int generate_edges = 0, int refine = 0,
                         bool fix_orientation = true);
@@ -789,6 +838,9 @@ public:
 
    ///@}
 
+   /// @name Mesh consistency methods
+   /// @{
+
    /** @brief Finalize the construction of the secondary topology (connectivity)
        data of a Mesh. */
    /** This method does not require any actual coordinate data (either vertex
@@ -816,8 +868,56 @@ public:
        Mesh vertices or nodes are set. */
    virtual void Finalize(bool refine = false, bool fix_orientation = false);
 
+   /// @brief Determine the sets of unique attribute values in domain and
+   /// boundary elements.
+   ///
+   /// Separately scan the domain and boundary elements to generate unique,
+   /// sorted sets of the element attribute values present in the mesh and
+   /// store these in the Mesh::attributes and Mesh::bdr_attributes arrays.
    virtual void SetAttributes();
 
+   /// Check (and optionally attempt to fix) the orientation of the elements
+   /** @param[in] fix_it  If `true`, attempt to fix the orientations of some
+                          elements: triangles, quads, and tets.
+       @return The number of elements with wrong orientation.
+
+       @note For meshes with nodes (e.g. high-order or periodic meshes), fixing
+       the element orientations may require additional permutation of the nodal
+       GridFunction of the mesh which is not performed by this method. Instead,
+       the method Finalize() should be used with the parameter
+       @a fix_orientation set to `true`.
+
+       @note This method performs a simple check if an element is inverted, e.g.
+       for most elements types, it checks if the Jacobian of the mapping from
+       the reference element is non-negative at the center of the element. */
+   int CheckElementOrientation(bool fix_it = true);
+
+   /// Check the orientation of the boundary elements
+   /** @return The number of boundary elements with wrong orientation. */
+   int CheckBdrElementOrientation(bool fix_it = true);
+
+   /** This method modifies a tetrahedral mesh so that Nedelec spaces of order
+       greater than 1 can be defined on the mesh. Specifically, we
+       1) rotate all tets in the mesh so that the vertices {v0, v1, v2, v3}
+       satisfy: v0 < v1 < min(v2, v3).
+       2) rotate all boundary triangles so that the vertices {v0, v1, v2}
+       satisfy: v0 < min(v1, v2).
+
+       @note Refinement does not work after a call to this method! */
+   MFEM_DEPRECATED virtual void ReorientTetMesh();
+
+   /// Remove unused vertices and rebuild mesh connectivity.
+   void RemoveUnusedVertices();
+
+   /** Remove boundary elements that lie in the interior of the mesh, i.e. that
+       have two adjacent faces in 3D, or edges in 2D. */
+   void RemoveInternalBoundaries();
+
+   /// @}
+
+   /// @name Element ordering methods
+   /// @{
+
    /** This is our integration with the Gecko library. The method finds an
        element ordering that will increase memory coherency by putting elements
        that are in physical proximity closer in memory. It can also be used to
@@ -853,6 +953,14 @@ public:
        reorders vertices, edges and faces along with the elements. */
    void ReorderElements(const Array<int> &ordering, bool reorder_vertices = true);
 
+   /// @}
+
+   /// @anchor mfem_Mesh_deprecated_ctors @name Deprecated mesh constructors
+   ///
+   /// These constructors have been deprecated in favor of
+   /// @ref mfem_Mesh_named_ctors "Named mesh constructors".
+   /// @{
+
    /// Deprecated: see @a MakeCartesian3D.
    MFEM_DEPRECATED
    Mesh(int nx, int ny, int nz, Element::Type type, bool generate_edges = false,
@@ -880,42 +988,27 @@ public:
       // Finalize(); // reminder: not needed
    }
 
-   /** Creates mesh by reading a file in MFEM, Netgen, or VTK format. If
-       generate_edges = 0 (default) edges are not generated, if 1 edges are
-       generated. See also @a Mesh::LoadFromFile. */
-   explicit Mesh(const char *filename, int generate_edges = 0, int refine = 1,
-                 bool fix_orientation = true);
-
-   /** Creates mesh by reading data stream in MFEM, Netgen, or VTK format. If
-       generate_edges = 0 (default) edges are not generated, if 1 edges are
-       generated. */
-   explicit Mesh(std::istream &input, int generate_edges = 0, int refine = 1,
-                 bool fix_orientation = true);
-
-   /// Create a disjoint mesh from the given mesh array
-   ///
-   /// @note Data is copied from the meshes in @a mesh_array.
-   Mesh(Mesh *mesh_array[], int num_pieces);
-
    /// Deprecated: see @a MakeRefined.
    MFEM_DEPRECATED
    Mesh(Mesh *orig_mesh, int ref_factor, int ref_type);
 
-   /** This is similar to the mesh constructor with the same arguments, but here
-       the current mesh is destroyed and another one created based on the data
-       stream again given in MFEM, Netgen, or VTK format. If generate_edges = 0
-       (default) edges are not generated, if 1 edges are generated. */
-   /// \see mfem::ifgzstream() for on-the-fly decompression of compressed ascii
-   /// inputs.
-   virtual void Load(std::istream &input, int generate_edges = 0,
-                     int refine = 1, bool fix_orientation = true)
-   {
-      Loader(input, generate_edges);
-      Finalize(refine, fix_orientation);
-   }
+   /// @}
 
-   /// Clear the contents of the Mesh.
-   void Clear() { Destroy(); SetEmpty(); }
+   /// @name Information about the mesh as a whole
+   /// @{
+
+   /// @brief Dimension of the reference space used within the elements
+   int Dimension() const { return Dim; }
+
+   /// @brief Dimension of the physical space containing the mesh
+   int SpaceDimension() const { return spaceDim; }
+
+   /// Equals 1 + num_holes - num_loops
+   inline int EulerNumber() const
+   { return NumOfVertices - NumOfEdges + NumOfFaces - NumOfElements; }
+   /// Equals 1 - num_holes
+   inline int EulerNumber2D() const
+   { return NumOfVertices - NumOfEdges + NumOfElements; }
 
    /** @brief Get the mesh generator/type.
 
@@ -934,6 +1027,38 @@ public:
    */
    inline int MeshGenerator() { return meshgen; }
 
+   /// Checks if the mesh has boundary elements
+   virtual bool HasBoundaryElements() const { return (NumOfBdrElements > 0); }
+
+   /** @brief Return true iff the given @a geom is encountered in the mesh.
+       Geometries of dimensions lower than Dimension() are counted as well. */
+   bool HasGeometry(Geometry::Type geom) const
+   { return mesh_geoms & (1 << geom); }
+
+   /** @brief Return the number of geometries of the given dimension present in
+       the mesh. */
+   /** For a parallel mesh only the local geometries are counted. */
+   int GetNumGeometries(int dim) const;
+
+   /// Return all element geometries of the given dimension present in the mesh.
+   /** For a parallel mesh only the local geometries are returned.
+
+       The returned geometries are sorted. */
+   void GetGeometries(int dim, Array<Geometry::Type> &el_geoms) const;
+
+   /// Returns the minimum and maximum corners of the mesh bounding box.
+   /** For high-order meshes, the geometry is first refined @a ref times. */
+   void GetBoundingBox(Vector &min, Vector &max, int ref = 2);
+
+   void GetCharacteristics(double &h_min, double &h_max,
+                           double &kappa_min, double &kappa_max,
+                           Vector *Vh = NULL, Vector *Vk = NULL);
+
+   /// @}
+
+   /// @name Information concerning numbers of mesh entities
+   /// @{
+
    /** @brief Returns number of vertices.  Vertices are only at the corners of
        elements, where you would expect them in the lowest-order mesh. */
    inline int GetNV() const { return NumOfVertices; }
@@ -967,97 +1092,13 @@ public:
        excluding all master nonconforming faces. */
    virtual int GetNFbyType(FaceType type) const;
 
-   /// Utility function: sum integers from all processors (Allreduce).
-   virtual long long ReduceInt(int value) const { return value; }
-
    /// Return the total (global) number of elements.
    long long GetGlobalNE() const { return ReduceInt(NumOfElements); }
 
-   /** Compute the Jacobian of the transformation from the perfect
-       reference element at the given integration point (defaults to the
-       center of the element if no integration point is specified) */
-   void GetElementJacobian(int i, DenseMatrix &J,
-                           const IntegrationPoint *ip = NULL);
-
-   /** Return vertex to vertex table. The connections stored in the table
-    are from smaller to bigger vertex index, i.e. if i<j and (i, j) is
-    in the table, then (j, i) is not stored. */
-   void GetVertexToVertexTable(DSTable &) const;
-
-   /** @brief Return the mesh geometric factors corresponding to the given
-       integration rule.
-
-       The IntegrationRule used with GetGeometricFactors needs to remain valid
-       until the internally stored GeometricFactors objects are destroyed (by
-       calling Mesh::DeleteGeometricFactors(), Mesh::NodesUpdated(), or the Mesh
-       destructor).
-
-       If the device MemoryType parameter @a d_mt is specified, then the
-       returned object will use that type unless it was previously allocated
-       with a different type.
-
-       The returned pointer points to an internal object that may be invalidated
-       by mesh operations such as refinement, vertex/node movement, etc. Since
-       not all such modifications can be tracked by the Mesh class (e.g. when
-       using the pointer returned by GetNodes() to change the nodes) one needs
-       to account for such changes by calling the method NodesUpdated() which,
-       in particular, will call DeleteGeometricFactors(). */
-   const GeometricFactors* GetGeometricFactors(
-      const IntegrationRule& ir,
-      const int flags,
-      MemoryType d_mt = MemoryType::DEFAULT);
+   /// @}
 
-   /** @brief Return the mesh geometric factors for the faces corresponding
-       to the given integration rule.
-
-       The IntegrationRule used with GetFaceGeometricFactors needs to remain
-       valid until the internally stored FaceGeometricFactors objects are
-       destroyed (by either calling Mesh::DeleteGeometricFactors(),
-       Mesh::NodesUpdated(), or the Mesh destructor).
-
-       If the device MemoryType parameter @a d_mt is specified, then the
-       returned object will use that type unless it was previously allocated
-       with a different type.
-
-       The returned pointer points to an internal object that may be invalidated
-       by mesh operations such as refinement, vertex/node movement, etc. Since
-       not all such modifications can be tracked by the Mesh class (e.g. when
-       using the pointer returned by GetNodes() to change the nodes) one needs
-       to account for such changes by calling the method NodesUpdated() which,
-       in particular, will call DeleteGeometricFactors(). */
-   const FaceGeometricFactors* GetFaceGeometricFactors(
-      const IntegrationRule& ir,
-      const int flags,
-      FaceType type,
-      MemoryType d_mt = MemoryType::DEFAULT);
-
-   /// Destroy all GeometricFactors stored by the Mesh.
-   /** This method can be used to force recomputation of the GeometricFactors,
-       for example, after the mesh nodes are modified externally.
-
-       @note In general, the preferred method for resetting the GeometricFactors
-       should be to call NodesUpdated(). */
-   void DeleteGeometricFactors();
-
-   /** @brief This function should be called after the mesh node coordinates
-       have been updated externally, e.g. by modifying the internal nodal
-       GridFunction returned by GetNodes(). */
-   /** It deletes internal quantities derived from the node coordinates,
-       such as the (Face)GeometricFactors.
-
-       @note Unlike the similarly named protected method UpdateNodes() this
-       method does not modify the nodes. */
-   void NodesUpdated() { DeleteGeometricFactors(); }
-
-   /// Equals 1 + num_holes - num_loops
-   inline int EulerNumber() const
-   { return NumOfVertices - NumOfEdges + NumOfFaces - NumOfElements; }
-   /// Equals 1 - num_holes
-   inline int EulerNumber2D() const
-   { return NumOfVertices - NumOfEdges + NumOfElements; }
-
-   int Dimension() const { return Dim; }
-   int SpaceDimension() const { return spaceDim; }
+   /// @name Access to individual mesh entities
+   /// @{
 
    /// @brief Return pointer to vertex i's coordinates.
    /// @warning For high-order meshes (when #Nodes != NULL) vertices may not be
@@ -1074,27 +1115,6 @@ public:
    /// changed by the caller.
    double *GetVertex(int i) { return vertices[i](); }
 
-   void GetElementData(int geom, Array<int> &elem_vtx, Array<int> &attr) const
-   { GetElementData(elements, geom, elem_vtx, attr); }
-
-   /// Checks if the mesh has boundary elements
-   virtual bool HasBoundaryElements() const { return (NumOfBdrElements > 0); }
-
-   void GetBdrElementData(int geom, Array<int> &bdr_elem_vtx,
-                          Array<int> &bdr_attr) const
-   { GetElementData(boundary, geom, bdr_elem_vtx, bdr_attr); }
-
-   /** @brief Set the internal Vertex array to point to the given @a vertices
-       array without assuming ownership of the pointer. */
-   /** If @a zerocopy is `true`, the vertices must be given as an array of 3
-       doubles per vertex. If @a zerocopy is `false` then the current Vertex
-       data is first copied to the @a vertices array. */
-   void ChangeVertexDataOwnership(double *vertices, int len_vertices,
-                                  bool zerocopy = false);
-
-   const Element* const *GetElementsArray() const
-   { return elements.GetData(); }
-
    /// @brief Return pointer to the i'th element object
    ///
    /// The index @a i should be in the range [0, this->Mesh::GetNE())
@@ -1125,8 +1145,72 @@ public:
    /// the Element object itself should not be deleted by the caller.
    Element *GetBdrElement(int i) { return boundary[i]; }
 
+   inline int GetNCMasterFaceIndex(int i) const
+   {
+      MFEM_ASSERT(i < nc_faces_info.Size() &&
+                  i >= 0, i << " not in [0, " << nc_faces_info.Size() << ")");
+      const auto &ncf = nc_faces_info[i];
+      MFEM_VERIFY(ncf.Slave, "If the master face is requested, must be slave");
+      return ncf.MasterFace;
+   }
    const Element *GetFace(int i) const { return faces[i]; }
 
+   /// @}
+
+   /// @name Access to groups of mesh entities
+   /// @{
+
+   const Element* const *GetElementsArray() const
+   { return elements.GetData(); }
+
+   void GetElementData(int geom, Array<int> &elem_vtx, Array<int> &attr) const
+   { GetElementData(elements, geom, elem_vtx, attr); }
+
+   void GetBdrElementData(int geom, Array<int> &bdr_elem_vtx,
+                          Array<int> &bdr_attr) const
+   { GetElementData(boundary, geom, bdr_elem_vtx, bdr_attr); }
+
+   /// @}
+
+   /// @name Access information concerning individual mesh entites
+   /// @{
+
+   /// Return the attribute of element i.
+   int GetAttribute(int i) const { return elements[i]->GetAttribute(); }
+
+   /// Set the attribute of element i.
+   void SetAttribute(int i, int attr) { elements[i]->SetAttribute(attr); }
+
+   /// Return the attribute of boundary element i.
+   int GetBdrAttribute(int i) const { return boundary[i]->GetAttribute(); }
+
+   /// Set the attribute of boundary element i.
+   void SetBdrAttribute(int i, int attr) { boundary[i]->SetAttribute(attr); }
+
+   /// Return the attribute of patch i, for a NURBS mesh.
+   int GetPatchAttribute(int i) const;
+
+   /// Set the attribute of patch i, for a NURBS mesh.
+   void SetPatchAttribute(int i, int attr);
+
+   /// Return the attribute of patch boundary element i, for a NURBS mesh.
+   int GetPatchBdrAttribute(int i) const;
+
+   /// Set the attribute of patch boundary element i, for a NURBS mesh.
+   void SetPatchBdrAttribute(int i, int attr);
+
+   /// Returns the type of element i.
+   Element::Type GetElementType(int i) const;
+
+   /// Returns the type of boundary element i.
+   Element::Type GetBdrElementType(int i) const;
+
+   /// Deprecated in favor of Mesh::GetFaceGeometry
+   MFEM_DEPRECATED Geometry::Type GetFaceGeometryType(int Face) const
+   { return GetFaceGeometry(Face); }
+
+   Element::Type  GetFaceElementType(int Face) const;
+
    /// Return the Geometry::Type associated with face @a i.
    Geometry::Type GetFaceGeometry(int i) const;
 
@@ -1150,21 +1234,29 @@ public:
    Geometry::Type GetBdrElementBaseGeometry(int i) const
    { return GetBdrElementGeometry(i); }
 
-   /** @brief Return true iff the given @a geom is encountered in the mesh.
-       Geometries of dimensions lower than Dimension() are counted as well. */
-   bool HasGeometry(Geometry::Type geom) const
-   { return mesh_geoms & (1 << geom); }
+   /// Return true if the given face is interior. @sa FaceIsTrueInterior().
+   bool FaceIsInterior(int FaceNo) const
+   {
+      return (faces_info[FaceNo].Elem2No >= 0);
+   }
 
-   /** @brief Return the number of geometries of the given dimension present in
-       the mesh. */
-   /** For a parallel mesh only the local geometries are counted. */
-   int GetNumGeometries(int dim) const;
+   /** @brief Get the size of the i-th element relative to the perfect
+       reference element. */
+   double GetElementSize(int i, int type = 0);
 
-   /// Return all element geometries of the given dimension present in the mesh.
-   /** For a parallel mesh only the local geometries are returned.
+   double GetElementSize(int i, const Vector &dir);
 
-       The returned geometries are sorted. */
-   void GetGeometries(int dim, Array<Geometry::Type> &el_geoms) const;
+   double GetElementVolume(int i);
+
+   void GetElementCenter(int i, Vector &center);
+
+   /** Compute the Jacobian of the transformation from the perfect
+       reference element at the given integration point (defaults to the
+       center of the element if no integration point is specified) */
+   void GetElementJacobian(int i, DenseMatrix &J,
+                           const IntegrationPoint *ip = NULL);
+
+   /// @}
 
    /// List of mesh geometries stored as Array<Geometry::Type>.
    class GeometryList : public Array<Geometry::Type>
@@ -1183,6 +1275,9 @@ public:
       { mesh.GetGeometries(dim, *this); }
    };
 
+   /// @name Access connectivity for individual mesh entites
+   /// @{
+
    /// Returns the indices of the vertices of element i.
    void GetElementVertices(int i, Array<int> &v) const
    { elements[i]->GetVertices(v); }
@@ -1217,16 +1312,6 @@ public:
    /// Returns the indices of the vertices of edge i.
    void GetEdgeVertices(int i, Array<int> &vert) const;
 
-   /// Returns the face-to-edge Table (3D)
-   ///
-   /// @note The returned object should NOT be deleted by the caller.
-   Table *GetFaceEdgeTable() const;
-
-   /// Returns the edge-to-vertex Table (3D)
-   ///
-   /// @note The returned object should NOT be deleted by the caller.
-   Table *GetEdgeVertexTable() const;
-
    /// Return the indices and the orientations of all faces of element i.
    void GetElementFaces(int i, Array<int> &faces, Array<int> &ori) const;
 
@@ -1262,19 +1347,50 @@ public:
        @sa GetBdrElementAdjacentElement() */
    void GetBdrElementAdjacentElement2(int bdr_el, int &el, int &info) const;
 
-   /// Returns the type of element i.
-   Element::Type GetElementType(int i) const;
+   /// Return the local face index for the given boundary face.
+   int GetBdrFace(int BdrElemNo) const;
 
-   /// Returns the type of boundary element i.
-   Element::Type GetBdrElementType(int i) const;
+   /// @}
 
-   /* Return point matrix of element i of dimension Dim X #v, where for every
-      vertex we give its coordinates in space of dimension Dim. */
-   void GetPointMatrix(int i, DenseMatrix &pointmat) const;
+   /// @name Access connectivity data
+   /// @{
 
-   /* Return point matrix of boundary element i of dimension Dim X #v, where for
-      every vertex we give its coordinates in space of dimension Dim. */
-   void GetBdrPointMatrix(int i, DenseMatrix &pointmat) const;
+   ///  The returned Table should be deleted by the caller
+   Table *GetVertexToElementTable();
+
+   /// Return the "face"-element Table. Here "face" refers to face (3D),
+   /// edge (2D), or vertex (1D).
+   /// The returned Table should be deleted by the caller.
+   Table *GetFaceToElementTable() const;
+
+   /// Returns the face-to-edge Table (3D)
+   ///
+   /// @note The returned object should NOT be deleted by the caller.
+   Table *GetFaceEdgeTable() const;
+
+   /// Returns the edge-to-vertex Table (3D)
+   /// @note The returned object should NOT be deleted by the caller.
+   Table *GetEdgeVertexTable() const;
+
+   /** Return vertex to vertex table. The connections stored in the table
+    are from smaller to bigger vertex index, i.e. if i<j and (i, j) is
+    in the table, then (j, i) is not stored.
+
+    @note This data is not stored internally as a Table. The Table passed as
+    an argument is populated using the EdgeVertex Table (see GetEdgeVertexTable)
+    if available or the element connectivity.
+   */
+   void GetVertexToVertexTable(DSTable &) const;
+
+   const Table &ElementToElementTable();
+
+   const Table &ElementToFaceTable() const;
+
+   const Table &ElementToEdgeTable() const;
+
+   Array<int> GetFaceToBdrElMap() const;
+
+   ///@}
 
    /// @brief Return FiniteElement for reference element of the specified type
    ///
@@ -1282,6 +1398,14 @@ public:
    /// should not be deleted by the caller.
    static FiniteElement *GetTransformationFEforElementType(Element::Type);
 
+   /// @anchor mfem_Mesh_elem_trans
+   /// @name Access the coordinate transformation for individual elements
+   ///
+   /// See also the methods related to
+   /// @ref mfem_Mesh_geom_factors "Geometric Factors" for accessing
+   /// information cached at quadrature points.
+   /// @{
+
    /// Builds the transformation defining the i-th element in @a ElTr.
    /// @a ElTr must be allocated in advance and will be owned by the caller.
    void GetElementTransformation(int i, IsoparametricTransformation *ElTr);
@@ -1377,26 +1501,83 @@ public:
       int FaceNo,
       int mask = 31);
 
-   /// See GetFaceElementTransformations().
-   /// @note The returned object should NOT be deleted by the caller.
-   FaceElementTransformations *GetInteriorFaceTransformations (int FaceNo)
-   {
-      if (faces_info[FaceNo].Elem2No < 0) { return NULL; }
-      return GetFaceElementTransformations (FaceNo);
-   }
+   /// See GetFaceElementTransformations().
+   /// @note The returned object should NOT be deleted by the caller.
+   FaceElementTransformations *GetInteriorFaceTransformations (int FaceNo)
+   {
+      if (faces_info[FaceNo].Elem2No < 0) { return NULL; }
+      return GetFaceElementTransformations (FaceNo);
+   }
+
+   /// Builds the transformation defining the given boundary face.
+   /// @note The returned object should NOT be deleted by the caller.
+   FaceElementTransformations *GetBdrFaceTransformations (int BdrElemNo);
+
+   /// @}
+
+   /// @anchor mfem_Mesh_geom_factors
+   /// @name Access the coordinate transformation at quadrature points
+   ///
+   /// See also methods related to
+   /// @ref mfem_Mesh_elem_trans "Element-wise coordinate transformation".
+   /// @{
+
+   /** @brief Return the mesh geometric factors corresponding to the given
+       integration rule.
+
+       The IntegrationRule used with GetGeometricFactors needs to remain valid
+       until the internally stored GeometricFactors objects are destroyed (by
+       calling Mesh::DeleteGeometricFactors(), Mesh::NodesUpdated(), or the Mesh
+       destructor).
+
+       If the device MemoryType parameter @a d_mt is specified, then the
+       returned object will use that type unless it was previously allocated
+       with a different type.
+
+       The returned pointer points to an internal object that may be invalidated
+       by mesh operations such as refinement, vertex/node movement, etc. Since
+       not all such modifications can be tracked by the Mesh class (e.g. when
+       using the pointer returned by GetNodes() to change the nodes) one needs
+       to account for such changes by calling the method NodesUpdated() which,
+       in particular, will call DeleteGeometricFactors(). */
+   const GeometricFactors* GetGeometricFactors(
+      const IntegrationRule& ir,
+      const int flags,
+      MemoryType d_mt = MemoryType::DEFAULT);
+
+   /** @brief Return the mesh geometric factors for the faces corresponding
+       to the given integration rule.
+
+       The IntegrationRule used with GetFaceGeometricFactors needs to remain
+       valid until the internally stored FaceGeometricFactors objects are
+       destroyed (by either calling Mesh::DeleteGeometricFactors(),
+       Mesh::NodesUpdated(), or the Mesh destructor).
+
+       If the device MemoryType parameter @a d_mt is specified, then the
+       returned object will use that type unless it was previously allocated
+       with a different type.
+
+       The returned pointer points to an internal object that may be invalidated
+       by mesh operations such as refinement, vertex/node movement, etc. Since
+       not all such modifications can be tracked by the Mesh class (e.g. when
+       using the pointer returned by GetNodes() to change the nodes) one needs
+       to account for such changes by calling the method NodesUpdated() which,
+       in particular, will call DeleteGeometricFactors(). */
+   const FaceGeometricFactors* GetFaceGeometricFactors(
+      const IntegrationRule& ir,
+      const int flags,
+      FaceType type,
+      MemoryType d_mt = MemoryType::DEFAULT);
 
-   /// Builds the transformation defining the given boundary face.
-   /// @note The returned object should NOT be deleted by the caller.
-   FaceElementTransformations *GetBdrFaceTransformations (int BdrElemNo);
+   /// Destroy all GeometricFactors stored by the Mesh.
+   /** This method can be used to force recomputation of the GeometricFactors,
+       for example, after the mesh nodes are modified externally.
 
-   /// Return the local face index for the given boundary face.
-   int GetBdrFace(int BdrElemNo) const;
+       @note In general, the preferred method for resetting the GeometricFactors
+       should be to call NodesUpdated(). */
+   void DeleteGeometricFactors();
 
-   /// Return true if the given face is interior. @sa FaceIsTrueInterior().
-   bool FaceIsInterior(int FaceNo) const
-   {
-      return (faces_info[FaceNo].Elem2No >= 0);
-   }
+   /// @}
 
    /** This enumerated type describes the three main face topologies:
        - Boundary, for faces on the boundary of the computational domain,
@@ -1460,7 +1641,7 @@ public:
                           };
 
    /** @brief This structure is used as a human readable output format that
-       decipheres the information contained in Mesh::FaceInfo when using the
+       deciphers the information contained in Mesh::FaceInfo when using the
        Mesh::GetFaceInformation() method.
 
        The element indices in this structure don't need further processing,
@@ -1558,6 +1739,17 @@ public:
       operator Mesh::FaceInfo() const;
    };
 
+   /// @name More advanced entity information access methods
+   /// @{
+
+   /* Return point matrix of element i of dimension Dim X #v, where for every
+      vertex we give its coordinates in space of dimension Dim. */
+   void GetPointMatrix(int i, DenseMatrix &pointmat) const;
+
+   /* Return point matrix of boundary element i of dimension Dim X #v, where for
+      every vertex we give its coordinates in space of dimension Dim. */
+   void GetBdrPointMatrix(int i, DenseMatrix &pointmat) const;
+
    /** This method aims to provide face information in a deciphered format, i.e.
        Mesh::FaceInformation, compared to the raw encoded information returned
        by Mesh::GetFaceElements() and Mesh::GetFaceInfos(). */
@@ -1567,89 +1759,25 @@ public:
    void GetFaceInfos (int Face, int *Inf1, int *Inf2) const;
    void GetFaceInfos (int Face, int *Inf1, int *Inf2, int *NCFace) const;
 
-   /// Deprecated in favor of Mesh::GetFaceGeometry
-   MFEM_DEPRECATED Geometry::Type GetFaceGeometryType(int Face) const
-   { return GetFaceGeometry(Face); }
-
-   Element::Type  GetFaceElementType(int Face) const;
-
-   Array<int> GetFaceToBdrElMap() const;
-
-   /// Check (and optionally attempt to fix) the orientation of the elements
-   /** @param[in] fix_it  If `true`, attempt to fix the orientations of some
-                          elements: triangles, quads, and tets.
-       @return The number of elements with wrong orientation.
-
-       @note For meshes with nodes (e.g. high-order or periodic meshes), fixing
-       the element orientations may require additional permutation of the nodal
-       GridFunction of the mesh which is not performed by this method. Instead,
-       the method Finalize() should be used with the parameter
-       @a fix_orientation set to `true`.
-
-       @note This method performs a simple check if an element is inverted, e.g.
-       for most elements types, it checks if the Jacobian of the mapping from
-       the reference element is non-negative at the center of the element. */
-   int CheckElementOrientation(bool fix_it = true);
-
-   /// Check the orientation of the boundary elements
-   /** @return The number of boundary elements with wrong orientation. */
-   int CheckBdrElementOrientation(bool fix_it = true);
-
-   /// Return the attribute of element i.
-   int GetAttribute(int i) const { return elements[i]->GetAttribute(); }
-
-   /// Set the attribute of element i.
-   void SetAttribute(int i, int attr) { elements[i]->SetAttribute(attr); }
-
-   /// Return the attribute of boundary element i.
-   int GetBdrAttribute(int i) const { return boundary[i]->GetAttribute(); }
-
-   /// Set the attribute of boundary element i.
-   void SetBdrAttribute(int i, int attr) { boundary[i]->SetAttribute(attr); }
-
-   /// Return the attribute of patch i, for a NURBS mesh.
-   int GetPatchAttribute(int i) const;
-
-   /// Set the attribute of patch i, for a NURBS mesh.
-   void SetPatchAttribute(int i, int attr);
-
-   /// Return the attribute of patch boundary element i, for a NURBS mesh.
-   int GetPatchBdrAttribute(int i) const;
-
-   /// Set the attribute of patch boundary element i, for a NURBS mesh.
-   void SetPatchBdrAttribute(int i, int attr);
+   /// @}
 
-   const Table &ElementToElementTable();
-
-   const Table &ElementToFaceTable() const;
-
-   const Table &ElementToEdgeTable() const;
-
-   ///  The returned Table should be deleted by the caller
-   Table *GetVertexToElementTable();
-
-   /** Return the "face"-element Table. Here "face" refers to face (3D),
-       edge (2D), or vertex (1D).
-       The returned Table should be deleted by the caller. */
-   Table *GetFaceToElementTable() const;
-
-   /** This method modifies a tetrahedral mesh so that Nedelec spaces of order
-       greater than 1 can be defined on the mesh. Specifically, we
-       1) rotate all tets in the mesh so that the vertices {v0, v1, v2, v3}
-       satisfy: v0 < v1 < min(v2, v3).
-       2) rotate all boundary triangles so that the vertices {v0, v1, v2}
-       satisfy: v0 < min(v1, v2).
-
-       @note Refinement does not work after a call to this method! */
-   MFEM_DEPRECATED virtual void ReorientTetMesh();
+   /// @name Methods related to mesh partitioning
+   /// @{
 
    /// @note The returned array should be deleted by the caller.
    int *CartesianPartitioning(int nxyz[]);
    /// @note The returned array should be deleted by the caller.
    int *GeneratePartitioning(int nparts, int part_method = 1);
+   /// @todo This method needs a proper description
    void CheckPartitioning(int *partitioning_);
 
-   void CheckDisplacements(const Vector &displacements, double &tmax);
+   /// @}
+
+   /// @anchor mfem_Mesh_trans
+   /// @name Methods related to accessing/altering mesh coordinates
+   ///
+   /// See also @ref mfem_Mesh_gf_nodes "Coordinates as a GridFunction".
+   /// @{
 
    // Vertices are only at the corners of elements, where you would expect them
    // in the lowest-order mesh.
@@ -1657,6 +1785,14 @@ public:
    void GetVertices(Vector &vert_coord) const;
    void SetVertices(const Vector &vert_coord);
 
+   /** @brief Set the internal Vertex array to point to the given @a vertices
+       array without assuming ownership of the pointer. */
+   /** If @a zerocopy is `true`, the vertices must be given as an array of 3
+       doubles per vertex. If @a zerocopy is `false` then the current Vertex
+       data is first copied to the @a vertices array. */
+   void ChangeVertexDataOwnership(double *vertices, int len_vertices,
+                                  bool zerocopy = false);
+
    // Nodes are only active for higher order meshes, and share locations with
    // the vertices, plus all the higher- order control points within the element
    // and along the edges and on the faces.
@@ -1671,6 +1807,30 @@ public:
    /// Updates the vertex/node locations. Invokes NodesUpdated().
    void SetNodes(const Vector &node_coord);
 
+   void ScaleSubdomains (double sf);
+   void ScaleElements (double sf);
+
+   void Transform(void (*f)(const Vector&, Vector&));
+   void Transform(VectorCoefficient &deformation);
+
+   /** @brief This function should be called after the mesh node coordinates
+       have been updated externally, e.g. by modifying the internal nodal
+       GridFunction returned by GetNodes(). */
+   /** It deletes internal quantities derived from the node coordinates,
+       such as the (Face)GeometricFactors.
+
+       @note Unlike the similarly named protected method UpdateNodes() this
+       method does not modify the nodes. */
+   void NodesUpdated() { DeleteGeometricFactors(); }
+
+   /// @}
+
+   /// @anchor mfem_Mesh_gf_nodes
+   /// @name Methods related to nodal coordinates stored as a GridFunction
+   ///
+   /// See also @ref mfem_Mesh_trans "Mesh Transformations".
+   /// @{
+
    /// @brief Return a pointer to the internal node GridFunction (may be NULL).
    ///
    /// If the mesh is straight-sided (low-order), it may not have a GridFunction
@@ -1725,6 +1885,11 @@ public:
    virtual void SetCurvature(int order, bool discont = false, int space_dim = -1,
                              int ordering = 1);
 
+   /// @}
+
+   /// @name Methods related to mesh refinement
+   /// @{
+
    /// Refine all mesh elements.
    /** @param[in] ref_algo %Refinement algorithm. Currently used only for pure
        tetrahedral meshes. If set to zero (default), a tet mesh will be refined
@@ -1784,14 +1949,6 @@ public:
    bool DerefineByError(const Vector &elem_error, double threshold,
                         int nc_limit = 0, int op = 1);
 
-   ///@{ @name NURBS mesh refinement methods
-   void KnotInsert(Array<KnotVector *> &kv);
-   void KnotInsert(Array<Vector *> &kv);
-   /* For each knot vector:
-         new_degree = max(old_degree, min(old_degree + rel_degree, degree)). */
-   void DegreeElevate(int rel_degree, int degree = 16);
-   ///@}
-
    /** Make sure that a quad/hex mesh is considered to be nonconforming (i.e.,
        has an associated NCMesh object). Simplex meshes can be both conforming
        (default) or nonconforming. */
@@ -1813,6 +1970,19 @@ public:
        Update() calls. */
    long GetSequence() const { return sequence; }
 
+   /// @}
+
+   ///@{ @name NURBS mesh refinement methods
+   void KnotInsert(Array<KnotVector *> &kv);
+   void KnotInsert(Array<Vector *> &kv);
+   /* For each knot vector:
+         new_degree = max(old_degree, min(old_degree + rel_degree, degree)). */
+   void DegreeElevate(int rel_degree, int degree = 16);
+   ///@}
+
+   /// @name Print/Save/Export methods
+   /// @{
+
    /// Print the mesh to the given stream using Netgen/Truegrid format.
    virtual void PrintXG(std::ostream &os = mfem::out) const;
 
@@ -1840,27 +2010,30 @@ public:
    /** Print the mesh in VTU format. The parameter ref > 0 specifies an element
        subdivision number (useful for high order fields and curved meshes).
        If @a bdr_elements is true, then output (only) the boundary elements,
-       otherwise output only the non-boundary elements. */
+       otherwise output only the non-boundary elements. The parameter
+       @a scale_factor sets a scale factor for the output mesh point
+       coordinates. */
    void PrintVTU(std::ostream &os,
                  int ref=1,
                  VTKFormat format=VTKFormat::ASCII,
                  bool high_order_output=false,
                  int compression_level=0,
-                 bool bdr_elements=false);
+                 bool bdr_elements=false,
+                 double scale_factor=1.0);
    /** Print the mesh in VTU format with file name fname. */
    virtual void PrintVTU(std::string fname,
                          VTKFormat format=VTKFormat::ASCII,
                          bool high_order_output=false,
                          int compression_level=0,
-                         bool bdr=false);
+                         bool bdr_elements=false,
+                         double scale_factor=1.0);
    /** Print the boundary elements of the mesh in VTU format, and output the
        boundary attributes as a data array (useful for boundary conditions). */
    void PrintBdrVTU(std::string fname,
                     VTKFormat format=VTKFormat::ASCII,
                     bool high_order_output=false,
-                    int compression_level=0);
-
-   void GetElementColoring(Array<int> &colors, int el0 = 0);
+                    int compression_level=0,
+                    double scale_factor=1.0);
 
    /** @brief Prints the mesh with boundary elements given by the boundary of
        the subdomains, so that the boundary of subdomain i has boundary
@@ -1880,37 +2053,6 @@ public:
     */
    void PrintSurfaces(const Table &Aface_face, std::ostream &out) const;
 
-   void ScaleSubdomains (double sf);
-   void ScaleElements (double sf);
-
-   void Transform(void (*f)(const Vector&, Vector&));
-   void Transform(VectorCoefficient &deformation);
-
-   /// Remove unused vertices and rebuild mesh connectivity.
-   void RemoveUnusedVertices();
-
-   /** Remove boundary elements that lie in the interior of the mesh, i.e. that
-       have two adjacent faces in 3D, or edges in 2D. */
-   void RemoveInternalBoundaries();
-
-   /** @brief Get the size of the i-th element relative to the perfect
-       reference element. */
-   double GetElementSize(int i, int type = 0);
-
-   double GetElementSize(int i, const Vector &dir);
-
-   double GetElementVolume(int i);
-
-   void GetElementCenter(int i, Vector &center);
-
-   /// Returns the minimum and maximum corners of the mesh bounding box.
-   /** For high-order meshes, the geometry is first refined @a ref times. */
-   void GetBoundingBox(Vector &min, Vector &max, int ref = 2);
-
-   void GetCharacteristics(double &h_min, double &h_max,
-                           double &kappa_min, double &kappa_max,
-                           Vector *Vh = NULL, Vector *Vk = NULL);
-
    /// Auxiliary method used by PrintCharacteristics().
    /** It is also used in the `mesh-explorer` miniapp. */
    static void PrintElementsByGeometry(int dim,
@@ -1933,6 +2075,28 @@ public:
       PrintCharacteristics(NULL, NULL, os);
    }
 
+#ifdef MFEM_DEBUG
+   /// Output an NCMesh-compatible debug dump.
+   void DebugDump(std::ostream &out) const;
+#endif
+
+   /// @}
+
+   /// @name Miscellaneous or undocumented methods
+   /// @{
+
+   /// @brief Creates a mapping @a v2v from the vertex indices of the mesh such
+   /// that coincident vertices under the given @a translations are identified.
+   /** Each Vector in @a translations should be of size @a sdim (the spatial
+       dimension of the mesh). Two vertices are considered coincident if the
+       translated coordinates of one vertex are within the given tolerance (@a
+       tol, relative to the mesh diameter) of the coordinates of the other
+       vertex.
+       @warning This algorithm does not scale well with the number of boundary
+       vertices in the mesh, and may run slowly on very large meshes. */
+   std::vector<int> CreatePeriodicVertexMapping(
+      const std::vector<Vector> &translations, double tol = 1e-8) const;
+
    /** @brief Find the ids of the elements that contain the given points, and
        their corresponding reference coordinates.
 
@@ -1977,17 +2141,19 @@ public:
                                            Vector &skew,
                                            Vector &ori) const;
 
-   /// Swaps internal data with another mesh. By default, non-geometry members
-   /// like 'ncmesh' and 'NURBSExt' are only swapped when 'non_geometry' is set.
-   void Swap(Mesh& other, bool non_geometry);
+   /// Utility function: sum integers from all processors (Allreduce).
+   virtual long long ReduceInt(int value) const { return value; }
 
-   /// Destroys Mesh.
-   virtual ~Mesh() { DestroyPointers(); }
+   /// @todo This method needs a proper description
+   void GetElementColoring(Array<int> &colors, int el0 = 0);
 
-#ifdef MFEM_DEBUG
-   /// Output an NCMesh-compatible debug dump.
-   void DebugDump(std::ostream &out) const;
-#endif
+   /// @todo This method needs a proper description
+   void MesquiteSmooth(const int mesquite_option = 0);
+
+   /// @todo This method needs a proper description
+   void CheckDisplacements(const Vector &displacements, double &tmax);
+
+   /// @}
 };
 
 /** Overload operator<< for std::ostream and Mesh; valid also for the derived
@@ -1995,6 +2161,195 @@ public:
 std::ostream &operator<<(std::ostream &out, const Mesh &mesh);
 
 
+// Class containing a minimal description of a part (a subset of the elements)
+// of a Mesh and its connectivity to other parts. The main purpose of this class
+// is to be communicated between MPI ranks for repartitioning purposes. It can
+// also be used to implement parallel mesh I/O functions with partitionings that
+// have number of parts different from the number of MPI tasks.
+//
+// Note: parts of NURBS or non-conforming meshes cannot be fully described by
+// this class alone.
+class MeshPart
+{
+protected:
+   struct Entity { int geom; int num_verts; const int *verts; };
+   struct EntityHelper
+   {
+      int dim, num_entities;
+      int geom_offsets[Geometry::NumGeom+1];
+      typedef const Array<int> entity_to_vertex_type[Geometry::NumGeom];
+      entity_to_vertex_type &entity_to_vertex;
+
+      EntityHelper(int dim_,
+                   const Array<int> (&entity_to_vertex_)[Geometry::NumGeom]);
+      Entity FindEntity(int bytype_entity_id);
+   };
+
+public:
+   // Reference space dimension of the elements
+   int dimension;
+
+   // Dimension of the physical space into which the MeshPart is embedded.
+   int space_dimension;
+
+   // Number of vertices
+   int num_vertices;
+
+   // Number of elements with reference space dimension equal to 'dimension'.
+   int num_elements;
+
+   // Number of boundary elements with reference space dimension equal to
+   // 'dimension'-1.
+   int num_bdr_elements;
+
+   // Each 'entity_to_vertex[geom]' describes the entities of Geometry::Type
+   // 'geom' in terms of their vertices. The number of entities of type 'geom'
+   // is:
+   //    num_entities[geom] = size('entity_to_vertex[geom]')/num_vertices[geom]
+   // The number of all elements, 'num_elements', is:
+   //    'num_elements' = sum_{dim[geom]=='dimension'} num_entities[geom]
+   // and the number of all boundary elements, 'num_bdr_elements' is:
+   //    'num_bdr_elements' = sum_{dim[geom]=='dimension'-1} num_entities[geom]
+   // Note that 'entity_to_vertex' does NOT describe all "faces" in the mesh
+   // part (i.e. all 'dimension'-1 entities) but only the boundary elements.
+   Array<int> entity_to_vertex[Geometry::NumGeom];
+
+   // Store the refinement flags for tetraheral elements. If all tets have zero
+   // refinement flags then this array is empty, i.e. has size 0.
+   Array<int> tet_refine_flags;
+
+   // "By-type" element/boundary ordering: ordered by Geometry::Type and within
+   // each Geometry::Type 'geom' ordered as in 'entity_to_vertex[geom]'.
+
+   // Optional re-ordering of the elements that will be used by (Par)Mesh
+   // objects constructed from this MeshPart. This array maps "natural" element
+   // ids (used by the Mesh/ParMesh objects) to "by-type" element ids (see
+   // above):
+   //    "by-type" element id = element_map["natural" element id]
+   // The size of the array is either 'num_elements' or 0 when no re-ordering is
+   // needed (then "by-type" id == "natural" id).
+   Array<int> element_map;
+
+   // Optional re-ordering for the boundary elements, similar to 'element_map'.
+   Array<int> boundary_map;
+
+   // Element attributes. Ordered using the "natural" element ordering defined
+   // by the array 'element_map'. The size of this array is 'num_elements'.
+   Array<int> attributes;
+
+   // Boundary element attributes. Ordered using the "natural" boundary element
+   // ordering defined by the array 'boundary_map'. The size of this array is
+   // 'num_bdr_elements'.
+   Array<int> bdr_attributes;
+
+   // Optional vertex coordinates. The size of the array is either
+   //    size = 'space_dimension' * 'num_vertices'
+   // or 0 when the vertex coordinates are not used, i.e. when the MeshPart uses
+   // a nodal GridFunction to describe its location in physical space. This
+   // array uses Ordering::byVDIM: "X0,Y0,Z0, X1,Y1,Z1, ...".
+   Array<double> vertex_coordinates;
+
+   // Optional serial Mesh object constructed on demand using the method
+   // GetMesh(). One use case for it is when one wants to construct FE spaces
+   // and GridFunction%s on the MeshPart for saving or MPI communication.
+   std::unique_ptr<Mesh> mesh;
+
+   // Nodal FE space defined on 'mesh' used by the GridFunction 'nodes'. Uses
+   // the FE collection from the global nodal FE space.
+   std::unique_ptr<FiniteElementSpace> nodal_fes;
+
+   // 'nodes': pointer to a GridFunction describing the physical location of the
+   // MeshPart. Used for describing high-order and periodic meshes. This
+   // GridFunction is defined on the FE space 'nodal_fes' which, in turn, is
+   // defined on the Mesh 'mesh'.
+   std::unique_ptr<GridFunction> nodes;
+
+   // Connectivity to other MeshPart objects
+   // --------------------------------------
+
+   // Total number of MeshParts
+   int num_parts;
+
+   // Index of the part described by this MeshPart:
+   //    0 <= 'my_part_id' < 'num_parts'
+   int my_part_id;
+
+   // A group G is a subsets of the set { 0, 1, ..., 'num_parts'-1 } for which
+   // there is a mesh entity E (of any dimension) in the global mesh such that
+   // G is the set of the parts assigned to the elements adjacent to E. The
+   // MeshPart describes only the "neighbor" groups, i.e. the groups that
+   // contain 'my_part_id'. The Table 'my_groups' defines the "neighbor" groups
+   // in terms of their part ids. In other words, it maps "neighbor" group ids
+   // to a (sorted) list of part ids. In particular, the number of "neighbor"
+   // groups is given by 'my_groups.Size()'. The "local" group { 'my_part_id' }
+   // has index 0 in 'my_groups'.
+   Table my_groups;
+
+   // Shared entities for this MeshPart are mesh entities of all dimensions less
+   // than 'dimension' that are generated by the elements of this MeshPart and
+   // at least one other MeshPart.
+   //
+   // The Table 'group__shared_entity_to_vertex[geom]' defines, for each group,
+   // the shared entities of Geometry::Type 'geom'. Each row (corresponding to a
+   // "neighbor" group, as defined by 'my_groups') in the Table defines the
+   // shared entities in a way similar to the arrays 'entity_to_vertex[geom]'.
+   // The "local" group (with index 0) does not have any shared entities, so the
+   // 0-th row in the Table is always empty.
+   //
+   // IMPORTANT: the desciptions of the groups in this MeshPart must match their
+   // descriptions in all neighboring MeshParts. This includes the ordering of
+   // the shared entities within the group, as well as the vertex ordering of
+   // each shared entity.
+   Table group__shared_entity_to_vertex[Geometry::NumGeom];
+
+   // Write the MeshPart to a stream using the parallel format "MFEM mesh v1.2".
+   void Print(std::ostream &os) const;
+
+   // Construct a serrial Mesh object from the MeshPart. The nodes of 'mesh' are
+   // NOT initialized by this method, however, the nodal FE space and nodal
+   // GridFunction can be created and then attached to the 'mesh'. The Mesh is
+   // constructed only if 'mesh' is empty, otherwise the method simply returns
+   // the object held by 'mesh'.
+   Mesh &GetMesh();
+};
+
+
+// TODO: documentation
+class MeshPartitioner
+{
+protected:
+   Mesh &mesh;
+   int *partitioning;
+   bool own_partitioning;
+   Table part_to_element;
+   Table part_to_boundary;
+   Table edge_to_element;
+   Table vertex_to_element;
+
+public:
+   // TODO: documentation
+   MeshPartitioner(Mesh &mesh_, int num_parts_, int *partitioning_ = NULL,
+                   int part_method = 1);
+
+   // TODO: documentation
+   void ExtractPart(int part_id, MeshPart &mesh_part) const;
+
+   // TODO: documentation
+   std::unique_ptr<FiniteElementSpace>
+   ExtractFESpace(MeshPart &mesh_part,
+                  const FiniteElementSpace &global_fespace) const;
+
+   // TODO: documentation
+   std::unique_ptr<GridFunction>
+   ExtractGridFunction(MeshPart &mesh_part,
+                       const GridFunction &global_gf,
+                       FiniteElementSpace &local_fespace) const;
+
+   // Destructor
+   ~MeshPartitioner();
+};
+
+
 /** @brief Structure for storing mesh geometric factors: coordinates, Jacobians,
     and determinants of the Jacobians. */
 /** Typically objects of this type are constructed and owned by objects of class
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index d15dbed23..550e104dd 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -2176,9 +2176,9 @@ void NCMesh::UpdateVertices()
    //   - ghost (non-local) vertices (code -3)
    //   - vertices beyond the ghost layer (code -4)
 
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto & node : nodes)
    {
-      node->vert_index = -4; // assume beyond ghost layer
+      node.vert_index = -4; // assume beyond ghost layer
    }
 
    for (int i = 0; i < leaf_elements.Size(); i++)
@@ -2208,11 +2208,11 @@ void NCMesh::UpdateVertices()
    // STEP 2: assign indices of top-level local vertices, in original order
 
    NVertices = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->vert_index == -1)
+      if (node.vert_index == -1)
       {
-         node->vert_index = NVertices++;
+         node.vert_index = NVertices++;
       }
    }
 
@@ -2308,20 +2308,20 @@ void NCMesh::UpdateVertices()
       }
 
       vertex_nodeId.SetSize(NVertices);
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index >= 0)
+         if (node.HasVertex() && node.vert_index >= 0)
          {
-            vertex_nodeId[node->vert_index] = node.index();
+            vertex_nodeId[node.vert_index] = node.index();
          }
       }
 
       NGhostVertices = 0;
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index < 0)
+         if (node.HasVertex() && node.vert_index < 0)
          {
-            node->vert_index = NVertices + (NGhostVertices++);
+            node.vert_index = NVertices + (NGhostVertices++);
          }
       }
    }
@@ -2449,18 +2449,21 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
    // left uninitialized here; they will be initialized later by the Mesh from
    // Nodes -- here we just make sure mesh.vertices has the correct size.
 
-   for (int i = 0; i < mesh.NumOfElements; i++)
+   for (auto elem : mesh.elements)
    {
-      mesh.FreeElement(mesh.elements[i]);
+      mesh.FreeElement(elem);
    }
    mesh.elements.SetSize(0);
 
-   for (int i = 0; i < mesh.NumOfBdrElements; i++)
+   for (auto elem : mesh.boundary)
    {
-      mesh.FreeElement(mesh.boundary[i]);
+      mesh.FreeElement(elem);
    }
    mesh.boundary.SetSize(0);
 
+   // Save off boundary face vertices to make boundary elements later.
+   std::map<int, mfem::Array<int>> unique_boundary_faces;
+
    // create an mfem::Element for each leaf Element
    for (int i = 0; i < NElements; i++)
    {
@@ -2478,65 +2481,83 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
          elem->GetVertices()[j] = nodes[node[j]].vert_index;
       }
 
-      // create boundary elements
-      // TODO: use boundary_faces?
-      for (int k = 0; k < gi.nf; k++)
+      // Loop over faces and collect those marked as boundaries
+      for (int k = 0; k < gi.nf; ++k)
       {
-         const int* fv = gi.faces[k];
          const int nfv = gi.nfv[k];
-         const Face* face = faces.Find(node[fv[0]], node[fv[1]],
-                                       node[fv[2]], node[fv[3]]);
-         if (face->Boundary())
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+         if (id >= 0 && faces[id].Boundary())
          {
-            if ((nc_elem.geom == Geometry::CUBE) ||
-                ((nc_elem.geom == Geometry::PRISM ||
-                  nc_elem.geom == Geometry::PYRAMID) && nfv == 4))
-            {
-               auto* quad = (Quadrilateral*) mesh.NewElement(Geometry::SQUARE);
-               quad->SetAttribute(face->attribute);
-               for (int j = 0; j < 4; j++)
-               {
-                  quad->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(quad);
-            }
-            else if (nc_elem.geom == Geometry::PRISM ||
-                     nc_elem.geom == Geometry::PYRAMID ||
-                     nc_elem.geom == Geometry::TETRAHEDRON)
+            const auto &face = faces[id];
+            if (face.elem[0] >= 0 && face.elem[1] >= 0 &&
+                nc_elem.rank != std::min(elements[face.elem[0]].rank,
+                                         elements[face.elem[1]].rank))
             {
-               MFEM_ASSERT(nfv == 3, "");
-               auto* tri = (Triangle*) mesh.NewElement(Geometry::TRIANGLE);
-               tri->SetAttribute(face->attribute);
-               for (int j = 0; j < 3; j++)
-               {
-                  tri->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(tri);
+               // This is a conformal internal face, but this element is not the lowest
+               // ranking attached processor, thus not the owner of the face.
+               // Consequently, we do not add this face to avoid double
+               // counting.
+               continue;
             }
-            else if (nc_elem.geom == Geometry::SQUARE ||
-                     nc_elem.geom == Geometry::TRIANGLE)
+
+            // Add in all boundary faces that are actual boundaries or not masters of another face.
+            // The fv[2] in the edge split is on purpose.
+            if ((nfv == 4 &&
+                 QuadFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]], node[fv[3]]))
+                || (nfv == 3 && TriFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]]))
+                || (nfv == 2 &&
+                    EdgeSplitLevel(node[fv[0]], node[fv[2]] /* [2] not an error */) == 0))
             {
-               auto* segment = (Segment*) mesh.NewElement(Geometry::SEGMENT);
-               segment->SetAttribute(face->attribute);
-               for (int j = 0; j < 2; j++)
+               // This face has no split faces below, it is conformal or a
+               // slave.
+               unique_boundary_faces[id].SetSize(nfv);
+               for (int v = 0; v < nfv; ++v)
                {
-                  segment->GetVertices()[j] = nodes[node[fv[2*j]]].vert_index;
+                  // Using a map overwrites if a face is visited twice.
+                  // The nfv==2 is necessary because faces of 2D are storing the
+                  // second index in the 2 slot, not the 1 slot.
+                  unique_boundary_faces[id][v] = nodes[node[fv[(nfv==2) ? 2*v : v]]].vert_index;
                }
-               mesh.boundary.Append(segment);
-            }
-            else
-            {
-               MFEM_ASSERT(nc_elem.geom == Geometry::SEGMENT, "");
-               auto* point = (mfem::Point*) mesh.NewElement(Geometry::POINT);
-               point->SetAttribute(face->attribute);
-               point->GetVertices()[0] = nodes[node[fv[0]]].vert_index;
-               mesh.boundary.Append(point);
             }
          }
       }
    }
+
+   auto geom_from_nfv = [](int nfv)
+   {
+      switch (nfv)
+      {
+         case 1: return Geometry::POINT;
+         case 2: return Geometry::SEGMENT;
+         case 3: return Geometry::TRIANGLE;
+         case 4: return Geometry::SQUARE;
+      }
+      return Geometry::INVALID;
+   };
+
+   for (const auto &fv : unique_boundary_faces)
+   {
+      const auto f = fv.first;
+      const auto &v = fv.second;
+      const auto &face = faces.At(f);
+
+      auto geom = geom_from_nfv(v.Size());
+
+      MFEM_ASSERT(geom != Geometry::INVALID,
+                  "nfv: " << v.Size() <<
+                  " does not match a valid face geometry: Quad, Tri, Segment, Point");
+
+      // Add a new boundary element, with matching attribute and vertices
+      mesh.boundary.Append(mesh.NewElement(geom));
+      auto * const be = mesh.boundary.Last();
+      be->SetAttribute(face.attribute);
+      be->SetVertices(v);
+   }
 }
 
+
 void NCMesh::OnMeshUpdated(Mesh *mesh)
 {
    //// PART 1: pull indices of regular edges/faces from the Mesh
@@ -2545,13 +2566,13 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
    NFaces = mesh->GetNumFaces();
    if (Dim < 2) { NFaces = 0; }
    // clear Node::edge_index and Face::index
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge()) { node->edge_index = -1; }
+      if (node.HasEdge()) { node.edge_index = -1; }
    }
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      face->index = -1;
+      face.index = -1;
    }
 
    // get edge enumeration from the Mesh
@@ -2615,19 +2636,19 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
 
    // count ghost edges and assign their indices
    NGhostEdges = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge() && node->edge_index < 0)
+      if (node.HasEdge() && node.edge_index < 0)
       {
-         node->edge_index = NEdges + (NGhostEdges++);
+         node.edge_index = NEdges + (NGhostEdges++);
       }
    }
 
    // count ghost faces
    NGhostFaces = 0;
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { NGhostFaces++; }
+      if (face.index < 0) { NGhostFaces++; }
    }
 
    if (Dim == 2)
@@ -2651,13 +2672,14 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
       for (int j = 0; j < gi.nf; j++)
       {
          const int *fv = gi.faces[j];
-         Face* face = faces.Find(el.node[fv[0]], el.node[fv[1]],
-                                 el.node[fv[2]], el.node[fv[3]]);
-         MFEM_ASSERT(face, "face not found!");
+         int fid = faces.FindId(el.node[fv[0]], el.node[fv[1]],
+                                el.node[fv[2]], el.node[fv[3]]);
+         MFEM_ASSERT(fid >= 0, "face not found!");
+         auto &face = faces[fid];
 
-         if (face->index < 0)
+         if (face.index < 0)
          {
-            face->index = NFaces + (nghosts++);
+            face.index = NFaces + (nghosts++);
 
             // store the face geometry
             static const Geometry::Type types[5] =
@@ -2665,15 +2687,15 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
                Geometry::INVALID, Geometry::INVALID,
                Geometry::SEGMENT, Geometry::TRIANGLE, Geometry::SQUARE
             };
-            face_geom[face->index] = types[gi.nfv[j]];
+            face_geom[face.index] = types[gi.nfv[j]];
          }
       }
    }
 
    // assign valid indices also to faces beyond the ghost layer
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { face->index = NFaces + (nghosts++); }
+      if (face.index < 0) { face.index = NFaces + (nghosts++); }
    }
    MFEM_ASSERT(nghosts == NGhostFaces, "");
 }
@@ -2741,7 +2763,7 @@ bool NCMesh::TriFaceSplit(int v1, int v2, int v3, int mid[3]) const
 
    if (mid) { mid[0] = e1, mid[1] = e2, mid[2] = e3; }
 
-   // NOTE: face (v1, v2, v3) still needs to be checked
+   // This is necessary but not sufficient to determine if a face has been split.
    return true;
 }
 
@@ -3452,7 +3474,7 @@ const NCMesh::MeshId& NCMesh::NCList::LookUp(int index, int *type) const
 
    if (!type)
    {
-      MFEM_VERIFY(key >= 0, "entity not found.");
+      MFEM_VERIFY(key >= 0, "index " << index << " not found.");
    }
    else // return entity type if requested, don't abort when not found
    {
@@ -5195,9 +5217,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetFaceList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          if (bdr_attr_is_ess[faces[face].attribute - 1])
          {
             int node[4];
@@ -5226,9 +5247,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetEdgeList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          Face &fc = faces[face];
          if (bdr_attr_is_ess[fc.attribute - 1])
          {
@@ -5245,18 +5265,35 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    bdr_edges.Unique();
 }
 
-static int max4(int a, int b, int c, int d)
-{
-   return std::max(std::max(a, b), std::max(c, d));
-}
-static int max6(int a, int b, int c, int d, int e, int f)
+namespace
 {
-   return std::max(max4(a, b, c, d), std::max(e, f));
-}
-static int max8(int a, int b, int c, int d, int e, int f, int g, int h)
+/**
+ * @brief Base case of convenience variadic max function.
+ *
+ * @tparam T Base type
+ * @param arg Recursion base value
+ * @return T value to max over
+ */
+template<typename T>
+T max(T&& arg)
+{
+   return arg;
+}
+/**
+ * @brief Convenience variadic max function.
+ *
+ * @tparam T Base Type
+ * @tparam Ts Parameter pack of other types
+ * @param arg Singular argument
+ * @param args Pack of arguments
+ * @return T maximum value
+ */
+template<typename T, typename... Ts>
+T max(T arg, Ts... args)
 {
-   return std::max(max4(a, b, c, d), max4(e, f, g, h));
+   return std::max(std::forward<T>(arg), max(args...));
 }
+} // namespace
 
 int NCMesh::EdgeSplitLevel(int vn1, int vn2) const
 {
@@ -5271,15 +5308,13 @@ int NCMesh::TriFaceSplitLevel(int vn1, int vn2, int vn3) const
    if (TriFaceSplit(vn1, vn2, vn3, mid) &&
        faces.FindId(vn1, vn2, vn3) < 0)
    {
-      return 1 + max4(TriFaceSplitLevel(vn1, mid[0], mid[2]),
-                      TriFaceSplitLevel(mid[0], vn2, mid[1]),
-                      TriFaceSplitLevel(mid[2], mid[1], vn3),
-                      TriFaceSplitLevel(mid[0], mid[1], mid[2]));
-   }
-   else // not split
-   {
-      return 0;
+      return 1 + max(TriFaceSplitLevel(vn1, mid[0], mid[2]),
+                     TriFaceSplitLevel(mid[0], vn2, mid[1]),
+                     TriFaceSplitLevel(mid[2], mid[1], vn3),
+                     TriFaceSplitLevel(mid[0], mid[1], mid[2]));
    }
+
+   return 0; // not split
 }
 
 void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
@@ -5309,6 +5344,13 @@ void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
    }
 }
 
+int NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const
+{
+   int h_level, v_level;
+   QuadFaceSplitLevel(vn1, vn2, vn3, vn4, h_level, v_level);
+   return h_level + v_level;
+}
+
 void NCMesh::CountSplits(int elem, int splits[3]) const
 {
    const Element &el = elements[elem];
@@ -5345,57 +5387,52 @@ void NCMesh::CountSplits(int elem, int splits[3]) const
 
    if (el.Geom() == Geometry::CUBE)
    {
-      splits[0] = max8(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
-                       elevel[0], elevel[2], elevel[4], elevel[6]);
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
+                      elevel[0], elevel[2], elevel[4], elevel[6]);
 
-      splits[1] = max8(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
-                       elevel[1], elevel[3], elevel[5], elevel[7]);
+      splits[1] = max(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
+                      elevel[1], elevel[3], elevel[5], elevel[7]);
 
-      splits[2] = max8(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[8], elevel[9], elevel[10], elevel[11]);
+      splits[2] = max(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[8], elevel[9], elevel[10], elevel[11]);
    }
    else if (el.Geom() == Geometry::PRISM)
    {
-      splits[0] = splits[1] =
-                     std::max(
-                        max6(flevel[0][0], flevel[1][0], 0,
-                             flevel[2][0], flevel[3][0], flevel[4][0]),
-                        max6(elevel[0], elevel[1], elevel[2],
-                             elevel[3], elevel[4], elevel[5]));
+      splits[0] = splits[1] = max(flevel[0][0], flevel[1][0], 0,
+                                  flevel[2][0], flevel[3][0], flevel[4][0],
+                                  elevel[0], elevel[1], elevel[2],
+                                  elevel[3], elevel[4], elevel[5]);
 
-      splits[2] = max6(flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[6], elevel[7], elevel[8]);
+      splits[2] = max(flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[6], elevel[7], elevel[8]);
    }
    else if (el.Geom() == Geometry::PYRAMID)
    {
-      splits[0] = std::max(
-                     max6(flevel[0][0], flevel[1][0], 0,
-                          flevel[2][0], flevel[3][0], flevel[4][0]),
-                     max8(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5],
-                          elevel[6], elevel[7]));
+      splits[0] = max(flevel[0][0], flevel[1][0], 0,
+                      flevel[2][0], flevel[3][0], flevel[4][0],
+                      elevel[0], elevel[1], elevel[2],
+                      elevel[3], elevel[4], elevel[5],
+                      elevel[6], elevel[7]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::TETRAHEDRON)
    {
-      splits[0] = std::max(
-                     max4(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0]),
-                     max6(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5]));
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0],
+                      elevel[0], elevel[1], elevel[2], elevel[3], elevel[4], elevel[5]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::SQUARE)
    {
-      splits[0] = std::max(elevel[0], elevel[2]);
-      splits[1] = std::max(elevel[1], elevel[3]);
+      splits[0] = max(elevel[0], elevel[2]);
+      splits[1] = max(elevel[1], elevel[3]);
    }
    else if (el.Geom() == Geometry::TRIANGLE)
    {
-      splits[0] = std::max(elevel[0], std::max(elevel[1], elevel[2]));
+      splits[0] = max(elevel[0], elevel[1], elevel[2]);
       splits[1] = splits[0];
    }
    else
@@ -6368,17 +6405,17 @@ void NCMesh::DebugDump(std::ostream &os) const
 
    // dump faces
    os << faces.Size() << "\n";
-   for (auto face = faces.cbegin(); face != faces.cend(); ++face)
+   for (const auto &face : faces)
    {
-      int elem = face->elem[0];
-      if (elem < 0) { elem = face->elem[1]; }
+      int elem = face.elem[0];
+      if (elem < 0) { elem = face.elem[1]; }
       MFEM_ASSERT(elem >= 0, "");
       const Element &el = elements[elem];
 
       int lf = find_local_face(el.Geom(),
-                               find_node(el, face->p1),
-                               find_node(el, face->p2),
-                               find_node(el, face->p3));
+                               find_node(el, face.p1),
+                               find_node(el, face.p2),
+                               find_node(el, face.p3));
 
       const int* fv = GI[el.Geom()].faces[lf];
       const int nfv = GI[el.Geom()].nfv[lf];
@@ -6388,7 +6425,7 @@ void NCMesh::DebugDump(std::ostream &os) const
       {
          os << " " << el.node[fv[i]];
       }
-      //os << " # face " << face.index() << ", index " << face->index << "\n";
+      //os << " # face " << face.index() << ", index " << face.index << "\n";
       os << "\n";
    }
 }
diff --git a/mesh/ncmesh.hpp b/mesh/ncmesh.hpp
index ddd423bfa..227aa4152 100644
--- a/mesh/ncmesh.hpp
+++ b/mesh/ncmesh.hpp
@@ -412,7 +412,6 @@ protected: // non-public interface for the Mesh class
        by calling Mesh::SetCurvature or otherwise setting the Nodes. */
    void MakeTopologyOnly() { coordinates.DeleteAll(); }
 
-
 protected: // implementation
 
    int Dim, spaceDim; ///< dimensions of the elements and the vertex coordinates
@@ -550,7 +549,6 @@ protected: // implementation
 
    Table element_vertex; ///< leaf-element to vertex table, see FindSetNeighbors
 
-
    /// Update the leaf elements indices in leaf_elements
    void UpdateLeafElements();
 
@@ -668,10 +666,79 @@ protected: // implementation
 
    mfem::Element* NewMeshElement(int geom) const;
 
-   int QuadFaceSplitType(int v1, int v2, int v3, int v4, int mid[5]
+   /**
+    * @brief Given a quad face defined by four vertices, establish which edges
+    * of this face have been split, and if so optionally return the mid points
+    * of those edges.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return int 0 -- no split, 1 -- "vertical" split, 2 -- "horizontal" split
+    */
+   int QuadFaceSplitType(int n1, int n2, int n3, int n4, int mid[5]
                          = NULL /*optional output of mid-edge nodes*/) const;
 
-   bool TriFaceSplit(int v1, int v2, int v3, int mid[3] = NULL) const;
+   /**
+    * @brief Given a tri face defined by three vertices, establish whether the
+    * edges that make up this face have been split, and if so optionally return
+    * the midpoints.
+    * @details This is a necessary condition for this face to have been split,
+    * but is not sufficient. Consider a triangle attached to three refined
+    * triangles, in this scenario all edges can be split but this face not be
+    * split. In this case, it is necessary to check if there is a face made up
+    * of the returned midpoint nodes.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return true Splits for all edges have been found
+    * @return false
+    */
+   bool TriFaceSplit(int n1, int n2, int n3, int mid[3] = NULL) const;
+
+   /**
+    * @brief Determine if a Triangle face is not a master
+    * @details This check requires looking for the edges making up the triangle
+    * being split, if nodes exist at their midpoints, and there are vertices at
+    * them, this implies the face COULD be split. To determine if it is, we then
+    * check whether these midpoints have all been connected, this is required to
+    * discriminate between an internal master face surrounded by nonconformal
+    * refinements and a conformal boundary face surrounded by refinements.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @return true The face is not a master
+    * @return false The face is a master
+    */
+   inline bool TriFaceNotMaster(int n1, int n2, int n3) const
+   {
+      int mid[3];
+      return !TriFaceSplit(n1, n2, n3, mid) // The edges aren't split
+             // OR none of the midpoints are connected.
+             || (nodes.FindId(mid[0], mid[1]) < 0 &&
+                 nodes.FindId(mid[0], mid[2]) < 0 &&
+                 nodes.FindId(mid[1], mid[2]) < 0);
+   }
+
+   /**
+    * @brief Determine if  a Quad face is not a master
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @return true The quad face is not a master
+    * @return false The quad face is a master
+    */
+   inline bool QuadFaceNotMaster(int n1, int n2, int n3, int n4) const
+   {
+      return QuadFaceSplitType(n1, n2, n3, n4) == 0;
+   }
 
    void ForceRefinement(int vn1, int vn2, int vn3, int vn4);
 
@@ -932,9 +999,7 @@ protected: // implementation
    void InitDerefTransforms();
    void SetDerefMatrixCodes(int parent, Array<int> &fine_coarse);
 
-
    // vertex temporary data, used by GetMeshComponents
-
    struct TmpVertex
    {
       bool valid, visited;
@@ -953,10 +1018,56 @@ protected: // implementation
 
    void FindFaceNodes(int face, int node[4]);
 
+   /**
+    * @brief Return the number of splits of this edge that have occurred in the
+    * NCMesh. If zero, this means the segment is not the master of any other segments.
+    *
+    * @param vn1 The first vertex making up the segment
+    * @param vn2 The second vertex making up the segment
+    * @return int The depth of splits of this segment that are present in the mesh.
+    */
    int EdgeSplitLevel(int vn1, int vn2) const;
+   /**
+    * @brief Return the number of splits of this triangle that have occurred in
+    * the NCMesh. If zero, this means the triangle is neither split, nor the
+    * master of a split face.
+    *
+    * @param vn1 The first vertex making up the triangle
+    * @param vn2 The second vertex making up the triangle
+    * @param vn3 The third vertex making up the triangle
+    * @return int The depth of splits of this triangle that are present in the mesh.
+    */
    int TriFaceSplitLevel(int vn1, int vn2, int vn3) const;
+   /**
+    * @brief Computes the number of horizontal and vertical splits of this quad
+    * that have occurred in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @param h_level The number of "horizontal" splits of the quad
+    * @param v_level The number of "vertical" splits of the quad
+    */
    void QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
                            int& h_level, int& v_level) const;
+   /**
+    * @brief Returns the total number of splits of this quad that have occurred
+    * in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    * @details This is a convenience wrapper that sums the horizontal and
+    * vertical levels from the full method.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @return int The depth of splits of this triangle that are present in the
+    * mesh. NB: An isotropic refinement has a level of 2, one horizontal split,
+    * followed by a vertical split.
+    */
+   int QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const;
 
    void CountSplits(int elem, int splits[3]) const;
    void GetLimitRefinements(Array<Refinement> &refinements, int max_level);
@@ -993,7 +1104,6 @@ protected: // implementation
    /// Load the deprecated MFEM mesh v1.1 format for backward compatibility.
    void LoadLegacyFormat(std::istream &input, int &curved, int &is_nc);
 
-
    // geometry
 
    /// This holds in one place the constants about the geometries we support
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index 8392d2b67..85cc7d103 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -34,7 +34,6 @@ ParMesh::ParMesh(const ParMesh &pmesh, bool copy_nodes)
      group_sedge(pmesh.group_sedge),
      group_stria(pmesh.group_stria),
      group_squad(pmesh.group_squad),
-     face_nbr_el_to_face(NULL),
      glob_elem_offset(-1),
      glob_offset_sequence(-1),
      gtopo(pmesh.gtopo)
@@ -106,8 +105,7 @@ ParMesh& ParMesh::operator=(ParMesh &&mesh)
 
 ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
                  int part_method)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -238,6 +236,8 @@ ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
       BuildSharedVertMapping(nsvert, vert_element, vert_global_local);
       delete vert_element;
 
+      // FIXME: the next two lines are already done above! Any reason to do them
+      //        again?
       SetMeshGen();
       meshgen = mesh.meshgen; // copy the global 'meshgen'
    }
@@ -350,11 +350,8 @@ int ParMesh::BuildLocalVertices(const mfem::Mesh &mesh,
 int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
                                 const Array<int>& vert_global_local)
 {
-   int nelems = 0;
-   for (int i = 0; i < mesh.GetNE(); i++)
-   {
-      if (partitioning[i] == MyRank) { nelems++; }
-   }
+   const int nelems = std::count_if(partitioning,
+   partitioning + mesh.GetNE(), [this](int i) { return i == MyRank;});
 
    elements.SetSize(nelems);
 
@@ -373,7 +370,7 @@ int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
          {
             v[j] = vert_global_local[v[j]];
          }
-         element_counter++;
+         ++element_counter;
       }
    }
 
@@ -386,7 +383,6 @@ int ParMesh::BuildLocalBoundary(const Mesh& mesh, const int* partitioning,
                                 Table*& edge_element)
 {
    int nbdry = 0;
-
    if (mesh.NURBSext)
    {
       activeBdrElem.SetSize(mesh.GetNBE());
@@ -854,7 +850,6 @@ ParMesh::ParMesh(const ParNCMesh &pncmesh)
    : MyComm(pncmesh.MyComm)
    , NRanks(pncmesh.NRanks)
    , MyRank(pncmesh.MyRank)
-   , face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(MyComm)
@@ -906,7 +901,7 @@ void ParMesh::FinalizeParTopo()
    sface_lface.SetSize(nst + shared_quads.Size());
    if (sface_lface.Size())
    {
-      STable3D *faces_tbl = GetFacesTable();
+      auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
       for (int st = 0; st < nst; st++)
       {
          const int *v = shared_trias[st].v;
@@ -917,13 +912,11 @@ void ParMesh::FinalizeParTopo()
          const int *v = shared_quads[sq].v;
          sface_lface[nst+sq] = (*faces_tbl)(v[0], v[1], v[2], v[3]);
       }
-      delete faces_tbl;
    }
 }
 
 ParMesh::ParMesh(MPI_Comm comm, istream &input, bool refine)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -1134,7 +1127,7 @@ void ParMesh::MakeRefined_(ParMesh &orig_mesh, int ref_factor, int ref_type)
    MyComm = orig_mesh.GetComm();
    NRanks = orig_mesh.GetNRanks();
    MyRank = orig_mesh.GetMyRank();
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
    glob_elem_offset = -1;
    glob_offset_sequence = -1;
    gtopo = orig_mesh.gtopo;
@@ -1516,6 +1509,7 @@ ParMesh ParMesh::MakeSimplicial(ParMesh &orig_mesh)
 void ParMesh::Finalize(bool refine, bool fix_orientation)
 {
    const int meshgen_save = meshgen; // Mesh::Finalize() may call SetMeshGen()
+   // 'mesh_geoms' is local, so there's no need to save and restore it.
 
    Mesh::Finalize(refine, fix_orientation);
 
@@ -2123,11 +2117,14 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors without communication
+      // with ParNCMesh we can set up face neighbors mostly without communication
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
-      ExchangeFaceNbrNodes();
+      // Internal boundary elements with an NC mesh requires extra "ghost
+      // boundary element" information for enforcing essential boundaries.
+      pncmesh->ComputeGhostBoundaryElements(*this);
+
       return;
    }
 
@@ -2192,7 +2189,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Dim == 3)
    {
-      GetFaceNbrElementToFaceTable();
+      BuildFaceNbrElementToFaceTable();
    }
 
    if (del_tables) { delete gr_sface; }
@@ -2320,6 +2317,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
    el_marker = -1;
    vertex_marker = -1;
    const int nst = shared_trias.Size();
+
    for (int fn = 0; fn < num_face_nbrs; fn++)
    {
       int nbr_group = face_nbr_group[fn];
@@ -2457,8 +2455,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
 
    // convert the element data into face_nbr_elements
    face_nbr_elements.SetSize(face_nbr_elements_offset[num_face_nbrs]);
-   face_nbr_el_ori.Clear();
-   face_nbr_el_ori.SetSize(face_nbr_elements_offset[num_face_nbrs], 6);
+   face_nbr_el_ori.reset(new Table(face_nbr_elements_offset[num_face_nbrs], 6));
    while (true)
    {
       int fn;
@@ -2489,7 +2486,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          if (Dim == 3)
          {
             int nf = el->GetNFaces();
-            int * fn_ori = face_nbr_el_ori.GetRow(elem_off);
+            int * fn_ori = face_nbr_el_ori->GetRow(elem_off);
             for (int j = 0; j < nf; j++)
             {
                fn_ori[j] = recv_elemdata[j];
@@ -2499,7 +2496,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          face_nbr_elements[elem_off++] = el;
       }
    }
-   face_nbr_el_ori.Finalize();
+   face_nbr_el_ori->Finalize();
 
    MPI_Waitall(num_face_nbrs, send_requests, statuses);
 
@@ -2721,191 +2718,118 @@ STable3D *ParMesh::GetSharedFacesTable()
    return sfaces_tbl;
 }
 
-STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
+template <int N>
+void
+ParMesh::AddTriFaces(const Array<int> &elem_vertices,
+                     const std::unique_ptr<STable3D> &faces,
+                     const std::unique_ptr<STable3D> &shared_faces,
+                     int elem, int start, int end, const int fverts[][N])
 {
-   int i, *v;
-   STable3D * faces_tbl = GetFacesTable();
-   STable3D * sfaces_tbl = GetSharedFacesTable();
-
-   if (face_nbr_el_to_face != NULL)
+   for (int i = start; i < end; ++i)
    {
-      delete face_nbr_el_to_face;
+      // Reference face vertices.
+      const auto fv = fverts[i];
+      // Element specific face vertices.
+      const Vert3 elem_fv(elem_vertices[fv[0]], elem_vertices[fv[1]],
+                          elem_vertices[fv[2]]);
+
+      // Check amongst the faces of elements local to this rank for this set of vertices
+      const int lf = faces->Index(elem_fv.v[0], elem_fv.v[1], elem_fv.v[2]);
+
+      // If the face wasn't found amonst processor local elements, search the
+      // ghosts for this set of vertices.
+      const int sf = lf < 0 ? shared_faces->Index(elem_fv.v[0], elem_fv.v[1],
+                                                  elem_fv.v[2]) : -1;
+      // If find local face -> use that
+      //    else if find shared face -> shift and use that
+      //       else no face found -> set to -1
+      const int face_to_add = lf < 0 ? (sf >= 0 ? sf + NumOfFaces : -1) : lf;
+
+      MFEM_ASSERT(sf >= 0 ||
+                  lf >= 0, "Face must be from a local or a face neighbor element");
+
+      // Add this discovered face to the list of faces of this face neighbor element
+      face_nbr_el_to_face->Push(elem, face_to_add);
    }
-   face_nbr_el_to_face = new Table(face_nbr_elements.Size(), 6);
-   for (i = 0; i < face_nbr_elements.Size(); i++)
+}
+
+void ParMesh::BuildFaceNbrElementToFaceTable()
+{
+   const auto faces = std::unique_ptr<STable3D>(GetFacesTable());
+   const auto shared_faces = std::unique_ptr<STable3D>(GetSharedFacesTable());
+
+   face_nbr_el_to_face.reset(new Table(face_nbr_elements.Size(), 6));
+
+   mfem::Array<int> v;
+
+   // Helper for adding quadrilateral faces.
+   auto add_quad_faces = [&faces, &shared_faces, &v, this]
+                         (int elem, int start, int end, const int fverts[][4])
    {
-      v = face_nbr_elements[i]->GetVertices();
-      switch (face_nbr_elements[i]->GetType())
+      for (int i = start; i < end; ++i)
       {
-         case Element::TETRAHEDRON:
+         const int * const fv = fverts[i];
+         int k = 0;
+         int max = v[fv[0]];
+
+         if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
+         if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
+         if (max < v[fv[3]]) { k = 3; }
+
+         int v0 = -1, v1 = -1, v2 = -1;
+         switch (k)
          {
-            for (int j = 0; j < 4; j++)
+            case 0:
+               v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 1:
+               v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 2:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
+               break;
+            case 3:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
+               break;
+         }
+         int lf = faces->Index(v0, v1, v2);
+         if (lf < 0)
+         {
+            lf = shared_faces->Index(v0, v1, v2);
+            if (lf >= 0)
             {
-               const int *fv = tet_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
+               lf += NumOfFaces;
             }
+         }
+         face_nbr_el_to_face->Push(elem, lf);
+      }
+   };
+
+   for (int i = 0; i < face_nbr_elements.Size(); i++)
+   {
+      face_nbr_elements[i]->GetVertices(v);
+      switch (face_nbr_elements[i]->GetType())
+      {
+         case Element::TETRAHEDRON:
+         {
+            AddTriFaces(v, faces, shared_faces, i, 0, 4, tet_t::FaceVert);
             break;
          }
          case Element::WEDGE:
          {
-            for (int j = 0; j < 2; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 2; j < 5; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            AddTriFaces(v, faces, shared_faces, i, 0, 2, pri_t::FaceVert);
+            add_quad_faces(i, 2, 5, pri_t::FaceVert);
             break;
          }
          case Element::PYRAMID:
          {
-            for (int j = 0; j < 1; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 1; j < 5; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 1, pyr_t::FaceVert);
+            AddTriFaces(v, faces, shared_faces, i, 1, 5, pyr_t::FaceVert);
             break;
          }
          case Element::HEXAHEDRON:
          {
-            // find the face by the vertices with the smallest 3 numbers
-            // z = 0, y = 0, x = 1, y = 1, x = 0, z = 1
-            for (int j = 0; j < 6; j++)
-            {
-               const int *fv = hex_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 6, hex_t::FaceVert);
             break;
          }
          default:
@@ -2913,14 +2837,6 @@ STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
       }
    }
    face_nbr_el_to_face->Finalize();
-
-   delete sfaces_tbl;
-   if (ret_ftbl)
-   {
-      return faces_tbl;
-   }
-   delete faces_tbl;
-   return NULL;
 }
 
 int ParMesh::GetFaceNbrRank(int fn) const
@@ -2941,33 +2857,31 @@ int ParMesh::GetFaceNbrRank(int fn) const
 }
 
 void
-ParMesh::GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const
+ParMesh::GetFaceNbrElementFaces(int i, Array<int> &faces,
+                                Array<int> &orientations) const
 {
-   int n, j;
    int el_nbr = i - GetNE();
-   if (face_nbr_el_to_face)
+   if (face_nbr_el_to_face != nullptr && el_nbr < face_nbr_el_to_face->Size())
    {
-      face_nbr_el_to_face->GetRow(el_nbr, fcs);
+      face_nbr_el_to_face->GetRow(el_nbr, faces);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
                  "face_nbr_el_to_face not generated.");
    }
-   if (el_nbr < face_nbr_el_ori.Size())
+
+   if (face_nbr_el_ori != nullptr && el_nbr < face_nbr_el_ori->Size())
    {
-      const int * row = face_nbr_el_ori.GetRow(el_nbr);
-      n = fcs.Size();
-      cor.SetSize(n);
-      for (j=0; j<n; j++)
-      {
-         cor[j] = row[j];
-      }
+      face_nbr_el_ori->GetRow(el_nbr, orientations);
    }
    else
    {
-      MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+      // No face_nbr_el_ori was generated, make the orientations invalid.
+      // This will cause errors if the face orientations are necessary to
+      // evaluate the basis in face neighbor elements.
+      orientations.SetSize(faces.Size());
+      orientations = -1;
    }
 }
 
@@ -3227,7 +3141,7 @@ int ParMesh::GetSharedFace(int sface) const
    {
       MFEM_ASSERT(Dim > 1, "");
       const NCMesh::NCList &shared = pncmesh->GetSharedList(Dim-1);
-      int csize = (int) shared.conforming.Size();
+      int csize = shared.conforming.Size();
       return sface < csize
              ? shared.conforming[sface].index
              : shared.slaves[sface - csize].index;
@@ -4593,7 +4507,7 @@ void ParMesh::UniformRefinement3D()
 
    DSTable v_to_v(NumOfVertices);
    GetVertexToVertexTable(v_to_v);
-   STable3D *faces_tbl = GetFacesTable();
+   auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
 
    // call Mesh::UniformRefinement3D_base so that it won't update the nodes
    Array<int> f2qf;
@@ -4608,7 +4522,6 @@ void ParMesh::UniformRefinement3D()
    // update the groups
    UniformRefineGroups3D(old_nv, old_nedges, v_to_v, *faces_tbl,
                          f2qf.Size() ? &f2qf : NULL);
-   delete faces_tbl;
 
    UpdateNodes();
 }
@@ -6339,6 +6252,7 @@ void ParMesh::ParPrint(ostream &os) const
    {
       os << "total_shared_faces " << sface_lface.Size() << '\n';
    }
+   os << "\n# group 0 has no shared entities\n";
    for (int gr = 1; gr < GetNGroups(); gr++)
    {
       {
@@ -6393,7 +6307,8 @@ void ParMesh::PrintVTU(std::string pathname,
                        VTKFormat format,
                        bool high_order_output,
                        int compression_level,
-                       bool bdr)
+                       bool bdr_elements,
+                       double scale_factor)
 {
    int pad_digits_rank = 6;
    DataCollection::create_directory(pathname, this, MyRank);
@@ -6453,7 +6368,8 @@ void ParMesh::PrintVTU(std::string pathname,
 
    std::string vtu_fname = pathname + "/" + fname + ".proc"
                            + to_padded_string(MyRank, pad_digits_rank);
-   Mesh::PrintVTU(vtu_fname, format, high_order_output, compression_level, bdr);
+   Mesh::PrintVTU(vtu_fname, format, high_order_output, compression_level,
+                  bdr_elements, scale_factor);
 }
 
 int ParMesh::FindPoints(DenseMatrix& point_mat, Array<int>& elem_id,
@@ -6707,6 +6623,8 @@ void ParMesh::Swap(ParMesh &other)
    mfem::Swap(face_nbr_vertices, other.face_nbr_vertices);
    mfem::Swap(send_face_nbr_elements, other.send_face_nbr_elements);
    mfem::Swap(send_face_nbr_vertices, other.send_face_nbr_vertices);
+   std::swap(face_nbr_el_ori, other.face_nbr_el_ori);
+   std::swap(face_nbr_el_to_face, other.face_nbr_el_to_face);
 
    // Nodes, NCMesh, and NURBSExtension are taken care of by Mesh::Swap
    mfem::Swap(pncmesh, other.pncmesh);
@@ -6727,8 +6645,7 @@ void ParMesh::Destroy()
    }
    shared_edges.DeleteAll();
 
-   delete face_nbr_el_to_face;
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
 }
 
 ParMesh::~ParMesh()
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 6ad702b58..f731faebc 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -77,8 +77,11 @@ protected:
    // sface ids: all triangles first, then all quads
    Array<int> sface_lface;
 
-   Table *face_nbr_el_to_face;
-   Table  face_nbr_el_ori; // orientations for each face (from nbr processor)
+   /// Table that maps from face neighbor element number, to the face numbers of
+   /// that element.
+   std::unique_ptr<Table> face_nbr_el_to_face;
+   /// orientations for each face (from nbr processor)
+   std::unique_ptr<Table> face_nbr_el_ori;
 
    IsoparametricTransformation FaceNbrTransformation;
 
@@ -97,6 +100,8 @@ protected:
    // Convert the local 'meshgen' to a global one.
    void ReduceMeshGen();
 
+   virtual void GenerateBoundaryElements() override { /* TODO */ }
+
    // Determine sedge_ledge and sface_lface.
    void FinalizeParTopo();
 
@@ -113,7 +118,32 @@ protected:
    bool DecodeFaceSplittings(HashTable<Hashed2> &v_to_v, const int *v,
                              const Array<unsigned> &codes, int &pos);
 
-   STable3D *GetFaceNbrElementToFaceTable(int ret_ftbl = 0);
+   // Given a completed FacesTable and SharedFacesTable, construct a table that
+   // maps from face neighbor element number, to the set of faces of that
+   // element. Store the resulting data in the member variable
+   // face_nbr_el_to_face. If the mesh is nonconforming, this also builds the
+   // the face_nbr_el_ori variable from the faces_info.
+   void BuildFaceNbrElementToFaceTable();
+
+   /**
+    * @brief Helper function for adding triangle face neighbor element to face
+    * table entries. Have to use a template here rather than lambda capture
+    * because the FaceVert entries in Geometry have inner size of 3 for tets and
+    * 4 for everything else.
+    *
+    * @tparam N Inner dimension on the fvert variable, 3 for tet, 4 otherwise
+    * @param v Set of vertices for this element
+    * @param faces Table of faces interior to this rank
+    * @param shared_faces Table of faces shared by this rank and another
+    * @param elem The face neighbor element
+    * @param start Starting index into fverts
+    * @param end End index into fverts
+    * @param fverts Array of face vertices for this particular geometry.
+    */
+   template <int N>
+   void AddTriFaces(const Array<int> &v, const std::unique_ptr<STable3D> &faces,
+                    const std::unique_ptr<STable3D> &shared_faces,
+                    int elem, int start, int end, const int fverts[][N]);
 
    void GetFaceNbrElementTransformation(
       int i, IsoparametricTransformation *ElTr);
@@ -287,7 +317,7 @@ protected:
 
 public:
    /// Default constructor. Create an empty @a ParMesh.
-   ParMesh() : MyComm(0), NRanks(0), MyRank(-1), face_nbr_el_to_face(NULL),
+   ParMesh() : MyComm(0), NRanks(0), MyRank(-1),
       glob_elem_offset(-1), glob_offset_sequence(-1),
       have_face_nbr_data(false), pncmesh(NULL) { }
 
@@ -465,7 +495,8 @@ public:
    int GetFaceNbrRank(int fn) const;
 
    /** Similar to Mesh::GetElementFaces */
-   void GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const;
+   void GetFaceNbrElementFaces(int i, Array<int> &faces,
+                               Array<int> &orientation) const;
 
    /** Similar to Mesh::GetFaceToElementTable with added face-neighbor elements
        with indices offset by the local number of elements. */
@@ -555,6 +586,8 @@ public:
    /// Return the local face index for the given shared face.
    int GetSharedFace(int sface) const;
 
+
+
    /** @brief Returns the number of local faces according to the requested type,
        does not count master non-conforming faces.
 
@@ -637,7 +670,8 @@ public:
                  VTKFormat format=VTKFormat::ASCII,
                  bool high_order_output=false,
                  int compression_level=0,
-                 bool bdr=false) override;
+                 bool bdr_elements=false,
+                 double scale_factor=1.0) override;
 
    /// Parallel version of Mesh::Load().
    void Load(std::istream &input, int generate_edges = 0,
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index 4a14d0c1d..edddf1ce6 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -16,10 +16,12 @@
 #include "mesh_headers.hpp"
 #include "pncmesh.hpp"
 #include "../general/binaryio.hpp"
+#include "../general/communication.hpp"
 
 #include <numeric> // std::accumulate
 #include <map>
 #include <climits> // INT_MIN, INT_MAX
+#include <array>
 
 namespace mfem
 {
@@ -435,25 +437,21 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
    entity_group = 0;
 
    CommGroup group;
-   group.reserve(128);
 
-   int begin = 0, end = 0;
-   while (begin < index_rank.Size())
+   for (auto begin = index_rank.begin(); begin != index_rank.end(); /* nothing */)
    {
-      int index = index_rank[begin].from;
-      if (index >= nentities)
-      {
-         break; // probably creating entity_conf_group (no ghosts)
-      }
-      while (end < index_rank.Size() && index_rank[end].from == index)
-      {
-         end++;
-      }
-      group.resize(end - begin);
-      for (int i = begin; i < end; i++)
-      {
-         group[i - begin] = index_rank[i].to;
-      }
+      const auto &index = begin->from;
+      if (index >= nentities) { break; }
+
+      // Locate the next connection that is not from this index
+      const auto end = std::find_if(begin, index_rank.end(),
+      [&index](const mfem::Connection &c) { return c.from != index;});
+
+      // For each connection from this index, collect the ranks connected.
+      group.resize(std::distance(begin, end));
+      std::transform(begin, end, group.begin(), [](const mfem::Connection &c) { return c.to; });
+
+      // assign this entity's group and advance the search start
       entity_group[index] = GetGroupId(group);
       begin = end;
    }
@@ -461,9 +459,9 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
 
 void ParNCMesh::AddConnections(int entity, int index, const Array<int> &ranks)
 {
-   for (int i = 0; i < ranks.Size(); i++)
+   for (auto rank : ranks)
    {
-      entity_index_rank[entity].Append(Connection(index, ranks[i]));
+      entity_index_rank[entity].Append(Connection(index, rank));
    }
 }
 
@@ -480,9 +478,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    ranks.Reserve(256);
 
    // connect slave edges to master edges and their vertices
-   for (int i = 0; i < shared_edges.masters.Size(); i++)
+   for (const auto &master_edge : shared_edges.masters)
    {
-      const Master &master_edge = shared_edges.masters[i];
       ranks.SetSize(0);
       for (int j = master_edge.slaves_begin; j < master_edge.slaves_end; j++)
       {
@@ -502,9 +499,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    }
 
    // connect slave faces to master faces and their edges and vertices
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const auto &master_face : shared_faces.masters)
    {
-      const Master &master_face = shared_faces.masters[i];
       ranks.SetSize(0);
       for (int j = master_face.slaves_begin; j < master_face.slaves_end; j++)
       {
@@ -581,17 +577,17 @@ void ParNCMesh::CalcFaceOrientations()
    face_orient.SetSize(NFaces);
    face_orient = 0;
 
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto face : faces)
    {
-      if (face->elem[0] >= 0 && face->elem[1] >= 0 && face->index < NFaces)
+      if (face.elem[0] >= 0 && face.elem[1] >= 0 && face.index < NFaces)
       {
-         Element *e1 = &elements[face->elem[0]];
-         Element *e2 = &elements[face->elem[1]];
+         Element *e1 = &elements[face.elem[0]];
+         Element *e2 = &elements[face.elem[1]];
 
          if (e1->rank == e2->rank) { continue; }
          if (e1->rank > e2->rank) { std::swap(e1, e2); }
 
-         face_orient[face->index] = get_face_orientation(*face, *e1, *e2);
+         face_orient[face.index] = get_face_orientation(face, *e1, *e2);
       }
    }
 }
@@ -602,16 +598,16 @@ void ParNCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
 {
    NCMesh::GetBoundaryClosure(bdr_attr_is_ess, bdr_vertices, bdr_edges);
 
-   int i, j;
    // filter out ghost vertices
-   for (i = j = 0; i < bdr_vertices.Size(); i++)
+   int j = 0;
+   for (int i = j = 0; i < bdr_vertices.Size(); i++)
    {
       if (bdr_vertices[i] < NVertices) { bdr_vertices[j++] = bdr_vertices[i]; }
    }
    bdr_vertices.SetSize(j);
 
    // filter out ghost edges
-   for (i = j = 0; i < bdr_edges.Size(); i++)
+   for (int i = j = 0; i < bdr_edges.Size(); i++)
    {
       if (bdr_edges[i] < NEdges) { bdr_edges[j++] = bdr_edges[i]; }
    }
@@ -893,6 +889,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
 
    Array<Element*> fnbr;
    Array<Connection> send_elems;
+   std::map<int, std::vector<int>> recv_elems;
 
    // Counts the number of slave faces of a master. This may be larger than the
    // number of shared slaves if there exist degenerate slave-faces from face-edge constraints.
@@ -907,8 +904,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    fnbr.Reserve(bound);
    send_elems.Reserve(bound);
 
+   // If there are face neighbor elements with triangular faces, the
+   // `face_nbr_el_ori` structure will need to be built. This requires
+   // communication so we attempt to avoid it by checking first.
+   bool face_nbr_w_tri_faces = false;
+
    // go over all shared faces and collect face neighbor elements
-   for (int i = 0; i < shared.conforming.Size(); i++)
+   for (int i = 0; i < shared.conforming.Size(); ++i)
    {
       const MeshId &cf = shared.conforming[i];
       Face* face = GetFace(elements[cf.element], cf.local);
@@ -920,8 +922,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       if (e[0]->rank == MyRank) { std::swap(e[0], e[1]); }
       MFEM_ASSERT(e[0]->rank != MyRank && e[1]->rank == MyRank, "");
 
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
       fnbr.Append(e[0]);
       send_elems.Append(Connection(e[0]->rank, e[1]->index));
+      recv_elems[e[0]->rank].push_back(e[0]->index);
    }
 
    for (int i = 0; i < shared.masters.Size(); i++)
@@ -944,8 +950,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          }
          if (loc0) { std::swap(e[0], e[1]); }
 
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
          fnbr.Append(e[0]);
          send_elems.Append(Connection(e[0]->rank, e[1]->index));
+         recv_elems[e[0]->rank].push_back(e[0]->index);
       }
    }
 
@@ -1028,6 +1038,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    send_elems.Sort();
    send_elems.Unique();
 
+   for (auto &kv : recv_elems)
+   {
+      std::sort(kv.second.begin(), kv.second.end());
+      kv.second.erase(std::unique(kv.second.begin(), kv.second.end()),
+                      kv.second.end());
+   }
+
    for (int i = 0, last_rank = -1; i < send_elems.Size(); i++)
    {
       Connection &c = send_elems[i];
@@ -1181,10 +1198,173 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       }
    }
 
+
+   // In 3D some extra orientation data structures can be needed.
+   if (Dim == 3)
+   {
+      // Populates face_nbr_el_to_face, always needed.
+      pmesh.BuildFaceNbrElementToFaceTable();
+
+      if (face_nbr_w_tri_faces)
+      {
+         // There are face neighbor elements with triangular faces, need to
+         // perform communication to ensure the orientation is valid.
+         using RankToOrientation = std::map<int, std::vector<std::array<int, 6>>>;
+         constexpr std::array<int, 6> unset_ori{{-1,-1,-1,-1,-1,-1}};
+         const int rank = pmesh.GetMyRank();
+
+         // Loop over send elems, compute the orientation and place in the buffer to
+         // send to each processor. Note elements are lexicographically sorted
+         // with rank and element number, and this ordering holds across processors.
+         RankToOrientation send_rank_to_face_neighbor_orientations;
+         Array<int> orientations, faces;
+
+         // send_elems goes from rank of the receiving processor, to the index
+         // of the face neighbor element on this processor.
+         for (const auto &se : send_elems)
+         {
+            const auto &true_rank = pmesh.face_nbr_group[se.from];
+            pmesh.GetElementFaces(se.to, faces, orientations);
+
+            // Place a new entry of unset orientations
+            send_rank_to_face_neighbor_orientations[true_rank].emplace_back(unset_ori);
+
+            // Copy the entries, any unset faces will remain -1.
+            std::copy(orientations.begin(), orientations.end(),
+                      send_rank_to_face_neighbor_orientations[true_rank].back().begin());
+         }
+
+         // Initialize the receive buffers and resize to match the expected
+         // number of elements coming in. The copy ensures the appropriate rank
+         // pairings are in place, and for a purely conformal interface, the
+         // resize is a no-op.
+         auto recv_rank_to_face_neighbor_orientations =
+            send_rank_to_face_neighbor_orientations;
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            kv.second.resize(recv_elems[kv.first].size());
+         }
+
+         // For asynchronous send/recv, will use arrays of requests to monitor the
+         // status of the connections.
+         std::vector<MPI_Request> send_requests, recv_requests;
+         std::vector<MPI_Status> status(nranks);
+
+         // NOTE: This is CRITICAL, to ensure the addresses of these requests
+         // do not change between the send/recv and the wait.
+         send_requests.reserve(nranks);
+         recv_requests.reserve(nranks);
+
+         // Shared face communication is bidirectional -> any rank to whom
+         // orientations must be sent, will need to send orientations back.
+         // The orientation data is contiguous because std::array<int,6> is an
+         // aggregate.
+
+         // Loop over each communication pairing, and dispatch the buffer loaded
+         // with  all the orientation data.
+         for (const auto &kv : send_rank_to_face_neighbor_orientations)
+         {
+            send_requests.emplace_back(); // instantiate a request for tracking.
+
+            // low rank sends on low, high rank sends on high.
+            const int send_tag = (rank < kv.first)
+                                 ? std::min(rank, kv.first)
+                                 : std::max(rank, kv.first);
+            MPI_Isend(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, send_tag, pmesh.MyComm, &send_requests.back());
+         }
+
+         // Loop over the communication pairing again, and receive the
+         // symmetric buffer from the other processor.
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            recv_requests.emplace_back(); // instantiate a request for tracking
+
+            // low rank receives on high, high rank receives on low.
+            const int recv_tag = (rank < kv.first)
+                                 ? std::max(rank, kv.first)
+                                 : std::min(rank, kv.first);
+            MPI_Irecv(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, recv_tag, pmesh.MyComm, &recv_requests.back());
+         }
+
+         // Wait until all receive buffers are full before beginning to process.
+         MPI_Waitall(int(recv_requests.size()), recv_requests.data(), status.data());
+
+         pmesh.face_nbr_el_ori.reset(new Table(pmesh.face_nbr_elements.Size(), 6));
+         int elem = 0;
+         for (const auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            // All elements associated to this face-neighbor rank
+            for (const auto &eo : kv.second)
+            {
+               std::copy(eo.begin(), eo.end(), pmesh.face_nbr_el_ori->GetRow(elem));
+               ++elem;
+            }
+         }
+         pmesh.face_nbr_el_ori->Finalize();
+
+         // Must wait for all send buffers to be released before the scope closes.
+         MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
+      }
+   }
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
 
+void ParNCMesh::ComputeGhostBoundaryElements(const ParMesh &mesh)
+{
+   // 1D cannot have ghost boundary elements
+   if (Dim == 1) { return; }
+
+   // ParNCMesh requires additional treatment of "ghost boundary elements" in
+   // the scenario where a parent face has only ghost children. A local mesh
+   // will fail to identify essential boundary conditions without the use of
+   // these ghost boundary elements, as they will not be added into the list of
+   // local boundary elements, whose masters will eventually be found.
+
+   ghost_boundary_elements.clear();
+   for (int n = NElements; n < NGhostElements + NElements; ++n)
+   {
+      const auto &nc_elem = elements[leaf_elements[n]];
+
+      const int * const node = nc_elem.node;
+      GeomInfo& gi = GI[(int) nc_elem.geom];
+
+      // Loop over faces and find those that are masters of internal boundaries
+      for (int k = 0; k < gi.nf; ++k)
+      {
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+
+         if (id >= 0 && faces[id].Boundary() && faces[id].index >= NFaces)
+         {
+            // Found a ghost face, and it is a boundary element.
+            // Need to check if it's a slave, and if it's internal.
+            const auto &face = faces[id];
+
+            // A conformal face
+            if (face.elem[0] >= 0 && face.elem[1] >= 0) { continue; }
+
+            // A ghost face not indexed by the mesh -> no useful information
+            if (face.index >= mesh.faces_info.Size()) { continue; }
+
+            MFEM_ASSERT(face.index >= 0, face.index);
+            const auto &finfo = mesh.faces_info[face.index];
+            if (mesh.IsSlaveFace(finfo)) // slave face
+            {
+               int master_face = mesh.GetNCMasterFaceIndex(finfo.NCFace);
+               if (master_face < mesh.GetNFaces())
+               {
+                  ghost_boundary_elements[face.attribute].insert(master_face);
+               }
+            }
+         }
+      }
+   }
+}
+
 void ParNCMesh::ClearAuxPM()
 {
    for (int i = 0; i < aux_pm_store.Size(); i++)
@@ -1825,10 +2005,9 @@ void ParNCMesh::RedistributeElements(Array<int> &new_ranks, int target_elements,
    NeighborElementRankMessage::RecvAll(recv_ghost_ranks, MyComm);
 
    // read new ranks for the ghost layer from messages received
-   NeighborElementRankMessage::Map::iterator it;
-   for (it = recv_ghost_ranks.begin(); it != recv_ghost_ranks.end(); ++it)
+   for (auto &kv : recv_ghost_ranks)
    {
-      NeighborElementRankMessage &msg = it->second;
+      NeighborElementRankMessage &msg = kv.second;
       for (int i = 0; i < msg.Size(); i++)
       {
          int ghost_index = elements[msg.elements[i]].index;
@@ -2355,9 +2534,8 @@ void ParNCMesh::AdjustMeshIds(Array<MeshId> ids[], int rank)
 
    // find vertices/edges of master faces shared with 'rank', and modify their
    // MeshIds so their element/local matches the element of the master face
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const MeshId &face_id : shared_faces.masters)
    {
-      const MeshId &face_id = shared_faces.masters[i];
       if (contains_rank[entity_pmat_group[2][face_id.index]])
       {
          int v[4], e[4], eo[4], pos, k;
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index ed919f14c..9c425b631 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -82,23 +82,23 @@ public:
    /** An override of NCMesh::Refine, which is called eventually, after making
        sure that refinements that occur on the processor boundary are sent to
        the neighbor processors so they can keep their ghost layers up to date.*/
-   virtual void Refine(const Array<Refinement> &refinements);
+   void Refine(const Array<Refinement> &refinements) override;
 
    /// Parallel version of NCMesh::LimitNCLevel.
-   virtual void LimitNCLevel(int max_nc_level);
+   void LimitNCLevel(int max_nc_level) override;
 
    /** Parallel version of NCMesh::CheckDerefinementNCLevel. */
-   virtual void CheckDerefinementNCLevel(const Table &deref_table,
-                                         Array<int> &level_ok, int max_nc_level);
+   void CheckDerefinementNCLevel(const Table &deref_table,
+                                 Array<int> &level_ok, int max_nc_level) override;
 
    /** Parallel reimplementation of NCMesh::Derefine, keeps ghost layers
        in sync. The interface is identical. */
-   virtual void Derefine(const Array<int> &derefs);
+   void Derefine(const Array<int> &derefs) override;
 
    /** Gets partitioning for the coarse mesh if the current fine mesh were to
        be derefined. */
-   virtual void GetFineToCoarsePartitioning(const Array<int> &derefs,
-                                            Array<int> &new_ranks) const;
+   void GetFineToCoarsePartitioning(const Array<int> &derefs,
+                                    Array<int> &new_ranks) const;
 
    /** Migrate leaf elements of the global refinement hierarchy (including ghost
        elements) so that each processor owns the same number of leaves (+-1).
@@ -108,15 +108,13 @@ public:
        passed. */
    void Rebalance(const Array<int> *custom_partition = NULL);
 
-
    // interface for ParFiniteElementSpace
-
    int GetNElements() const { return NElements; }
 
    int GetNGhostVertices() const { return NGhostVertices; }
    int GetNGhostEdges() const { return NGhostEdges; }
    int GetNGhostFaces() const { return NGhostFaces; }
-   int GetNGhostElements() const { return NGhostElements; }
+   int GetNGhostElements() const override { return NGhostElements; }
 
    // Return a list of vertices/edges/faces shared by this processor and at
    // least one other processor. These are subsets of NCMesh::<entity>_list. */
@@ -141,8 +139,8 @@ public:
       return (index < NFaces) ? face_orient[index] : 0;
    }
 
-   typedef short GroupId;
-   typedef std::vector<int> CommGroup;
+   using GroupId = short;
+   using CommGroup = std::vector<int>;
 
    /// Return vertex/edge/face ('entity' == 0/1/2, resp.) owner.
    GroupId GetEntityOwnerId(int entity, int index)
@@ -232,12 +230,12 @@ public:
 
    /** Extension of NCMesh::GetBoundaryClosure. Filters out ghost vertices and
        ghost edges from 'bdr_vertices' and 'bdr_edges'. */
-   virtual void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
-                                   Array<int> &bdr_vertices,
-                                   Array<int> &bdr_edges);
+   void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
+                           Array<int> &bdr_vertices,
+                           Array<int> &bdr_edges) override;
 
    /// Save memory by releasing all non-essential and cached data.
-   virtual void Trim();
+   void Trim() override;
 
    /// Return total number of bytes allocated.
    std::size_t MemoryUsage(bool with_base = true) const;
@@ -248,6 +246,17 @@ public:
        The debug mesh will have element attributes set to element rank + 1. */
    void GetDebugMesh(Mesh &debug_mesh) const;
 
+   /**
+    * @brief Get the Ghost Boundary Elements object, explicitly behind a const
+    * interface to avoid external modification. See ComputeGhostBoundaryElements
+    * for information on ghost boundary elements and their importance.
+    *
+    * @return std::map<int, std::set<int>> Container from boundary attribute
+    * value to set of codimension 1 objects that are parents of ghost
+    * children with this attribute.
+    */
+   std::map<int, std::set<int>> GetGhostBoundaryElements() const { return ghost_boundary_elements; }
+
 protected: // interface for ParMesh
 
    friend class ParMesh;
@@ -261,14 +270,42 @@ protected: // interface for ParMesh
        communication. */
    void GetFaceNeighbors(class ParMesh &pmesh);
 
+   /**
+    * @brief Given a ParMesh with all FaceNbrData computed, populate the
+    * ghost_boundary_elements.
+    * @details The ghost_boundary_elements container is accessed via
+    * GetGhostBoundaryElements, and represents a collection of parent faces that
+    * are coincident to a given boundary element, but whose child faces are all
+    * ghosts. Boundary elements must be child faces or conformal faces, in
+    * order to calculate functionals and boundary condition integrals. However,
+    * essential boundary conditions, must be imposed via the parent faces, in
+    * order to correctly constrain all face internal DOFs. This is accomplished
+    * by traversing from child faces to parent faces, but these dofs cannot be
+    * constrained if the parent face is a ghost.
+    *
+    * The corollary to this is that a parent face with only ghost children, will
+    * never be marked as part of an internal boundary during the usual boundary
+    * element traversal. Consequently, the ghost boundary elements keep track of
+    * these ghost boundary elements, by collecting them once the face neighbor
+    * data has been exchanged. A ParFiniteElementSpace is then able to loop over
+    * these DOF additionally during GetEssentialVDofs.
+    *
+    * NOTE: Users do not need to call this method, it will be called during
+    * ExchangeFaceNbrData once the relevant predicate information has been
+    * established.
+    *
+    * @param mesh The mesh for whom the ghost boundary elements should be
+    * established.
+    */
+   void ComputeGhostBoundaryElements(const ParMesh &mesh);
 
 protected: // implementation
 
    MPI_Comm MyComm;
    int NRanks;
 
-   typedef std::vector<CommGroup> GroupList;
-   typedef std::map<CommGroup, GroupId> GroupMap;
+   using GroupList = std::vector<CommGroup>;
+   using GroupMap = std::map<CommGroup, GroupId>;
 
    GroupList groups;  // comm group list; NOTE: groups[0] = { MyRank }
    GroupMap group_id; // search index over groups
@@ -299,7 +336,14 @@ protected: // implementation
    Array<int> ghost_layer;    ///< list of elements whose 'element_type' == 2.
    Array<int> boundary_layer; ///< list of type 3 elements
 
-   virtual void Update();
+   /// Master face internal boundary elements that are attached to the processor
+   /// boundary which cannot be found by looping over the boundary elements alone.
+   /// This variable maps from boundary attributes, to a collection of boundary
+   /// faces (i.e. codimension 1 objects) that are parents of ghost child faces
+   /// with this attribute.
+   std::map<int, std::set<int>> ghost_boundary_elements;
+
+   void Update() override;
 
    /// Return the processor number for a global element number.
    int Partition(long index, long total_elements) const
@@ -313,13 +357,13 @@ protected: // implementation
    long PartitionFirstIndex(int rank, long total_elements) const
    { return (rank * total_elements + NRanks-1) / NRanks; }
 
-   virtual void BuildFaceList();
-   virtual void BuildEdgeList();
-   virtual void BuildVertexList();
+   void BuildFaceList() override;
+   void BuildEdgeList() override;
+   void BuildVertexList() override;
 
-   virtual void ElementSharesFace(int elem, int local, int face);
-   virtual void ElementSharesEdge(int elem, int local, int enode);
-   virtual void ElementSharesVertex(int elem, int local, int vnode);
+   void ElementSharesFace(int elem, int local, int face) override;
+   void ElementSharesEdge(int elem, int local, int enode) override;
+   void ElementSharesVertex(int elem, int local, int vnode) override;
 
    GroupId GetGroupId(const CommGroup &group);
    GroupId GetSingletonGroup(int rank);
@@ -451,8 +495,8 @@ protected: // implementation
    protected:
       ParNCMesh* pncmesh;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Used by ParNCMesh::Refine() to inform neighbors about refinements at
@@ -513,8 +557,8 @@ protected: // implementation
    protected:
       ElementSet eset;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Assign new Element::rank to leaf elements and send them to their new
diff --git a/mesh/point.cpp b/mesh/point.cpp
index ecf6a4dd0..22e4acda8 100644
--- a/mesh/point.cpp
+++ b/mesh/point.cpp
@@ -21,12 +21,18 @@ Point::Point( const int *ind, int attr ) : Element(Geometry::POINT)
    indices[0] = ind[0];
 }
 
-void Point::GetVertices( Array<int> &v ) const
+void Point::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 1 );
+   v.SetSize(1);
    v[0] = indices[0];
 }
 
+void Point::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 1, "!");
+   indices[0] = v[0];
+}
+
 PointFiniteElement PointFE;
 
 }
diff --git a/mesh/point.hpp b/mesh/point.hpp
index f154e205e..7c660d164 100644
--- a/mesh/point.hpp
+++ b/mesh/point.hpp
@@ -33,33 +33,34 @@ public:
    Point( const int *ind, int attr = -1 );
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::POINT; }
+   Type GetType() const override { return Element::POINT; }
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices( Array<int> &v ) const;
+   /// Access the indices of the element's  vertices.
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const  Array<int> &v) override;
 
-   virtual int * GetVertices () { return indices; }
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNVertices() const { return 1; }
+   int GetNVertices() const override { return 1; }
 
-   virtual int GetNEdges() const { return (0); }
+   int GetNEdges() const override { return (0); }
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Point (indices, attribute); }
 
-   virtual ~Point() { }
+   virtual ~Point() = default;
 };
 
 class PointFiniteElement;
diff --git a/mesh/pyramid.cpp b/mesh/pyramid.cpp
index d67841564..f64f2afe9 100644
--- a/mesh/pyramid.cpp
+++ b/mesh/pyramid.cpp
@@ -48,10 +48,13 @@ void Pyramid::SetVertices(const int *ind)
 void Pyramid::GetVertices(Array<int> &v) const
 {
    v.SetSize(5);
-   for (int i = 0; i < 5; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 5, v.begin());
+}
+
+void Pyramid::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 5, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Pyramid::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 8e171a31d..ec4ab1fb7 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -37,38 +37,39 @@ public:
            int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::PYRAMID; }
+   Type GetType() const override { return Element::PYRAMID; }
 
    /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Access the indices of the element's  vertices.
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 5; }
+   int GetNVertices() const override { return 5; }
 
-   virtual int GetNEdges() const { return 8; }
+   int GetNEdges() const override { return 8; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return ( ( fi < 1 ) ? 4 : 3); }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Pyramid(indices, attribute); }
 
-   virtual ~Pyramid() { }
+   virtual ~Pyramid() = default;
 };
 
 extern class LinearPyramidFiniteElement PyramidFE;
diff --git a/mesh/quadrilateral.cpp b/mesh/quadrilateral.cpp
index 1a69cf179..f658c04bd 100644
--- a/mesh/quadrilateral.cpp
+++ b/mesh/quadrilateral.cpp
@@ -43,13 +43,17 @@ void Quadrilateral::SetVertices(const int *ind)
    }
 }
 
-void Quadrilateral::GetVertices( Array<int> &v ) const
+void Quadrilateral::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 4 );
-   for (int i=0; i<4; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(4);
+   std::copy(indices, indices + 4, v.begin());
+}
+
+
+void Quadrilateral::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/quadrilateral.hpp b/mesh/quadrilateral.hpp
index 9f6b9a442..4b547bb2a 100644
--- a/mesh/quadrilateral.hpp
+++ b/mesh/quadrilateral.hpp
@@ -36,37 +36,38 @@ public:
    Quadrilateral(int ind1, int ind2, int ind3, int ind4, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::QUADRILATERAL; }
+   Type GetType() const override { return Element::QUADRILATERAL; }
 
    /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
    /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (4); }
+   int GetNEdges() const override { return (4); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Quadrilateral(indices, attribute); }
 
-   virtual ~Quadrilateral() { }
+   virtual ~Quadrilateral() = default;
 };
 
 extern MFEM_EXPORT class BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/segment.cpp b/mesh/segment.cpp
index 717245907..910614770 100644
--- a/mesh/segment.cpp
+++ b/mesh/segment.cpp
@@ -37,13 +37,16 @@ void Segment::SetVertices(const int *ind)
    indices[1] = ind[1];
 }
 
-void Segment::GetVertices( Array<int> &v ) const
+void Segment::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 2 );
-   for (int i=0; i<2; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(2);
+   std::copy(indices, indices + 2, v.begin());
+}
+
+void Segment::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 2, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Linear1DFiniteElement SegmentFE;
diff --git a/mesh/segment.hpp b/mesh/segment.hpp
index 6ca918758..f5d5e1c17 100644
--- a/mesh/segment.hpp
+++ b/mesh/segment.hpp
@@ -36,36 +36,37 @@ public:
    Segment(int ind1, int ind2, int attr = 1);
 
    /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::SEGMENT; }
+   Type GetType() const override { return Element::SEGMENT; }
 
    /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 2; }
+   int GetNVertices() const override { return 2; }
 
-   virtual int GetNEdges() const { return (0); }
+   int GetNEdges() const override { return 0; }
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Segment(indices, attribute); }
 
-   virtual ~Segment() { }
+   virtual ~Segment() = default;
 };
 
 class Linear1DFiniteElement;
diff --git a/mesh/tetrahedron.cpp b/mesh/tetrahedron.cpp
index c7ebc064b..22eecbd42 100644
--- a/mesh/tetrahedron.cpp
+++ b/mesh/tetrahedron.cpp
@@ -53,7 +53,7 @@ void Tetrahedron::Init(int ind1, int ind2, int ind3, int ind4, int attr,
 }
 
 void Tetrahedron::ParseRefinementFlag(int refinement_edges[2], int &type,
-                                      int &flag)
+                                      int &flag) const
 {
    int i, f = refinement_flag;
 
@@ -134,9 +134,10 @@ void Tetrahedron::CreateRefinementFlag(int refinement_edges[2], int type,
    refinement_flag |= refinement_edges[0];
 }
 
-void Tetrahedron::GetMarkedFace(const int face, int *fv)
+void Tetrahedron::GetMarkedFace(const int face, int *fv) const
 {
-   int re[2], type, flag, *tv = this->indices;
+   int re[2], type, flag;
+   const int *tv = this->indices;
    ParseRefinementFlag(re, type, flag);
    switch (face)
    {
@@ -326,10 +327,13 @@ void Tetrahedron::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Tetrahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(4);
-   for (int i = 0; i < 4; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 4, v.begin());
+}
+
+void Tetrahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Element *Tetrahedron::Duplicate(Mesh *m) const
diff --git a/mesh/tetrahedron.hpp b/mesh/tetrahedron.hpp
index c434ae903..cdbc6be97 100644
--- a/mesh/tetrahedron.hpp
+++ b/mesh/tetrahedron.hpp
@@ -56,64 +56,66 @@ public:
              int ref_flag = 0);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TETRAHEDRON; }
+   Type GetType() const override { return Element::TETRAHEDRON; }
 
-   void  ParseRefinementFlag(int refinement_edges[2], int &type, int &flag);
+   void  ParseRefinementFlag(int refinement_edges[2], int &type,
+                             int &flag) const;
    void CreateRefinementFlag(int refinement_edges[2], int  type, int  flag = 0);
 
-   void GetMarkedFace(const int face, int *fv);
+   void GetMarkedFace(const int face, int *fv) const;
 
-   int GetRefinementFlag() { return refinement_flag; }
+   int GetRefinementFlag() const { return refinement_flag; }
 
    void SetRefinementFlag(int rf) { refinement_flag = rf; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
        because the order may be used later for setting the edges. **/
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length);
+   void MarkEdge(const DSTable &v_to_v, const int *length) override;
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Access the indices of the element's  vertices.
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (6); }
+   int GetNEdges() const override { return (6); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 3; return 4; }
 
-   virtual int GetNFaces() const { return 4; }
+   int GetNFaces() const override { return 4; }
 
-   virtual int GetNFaceVertices(int) const { return 3; }
+   int GetNFaceVertices(int) const override { return 3; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const;
+   Element *Duplicate(Mesh *m) const override;
 
-   virtual ~Tetrahedron() { }
+   virtual ~Tetrahedron() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/triangle.cpp b/mesh/triangle.cpp
index 5ce32cb31..eb7493398 100644
--- a/mesh/triangle.cpp
+++ b/mesh/triangle.cpp
@@ -188,10 +188,13 @@ void Triangle::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Triangle::GetVertices(Array<int> &v) const
 {
    v.SetSize(3);
-   for (int i = 0; i < 3; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 3, v.begin());
+}
+
+void Triangle::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 3, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 } // namespace mfem
diff --git a/mesh/triangle.hpp b/mesh/triangle.hpp
index 363bd4503..b4926922e 100644
--- a/mesh/triangle.hpp
+++ b/mesh/triangle.hpp
@@ -39,13 +39,13 @@ public:
    Triangle(int ind1, int ind2, int ind3, int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TRIANGLE; }
+   Type GetType() const override { return Element::TRIANGLE; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
@@ -55,46 +55,47 @@ public:
    static void MarkEdge(int *indices, const DSTable &v_to_v, const int *length);
 
    /// Mark the longest edge by assuming/changing the order of the vertices.
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length)
+   void MarkEdge(const DSTable &v_to_v, const int *length) override
    { MarkEdge(indices, v_to_v, length); }
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Access the indices of the element's  vertices.
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 3; }
+   int GetNVertices() const override { return 3; }
 
-   virtual int GetNEdges() const { return (3); }
+   int GetNEdges() const override { return (3); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { MFEM_ABORT("not implemented"); return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Triangle(indices, attribute); }
 
-   virtual ~Triangle() { }
+   virtual ~Triangle() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/wedge.cpp b/mesh/wedge.cpp
index 898da7653..b1aea933d 100644
--- a/mesh/wedge.cpp
+++ b/mesh/wedge.cpp
@@ -50,10 +50,13 @@ void Wedge::SetVertices(const int *ind)
 void Wedge::GetVertices(Array<int> &v) const
 {
    v.SetSize(6);
-   for (int i = 0; i < 6; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 6, v.begin());
+}
+
+void Wedge::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 6, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Wedge::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/wedge.hpp b/mesh/wedge.hpp
index fb8583f8e..3333ebc57 100644
--- a/mesh/wedge.hpp
+++ b/mesh/wedge.hpp
@@ -37,38 +37,39 @@ public:
          int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::WEDGE; }
+   Type GetType() const override { return Element::WEDGE; }
 
    /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   void SetVertices(const int *ind) override;
 
    /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   void GetVertices(Array<int> &v) const override;
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   int *GetVertices() override { return indices; }
 
-   virtual int GetNVertices() const { return 6; }
+   int GetNVertices() const override { return 6; }
 
-   virtual int GetNEdges() const { return 9; }
+   int GetNEdges() const override { return 9; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return (fi < 2) ? 3 : 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Wedge(indices, attribute); }
 
-   virtual ~Wedge() { }
+   virtual ~Wedge() = default;
 };
 
 extern MFEM_EXPORT class LinearWedgeFiniteElement WedgeFE;
diff --git a/miniapps/gslib/findpts.cpp b/miniapps/gslib/findpts.cpp
index d45e1be39..2ae5a9eb6 100644
--- a/miniapps/gslib/findpts.cpp
+++ b/miniapps/gslib/findpts.cpp
@@ -448,9 +448,8 @@ int main (int argc, char *argv[])
    Vector dist_p_out = finder.GetDist();
 
    int face_pts = 0, not_found = 0, found = 0;
-   double err = 0.0, max_err = 0.0, max_dist = 0.0;
+   double error = 0.0, max_err = 0.0, max_dist = 0.0;
    Vector pos(dim);
-   int npt = 0;
    for (int j = 0; j < vec_dim; j++)
    {
       for (int i = 0; i < pts_cnt; i++)
@@ -466,15 +465,14 @@ int main (int argc, char *argv[])
             }
             Vector exact_val(vec_dim);
             F_exact(pos, exact_val);
-            err = gf_ordering == Ordering::byNODES ?
-                  fabs(exact_val(j) - interp_vals[i + j*pts_cnt]) :
-                  fabs(exact_val(j) - interp_vals[i*vec_dim + j]);
-            max_err  = std::max(max_err, err);
+            error = gf_ordering == Ordering::byNODES ?
+                    fabs(exact_val(j) - interp_vals[i + j*pts_cnt]) :
+                    fabs(exact_val(j) - interp_vals[i*vec_dim + j]);
+            max_err  = std::max(max_err, error);
             max_dist = std::max(max_dist, dist_p_out(i));
             if (code_out[i] == 1 && j == 0) { face_pts++; }
          }
          else { if (j == 0) { not_found++; } }
-         npt++;
       }
    }
 
diff --git a/miniapps/gslib/pfindpts.cpp b/miniapps/gslib/pfindpts.cpp
index afdd5acbe..9fc4642e1 100644
--- a/miniapps/gslib/pfindpts.cpp
+++ b/miniapps/gslib/pfindpts.cpp
@@ -308,9 +308,8 @@ int main (int argc, char *argv[])
    if (myid == 0 )
    {
       int face_pts = 0, not_found = 0, found_loc = 0, found_away = 0;
-      double err = 0.0, max_err = 0.0, max_dist = 0.0;
+      double error = 0.0, max_err = 0.0, max_dist = 0.0;
       Vector pos(dim);
-      int npt = 0;
       for (int j = 0; j < vec_dim; j++)
       {
          for (int i = 0; i < pts_cnt; i++)
@@ -330,15 +329,14 @@ int main (int argc, char *argv[])
                }
                Vector exact_val(vec_dim);
                F_exact(pos, exact_val);
-               err = gf_ordering == Ordering::byNODES ?
-                     fabs(exact_val(j) - interp_vals[i + j*pts_cnt]) :
-                     fabs(exact_val(j) - interp_vals[i*vec_dim + j]);
-               max_err  = std::max(max_err, err);
+               error = gf_ordering == Ordering::byNODES ?
+                       fabs(exact_val(j) - interp_vals[i + j*pts_cnt]) :
+                       fabs(exact_val(j) - interp_vals[i*vec_dim + j]);
+               max_err  = std::max(max_err, error);
                max_dist = std::max(max_dist, dist_p_out(i));
                if (code_out[i] == 1 && j == 0) { face_pts++; }
             }
             else { if (j == 0) { not_found++; } }
-            npt++;
          }
       }
 
diff --git a/miniapps/gslib/schwarz_ex1p.cpp b/miniapps/gslib/schwarz_ex1p.cpp
index 64e9fd728..af457cf1a 100644
--- a/miniapps/gslib/schwarz_ex1p.cpp
+++ b/miniapps/gslib/schwarz_ex1p.cpp
@@ -362,7 +362,7 @@ int main(int argc, char *argv[])
    int NiterSchwarz = 100;
    for (int schwarz = 0; schwarz < NiterSchwarz; schwarz++)
    {
-      ParLinearForm *b = new ParLinearForm(fespace);
+      b = new ParLinearForm(fespace);
       b->AddDomainIntegrator(new DomainLFIntegrator(one));
       b->Assemble();
 
diff --git a/miniapps/meshing/makefile b/miniapps/meshing/makefile
index 315dc4465..656f80d0e 100644
--- a/miniapps/meshing/makefile
+++ b/miniapps/meshing/makefile
@@ -121,7 +121,7 @@ clean-build:
 	rm -rf *.dSYM *.TVD.*breakpoints
 
 clean-exec:
-	@rm -f mobius-strip.mesh klein-bottle.mesh mesh-explorer.mesh
+	@rm -f mobius-strip.mesh klein-bottle.mesh mesh-explorer.mesh*
 	@rm -f toroid-*.mesh twist-*.mesh trimmer.mesh reflected.mesh
 	@rm -f partitioning.txt shaper.mesh extruder.mesh
 	@rm -f optimized* perturbed* polar-nc.mesh
diff --git a/miniapps/meshing/mesh-explorer.cpp b/miniapps/meshing/mesh-explorer.cpp
index f05e18e83..6a2a4e78b 100644
--- a/miniapps/meshing/mesh-explorer.cpp
+++ b/miniapps/meshing/mesh-explorer.cpp
@@ -308,6 +308,7 @@ int main (int argc, char *argv[])
       partitioning = 0;
       bdr_partitioning.SetSize(mesh->GetNBE());
       bdr_partitioning = 0;
+      np = 1;
    }
    else
    {
@@ -382,7 +383,8 @@ int main (int argc, char *argv[])
            "f) Find physical point in reference space\n"
            "p) Generate a partitioning\n"
            "o) Reorder elements\n"
-           "S) Save in MFEM format\n"
+           "S) Save in MFEM serial format\n"
+           "D) Save in MFEM parallel format using the current partitioning\n"
            "V) Save in VTK format (only linear and quadratic meshes)\n"
            "D) Save as a DataCollection\n"
            "q) Quit\n"
@@ -984,7 +986,7 @@ int main (int argc, char *argv[])
                partitioning.SetSize(mesh->GetNE());
                for (int i = 0; i < mesh->GetNE(); i++)
                {
-                  partitioning[i] = i * np / mesh->GetNE();
+                  partitioning[i] = (long long)i * np / mesh->GetNE();
                }
                recover_bdr_partitioning(mesh, partitioning, bdr_partitioning);
             }
@@ -997,6 +999,7 @@ int main (int argc, char *argv[])
                }
                cout << "Enter number of processors: " << flush;
                cin >> np;
+
                int *part = mesh->GeneratePartitioning(np, part_method);
                partitioning = Array<int>(part, mesh->GetNE());
                delete [] part;
@@ -1197,6 +1200,25 @@ int main (int argc, char *argv[])
          cout << "New mesh file: " << omesh_file << endl;
       }
 
+      if (mk == 'D')
+      {
+         const char mesh_prefix[] = "mesh-explorer.mesh.";
+         MeshPartitioner partitioner(*mesh, np, partitioning);
+         MeshPart mesh_part;
+         int precision;
+         cout << "Enter desired precision: " << flush;
+         cin >> precision;
+         for (int i = 0; i < np; i++)
+         {
+            partitioner.ExtractPart(i, mesh_part);
+
+            ofstream omesh(MakeParFilename(mesh_prefix, i));
+            omesh.precision(precision);
+            mesh_part.Print(omesh);
+         }
+         cout << "New parallel mesh files: " << mesh_prefix << "<rank>" << endl;
+      }
+
       if (mk == 'V')
       {
          const char omesh_file[] = "mesh-explorer.vtk";
diff --git a/miniapps/meshing/mesh-optimizer.cpp b/miniapps/meshing/mesh-optimizer.cpp
index 95e3ee377..09c31c186 100644
--- a/miniapps/meshing/mesh-optimizer.cpp
+++ b/miniapps/meshing/mesh-optimizer.cpp
@@ -142,6 +142,7 @@ int main(int argc, char *argv[])
    bool fdscheme         = false;
    int adapt_eval        = 0;
    bool exactaction      = false;
+   bool integ_over_targ  = true;
    const char *devopt    = "cpu";
    bool pa               = false;
    int n_hr_iter         = 5;
@@ -270,6 +271,9 @@ int main(int argc, char *argv[])
    args.AddOption(&exactaction, "-ex", "--exact_action",
                   "-no-ex", "--no-exact-action",
                   "Enable exact action of TMOP_Integrator.");
+   args.AddOption(&integ_over_targ, "-it", "--integrate-target",
+                  "-ir", "--integrate-reference",
+                  "Integrate over target (-it) or reference (-ir) element.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -771,8 +775,8 @@ int main(int argc, char *argv[])
    TMOP_QualityMetric *metric_to_use = barrier_type > 0 || worst_case_type > 0
                                        ? untangler_metric
                                        : metric;
-   TMOP_Integrator *tmop_integ = new TMOP_Integrator(metric_to_use, target_c,
-                                                     h_metric);
+   auto tmop_integ = new TMOP_Integrator(metric_to_use, target_c, h_metric);
+   tmop_integ->IntegrateOverTarget(integ_over_targ);
    if (barrier_type > 0 || worst_case_type > 0)
    {
       tmop_integ->ComputeUntangleMetricQuantiles(x, *fespace);
@@ -893,6 +897,7 @@ int main(int argc, char *argv[])
          tmop_integ2->SetCoefficient(metric_coeff2);
       }
       else { tmop_integ2 = new TMOP_Integrator(metric2, target_c, h_metric); }
+      tmop_integ2->IntegrateOverTarget(integ_over_targ);
       tmop_integ2->SetIntegrationRules(*irules, quad_order);
       if (fdscheme) { tmop_integ2->EnableFiniteDifferences(x); }
       tmop_integ2->SetExactActionFlag(exactaction);
diff --git a/miniapps/meshing/minimal-surface.cpp b/miniapps/meshing/minimal-surface.cpp
index 620d1e5b4..0b9086520 100644
--- a/miniapps/meshing/minimal-surface.cpp
+++ b/miniapps/meshing/minimal-surface.cpp
@@ -6,7 +6,7 @@
 // availability visit https://mfem.org.
 //
 // MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 //
 //             -------------------------------------------------
diff --git a/miniapps/meshing/pmesh-optimizer.cpp b/miniapps/meshing/pmesh-optimizer.cpp
index f4eadf1a5..0b08b2686 100644
--- a/miniapps/meshing/pmesh-optimizer.cpp
+++ b/miniapps/meshing/pmesh-optimizer.cpp
@@ -152,6 +152,7 @@ int main (int argc, char *argv[])
    bool fdscheme         = false;
    int adapt_eval        = 0;
    bool exactaction      = false;
+   bool integ_over_targ  = true;
    const char *devopt    = "cpu";
    bool pa               = false;
    int n_hr_iter         = 5;
@@ -281,6 +282,9 @@ int main (int argc, char *argv[])
    args.AddOption(&exactaction, "-ex", "--exact_action",
                   "-no-ex", "--no-exact-action",
                   "Enable exact action of TMOP_Integrator.");
+   args.AddOption(&integ_over_targ, "-it", "--integrate-target",
+                  "-ir", "--integrate-reference",
+                  "Integrate over target (-it) or reference (-ir) element.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -802,8 +806,8 @@ int main (int argc, char *argv[])
    TMOP_QualityMetric *metric_to_use = barrier_type > 0 || worst_case_type > 0
                                        ? untangler_metric
                                        : metric;
-   TMOP_Integrator *tmop_integ = new TMOP_Integrator(metric_to_use, target_c,
-                                                     h_metric);
+   auto tmop_integ = new TMOP_Integrator(metric_to_use, target_c, h_metric);
+   tmop_integ->IntegrateOverTarget(integ_over_targ);
    if (barrier_type > 0 || worst_case_type > 0)
    {
       tmop_integ->ComputeUntangleMetricQuantiles(x, *pfespace);
@@ -926,6 +930,7 @@ int main (int argc, char *argv[])
          tmop_integ2->SetCoefficient(metric_coeff2);
       }
       else { tmop_integ2 = new TMOP_Integrator(metric2, target_c, h_metric); }
+      tmop_integ2->IntegrateOverTarget(integ_over_targ);
       tmop_integ2->SetIntegrationRules(*irules, quad_order);
       if (fdscheme) { tmop_integ2->EnableFiniteDifferences(x); }
       tmop_integ2->SetExactActionFlag(exactaction);
diff --git a/miniapps/meshing/pminimal-surface.cpp b/miniapps/meshing/pminimal-surface.cpp
index 391aa75b9..0fa944ff3 100644
--- a/miniapps/meshing/pminimal-surface.cpp
+++ b/miniapps/meshing/pminimal-surface.cpp
@@ -6,7 +6,7 @@
 // availability visit https://mfem.org.
 //
 // MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 //
 //     --------------------------------------------------------------------
diff --git a/tests/scripts/branch-history b/tests/scripts/branch-history
index 274d26d0b..f0c038df7 100755
--- a/tests/scripts/branch-history
+++ b/tests/scripts/branch-history
@@ -149,7 +149,7 @@ foreach my $sha (@commits) {
         # File was added
         $blob_size += int(`git cat-file -s $dst`); }
       elsif ($mode eq "DD") { }
-      elsif ($mode eq "MM" || $mode eq "MR") {
+      elsif ($mode eq "MM" || $mode eq "MR" || $mode eq "RM") {
         # File was modified, use the gzip'ed diff as a proxy of the required git
         # storage
         my $sz1 = int(`git diff -U0 --binary $src1 $dst | gzip -c | wc -c`);
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index 4b7a81af7..526b86463 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -93,6 +93,7 @@ set(UNIT_TESTS_SRCS
   fem/test_pa_grad.cpp
   fem/test_pa_idinterp.cpp
   fem/test_pa_kernels.cpp
+  fem/test_pgridfunc_save_serial.cpp
   fem/test_project_bdr.cpp
   fem/test_quadf_coef.cpp
   fem/test_quadinterpolator.cpp
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index ebbb8e224..050561e1d 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -17,11 +17,9 @@ using namespace mfem;
 namespace assemblediagonalpa
 {
 
-int dimension;
-
 double coeffFunction(const Vector& x)
 {
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       return sin(8.0 * M_PI * x[0]) * cos(6.0 * M_PI * x[1]) + 2.0;
    }
@@ -36,12 +34,12 @@ double coeffFunction(const Vector& x)
 void vectorCoeffFunction(const Vector & x, Vector & f)
 {
    f = 0.0;
-   if (dimension > 1)
+   if (x.Size() > 1)
    {
       f[0] = sin(M_PI * x[1]);
       f[1] = sin(2.5 * M_PI * x[0]);
    }
-   if (dimension == 3)
+   if (x.Size() == 3)
    {
       f[2] = sin(6.1 * M_PI * x[2]);
    }
@@ -50,14 +48,14 @@ void vectorCoeffFunction(const Vector & x, Vector & f)
 void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(1,0) = cos(1.3 * M_PI * x[1]);  // 2,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -74,13 +72,13 @@ void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -93,7 +91,7 @@ void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 
 TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -140,9 +138,45 @@ TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
    }
 }
 
+TEST_CASE("Mass Boundary Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   CAPTURE(fname, order);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   FunctionCoefficient coeff(coeffFunction);
+
+   Vector diag_fa(fes.GetTrueVSize()), diag_pa(fes.GetTrueVSize());
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.SpMat().GetDiag(diag_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.AssembleDiagonal(diag_pa);
+
+   diag_pa -= diag_fa;
+
+   REQUIRE(diag_pa.Normlinf() == MFEM_Approx(0.0));
+}
+
 TEST_CASE("Diffusion Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -322,7 +356,7 @@ TEST_CASE("Vector Diffusion Diagonal PA",
 TEST_CASE("Hcurl/Hdiv diagonal PA",
           "[CUDA][PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int coeffType = 0; coeffType < 5; ++coeffType)
       {
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index ddb36cdf2..1077d998a 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -9,11 +9,6 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifdef _WIN32
-#define _USE_MATH_DEFINES
-#include <cmath>
-#endif
-
 #include "unit_tests.hpp"
 #include "mfem.hpp"
 
@@ -390,17 +385,17 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    }
    int dim = mesh.Dimension();
 
-   FiniteElementCollection *fec;
+   std::unique_ptr<FiniteElementCollection> fec;
    if (prob)
    {
       auto basis = prob==3 ? BasisType::Positive : BasisType::GaussLobatto;
-      fec = new L2_FECollection(order, dim, basis);
+      fec.reset(new L2_FECollection(order, dim, basis));
    }
    else
    {
-      fec = new H1_FECollection(order, dim);
+      fec.reset(new H1_FECollection(order, dim));
    }
-   FiniteElementSpace fespace(&mesh, fec);
+   FiniteElementSpace fespace(&mesh, fec.get());
 
    L2_FECollection vel_fec(order, dim, BasisType::GaussLobatto);
    FiniteElementSpace vel_fespace(&mesh, &vel_fec, dim);
@@ -410,21 +405,21 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    BilinearForm k_pa(&fespace);
    BilinearForm k_fa(&fespace);
 
-   VectorCoefficient *vel_coeff;
-   Coefficient *rho;
+   std::unique_ptr<VectorCoefficient> vel_coeff;
+   std::unique_ptr<Coefficient> rho;
 
    // prob: 0: CG, 1: DG continuous coeff, 2: DG discontinuous coeff
    if (prob >= 2)
    {
       vel_gf.Randomize(1);
-      vel_coeff = new VectorGridFunctionCoefficient(&vel_gf);
+      vel_coeff.reset(new VectorGridFunctionCoefficient(&vel_gf));
       rho_gf.Randomize(1);
-      rho = new GridFunctionCoefficient(&rho_gf);
+      rho.reset(new GridFunctionCoefficient(&rho_gf));
    }
    else
    {
-      vel_coeff = new VectorFunctionCoefficient(dim, velocity_function);
-      rho = new ConstantCoefficient(1.0);
+      vel_coeff.reset(new VectorFunctionCoefficient(dim, velocity_function));
+      rho.reset(new ConstantCoefficient(1.0));
    }
 
 
@@ -456,10 +451,6 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    y_pa -= y_fa;
 
    REQUIRE(y_pa.Norml2() < 1.e-12);
-
-   delete vel_coeff;
-   delete rho;
-   delete fec;
 }
 
 // Basic unit tests for convection
@@ -473,7 +464,7 @@ TEST_CASE("PA Convection", "[PartialAssembly], [CUDA]")
    auto prob = GENERATE(0, 1, 2, 3);
    auto order = GENERATE(2);
    // refinement > 0 => Non-conforming mesh
-   auto refinement = GENERATE(0,1);
+   auto refinement = GENERATE(0, 1);
 
    SECTION("2D")
    {
@@ -549,17 +540,17 @@ static void test_pa_integrator()
    GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
    x.Randomize(1);
 
-   ConstantCoefficient pi(M_PI);
+   FunctionCoefficient coeff(f1);
 
    BilinearForm blf_fa(&fes);
-   blf_fa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_fa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_fa.Assemble();
    blf_fa.Finalize();
    blf_fa.Mult(x, y_fa);
 
    BilinearForm blf_pa(&fes);
    blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
-   blf_pa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_pa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_pa.Assemble();
    blf_pa.Mult(x, y_pa);
 
@@ -578,4 +569,39 @@ TEST_CASE("PA Diffusion", "[PartialAssembly], [CUDA]")
    test_pa_integrator<DiffusionIntegrator>();
 } // PA Diffusion test case
 
+TEST_CASE("PA Boundary Mass", "[PartialAssembly], [CUDA]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
+   x.Randomize(1);
+
+   FunctionCoefficient coeff(f1);
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.Mult(x, y_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.Mult(x, y_pa);
+
+   y_fa -= y_pa;
+
+   REQUIRE(y_fa.Normlinf() == MFEM_Approx(0.0));
+}
+
 } // namespace pa_kernels
diff --git a/tests/unit/fem/test_pgridfunc_save_serial.cpp b/tests/unit/fem/test_pgridfunc_save_serial.cpp
new file mode 100644
index 000000000..dd9ea3adf
--- /dev/null
+++ b/tests/unit/fem/test_pgridfunc_save_serial.cpp
@@ -0,0 +1,92 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+using namespace mfem;
+
+namespace pgridfunc_save_in_serial
+{
+
+double squared(const Vector &x)
+{
+   double sum = 0.0;
+   for (int d = 0; d < x.Size(); d++)
+   {
+      sum += std::pow(x(d), 2.0);
+   }
+   return sum;
+}
+
+
+#ifdef MFEM_USE_MPI
+#
+TEST_CASE("ParGridFunction in Serial",
+          "[ParGridFunction]"
+          "[Parallel]")
+{
+   int num_procs;
+   MPI_Comm_size(MPI_COMM_WORLD, &num_procs);
+
+   int my_rank;
+   MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
+
+   int order = 1;
+   int save_rank = 0;
+   int n = 2 * num_procs;
+
+   FunctionCoefficient squaredFC(squared);
+   Mesh mesh = Mesh::MakeCartesian2D(n, n, Element::QUADRILATERAL);
+   mesh.SetCurvature(2);
+   H1_FECollection fec(order, mesh.Dimension());
+
+   double ser_l2_err = 0.0;
+   FiniteElementSpace fespace(&mesh, &fec);
+   GridFunction x(&fespace);
+   x.ProjectCoefficient(squaredFC);
+   ser_l2_err = x.ComputeL2Error(squaredFC);
+
+   // Define a parallel mesh by a partitioning of the serial mesh.
+   ParMesh pmesh(MPI_COMM_WORLD, mesh);
+   ParFiniteElementSpace pfespace(&pmesh, &fec);
+   ParGridFunction px(&pfespace);
+   px.ProjectCoefficient(squaredFC);
+
+   // Get the ParMesh and ParGridFunction on 1 of the mpi ranks. Check the
+   // L2 error on that rank and save gridfunction.
+   Mesh par_to_ser_mesh = pmesh.GetSerialMesh(save_rank);
+   GridFunction x_par_to_ser = px.GetSerialGridFunction(save_rank,
+                                                        par_to_ser_mesh);
+   double par_to_ser_l2_err = 0.0;
+   if (my_rank == save_rank)
+   {
+      par_to_ser_l2_err = x_par_to_ser.ComputeL2Error(squaredFC);
+      REQUIRE(std::fabs(par_to_ser_l2_err-ser_l2_err) == MFEM_Approx(0.0));
+
+      // Save
+      par_to_ser_mesh.Save("parallel_in_serial.mesh");
+   }
+   MPI_Barrier(MPI_COMM_WORLD);
+
+   // Save the mesh and then load the saved mesh and gridfunction, and check
+   // the L2 error on all ranks.
+   px.SaveAsSerial("parallel_in_serial.gf", 16, save_rank);
+   Mesh par_to_ser_mesh_read = Mesh("parallel_in_serial.mesh");
+   named_ifgzstream gfstream("parallel_in_serial.gf");
+   GridFunction x_par_to_ser_read = GridFunction(&par_to_ser_mesh_read,
+                                                 gfstream);
+   double par_to_ser_l2_read_err = x_par_to_ser_read.ComputeL2Error(squaredFC);
+   REQUIRE(std::fabs(par_to_ser_l2_read_err-ser_l2_err) == MFEM_Approx(0.0));
+}
+#endif // MFEM_USE_MPI
+
+} // namespace pgridfunc_save_in_serial
diff --git a/tests/unit/linalg/test_direct_solvers.cpp b/tests/unit/linalg/test_direct_solvers.cpp
index d015a8b94..48a1ac30e 100644
--- a/tests/unit/linalg/test_direct_solvers.cpp
+++ b/tests/unit/linalg/test_direct_solvers.cpp
@@ -17,6 +17,9 @@ using namespace mfem;
 #ifdef MFEM_USE_SUITESPARSE
 #define DIRECT_SOLVE_SERIAL
 #endif
+#ifdef MFEM_USE_MKL_PARDISO
+#define DIRECT_SOLVE_SERIAL
+#endif
 #ifdef MFEM_USE_MUMPS
 #define DIRECT_SOLVE_PARALLEL
 #endif
@@ -138,20 +141,41 @@ TEST_CASE("Serial Direct Solvers", "[CUDA]")
       Vector B, X;
       a.FormLinearSystem(ess_tdof_list, x, b, A, X, B);
 
-      UMFPackSolver umf_solver;
-      umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
-      umf_solver.SetOperator(*A);
-      umf_solver.Mult(B, X);
+#ifdef MFEM_USE_SUITESPARSE
+      {
+         UMFPackSolver umf_solver;
+         umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
+         umf_solver.SetOperator(*A);
+         umf_solver.Mult(B, X);
 
-      Vector Y(X.Size());
-      A->Mult(X, Y);
-      Y -= B;
-      REQUIRE(Y.Norml2() < 1.e-12);
+         Vector Y(X.Size());
+         A->Mult(X, Y);
+         Y -= B;
+         REQUIRE(Y.Norml2() < 1.e-12);
 
-      a.RecoverFEMSolution(X, b, x);
-      VectorFunctionCoefficient grad(dim, gradexact);
-      double error = x.ComputeH1Error(&uex, &grad);
-      REQUIRE(error < 1.e-12);
+         a.RecoverFEMSolution(X, b, x);
+         VectorFunctionCoefficient grad(dim, gradexact);
+         double error = x.ComputeH1Error(&uex, &grad);
+         REQUIRE(error < 1.e-12);
+      }
+#endif
+#ifdef MFEM_USE_MKL_PARDISO
+      {
+         PardisoSolver pardiso_solver;
+         pardiso_solver.SetOperator(*A);
+         pardiso_solver.Mult(B, X);
+
+         Vector Y(X.Size());
+         A->Mult(X, Y);
+         Y -= B;
+         REQUIRE(Y.Norml2() < 1.e-12);
+
+         a.RecoverFEMSolution(X, b, x);
+         VectorFunctionCoefficient grad(dim, gradexact);
+         double error = x.ComputeH1Error(&uex, &grad);
+         REQUIRE(error < 1.e-12);
+      }
+#endif
    }
 }
 
diff --git a/tests/unit/linalg/test_operator.cpp b/tests/unit/linalg/test_operator.cpp
index 8ed47de3f..8e6fe0fd0 100644
--- a/tests/unit/linalg/test_operator.cpp
+++ b/tests/unit/linalg/test_operator.cpp
@@ -31,23 +31,19 @@ TEST_CASE("Operator", "[Operator]")
    {
       // When cg is in a product (on the right), we require cg->iterative_mode to be false.
 
-      ProductOperator *product = NULL;
-      RAPOperator *rap = NULL;
-      TripleProductOperator *triple = NULL;
-
       // First, test that the failing version throws an exception.
       cg.iterative_mode = true;
-      REQUIRE_THROWS(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_THROWS(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                        false));
-      REQUIRE_THROWS(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_THROWS(ProductOperator(&A, &cg, false, false));
+      REQUIRE_THROWS(TripleProductOperator(&A, &cg, &cg, false, false,
+                                           false));
+      REQUIRE_THROWS(RAPOperator(A, cg, cg));
 
       // Second, test that the correct version does not throw.
       cg.iterative_mode = false;
-      REQUIRE_NOTHROW(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_NOTHROW(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                         false));
-      REQUIRE_NOTHROW(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_NOTHROW(ProductOperator(&A, &cg, false, false));
+      REQUIRE_NOTHROW(TripleProductOperator(&A, &cg, &cg, false, false,
+                                            false));
+      REQUIRE_NOTHROW(RAPOperator(A, cg, cg));
    }
 }
 
diff --git a/tests/unit/makefile b/tests/unit/makefile
index d479e0864..9c73d67ba 100644
--- a/tests/unit/makefile
+++ b/tests/unit/makefile
@@ -254,4 +254,4 @@ $(MFEM_LIB_FILE):
 
 clean:
 	rm -f $(SEQ_UNIT_TESTS) $(PAR_UNIT_TESTS) *.o */*.o */*~ *~
-	rm -rf *.dSYM output_meshes
+	rm -rf *.dSYM output_meshes parallel_in_serial.mesh parallel_in_serial.gf
diff --git a/tests/unit/mesh/mesh_test_utils.cpp b/tests/unit/mesh/mesh_test_utils.cpp
new file mode 100644
index 000000000..65fb2e01d
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.cpp
@@ -0,0 +1,207 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mesh_test_utils.hpp"
+
+namespace mfem
+{
+
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction sol(&fes);
+
+   ConstantCoefficient one(1.0);
+   BilinearForm a(&fes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+
+   LinearForm b(&fes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(mesh.bdr_attributes.Max() > 0);
+
+   // Mark all boundaries essential
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      bdr_attr_is_ess[mesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   REQUIRE(ess_tdof_list.Size() > 0);
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B);
+
+   // Solve the system
+   CG(*A, B, X, 2, 1000, 1e-20, 0.0);
+
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   bool satisfy_bc = true;
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+   return ess_tdof_list.Size();
+};
+
+#ifdef MFEM_USE_MPI
+
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&pmesh, &fec);
+
+   ParGridFunction sol(&pfes);
+
+   ConstantCoefficient one(1.0);
+   ParBilinearForm a(&pfes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+   ParLinearForm b(&pfes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(pmesh.bdr_attributes.Max() > 0);
+
+   Array<int> bdr_attr_is_ess(pmesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      CAPTURE(disabled_boundary_attribute);
+      bdr_attr_is_ess[pmesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   int num_ess_dof = ess_tdof_list.Size();
+   MPI_Allreduce(MPI_IN_PLACE, &num_ess_dof, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   REQUIRE(num_ess_dof > 0);
+
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   const bool copy_interior = true; // interior(sol) --> interior(X)
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B, copy_interior);
+
+   // Solve the system
+   CGSolver cg(MPI_COMM_WORLD);
+   // HypreBoomerAMG preconditioner;
+   cg.SetMaxIter(2000);
+   cg.SetRelTol(1e-12);
+   cg.SetPrintLevel(0);
+   cg.SetOperator(*A);
+   // cg.SetPreconditioner(preconditioner);
+   cg.Mult(B, X);
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   // Initialize the bdr_dof to be checked
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   bool satisfy_bc = true;
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+};
+
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition)
+{
+   auto pmesh = std::unique_ptr<ParMesh>(new ParMesh(MPI_COMM_WORLD, smesh,
+                                                     partition.get()));
+
+   int nbe = pmesh->GetNBE();
+   MPI_Allreduce(MPI_IN_PLACE, &nbe, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(nbe == smesh.GetNBE());
+   return pmesh;
+};
+
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared)
+{
+   int e1, e2;
+   pmesh.GetFaceElements(f, &e1, &e2);
+   int inf1, inf2, ncface;
+   pmesh.GetFaceInfos(f, &inf1, &inf2, &ncface);
+
+   if (e2 < 0 && inf2 >=0)
+   {
+      // Shared face on processor boundary -> Need to discover the neighbor
+      // attributes
+      auto FET = pmesh.GetSharedFaceTransformations(local_to_shared.at(f));
+
+      if (FET->Elem1->Attribute != FET->Elem2->Attribute && f < pmesh.GetNumFaces())
+      {
+         // shared face on domain attribute boundary, which this rank owns
+         return true;
+      }
+   }
+
+   if (e2 >= 0 && pmesh.GetAttribute(e1) != pmesh.GetAttribute(e2))
+   {
+      // local face on domain attribute boundary
+      return true;
+   }
+   return false;
+};
+
+#endif
+
+} // namespace mfem
diff --git a/tests/unit/mesh/mesh_test_utils.hpp b/tests/unit/mesh/mesh_test_utils.hpp
new file mode 100644
index 000000000..e4088a788
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.hpp
@@ -0,0 +1,78 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_MESH_TEST_UTILS
+#define MFEM_MESH_TEST_UTILS
+
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+namespace mfem
+{
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a serial mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The SERIAL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute = -1);
+
+#ifdef MFEM_USE_MPI
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a parallel mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The PARALLEL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute = -1);
+
+/**
+ * @brief Check that a Parmesh generates the same number of boundary elements as
+ * the serial mesh.
+ *
+ * @param smesh Serial mesh to be built from and compared against
+ * @param partition Optional partition
+ * @return std::unique_ptr<ParMesh> Pointer to the mesh in question.
+ */
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition = nullptr);
+
+/**
+ * @brief Helper function to track if a face index is internal
+ *
+ * @param pmesh The mesh containing the face
+ * @param f The face index
+ * @param local_to_shared A map from local faces to shared faces
+ * @return true the face is between domain attributes (and owned by this rank)
+ * @return false the face is not between domain attributes or not owned by this rank
+ */
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared);
+
+#endif
+
+} // namespace mfem
+
+#endif // MFEM_MESH_TEST_UTILS
\ No newline at end of file
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index e78c68401..ee9997b05 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -113,7 +113,6 @@ TEST_CASE("NCMesh PA diagonal", "[NCMesh]")
 
 } // test case
 
-
 TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -145,7 +144,6 @@ TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
    REQUIRE(summed_volume == MFEM_Approx(original_volume));
 } // test case
 
-
 TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -176,8 +174,174 @@ TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
 } // test case
 
 
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a serial mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The SERIAL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute = -1)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction sol(&fes);
+
+   ConstantCoefficient one(1.0);
+   BilinearForm a(&fes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+
+   LinearForm b(&fes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(mesh.bdr_attributes.Max() > 0);
+
+   // Mark all boundaries essential
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      bdr_attr_is_ess[mesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   REQUIRE(ess_tdof_list.Size() > 0);
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B);
+
+   // Solve the system
+   CG(*A, B, X, 2, 1000, 1e-20, 0.0);
+
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   bool satisfy_bc = true;
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+   return ess_tdof_list.Size();
+};
+
 #ifdef MFEM_USE_MPI
 
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a parallel mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The PARALLEL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute = -1)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&pmesh, &fec);
+
+   ParGridFunction sol(&pfes);
+
+   ConstantCoefficient one(1.0);
+   ParBilinearForm a(&pfes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+   ParLinearForm b(&pfes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(pmesh.bdr_attributes.Max() > 0);
+
+   Array<int> bdr_attr_is_ess(pmesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      CAPTURE(disabled_boundary_attribute);
+      bdr_attr_is_ess[pmesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   int num_ess_dof = ess_tdof_list.Size();
+   MPI_Allreduce(MPI_IN_PLACE, &num_ess_dof, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   REQUIRE(num_ess_dof > 0);
+
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   const bool copy_interior = true; // interior(sol) --> interior(X)
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B, copy_interior);
+
+   // Solve the system
+   CGSolver cg(MPI_COMM_WORLD);
+   // HypreBoomerAMG preconditioner;
+   cg.SetMaxIter(2000);
+   cg.SetRelTol(1e-12);
+   cg.SetPrintLevel(0);
+   cg.SetOperator(*A);
+   // cg.SetPreconditioner(preconditioner);
+   cg.Mult(B, X);
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   // Initialize the bdr_dof to be checked
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   bool satisfy_bc = true;
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+};
+
 // Test case: Verify that a conforming mesh yields the same norm for the
 //            assembled diagonal with PA when using the standard (conforming)
 //            Mesh vs. the corresponding (non-conforming) NCMesh.
@@ -294,128 +458,132 @@ TEST_CASE("pNCMesh PA diagonal",  "[Parallel], [NCMesh]")
          MPI_Barrier(MPI_COMM_WORLD);
       }
    }
-
 } // test case
 
-TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+
+// Given a parallel and a serial mesh, perform an L2 projection and check the
+// solutions match exactly.
+void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
+                       std::function<double(Vector const&)> exact_soln)
 {
-   constexpr int refining_rank = 0;
-   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
+   REQUIRE(pmesh.Dimension() == smesh.Dimension());
+   REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
 
-   REQUIRE(smesh.GetNE() == 1);
-   {
-      // Start the test with two tetrahedra attached by triangle.
-      auto single_edge_refine = Array<Refinement>(1);
-      single_edge_refine[0].index = 0;
-      single_edge_refine[0].ref_type = Refinement::X;
+   // Make an H1 space, then a mass matrix operator and invert it.
+   // If all non-conformal constraints have been conveyed correctly, the
+   // resulting DOF should match exactly on the serial and the parallel
+   // solution.
 
-      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
-   }
+   H1_FECollection fec(order, smesh.Dimension());
+   ConstantCoefficient one(1.0);
+   FunctionCoefficient rhs_coef(exact_soln);
 
-   auto exact_soln = [](const Vector& x)
-   {
-      // sin(|| x - d ||^2) -> non polynomial but very smooth.
-      Vector d(3);
-      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
-      d -= x;
-      return std::sin(d * d);
-   };
+   constexpr double linear_tol = 1e-16;
 
-   // Given a parallel and a serial mesh, perform an L2 projection and check the
-   // solutions match exactly.
-   auto check_l2_projection = [&exact_soln](ParMesh& pmesh, Mesh& smesh, int order)
+   // serial solve
+   auto serror = [&]
    {
+      FiniteElementSpace fes(&smesh, &fec);
+      // solution vectors
+      GridFunction x(&fes);
+      x = 0.0;
 
-      REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
-      REQUIRE(pmesh.Dimension() == smesh.Dimension());
-      REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
+      double snorm = x.ComputeL2Error(rhs_coef);
 
-      // Make an H1 space, then a mass matrix operator and invert it.
-      // If all non-conformal constraints have been conveyed correctly, the
-      // resulting DOF should match exactly on the serial and the parallel
-      // solution.
+      LinearForm b(&fes);
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
 
-      H1_FECollection fec(order, smesh.Dimension());
-      ConstantCoefficient one(1.0);
-      FunctionCoefficient rhs_coef(exact_soln);
+      BilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
 
-      constexpr double linear_tol = 1e-16;
+      SparseMatrix A;
+      Vector B, X;
 
-      // serial solve
-      auto serror = [&]
-      {
-         FiniteElementSpace fes(&smesh, &fec);
-         // solution vectors
-         GridFunction x(&fes);
-         x = 0.0;
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+
+#ifndef MFEM_USE_SUITESPARSE
+      // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
+      //    solve the system AX=B with PCG.
+      GSSmoother M(A);
+      PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
+#else
+      // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
+      UMFPackSolver umf_solver;
+      umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
+      umf_solver.SetOperator(A);
+      umf_solver.Mult(B, X);
+#endif
 
-         LinearForm b(&fes);
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
+      a.RecoverFEMSolution(X, b, x);
+      return x.ComputeL2Error(rhs_coef) / snorm;
+   }();
 
-         BilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
+   auto perror = [&]
+   {
+      // parallel solve
+      ParFiniteElementSpace fes(&pmesh, &fec);
 
-         SparseMatrix A;
-         Vector B, X;
+      ParGridFunction x(&fes);
+      x = 0.0;
 
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+      double pnorm = x.ComputeL2Error(rhs_coef);
 
-#ifndef MFEM_USE_SUITESPARSE
-         // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
-         //    solve the system AX=B with PCG.
-         GSSmoother M(A);
-         PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
-#else
-         // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
-         UMFPackSolver umf_solver;
-         umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
-         umf_solver.SetOperator(A);
-         umf_solver.Mult(B, X);
-#endif
+      ParLinearForm b(&fes);
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
 
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
+      ParBilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
 
-      auto perror = [&]
-      {
-         // parallel solve
-         ParFiniteElementSpace fes(&pmesh, &fec);
-         ParLinearForm b(&fes);
+      HypreParMatrix A;
+      Vector B, X;
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
 
-         ParGridFunction x(&fes);
-         x = 0.0;
+      HypreBoomerAMG amg(A);
+      HyprePCG pcg(A);
+      amg.SetPrintLevel(-1);
+      pcg.SetTol(linear_tol);
+      pcg.SetMaxIter(500);
+      pcg.SetPrintLevel(-1);
+      pcg.SetPreconditioner(amg);
+      pcg.Mult(B, X);
+      a.RecoverFEMSolution(X, b, x);
 
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
+      return x.ComputeL2Error(rhs_coef) / pnorm;
+   }();
 
-         ParBilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
+   constexpr double test_tol = 1e-9;
+   CHECK(std::abs(serror - perror) < test_tol);
+};
+
+TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+{
+   constexpr int refining_rank = 0;
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNE() == 1);
+   {
+      // Start the test with two tetrahedra attached by triangle.
+      auto single_edge_refine = Array<Refinement>(1);
+      single_edge_refine[0].index = 0;
+      single_edge_refine[0].ref_type = Refinement::X;
 
-         HypreParMatrix A;
-         Vector B, X;
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
-
-         HypreBoomerAMG amg(A);
-         HyprePCG pcg(A);
-         amg.SetPrintLevel(-1);
-         pcg.SetTol(linear_tol);
-         pcg.SetMaxIter(500);
-         pcg.SetPrintLevel(-1);
-         pcg.SetPreconditioner(amg);
-         pcg.Mult(B, X);
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
-
-      constexpr double test_tol = 1e-9;
-      CHECK(std::abs(serror - perror) < test_tol);
+      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
+   }
 
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
    };
 
    REQUIRE(smesh.GetNE() == 2);
@@ -498,28 +666,1622 @@ TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
       for (int iface = 0; iface < sttmp.GetNumFaces(); ++iface)
       {
          const auto face_transform = sttmp.GetFaceElementTransformations(iface);
-
          CHECK(face_transform->CheckConsistency(0) < 1e-12);
       }
 
       for (int iface = 0; iface < ttmp.GetNumFacesWithGhost(); ++iface)
       {
          const auto face_transform = ttmp.GetFaceElementTransformations(iface);
-
          CHECK(face_transform->CheckConsistency(0) < 1e-12);
       }
 
       // Use P4 to ensure there's a few fully interior DOF.
-      check_l2_projection(ttmp, sttmp, 4);
+      CheckL2Projection(ttmp, sttmp, 4, exact_soln);
 
       ttmp.ExchangeFaceNbrData();
       ttmp.Rebalance();
 
-      check_l2_projection(ttmp, sttmp, 4);
+      CheckL2Projection(ttmp, sttmp, 4, exact_soln);
    }
 } // test case
 
+Mesh CylinderMesh(Geometry::Type el_type, bool quadratic, int variant = 0)
+{
+   double c[3];
+
+   int nnodes = (el_type == Geometry::CUBE) ? 24 : 15;
+   int nelems = 8; // Geometry::PRISM
+   if (el_type == Geometry::CUBE)        { nelems = 10; }
+   if (el_type == Geometry::TETRAHEDRON) { nelems = 24; }
+
+   Mesh mesh(3, nnodes, nelems);
+
+   for (int i=0; i<3; i++)
+   {
+      if (el_type != Geometry::CUBE)
+      {
+         c[0] = 0.0;  c[1] = 0.0;  c[2] = 2.74 * i;
+         mesh.AddVertex(c);
+      }
+
+      for (int j=0; j<4; j++)
+      {
+         if (el_type == Geometry::CUBE)
+         {
+            c[0] = 1.14 * ((j + 1) % 2) * (1 - j);
+            c[1] = 1.14 * (j % 2) * (2 - j);
+            c[2] = 2.74 * i;
+            mesh.AddVertex(c);
+         }
+
+         c[0] = 2.74 * ((j + 1) % 2) * (1 - j);
+         c[1] = 2.74 * (j % 2) * (2 - j);
+         c[2] = 2.74 * i;
+         mesh.AddVertex(c);
+      }
+   }
+
+   for (int i=0; i<2; i++)
+   {
+      if (el_type == Geometry::CUBE)
+      {
+         mesh.AddHex(8*i, 8*i+2, 8*i+4, 8*i+6,
+                     8*(i+1), 8*(i+1)+2, 8*(i+1)+4, 8*(i+1)+6);
+      }
+
+      for (int j=0; j<4; j++)
+      {
+         if (el_type == Geometry::PRISM)
+         {
+            switch (variant)
+            {
+               case 0:
+                  mesh.AddWedge(5*i, 5*i+j+1, 5*i+(j+1)%4+1,
+                                5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+                  break;
+               case 1:
+                  mesh.AddWedge(5*i, 5*i+j+1, 5*i+(j+1)%4+1,
+                                5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+                  break;
+               case 2:
+                  mesh.AddWedge(5*i+(j+1)%4+1, 5*i, 5*i+j+1,
+                                5*(i+1)+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1);
+                  break;
+            }
+         }
+         else if (el_type == Geometry::CUBE)
+         {
+            mesh.AddHex(8*i+2*j, 8*i+2*j+1, 8*i+(2*j+3)%8, 8*i+(2*j+2)%8,
+                        8*(i+1)+2*j, 8*(i+1)+2*j+1, 8*(i+1)+(2*j+3)%8,
+                        8*(i+1)+(2*j+2)%8);
+         }
+         else if (el_type == Geometry::TETRAHEDRON)
+         {
+            mesh.AddTet(5*i, 5*i+j+1, 5*i+(j+1)%4+1, 5*(i+1));
+            mesh.AddTet(5*i+j+1, 5*i+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1);
+            mesh.AddTet(5*i+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+         }
+      }
+   }
+
+   mesh.FinalizeTopology();
+
+   if (quadratic)
+   {
+      mesh.SetCurvature(2);
+
+      if (el_type == Geometry::CUBE)
+      {
+         auto quad_cyl_hex = [](const Vector& x, Vector& d)
+         {
+            d.SetSize(3);
+            d = x;
+            const double Rmax = 2.74;
+            const double Rmin = 1.14;
+            double ax = std::abs(x[0]);
+            if (ax <= 1e-6) { return; }
+            double ay = std::abs(x[1]);
+            if (ay <= 1e-6) { return; }
+            double r = ax + ay;
+            if (r <= Rmin + 1e-6) { return; }
+
+            double sx = std::copysign(1.0, x[0]);
+            double sy = std::copysign(1.0, x[1]);
+
+            double R = (Rmax - Rmin) * Rmax / (r - Rmin);
+            double r2 = r * r;
+            double R2 = R * R;
+
+            double acosarg = 0.5 * (r + std::sqrt(2.0 * R2 - r2)) / R;
+            double tR = std::acos(std::min(acosarg, 1.0));
+            double tQ = (1.0 + sx * sy * (ay - ax) / r);
+            double tP = 0.25 * M_PI * (3.0 - (2.0 + sx) * sy);
+
+            double t = tR + (0.25 * M_PI - tR) * tQ + tP;
+
+            double s0 = std::sqrt(2.0 * R2 - r2);
+            double s1 = 0.25 * std::pow(r + s0, 2);
+            double s = std::sqrt(R2 - s1);
+
+            d[0] = R * std::cos(t) - sx * s;
+            d[1] = R * std::sin(t) - sy * s;
+
+            return;
+         };
+
+         mesh.Transform(quad_cyl_hex);
+      }
+      else
+      {
+         auto quad_cyl = [](const Vector& x, Vector& d)
+         {
+            d.SetSize(3);
+            d = x;
+            double ax = std::abs(x[0]);
+            double ay = std::abs(x[1]);
+            double r = ax + ay;
+            if (r < 1e-6) { return; }
+
+            double sx = std::copysign(1.0, x[0]);
+            double sy = std::copysign(1.0, x[1]);
+
+            double t = ((2.0 - (1.0 + sx) * sy) * ax +
+                        (2.0 - sy) * ay) * 0.5 * M_PI / r;
+            d[0] = r * std::cos(t);
+            d[1] = r * std::sin(t);
+
+            return;
+         };
+
+         mesh.Transform(quad_cyl);
+      }
+   }
+
+   mesh.Finalize(true);
+
+   return mesh;
+}
+
+TEST_CASE("P2Q1PureTetHexPri",  "[Parallel], [NCMesh]")
+{
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   auto el_type = GENERATE(Geometry::TETRAHEDRON,
+                           Geometry::CUBE,
+                           Geometry::PRISM);
+   int variant = GENERATE(0,1,2);
+
+   if (variant > 0 && el_type != Geometry::PRISM)
+   {
+      return;
+   }
+
+   CAPTURE(el_type, variant);
+
+   auto smesh = CylinderMesh(el_type, false, variant);
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      // P2 ensures there are triangles without dofs
+      CheckL2Projection(pmesh, smesh, 2, exact_soln);
+   }
+} // test case
+
+TEST_CASE("PNQ2PureTetHexPri",  "[Parallel], [NCMesh]")
+{
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   auto el_type = GENERATE(Geometry::TETRAHEDRON,
+                           Geometry::CUBE,
+                           Geometry::PRISM);
+   int variant = GENERATE(0,1,2);
+
+   if (variant > 0 && el_type != Geometry::PRISM)
+   {
+      return;
+   }
+
+   CAPTURE(el_type, variant);
+
+   auto smesh = CylinderMesh(el_type, true);
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      for (int p = 1; p < 3; ++p)
+      {
+         CheckL2Projection(pmesh, smesh, p, exact_soln);
+      }
+   }
+} // test case
+
+/**
+ * @brief Test GetVectorValue on face neighbor elements for nonconformal meshes
+ *
+ * @param smesh The serial mesh to start from
+ * @param nc_level Depth of refinement on processor boundaries
+ * @param skip Refine every "skip" processor boundary element
+ * @param use_ND Whether to use Nedelec elements (which are sensitive to orientation)
+ */
+void TestVectorValueInVolume(Mesh &smesh, int nc_level, int skip, bool use_ND)
+{
+   auto vector_exact_soln = [](const Vector& x, Vector& v)
+   {
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      v = (d -= x);
+   };
+
+   smesh.Finalize();
+   smesh.EnsureNCMesh(true); // uncomment this to trigger the failure
+
+   auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+   // Apply refinement on face neighbors to achieve a given nc level mismatch.
+   for (int i = 0; i < nc_level; ++i)
+   {
+      // To refine the face neighbors, need to know where they are.
+      pmesh.ExchangeFaceNbrData();
+      Array<int> elem_to_refine;
+      // Refine only on odd ranks.
+      if ((Mpi::WorldRank() + 1) % 2 == 0)
+      {
+         // Refine a subset of all shared faces. Using a subset helps to
+         // mix in conformal faces with nonconformal faces.
+         for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+         {
+            if (n % skip != 0) { continue; }
+            const int local_face = pmesh.GetSharedFace(n);
+            const auto &face_info = pmesh.GetFaceInformation(local_face);
+            REQUIRE(face_info.IsShared());
+            REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+            elem_to_refine.Append(face_info.element[0].index);
+         }
+      }
+      pmesh.GeneralRefinement(elem_to_refine);
+   }
+
+   // Do not rebalance again! The test is also checking for nc refinements
+   // along the processor boundary.
+
+   // Create a grid function of the mesh coordinates
+   pmesh.ExchangeFaceNbrData();
+   pmesh.EnsureNodes();
+   REQUIRE(pmesh.OwnsNodes());
+   GridFunction * const coords = pmesh.GetNodes();
+   dynamic_cast<ParGridFunction *>(pmesh.GetNodes())->ExchangeFaceNbrData();
+
+   // Project the linear function onto the mesh. Quadratic ND tetrahedral
+   // elements are the first to require face orientations.
+   const int order = 2, dim = 3;
+   std::unique_ptr<FiniteElementCollection> fec;
+   if (use_ND)
+   {
+      fec = std::unique_ptr<ND_FECollection>(new ND_FECollection(order, dim));
+   }
+   else
+   {
+      fec = std::unique_ptr<RT_FECollection>(new RT_FECollection(order, dim));
+   }
+   ParFiniteElementSpace pnd_fes(&pmesh, fec.get());
+
+   ParGridFunction psol(&pnd_fes);
+
+   VectorFunctionCoefficient func(3, vector_exact_soln);
+   psol.ProjectCoefficient(func);
+   psol.ExchangeFaceNbrData();
+
+   mfem::Vector value(3), exact(3), position(3);
+   const IntegrationRule &ir = mfem::IntRules.Get(Geometry::Type::TETRAHEDRON,
+                                                  order + 1);
+
+   // Check that non-ghost elements match up on the serial and parallel spaces.
+   for (int n = 0; n < pmesh.GetNE(); ++n)
+   {
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         coords->GetVectorValue(n, ip, position);
+         psol.GetVectorValue(n, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+
+   // Loop over face neighbor elements and check the vector values match in the
+   // face neighbor elements.
+   for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+   {
+      const int local_face = pmesh.GetSharedFace(n);
+      const auto &face_info = pmesh.GetFaceInformation(local_face);
+      REQUIRE(face_info.IsShared());
+      REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+
+      auto &T = *pmesh.GetFaceNbrElementTransformation(face_info.element[1].index);
+
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         T.SetIntPoint(&ip);
+         coords->GetVectorValue(T, ip, position);
+         psol.GetVectorValue(T, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+}
+
+TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
+{
+   // The aim of this test is to verify the correct behaviour of the
+   // GetVectorValue method when called on face neighbor elements in a non
+   // conforming mesh.
+   auto smesh = Mesh("../../data/beam-tet.mesh");
+
+   for (int nc_level : {0,1,2,3})
+   {
+      for (int skip : {1,2})
+      {
+         for (bool use_ND : {false, true})
+         {
+            TestVectorValueInVolume(smesh, nc_level, skip, use_ND);
+         }
+      }
+   }
+}
+
+/**
+ * @brief Check that a Parmesh generates the same number of boundary elements as
+ * the serial mesh.
+ *
+ * @param smesh Serial mesh to be built from and compared against
+ * @param partition Optional partition
+ * @return std::unique_ptr<ParMesh> Pointer to the mesh in question.
+ */
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition = nullptr)
+{
+   auto pmesh = std::unique_ptr<ParMesh>(new ParMesh(MPI_COMM_WORLD, smesh,
+                                                     partition.get()));
+
+   int nbe = pmesh->GetNBE();
+   MPI_Allreduce(MPI_IN_PLACE, &nbe, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(nbe == smesh.GetNBE());
+   return pmesh;
+};
+
+/**
+ * @brief Helper function to track if a face index is internal
+ *
+ * @param pmesh The mesh containing the face
+ * @param f The face index
+ * @param local_to_shared A map from local faces to shared faces
+ * @return true the face is between domain attributes (and owned by this rank)
+ * @return false the face is not between domain attributes or not owned by this rank
+ */
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared)
+{
+   int e1, e2;
+   pmesh.GetFaceElements(f, &e1, &e2);
+   int inf1, inf2, ncface;
+   pmesh.GetFaceInfos(f, &inf1, &inf2, &ncface);
+
+   if (e2 < 0 && inf2 >=0)
+   {
+      // Shared face on processor boundary -> Need to discover the neighbor
+      // attributes
+      auto FET = pmesh.GetSharedFaceTransformations(local_to_shared.at(f));
+
+      if (FET->Elem1->Attribute != FET->Elem2->Attribute && f < pmesh.GetNumFaces())
+      {
+         // shared face on domain attribute boundary, which this rank owns
+         return true;
+      }
+   }
+
+   if (e2 >= 0 && pmesh.GetAttribute(e1) != pmesh.GetAttribute(e2))
+   {
+      // local face on domain attribute boundary
+      return true;
+   }
+   return false;
+};
+
+TEST_CASE("InteriorBoundaryReferenceTets", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 3 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rank 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineTetRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-tet.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   smesh.EnsureNCMesh(true);
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+TEST_CASE("InteriorBoundaryReferenceCubes", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+
+   REQUIRE(smesh.GetNBE() == 6);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   // Throw away the NCMesh, will restart NC later.
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 5 + 1);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Conforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 5 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (5 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rank 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineHexRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-hex.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+#endif // MFEM_USE_MPI
+
+TEST_CASE("ReferenceCubeInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+
+   CheckPoisson(smesh, p);
+
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   int without_internal, with_internal;
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 1); break;
+      case 3:
+         CHECK(with_internal == without_internal + 4); break;
+   }
+
+   auto ref_type = char(GENERATE(//Refinement::Y, Refinement::Z, Refinement::YZ,
+                           Refinement::XYZ));
+
+   for (auto ref : {0,1})
+   {
+      refs[0].index = ref;
+
+      auto ssmesh = Mesh(smesh);
+
+      CAPTURE(ref_type);
+
+      // Now NC refine one of the attached elements, this should result in 2
+      // internal boundary elements.
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      if (ref_type == 2 /* Y */ || ref_type == 4 /* Z */)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 2 /* internal boundaries */
+               + (2 * 4) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 6)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 7)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3 + 4 * 2) /* external boundaries of refined elements */);
+      }
+      else
+      {
+         MFEM_ABORT("!");
+      }
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == (ref_type <= 4 ? 2 : 4));
+
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      without_internal = CheckPoisson(ssmesh, p,
+                                      ssmesh.bdr_attributes.Max()); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      // All slaves dofs that are introduced on the face are constrained by
+      // the master dofs, thus the additional constraints on the internal
+      // boundary are purely on the master face, which matches the initial
+      // unrefined case.
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal + 1); break;
+         case 3:
+            CHECK(with_internal == without_internal + 4); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedCubesInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.UniformRefinement();
+
+   // Introduce four internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   int without_internal = CheckPoisson(smesh, p,
+                                       7); // Exclude the internal boundary
+   int with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // There should now be 16 internal boundary elements, where there were 4 before
+
+   CHECK(smesh.GetNBE() == 5 * 4 /* external boundaries of unrefined domain  */
+         + 4 * 4 /* internal boundaries */
+         + 5 * 16 /* external boundaries of refined elements */);
+
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 16);
+
+
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+}
+
+TEST_CASE("ReferenceTetInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal); break;
+      case 3:
+         CHECK(with_internal == without_internal + 1); break;
+   }
+
+   // Now NC refine one of the attached elements, this should result in 2
+   // internal boundary elements.
+   for (int ref : {0, 1})
+   {
+      refs[0].index = ref;
+      refs[0].ref_type = Refinement::XYZ;
+      auto ssmesh = Mesh(smesh);
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(ssmesh.GetNBE() == 3 /* external boundaries of unrefined element  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined element */);
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == 4);
+
+      without_internal = CheckPoisson(ssmesh, p, 5); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal); break;
+         case 3:
+            CHECK(with_internal == without_internal + 1); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedTetsInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.UniformRefinement();
+
+   CHECK(smesh.GetNBE() == 2 * 3 * 4);
+
+   // Introduce internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+
+   // Now NC refine all elements with the 2 attribute.
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   // There should now be four internal boundary elements, where there was one
+   // before.
+   CHECK(smesh.GetNBE() == 3 * 4 /* external boundaries of unrefined elements  */
+         + 4 * 4 /* internal boundaries */
+         + (3 * 4 * 4) /* external boundaries of refined elements */);
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 4 * 4);
+
+   without_internal = CheckPoisson(smesh, p, 5); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+}
+
+TEST_CASE("PoissonOnReferenceCubeNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   // Check that Poisson can be solved on the domain
+   CheckPoisson(smesh, p);
+
+   auto ref_type = char(GENERATE(Refinement::X, Refinement::Y, Refinement::Z,
+                                 Refinement::XY, Refinement::XZ, Refinement::YZ,
+                                 Refinement::XYZ));
+   CAPTURE(ref_type);
+   for (auto refined_elem : {0}) // The left or the right element
+   {
+      refs[0].index = refined_elem;
+      auto ssmesh = Mesh(smesh);
+
+      // Now NC refine one of the attached elements
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("PoissonOnReferenceTetNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   CheckPoisson(smesh, p);
+
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Check that Poisson can be solved on the pair of tets
+   CheckPoisson(smesh, p);
+
+   auto nc = GENERATE(false, true);
+   CAPTURE(nc);
+
+   smesh.EnsureNCMesh(GENERATE(false, true));
+
+   for (auto refined_elem : {0, 1})
+   {
+      auto ssmesh = Mesh(smesh);
+
+      refs[0].index = refined_elem;
+      refs[0].ref_type = Refinement::XYZ;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+
+TEST_CASE("TetBoundaryRefinement", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+
+   smesh.FinalizeTopology();
+   smesh.Finalize(true);
+   smesh.UniformRefinement();
+
+   smesh.EnsureNCMesh(true);
+
+   CHECK(smesh.GetNBE() == 4 * 4);
+
+   // Loop over elements and mark for refinement if any vertices match the
+   // original
+   Array<int> vertices, elements;
+   // reference vertices of (0,0,0), (1,0,0), (0,1,0), (0,0,1) are [0,3]
+   auto original_vert = [](int i) { return i >= 0 && i <= 3; };
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      smesh.GetElementVertices(n, vertices);
+      if (std::any_of(vertices.begin(), vertices.end(), original_vert))
+      {
+         elements.Append(n);
+      }
+   }
+
+   smesh.GeneralRefinement(elements);
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Each side of the tetrahedron should now have 1 original face, and then 3 *
+   // 4 nonconformally generated faces.
+   CHECK(smesh.GetNBE() == 4 * (1 + 3 * 4));
+}
+
 
-#endif // MFEM_USE_MPI
 
 } // namespace mfem
